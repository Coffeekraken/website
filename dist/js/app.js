/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// main application entry point
	__webpack_require__(1);
	__webpack_require__(51);
	__webpack_require__(52);
	__webpack_require__(167);

	window.addEventListener('scroll', function (e) {
		if (document.body.scrollTop > 300) {
			document.body.classList.add('scrolled');
		} else {
			document.body.classList.remove('scrolled');
		}
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var _vue = __webpack_require__(2);

	var _vue2 = _interopRequireDefault(_vue);

	var _githubApi = __webpack_require__(3);

	var _githubApi2 = _interopRequireDefault(_githubApi);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// check if we have already some repos in the localstorage
	var localRepos = localStorage.getItem('coffeekraken-repos');
	if (localRepos) {
		localRepos = JSON.parse(localRepos);
		// check time
		if (localRepos.timestamp < new Date().getTime() - 3600 * 24 * 1000) {
			// fetch new repos
			fetchRepos();
		} else {
			// display repos
			displayRepos(localRepos.repos);
		}
	} else {
		fetchRepos();
	}

	function fetchRepos() {
		var token = 'd27c9ea77d47fd90da48720ebe98277a519ba262';
		var github = new _githubApi2.default({
			user: "olivierbossel",
			token: token.split('').reverse().join('')
		});
		var user = github.getUser();
		user.listRepos({}, function (err, repos) {
			if (!repos) return;
			// filter repos
			var coffeeRepos = repos.filter(function (repo) {
				return repo.owner.login === 'Coffeekraken';
			});
			// save into localstorage
			localStorage.setItem('coffeekraken-repos', JSON.stringify({
				timestamp: new Date().getTime(),
				repos: coffeeRepos
			}));
			// display repos
			displayRepos(coffeeRepos);
		}, function () {});
	}

	// display repos
	function displayRepos(repos) {
		// new Vue component
		_vue2.default.component('coffeekraken-repos', {
			template: '\n\t\t\t<ul class="nav nav--pills">\n\t\t\t\t<li class="nav__item" v-for="repo in repos">\n\t\t\t\t\t<a :href="repo.html_url" :title="repo.name" target="_blank">\n\t\t\t\t\t\t<span class="pill" :class="{ \'pill--secondary\' : repo.name.substr(0,2) === \'s-\' }">\n\t\t\t\t\t\t\t{{repo.name}}\n\t\t\t\t\t\t\t<div class="tooltip tooltip--t tf t-center">\n\t\t\t\t\t\t\t\t{{repo.description}}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t',
			data: function data() {
				return {
					repos: repos
				};
			}
		});

		// new Vue
		new _vue2.default({
			el: document.querySelector('[vue-coffeekraken-repos]')
		});
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Vue.js v2.2.6
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Vue=t()}(this,function(){"use strict";function e(e){return null==e?"":"object"==typeof e?JSON.stringify(e,null,2):String(e)}function t(e){var t=parseFloat(e);return isNaN(t)?e:t}function n(e,t){for(var n=Object.create(null),r=e.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}function r(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}function i(e,t){return $i.call(e,t)}function o(e){return"string"==typeof e||"number"==typeof e}function a(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}function s(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n}function c(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function u(e,t){for(var n in t)e[n]=t[n];return e}function l(e){return null!==e&&"object"==typeof e}function f(e){return ki.call(e)===Ai}function p(e){for(var t={},n=0;n<e.length;n++)e[n]&&u(t,e[n]);return t}function d(){}function v(e,t){var n=l(e),r=l(t);if(!n||!r)return!n&&!r&&String(e)===String(t);try{return JSON.stringify(e)===JSON.stringify(t)}catch(n){return e===t}}function h(e,t){for(var n=0;n<e.length;n++)if(v(e[n],t))return n;return-1}function m(e){var t=!1;return function(){t||(t=!0,e())}}function g(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function y(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function _(e){if(!ji.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}function b(e){return/native code/.test(e.toString())}function $(e){qi.target&&Wi.push(qi.target),qi.target=e}function w(){qi.target=Wi.pop()}function x(e,t){e.__proto__=t}function C(e,t,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];y(e,o,t[o])}}function k(e,t){if(l(e)){var n;return i(e,"__ob__")&&e.__ob__ instanceof Xi?n=e.__ob__:Qi.shouldConvert&&!Ui()&&(Array.isArray(e)||f(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Xi(e)),t&&n&&n.vmCount++,n}}function A(e,t,n,r){var i=new qi,o=Object.getOwnPropertyDescriptor(e,t);if(!o||o.configurable!==!1){var a=o&&o.get,s=o&&o.set,c=k(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=a?a.call(e):n;return qi.target&&(i.depend(),c&&c.dep.depend(),Array.isArray(t)&&S(t)),t},set:function(t){var r=a?a.call(e):n;t===r||t!==t&&r!==r||(s?s.call(e,t):n=t,c=k(t),i.notify())}})}}function O(e,t,n){if(Array.isArray(e)&&"number"==typeof t)return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(i(e,t))return e[t]=n,n;var r=e.__ob__;return e._isVue||r&&r.vmCount?n:r?(A(r.value,t,n),r.dep.notify(),n):(e[t]=n,n)}function T(e,t){if(Array.isArray(e)&&"number"==typeof t)return void e.splice(t,1);var n=e.__ob__;e._isVue||n&&n.vmCount||i(e,t)&&(delete e[t],n&&n.dep.notify())}function S(e){for(var t=void 0,n=0,r=e.length;n<r;n++)t=e[n],t&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&S(t)}function E(e,t){if(!t)return e;for(var n,r,o,a=Object.keys(t),s=0;s<a.length;s++)n=a[s],r=e[n],o=t[n],i(e,n)?f(r)&&f(o)&&E(r,o):O(e,n,o);return e}function j(e,t){return t?e?e.concat(t):Array.isArray(t)?t:[t]:e}function N(e,t){var n=Object.create(e||null);return t?u(n,t):n}function I(e){var t=e.props;if(t){var n,r,i,o={};if(Array.isArray(t))for(n=t.length;n--;)"string"==typeof(r=t[n])&&(i=wi(r),o[i]={type:null});else if(f(t))for(var a in t)r=t[a],i=wi(a),o[i]=f(r)?r:{type:r};e.props=o}}function L(e){var t=e.directives;if(t)for(var n in t){var r=t[n];"function"==typeof r&&(t[n]={bind:r,update:r})}}function D(e,t,n){function r(r){var i=eo[r]||to;l[r]=i(e[r],t[r],n,r)}I(t),L(t);var o=t.extends;if(o&&(e="function"==typeof o?D(e,o.options,n):D(e,o,n)),t.mixins)for(var a=0,s=t.mixins.length;a<s;a++){var c=t.mixins[a];c.prototype instanceof nt&&(c=c.options),e=D(e,c,n)}var u,l={};for(u in e)r(u);for(u in t)i(e,u)||r(u);return l}function M(e,t,n,r){if("string"==typeof n){var o=e[t];if(i(o,n))return o[n];var a=wi(n);if(i(o,a))return o[a];var s=xi(a);if(i(o,s))return o[s];var c=o[n]||o[a]||o[s];return c}}function P(e,t,n,r){var o=t[e],a=!i(n,e),s=n[e];if(H(Boolean,o.type)&&(a&&!i(o,"default")?s=!1:H(String,o.type)||""!==s&&s!==Ci(e)||(s=!0)),void 0===s){s=R(r,o,e);var c=Qi.shouldConvert;Qi.shouldConvert=!0,k(s),Qi.shouldConvert=c}return s}function R(e,t,n){if(i(t,"default")){var r=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof r&&"Function"!==F(t.type)?r.call(e):r}}function F(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t&&t[1]}function H(e,t){if(!Array.isArray(t))return F(t)===F(e);for(var n=0,r=t.length;n<r;n++)if(F(t[n])===F(e))return!0;return!1}function U(e,t,n){if(Si.errorHandler)Si.errorHandler.call(null,e,t,n);else{if(!Ii||"undefined"==typeof console)throw e;console.error(e)}}function B(e){return new no(void 0,void 0,void 0,String(e))}function V(e){var t=new no(e.tag,e.data,e.children,e.text,e.elm,e.context,e.componentOptions);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isCloned=!0,t}function z(e){for(var t=e.length,n=new Array(t),r=0;r<t;r++)n[r]=V(e[r]);return n}function J(e){function t(){var e=arguments,n=t.fns;if(!Array.isArray(n))return n.apply(null,arguments);for(var r=0;r<n.length;r++)n[r].apply(null,e)}return t.fns=e,t}function K(e,t,n,r,i){var o,a,s,c;for(o in e)a=e[o],s=t[o],c=ao(o),a&&(s?a!==s&&(s.fns=a,e[o]=s):(a.fns||(a=e[o]=J(a)),n(c.name,a,c.once,c.capture)));for(o in t)e[o]||(c=ao(o),r(c.name,t[o],c.capture))}function q(e,t,n){function i(){n.apply(this,arguments),r(o.fns,i)}var o,a=e[t];a?a.fns&&a.merged?(o=a,o.fns.push(i)):o=J([a,i]):o=J([i]),o.merged=!0,e[t]=o}function W(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}function Z(e){return o(e)?[B(e)]:Array.isArray(e)?G(e):void 0}function G(e,t){var n,r,i,a=[];for(n=0;n<e.length;n++)null!=(r=e[n])&&"boolean"!=typeof r&&(i=a[a.length-1],Array.isArray(r)?a.push.apply(a,G(r,(t||"")+"_"+n)):o(r)?i&&i.text?i.text+=String(r):""!==r&&a.push(B(r)):r.text&&i&&i.text?a[a.length-1]=B(i.text+r.text):(r.tag&&null==r.key&&null!=t&&(r.key="__vlist"+t+"_"+n+"__"),a.push(r)));return a}function Y(e){return e&&e.filter(function(e){return e&&e.componentOptions})[0]}function Q(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&te(e,t)}function X(e,t,n){n?io.$once(e,t):io.$on(e,t)}function ee(e,t){io.$off(e,t)}function te(e,t,n){io=e,K(t,n||{},X,ee,e)}function ne(e,t){var n={};if(!e)return n;for(var r,i,o=[],a=0,s=e.length;a<s;a++)if(i=e[a],(i.context===t||i.functionalContext===t)&&i.data&&(r=i.data.slot)){var c=n[r]||(n[r]=[]);"template"===i.tag?c.push.apply(c,i.children):c.push(i)}else o.push(i);return o.every(re)||(n.default=o),n}function re(e){return e.isComment||" "===e.text}function ie(e){for(var t={},n=0;n<e.length;n++)t[e[n][0]]=e[n][1];return t}function oe(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}function ae(e,t,n){e.$el=t,e.$options.render||(e.$options.render=oo),fe(e,"beforeMount");var r;return r=function(){e._update(e._render(),n)},e._watcher=new ho(e,r,d),n=!1,null==e.$vnode&&(e._isMounted=!0,fe(e,"mounted")),e}function se(e,t,n,r,i){var o=!!(i||e.$options._renderChildren||r.data.scopedSlots||e.$scopedSlots!==Ei);if(e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=i,t&&e.$options.props){Qi.shouldConvert=!1;for(var a=e._props,s=e.$options._propKeys||[],c=0;c<s.length;c++){var u=s[c];a[u]=P(u,e.$options.props,t,e)}Qi.shouldConvert=!0,e.$options.propsData=t}if(n){var l=e.$options._parentListeners;e.$options._parentListeners=n,te(e,n,l)}o&&(e.$slots=ne(i,r.context),e.$forceUpdate())}function ce(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function ue(e,t){if(t){if(e._directInactive=!1,ce(e))return}else if(e._directInactive)return;if(e._inactive||null==e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)ue(e.$children[n]);fe(e,"activated")}}function le(e,t){if(!(t&&(e._directInactive=!0,ce(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)le(e.$children[n]);fe(e,"deactivated")}}function fe(e,t){var n=e.$options[t];if(n)for(var r=0,i=n.length;r<i;r++)try{n[r].call(e)}catch(n){U(n,e,t+" hook")}e._hasHookEvent&&e.$emit("hook:"+t)}function pe(){co.length=0,uo={},lo=fo=!1}function de(){fo=!0;var e,t,n;for(co.sort(function(e,t){return e.id-t.id}),po=0;po<co.length;po++)e=co[po],t=e.id,uo[t]=null,e.run();var r=co.slice();for(pe(),po=r.length;po--;)e=r[po],n=e.vm,n._watcher===e&&n._isMounted&&fe(n,"updated");Bi&&Si.devtools&&Bi.emit("flush")}function ve(e){var t=e.id;if(null==uo[t]){if(uo[t]=!0,fo){for(var n=co.length-1;n>=0&&co[n].id>e.id;)n--;co.splice(Math.max(n,po)+1,0,e)}else co.push(e);lo||(lo=!0,zi(de))}}function he(e){mo.clear(),me(e,mo)}function me(e,t){var n,r,i=Array.isArray(e);if((i||l(e))&&Object.isExtensible(e)){if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(n=e.length;n--;)me(e[n],t);else for(r=Object.keys(e),n=r.length;n--;)me(e[r[n]],t)}}function ge(e,t,n){go.get=function(){return this[t][n]},go.set=function(e){this[t][n]=e},Object.defineProperty(e,n,go)}function ye(e){e._watchers=[];var t=e.$options;t.props&&_e(e,t.props),t.methods&&ke(e,t.methods),t.data?be(e):k(e._data={},!0),t.computed&&we(e,t.computed),t.watch&&Ae(e,t.watch)}function _e(e,t){var n=e.$options.propsData||{},r=e._props={},i=e.$options._propKeys=[],o=!e.$parent;Qi.shouldConvert=o;for(var a in t)!function(o){i.push(o);var a=P(o,t,n,e);A(r,o,a),o in e||ge(e,"_props",o)}(a);Qi.shouldConvert=!0}function be(e){var t=e.$options.data;t=e._data="function"==typeof t?$e(t,e):t||{},f(t)||(t={});for(var n=Object.keys(t),r=e.$options.props,o=n.length;o--;)r&&i(r,n[o])||g(n[o])||ge(e,"_data",n[o]);k(t,!0)}function $e(e,t){try{return e.call(t)}catch(e){return U(e,t,"data()"),{}}}function we(e,t){var n=e._computedWatchers=Object.create(null);for(var r in t){var i=t[r],o="function"==typeof i?i:i.get;n[r]=new ho(e,o,d,yo),r in e||xe(e,r,i)}}function xe(e,t,n){"function"==typeof n?(go.get=Ce(t),go.set=d):(go.get=n.get?n.cache!==!1?Ce(t):n.get:d,go.set=n.set?n.set:d),Object.defineProperty(e,t,go)}function Ce(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),qi.target&&t.depend(),t.value}}function ke(e,t){e.$options.props;for(var n in t)e[n]=null==t[n]?d:s(t[n],e)}function Ae(e,t){for(var n in t){var r=t[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)Oe(e,n,r[i]);else Oe(e,n,r)}}function Oe(e,t,n){var r;f(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,r)}function Te(e,t,n,r,i){if(e){var o=n.$options._base;if(l(e)&&(e=o.extend(e)),"function"==typeof e){if(!e.cid)if(e.resolved)e=e.resolved;else if(!(e=je(e,o,function(){n.$forceUpdate()})))return;Xe(e),t=t||{},t.model&&Me(e.options,t);var a=Ne(t,e,i);if(e.options.functional)return Se(e,a,t,n,r);var s=t.on;t.on=t.nativeOn,e.options.abstract&&(t={}),Le(t);var c=e.options.name||i;return new no("vue-component-"+e.cid+(c?"-"+c:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:a,listeners:s,tag:i,children:r})}}}function Se(e,t,n,r,i){var o={},a=e.options.props;if(a)for(var s in a)o[s]=P(s,a,t);var c=Object.create(r),u=function(e,t,n,r){return Pe(c,e,t,n,r,!0)},l=e.options.render.call(null,u,{props:o,data:n,parent:r,children:i,slots:function(){return ne(i,r)}});return l instanceof no&&(l.functionalContext=r,n.slot&&((l.data||(l.data={})).slot=n.slot)),l}function Ee(e,t,n,r){var i=e.componentOptions,o={_isComponent:!0,parent:t,propsData:i.propsData,_componentTag:i.tag,_parentVnode:e,_parentListeners:i.listeners,_renderChildren:i.children,_parentElm:n||null,_refElm:r||null},a=e.data.inlineTemplate;return a&&(o.render=a.render,o.staticRenderFns=a.staticRenderFns),new i.Ctor(o)}function je(e,t,n){if(!e.requested){e.requested=!0;var r=e.pendingCallbacks=[n],i=!0,o=function(n){if(l(n)&&(n=t.extend(n)),e.resolved=n,!i)for(var o=0,a=r.length;o<a;o++)r[o](n)},a=function(e){},s=e(o,a);return s&&"function"==typeof s.then&&!e.resolved&&s.then(o,a),i=!1,e.resolved}e.pendingCallbacks.push(n)}function Ne(e,t,n){var r=t.options.props;if(r){var i={},o=e.attrs,a=e.props,s=e.domProps;if(o||a||s)for(var c in r){var u=Ci(c);Ie(i,a,c,u,!0)||Ie(i,o,c,u)||Ie(i,s,c,u)}return i}}function Ie(e,t,n,r,o){if(t){if(i(t,n))return e[n]=t[n],o||delete t[n],!0;if(i(t,r))return e[n]=t[r],o||delete t[r],!0}return!1}function Le(e){e.hook||(e.hook={});for(var t=0;t<bo.length;t++){var n=bo[t],r=e.hook[n],i=_o[n];e.hook[n]=r?De(i,r):i}}function De(e,t){return function(n,r,i,o){e(n,r,i,o),t(n,r,i,o)}}function Me(e,t){var n=e.model&&e.model.prop||"value",r=e.model&&e.model.event||"input";(t.props||(t.props={}))[n]=t.model.value;var i=t.on||(t.on={});i[r]?i[r]=[t.model.callback].concat(i[r]):i[r]=t.model.callback}function Pe(e,t,n,r,i,a){return(Array.isArray(n)||o(n))&&(i=r,r=n,n=void 0),a&&(i=wo),Re(e,t,n,r,i)}function Re(e,t,n,r,i){if(n&&n.__ob__)return oo();if(!t)return oo();Array.isArray(r)&&"function"==typeof r[0]&&(n=n||{},n.scopedSlots={default:r[0]},r.length=0),i===wo?r=Z(r):i===$o&&(r=W(r));var o,a;if("string"==typeof t){var s;a=Si.getTagNamespace(t),o=Si.isReservedTag(t)?new no(Si.parsePlatformTagName(t),n,r,void 0,void 0,e):(s=M(e.$options,"components",t))?Te(s,n,e,r,t):new no(t,n,r,void 0,void 0,e)}else o=Te(t,n,e,r);return o?(a&&Fe(o,a),o):oo()}function Fe(e,t){if(e.ns=t,"foreignObject"!==e.tag&&e.children)for(var n=0,r=e.children.length;n<r;n++){var i=e.children[n];i.tag&&!i.ns&&Fe(i,t)}}function He(e,t){var n,r,i,o,a;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),r=0,i=e.length;r<i;r++)n[r]=t(e[r],r);else if("number"==typeof e)for(n=new Array(e),r=0;r<e;r++)n[r]=t(r+1,r);else if(l(e))for(o=Object.keys(e),n=new Array(o.length),r=0,i=o.length;r<i;r++)a=o[r],n[r]=t(e[a],a,r);return n}function Ue(e,t,n,r){var i=this.$scopedSlots[e];if(i)return n=n||{},r&&u(n,r),i(n)||t;var o=this.$slots[e];return o||t}function Be(e){return M(this.$options,"filters",e,!0)||Ti}function Ve(e,t,n){var r=Si.keyCodes[t]||n;return Array.isArray(r)?r.indexOf(e)===-1:r!==e}function ze(e,t,n,r){if(n)if(l(n)){Array.isArray(n)&&(n=p(n));var i;for(var o in n){if("class"===o||"style"===o)i=e;else{var a=e.attrs&&e.attrs.type;i=r||Si.mustUseProp(t,a,o)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}o in i||(i[o]=n[o])}}else;return e}function Je(e,t){var n=this._staticTrees[e];return n&&!t?Array.isArray(n)?z(n):V(n):(n=this._staticTrees[e]=this.$options.staticRenderFns[e].call(this._renderProxy),qe(n,"__static__"+e,!1),n)}function Ke(e,t,n){return qe(e,"__once__"+t+(n?"_"+n:""),!0),e}function qe(e,t,n){if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&We(e[r],t+"_"+r,n);else We(e,t,n)}function We(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Ze(e){e.$vnode=null,e._vnode=null,e._staticTrees=null;var t=e.$options._parentVnode,n=t&&t.context;e.$slots=ne(e.$options._renderChildren,n),e.$scopedSlots=Ei,e._c=function(t,n,r,i){return Pe(e,t,n,r,i,!1)},e.$createElement=function(t,n,r,i){return Pe(e,t,n,r,i,!0)}}function Ge(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}function Ye(e){var t=e.$options.inject;if(t)for(var n=Array.isArray(t),r=n?t:Vi?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++)!function(i){for(var o=r[i],a=n?o:t[o],s=e;s;){if(s._provided&&a in s._provided){A(e,o,s._provided[a]);break}s=s.$parent}}(i)}function Qe(e,t){var n=e.$options=Object.create(e.constructor.options);n.parent=t.parent,n.propsData=t.propsData,n._parentVnode=t._parentVnode,n._parentListeners=t._parentListeners,n._renderChildren=t._renderChildren,n._componentTag=t._componentTag,n._parentElm=t._parentElm,n._refElm=t._refElm,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}function Xe(e){var t=e.options;if(e.super){var n=Xe(e.super);if(n!==e.superOptions){e.superOptions=n;var r=et(e);r&&u(e.extendOptions,r),t=e.options=D(n,e.extendOptions),t.name&&(t.components[t.name]=e)}}return t}function et(e){var t,n=e.options,r=e.sealedOptions;for(var i in n)n[i]!==r[i]&&(t||(t={}),t[i]=tt(n[i],r[i]));return t}function tt(e,t){if(Array.isArray(e)){var n=[];t=Array.isArray(t)?t:[t];for(var r=0;r<e.length;r++)t.indexOf(e[r])<0&&n.push(e[r]);return n}return e}function nt(e){this._init(e)}function rt(e){e.use=function(e){if(!e.installed){var t=c(arguments,1);return t.unshift(this),"function"==typeof e.install?e.install.apply(e,t):"function"==typeof e&&e.apply(null,t),e.installed=!0,this}}}function it(e){e.mixin=function(e){this.options=D(this.options,e)}}function ot(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,r=n.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=e.name||n.options.name,a=function(e){this._init(e)};return a.prototype=Object.create(n.prototype),a.prototype.constructor=a,a.cid=t++,a.options=D(n.options,e),a.super=n,a.options.props&&at(a),a.options.computed&&st(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,Si._assetTypes.forEach(function(e){a[e]=n[e]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=e,a.sealedOptions=u({},a.options),i[r]=a,a}}function at(e){var t=e.options.props;for(var n in t)ge(e.prototype,"_props",n)}function st(e){var t=e.options.computed;for(var n in t)xe(e.prototype,n,t[n])}function ct(e){Si._assetTypes.forEach(function(t){e[t]=function(e,n){return n?("component"===t&&f(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}})}function ut(e){return e&&(e.Ctor.options.name||e.tag)}function lt(e,t){return"string"==typeof e?e.split(",").indexOf(t)>-1:e instanceof RegExp&&e.test(t)}function ft(e,t){for(var n in e){var r=e[n];if(r){var i=ut(r.componentOptions);i&&!t(i)&&(pt(r),e[n]=null)}}}function pt(e){e&&(e.componentInstance._inactive||fe(e.componentInstance,"deactivated"),e.componentInstance.$destroy())}function dt(e){for(var t=e.data,n=e,r=e;r.componentInstance;)r=r.componentInstance._vnode,r.data&&(t=vt(r.data,t));for(;n=n.parent;)n.data&&(t=vt(t,n.data));return ht(t)}function vt(e,t){return{staticClass:mt(e.staticClass,t.staticClass),class:e.class?[e.class,t.class]:t.class}}function ht(e){var t=e.class,n=e.staticClass;return n||t?mt(n,gt(t)):""}function mt(e,t){return e?t?e+" "+t:e:t||""}function gt(e){var t="";if(!e)return t;if("string"==typeof e)return e;if(Array.isArray(e)){for(var n,r=0,i=e.length;r<i;r++)e[r]&&(n=gt(e[r]))&&(t+=n+" ");return t.slice(0,-1)}if(l(e)){for(var o in e)e[o]&&(t+=o+" ");return t.slice(0,-1)}return t}function yt(e){return Ko(e)?"svg":"math"===e?"math":void 0}function _t(e){if(!Ii)return!0;if(Wo(e))return!1;if(e=e.toLowerCase(),null!=Zo[e])return Zo[e];var t=document.createElement(e);return e.indexOf("-")>-1?Zo[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Zo[e]=/HTMLUnknownElement/.test(t.toString())}function bt(e){if("string"==typeof e){var t=document.querySelector(e);return t?t:document.createElement("div")}return e}function $t(e,t){var n=document.createElement(e);return"select"!==e?n:(t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)}function wt(e,t){return document.createElementNS(zo[e],t)}function xt(e){return document.createTextNode(e)}function Ct(e){return document.createComment(e)}function kt(e,t,n){e.insertBefore(t,n)}function At(e,t){e.removeChild(t)}function Ot(e,t){e.appendChild(t)}function Tt(e){return e.parentNode}function St(e){return e.nextSibling}function Et(e){return e.tagName}function jt(e,t){e.textContent=t}function Nt(e,t,n){e.setAttribute(t,n)}function It(e,t){var n=e.data.ref;if(n){var i=e.context,o=e.componentInstance||e.elm,a=i.$refs;t?Array.isArray(a[n])?r(a[n],o):a[n]===o&&(a[n]=void 0):e.data.refInFor?Array.isArray(a[n])&&a[n].indexOf(o)<0?a[n].push(o):a[n]=[o]:a[n]=o}}function Lt(e){return void 0===e||null===e}function Dt(e){return void 0!==e&&null!==e}function Mt(e){return e===!0}function Pt(e,t){return e.key===t.key&&e.tag===t.tag&&e.isComment===t.isComment&&Dt(e.data)===Dt(t.data)&&Rt(e,t)}function Rt(e,t){if("input"!==e.tag)return!0;var n;return(Dt(n=e.data)&&Dt(n=n.attrs)&&n.type)===(Dt(n=t.data)&&Dt(n=n.attrs)&&n.type)}function Ft(e,t,n){var r,i,o={};for(r=t;r<=n;++r)i=e[r].key,Dt(i)&&(o[i]=r);return o}function Ht(e,t){(e.data.directives||t.data.directives)&&Ut(e,t)}function Ut(e,t){var n,r,i,o=e===Qo,a=t===Qo,s=Bt(e.data.directives,e.context),c=Bt(t.data.directives,t.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,zt(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(zt(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)zt(u[n],"inserted",t,e)};o?q(t.data.hook||(t.data.hook={}),"insert",f):f()}if(l.length&&q(t.data.hook||(t.data.hook={}),"postpatch",function(){for(var n=0;n<l.length;n++)zt(l[n],"componentUpdated",t,e)}),!o)for(n in s)c[n]||zt(s[n],"unbind",e,e,a)}function Bt(e,t){var n=Object.create(null);if(!e)return n;var r,i;for(r=0;r<e.length;r++)i=e[r],i.modifiers||(i.modifiers=ta),n[Vt(i)]=i,i.def=M(t.$options,"directives",i.name,!0);return n}function Vt(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function zt(e,t,n,r,i){var o=e.def&&e.def[t];o&&o(n.elm,e,n,r,i)}function Jt(e,t){if(e.data.attrs||t.data.attrs){var n,r,i=t.elm,o=e.data.attrs||{},a=t.data.attrs||{};a.__ob__&&(a=t.data.attrs=u({},a));for(n in a)r=a[n],o[n]!==r&&Kt(i,n,r);Mi&&a.value!==o.value&&Kt(i,"value",a.value);for(n in o)null==a[n]&&(Uo(n)?i.removeAttributeNS(Ho,Bo(n)):Ro(n)||i.removeAttribute(n))}}function Kt(e,t,n){Fo(t)?Vo(n)?e.removeAttribute(t):e.setAttribute(t,t):Ro(t)?e.setAttribute(t,Vo(n)||"false"===n?"false":"true"):Uo(t)?Vo(n)?e.removeAttributeNS(Ho,Bo(t)):e.setAttributeNS(Ho,t,n):Vo(n)?e.removeAttribute(t):e.setAttribute(t,n)}function qt(e,t){var n=t.elm,r=t.data,i=e.data;if(r.staticClass||r.class||i&&(i.staticClass||i.class)){var o=dt(t),a=n._transitionClasses;a&&(o=mt(o,gt(a))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}function Wt(e){function t(){(a||(a=[])).push(e.slice(v,i).trim()),v=i+1}var n,r,i,o,a,s=!1,c=!1,u=!1,l=!1,f=0,p=0,d=0,v=0;for(i=0;i<e.length;i++)if(r=n,n=e.charCodeAt(i),s)39===n&&92!==r&&(s=!1);else if(c)34===n&&92!==r&&(c=!1);else if(u)96===n&&92!==r&&(u=!1);else if(l)47===n&&92!==r&&(l=!1);else if(124!==n||124===e.charCodeAt(i+1)||124===e.charCodeAt(i-1)||f||p||d){switch(n){case 34:c=!0;break;case 39:s=!0;break;case 96:u=!0;break;case 40:d++;break;case 41:d--;break;case 91:p++;break;case 93:p--;break;case 123:f++;break;case 125:f--}if(47===n){for(var h=i-1,m=void 0;h>=0&&" "===(m=e.charAt(h));h--);m&&oa.test(m)||(l=!0)}}else void 0===o?(v=i+1,o=e.slice(0,i).trim()):t();if(void 0===o?o=e.slice(0,i).trim():0!==v&&t(),a)for(i=0;i<a.length;i++)o=Zt(o,a[i]);return o}function Zt(e,t){var n=t.indexOf("(");return n<0?'_f("'+t+'")('+e+")":'_f("'+t.slice(0,n)+'")('+e+","+t.slice(n+1)}function Gt(e){console.error("[Vue compiler]: "+e)}function Yt(e,t){return e?e.map(function(e){return e[t]}).filter(function(e){return e}):[]}function Qt(e,t,n){(e.props||(e.props=[])).push({name:t,value:n})}function Xt(e,t,n){(e.attrs||(e.attrs=[])).push({name:t,value:n})}function en(e,t,n,r,i,o){(e.directives||(e.directives=[])).push({name:t,rawName:n,value:r,arg:i,modifiers:o})}function tn(e,t,n,r,i){r&&r.capture&&(delete r.capture,t="!"+t),r&&r.once&&(delete r.once,t="~"+t);var o;r&&r.native?(delete r.native,o=e.nativeEvents||(e.nativeEvents={})):o=e.events||(e.events={});var a={value:n,modifiers:r},s=o[t];Array.isArray(s)?i?s.unshift(a):s.push(a):o[t]=s?i?[a,s]:[s,a]:a}function nn(e,t,n){var r=rn(e,":"+t)||rn(e,"v-bind:"+t);if(null!=r)return Wt(r);if(n!==!1){var i=rn(e,t);if(null!=i)return JSON.stringify(i)}}function rn(e,t){var n;if(null!=(n=e.attrsMap[t]))for(var r=e.attrsList,i=0,o=r.length;i<o;i++)if(r[i].name===t){r.splice(i,1);break}return n}function on(e,t,n){var r=n||{},i=r.number,o=r.trim,a="$$v";o&&(a="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(a="_n("+a+")");var s=an(t,a);e.model={value:"("+t+")",expression:'"'+t+'"',callback:"function ($$v) {"+s+"}"}}function an(e,t){var n=sn(e);return null===n.idx?e+"="+t:"var $$exp = "+n.exp+", $$idx = "+n.idx+";if (!Array.isArray($$exp)){"+e+"="+t+"}else{$$exp.splice($$idx, 1, "+t+")}"}function sn(e){if(To=e,Oo=To.length,Eo=jo=No=0,e.indexOf("[")<0||e.lastIndexOf("]")<Oo-1)return{exp:e,idx:null};for(;!un();)So=cn(),ln(So)?pn(So):91===So&&fn(So);return{exp:e.substring(0,jo),idx:e.substring(jo+1,No)}}function cn(){return To.charCodeAt(++Eo)}function un(){return Eo>=Oo}function ln(e){return 34===e||39===e}function fn(e){var t=1;for(jo=Eo;!un();)if(e=cn(),ln(e))pn(e);else if(91===e&&t++,93===e&&t--,0===t){No=Eo;break}}function pn(e){for(var t=e;!un()&&(e=cn())!==t;);}function dn(e,t,n){Io=n;var r=t.value,i=t.modifiers,o=e.tag,a=e.attrsMap.type;if("select"===o)mn(e,r,i);else if("input"===o&&"checkbox"===a)vn(e,r,i);else if("input"===o&&"radio"===a)hn(e,r,i);else if("input"===o||"textarea"===o)gn(e,r,i);else if(!Si.isReservedTag(o))return on(e,r,i),!1;return!0}function vn(e,t,n){var r=n&&n.number,i=nn(e,"value")||"null",o=nn(e,"true-value")||"true",a=nn(e,"false-value")||"false";Qt(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===o?":("+t+")":":_q("+t+","+o+")")),tn(e,sa,"var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$c){$$i<0&&("+t+"=$$a.concat($$v))}else{$$i>-1&&("+t+"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{"+t+"=$$c}",null,!0)}function hn(e,t,n){var r=n&&n.number,i=nn(e,"value")||"null";i=r?"_n("+i+")":i,Qt(e,"checked","_q("+t+","+i+")"),tn(e,sa,an(t,i),null,!0)}function mn(e,t,n){var r=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(r?"_n(val)":"val")+"})",o="var $$selectedVal = "+i+";";o=o+" "+an(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),tn(e,"change",o,null,!0)}function gn(e,t,n){var r=e.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?aa:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=an(t,l);c&&(f="if($event.target.composing)return;"+f),Qt(e,"value","("+t+")"),tn(e,u,f,null,!0),(s||a||"number"===r)&&tn(e,"blur","$forceUpdate()")}function yn(e){var t;e[aa]&&(t=Di?"change":"input",e[t]=[].concat(e[aa],e[t]||[]),delete e[aa]),e[sa]&&(t=Hi?"click":"change",e[t]=[].concat(e[sa],e[t]||[]),delete e[sa])}function _n(e,t,n,r){if(n){var i=t,o=Lo;t=function(n){null!==(1===arguments.length?i(n):i.apply(null,arguments))&&bn(e,t,r,o)}}Lo.addEventListener(e,t,r)}function bn(e,t,n,r){(r||Lo).removeEventListener(e,t,n)}function $n(e,t){if(e.data.on||t.data.on){var n=t.data.on||{},r=e.data.on||{};Lo=t.elm,yn(n),K(n,r,_n,bn,t.context)}}function wn(e,t){if(e.data.domProps||t.data.domProps){var n,r,i=t.elm,o=e.data.domProps||{},a=t.data.domProps||{};a.__ob__&&(a=t.data.domProps=u({},a));for(n in o)null==a[n]&&(i[n]="");for(n in a)if(r=a[n],"textContent"!==n&&"innerHTML"!==n||(t.children&&(t.children.length=0),r!==o[n]))if("value"===n){i._value=r;var s=null==r?"":String(r);xn(i,t,s)&&(i.value=s)}else i[n]=r}}function xn(e,t,n){return!e.composing&&("option"===t.tag||Cn(e,n)||kn(e,n))}function Cn(e,t){return document.activeElement!==e&&e.value!==t}function kn(e,n){var r=e.value,i=e._vModifiers;return i&&i.number||"number"===e.type?t(r)!==t(n):i&&i.trim?r.trim()!==n.trim():r!==n}function An(e){var t=On(e.style);return e.staticStyle?u(e.staticStyle,t):t}function On(e){return Array.isArray(e)?p(e):"string"==typeof e?la(e):e}function Tn(e,t){var n,r={};if(t)for(var i=e;i.componentInstance;)i=i.componentInstance._vnode,i.data&&(n=An(i.data))&&u(r,n);(n=An(e.data))&&u(r,n);for(var o=e;o=o.parent;)o.data&&(n=An(o.data))&&u(r,n);return r}function Sn(e,t){var n=t.data,r=e.data;if(n.staticStyle||n.style||r.staticStyle||r.style){var i,o,a=t.elm,s=e.data.staticStyle,c=e.data.style||{},l=s||c,f=On(t.data.style)||{};t.data.style=f.__ob__?u({},f):f;var p=Tn(t,!0);for(o in l)null==p[o]&&da(a,o,"");for(o in p)(i=p[o])!==l[o]&&da(a,o,null==i?"":i)}}function En(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.add(t)}):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function jn(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.remove(t)}):e.classList.remove(t);else{for(var n=" "+(e.getAttribute("class")||"")+" ",r=" "+t+" ";n.indexOf(r)>=0;)n=n.replace(r," ");e.setAttribute("class",n.trim())}}function Nn(e){if(e){if("object"==typeof e){var t={};return e.css!==!1&&u(t,ga(e.name||"v")),u(t,e),t}return"string"==typeof e?ga(e):void 0}}function In(e){ka(function(){ka(e)})}function Ln(e,t){(e._transitionClasses||(e._transitionClasses=[])).push(t),En(e,t)}function Dn(e,t){e._transitionClasses&&r(e._transitionClasses,t),jn(e,t)}function Mn(e,t,n){var r=Pn(e,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===_a?wa:Ca,c=0,u=function(){e.removeEventListener(s,l),n()},l=function(t){t.target===e&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),e.addEventListener(s,l)}function Pn(e,t){var n,r=window.getComputedStyle(e),i=r[$a+"Delay"].split(", "),o=r[$a+"Duration"].split(", "),a=Rn(i,o),s=r[xa+"Delay"].split(", "),c=r[xa+"Duration"].split(", "),u=Rn(s,c),l=0,f=0;return t===_a?a>0&&(n=_a,l=a,f=o.length):t===ba?u>0&&(n=ba,l=u,f=c.length):(l=Math.max(a,u),n=l>0?a>u?_a:ba:null,f=n?n===_a?o.length:c.length:0),{type:n,timeout:l,propCount:f,hasTransform:n===_a&&Aa.test(r[$a+"Property"])}}function Rn(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map(function(t,n){return Fn(t)+Fn(e[n])}))}function Fn(e){return 1e3*Number(e.slice(0,-1))}function Hn(e,n){var r=e.elm;r._leaveCb&&(r._leaveCb.cancelled=!0,r._leaveCb());var i=Nn(e.data.transition);if(i&&!r._enterCb&&1===r.nodeType){for(var o=i.css,a=i.type,s=i.enterClass,c=i.enterToClass,u=i.enterActiveClass,f=i.appearClass,p=i.appearToClass,d=i.appearActiveClass,v=i.beforeEnter,h=i.enter,g=i.afterEnter,y=i.enterCancelled,_=i.beforeAppear,b=i.appear,$=i.afterAppear,w=i.appearCancelled,x=i.duration,C=so,k=so.$vnode;k&&k.parent;)k=k.parent,C=k.context;var A=!C._isMounted||!e.isRootInsert;if(!A||b||""===b){var O=A&&f?f:s,T=A&&d?d:u,S=A&&p?p:c,E=A?_||v:v,j=A&&"function"==typeof b?b:h,N=A?$||g:g,I=A?w||y:y,L=t(l(x)?x.enter:x),D=o!==!1&&!Mi,M=Vn(j),P=r._enterCb=m(function(){D&&(Dn(r,S),Dn(r,T)),P.cancelled?(D&&Dn(r,O),I&&I(r)):N&&N(r),r._enterCb=null});e.data.show||q(e.data.hook||(e.data.hook={}),"insert",function(){var t=r.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),j&&j(r,P)}),E&&E(r),D&&(Ln(r,O),Ln(r,T),In(function(){Ln(r,S),Dn(r,O),P.cancelled||M||(Bn(L)?setTimeout(P,L):Mn(r,a,P))})),e.data.show&&(n&&n(),j&&j(r,P)),D||M||P()}}}function Un(e,n){function r(){w.cancelled||(e.data.show||((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),p&&p(i),_&&(Ln(i,c),Ln(i,f),In(function(){Ln(i,u),Dn(i,c),w.cancelled||b||(Bn($)?setTimeout(w,$):Mn(i,s,w))})),d&&d(i,w),_||b||w())}var i=e.elm;i._enterCb&&(i._enterCb.cancelled=!0,i._enterCb());var o=Nn(e.data.transition);if(!o)return n();if(!i._leaveCb&&1===i.nodeType){
	var a=o.css,s=o.type,c=o.leaveClass,u=o.leaveToClass,f=o.leaveActiveClass,p=o.beforeLeave,d=o.leave,v=o.afterLeave,h=o.leaveCancelled,g=o.delayLeave,y=o.duration,_=a!==!1&&!Mi,b=Vn(d),$=t(l(y)?y.leave:y),w=i._leaveCb=m(function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),_&&(Dn(i,u),Dn(i,f)),w.cancelled?(_&&Dn(i,c),h&&h(i)):(n(),v&&v(i)),i._leaveCb=null});g?g(r):r()}}function Bn(e){return"number"==typeof e&&!isNaN(e)}function Vn(e){if(!e)return!1;var t=e.fns;return t?Vn(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function zn(e,t){t.data.show||Hn(t)}function Jn(e,t,n){var r=t.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=h(r,qn(a))>-1,a.selected!==o&&(a.selected=o);else if(v(qn(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function Kn(e,t){for(var n=0,r=t.length;n<r;n++)if(v(qn(t[n]),e))return!1;return!0}function qn(e){return"_value"in e?e._value:e.value}function Wn(e){e.target.composing=!0}function Zn(e){e.target.composing=!1,Gn(e.target,"input")}function Gn(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Yn(e){return!e.componentInstance||e.data&&e.data.transition?e:Yn(e.componentInstance._vnode)}function Qn(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Qn(Y(t.children)):e}function Xn(e){var t={},n=e.$options;for(var r in n.propsData)t[r]=e[r];var i=n._parentListeners;for(var o in i)t[wi(o)]=i[o];return t}function er(e,t){return/\d-keep-alive$/.test(t.tag)?e("keep-alive"):null}function tr(e){for(;e=e.parent;)if(e.data.transition)return!0}function nr(e,t){return t.key===e.key&&t.tag===e.tag}function rr(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function ir(e){e.data.newPos=e.elm.getBoundingClientRect()}function or(e){var t=e.data.pos,n=e.data.newPos,r=t.left-n.left,i=t.top-n.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}function ar(e){return Fa=Fa||document.createElement("div"),Fa.innerHTML=e,Fa.textContent}function sr(e,t){var n=t?ws:$s;return e.replace(n,function(e){return bs[e]})}function cr(e,t){function n(t){l+=t,e=e.substring(t)}function r(e,n,r){var i,s;if(null==n&&(n=l),null==r&&(r=l),e&&(s=e.toLowerCase()),e)for(i=a.length-1;i>=0&&a[i].lowerCasedTag!==s;i--);else i=0;if(i>=0){for(var c=a.length-1;c>=i;c--)t.end&&t.end(a[c].tag,n,r);a.length=i,o=i&&a[i-1].tag}else"br"===s?t.start&&t.start(e,[],!0,n,r):"p"===s&&(t.start&&t.start(e,[],!1,n,r),t.end&&t.end(e,n,r))}for(var i,o,a=[],s=t.expectHTML,c=t.isUnaryTag||Oi,u=t.canBeLeftOpenTag||Oi,l=0;e;){if(i=e,o&&ys(o)){var f=o.toLowerCase(),p=_s[f]||(_s[f]=new RegExp("([\\s\\S]*?)(</"+f+"[^>]*>)","i")),d=0,v=e.replace(p,function(e,n,r){return d=r.length,ys(f)||"noscript"===f||(n=n.replace(/<!--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),t.chars&&t.chars(n),""});l+=e.length-v.length,e=v,r(f,l-d,l)}else{var h=e.indexOf("<");if(0===h){if(Ya.test(e)){var m=e.indexOf("-->");if(m>=0){n(m+3);continue}}if(Qa.test(e)){var g=e.indexOf("]>");if(g>=0){n(g+2);continue}}var y=e.match(Ga);if(y){n(y[0].length);continue}var _=e.match(Za);if(_){var b=l;n(_[0].length),r(_[1],b,l);continue}var $=function(){var t=e.match(qa);if(t){var r={tagName:t[1],attrs:[],start:l};n(t[0].length);for(var i,o;!(i=e.match(Wa))&&(o=e.match(Ja));)n(o[0].length),r.attrs.push(o);if(i)return r.unarySlash=i[1],n(i[0].length),r.end=l,r}}();if($){!function(e){var n=e.tagName,i=e.unarySlash;s&&("p"===o&&Va(n)&&r(o),u(n)&&o===n&&r(n));for(var l=c(n)||"html"===n&&"head"===o||!!i,f=e.attrs.length,p=new Array(f),d=0;d<f;d++){var v=e.attrs[d];Xa&&v[0].indexOf('""')===-1&&(""===v[3]&&delete v[3],""===v[4]&&delete v[4],""===v[5]&&delete v[5]);var h=v[3]||v[4]||v[5]||"";p[d]={name:v[1],value:sr(h,t.shouldDecodeNewlines)}}l||(a.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:p}),o=n),t.start&&t.start(n,p,l,e.start,e.end)}($);continue}}var w=void 0,x=void 0,C=void 0;if(h>=0){for(x=e.slice(h);!(Za.test(x)||qa.test(x)||Ya.test(x)||Qa.test(x)||(C=x.indexOf("<",1))<0);)h+=C,x=e.slice(h);w=e.substring(0,h),n(h)}h<0&&(w=e,e=""),t.chars&&w&&t.chars(w)}if(e===i){t.chars&&t.chars(e);break}}r()}function ur(e,t){var n=t?Cs(t):xs;if(n.test(e)){for(var r,i,o=[],a=n.lastIndex=0;r=n.exec(e);){i=r.index,i>a&&o.push(JSON.stringify(e.slice(a,i)));var s=Wt(r[1].trim());o.push("_s("+s+")"),a=i+r[0].length}return a<e.length&&o.push(JSON.stringify(e.slice(a))),o.join("+")}}function lr(e,t){function n(e){e.pre&&(s=!1),os(e.tag)&&(c=!1)}es=t.warn||Gt,ss=t.getTagNamespace||Oi,as=t.mustUseProp||Oi,os=t.isPreTag||Oi,rs=Yt(t.modules,"preTransformNode"),ns=Yt(t.modules,"transformNode"),is=Yt(t.modules,"postTransformNode"),ts=t.delimiters;var r,i,o=[],a=t.preserveWhitespace!==!1,s=!1,c=!1;return cr(e,{warn:es,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,start:function(e,a,u){var l=i&&i.ns||ss(e);Di&&"svg"===l&&(a=Tr(a));var f={type:1,tag:e,attrsList:a,attrsMap:Ar(a),parent:i,children:[]};l&&(f.ns=l),Or(f)&&!Ui()&&(f.forbidden=!0);for(var p=0;p<rs.length;p++)rs[p](f,t);if(s||(fr(f),f.pre&&(s=!0)),os(f.tag)&&(c=!0),s)pr(f);else{hr(f),mr(f),br(f),dr(f),f.plain=!f.key&&!a.length,vr(f),$r(f),wr(f);for(var d=0;d<ns.length;d++)ns[d](f,t);xr(f)}if(r?o.length||r.if&&(f.elseif||f.else)&&_r(r,{exp:f.elseif,block:f}):r=f,i&&!f.forbidden)if(f.elseif||f.else)gr(f,i);else if(f.slotScope){i.plain=!1;var v=f.slotTarget||'"default"';(i.scopedSlots||(i.scopedSlots={}))[v]=f}else i.children.push(f),f.parent=i;u?n(f):(i=f,o.push(f));for(var h=0;h<is.length;h++)is[h](f,t)},end:function(){var e=o[o.length-1],t=e.children[e.children.length-1];t&&3===t.type&&" "===t.text&&!c&&e.children.pop(),o.length-=1,i=o[o.length-1],n(e)},chars:function(e){if(i&&(!Di||"textarea"!==i.tag||i.attrsMap.placeholder!==e)){var t=i.children;if(e=c||e.trim()?Ns(e):a&&t.length?" ":""){var n;!s&&" "!==e&&(n=ur(e,ts))?t.push({type:2,expression:n,text:e}):" "===e&&t.length&&" "===t[t.length-1].text||t.push({type:3,text:e})}}}}),r}function fr(e){null!=rn(e,"v-pre")&&(e.pre=!0)}function pr(e){var t=e.attrsList.length;if(t)for(var n=e.attrs=new Array(t),r=0;r<t;r++)n[r]={name:e.attrsList[r].name,value:JSON.stringify(e.attrsList[r].value)};else e.pre||(e.plain=!0)}function dr(e){var t=nn(e,"key");t&&(e.key=t)}function vr(e){var t=nn(e,"ref");t&&(e.ref=t,e.refInFor=Cr(e))}function hr(e){var t;if(t=rn(e,"v-for")){var n=t.match(Os);if(!n)return;e.for=n[2].trim();var r=n[1].trim(),i=r.match(Ts);i?(e.alias=i[1].trim(),e.iterator1=i[2].trim(),i[3]&&(e.iterator2=i[3].trim())):e.alias=r}}function mr(e){var t=rn(e,"v-if");if(t)e.if=t,_r(e,{exp:t,block:e});else{null!=rn(e,"v-else")&&(e.else=!0);var n=rn(e,"v-else-if");n&&(e.elseif=n)}}function gr(e,t){var n=yr(t.children);n&&n.if&&_r(n,{exp:e.elseif,block:e})}function yr(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}function _r(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function br(e){null!=rn(e,"v-once")&&(e.once=!0)}function $r(e){if("slot"===e.tag)e.slotName=nn(e,"name");else{var t=nn(e,"slot");t&&(e.slotTarget='""'===t?'"default"':t),"template"===e.tag&&(e.slotScope=rn(e,"scope"))}}function wr(e){var t;(t=nn(e,"is"))&&(e.component=t),null!=rn(e,"inline-template")&&(e.inlineTemplate=!0)}function xr(e){var t,n,r,i,o,a,s,c=e.attrsList;for(t=0,n=c.length;t<n;t++)if(r=i=c[t].name,o=c[t].value,As.test(r))if(e.hasBindings=!0,a=kr(r),a&&(r=r.replace(js,"")),Es.test(r))r=r.replace(Es,""),o=Wt(o),s=!1,a&&(a.prop&&(s=!0,"innerHtml"===(r=wi(r))&&(r="innerHTML")),a.camel&&(r=wi(r))),s||as(e.tag,e.attrsMap.type,r)?Qt(e,r,o):Xt(e,r,o);else if(ks.test(r))r=r.replace(ks,""),tn(e,r,o,a);else{r=r.replace(As,"");var u=r.match(Ss),l=u&&u[1];l&&(r=r.slice(0,-(l.length+1))),en(e,r,i,o,l,a)}else Xt(e,r,JSON.stringify(o))}function Cr(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}function kr(e){var t=e.match(js);if(t){var n={};return t.forEach(function(e){n[e.slice(1)]=!0}),n}}function Ar(e){for(var t={},n=0,r=e.length;n<r;n++)t[e[n].name]=e[n].value;return t}function Or(e){return"style"===e.tag||"script"===e.tag&&(!e.attrsMap.type||"text/javascript"===e.attrsMap.type)}function Tr(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];Is.test(r.name)||(r.name=r.name.replace(Ls,""),t.push(r))}return t}function Sr(e,t){e&&(cs=Ds(t.staticKeys||""),us=t.isReservedTag||Oi,jr(e),Nr(e,!1))}function Er(e){return n("type,tag,attrsList,attrsMap,plain,parent,children,attrs"+(e?","+e:""))}function jr(e){if(e.static=Lr(e),1===e.type){if(!us(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var r=e.children[t];jr(r),r.static||(e.static=!1)}}}function Nr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,r=e.children.length;n<r;n++)Nr(e.children[n],t||!!e.for);e.ifConditions&&Ir(e.ifConditions,t)}}function Ir(e,t){for(var n=1,r=e.length;n<r;n++)Nr(e[n].block,t)}function Lr(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||bi(e.tag)||!us(e.tag)||Dr(e)||!Object.keys(e).every(cs))))}function Dr(e){for(;e.parent;){if(e=e.parent,"template"!==e.tag)return!1;if(e.for)return!0}return!1}function Mr(e,t){var n=t?"nativeOn:{":"on:{";for(var r in e)n+='"'+r+'":'+Pr(r,e[r])+",";return n.slice(0,-1)+"}"}function Pr(e,t){if(!t)return"function(){}";if(Array.isArray(t))return"["+t.map(function(t){return Pr(e,t)}).join(",")+"]";var n=Ps.test(t.value),r=Ms.test(t.value);if(t.modifiers){var i="",o="",a=[];for(var s in t.modifiers)Hs[s]?(o+=Hs[s],Rs[s]&&a.push(s)):a.push(s);a.length&&(i+=Rr(a)),o&&(i+=o);return"function($event){"+i+(n?t.value+"($event)":r?"("+t.value+")($event)":t.value)+"}"}return n||r?t.value:"function($event){"+t.value+"}"}function Rr(e){return"if(!('button' in $event)&&"+e.map(Fr).join("&&")+")return null;"}function Fr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Rs[e];return"_k($event.keyCode,"+JSON.stringify(e)+(n?","+JSON.stringify(n):"")+")"}function Hr(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+(t.modifiers&&t.modifiers.prop?",true":"")+")"}}function Ur(e,t){var n=hs,r=hs=[],i=ms;ms=0,gs=t,ls=t.warn||Gt,fs=Yt(t.modules,"transformCode"),ps=Yt(t.modules,"genData"),ds=t.directives||{},vs=t.isReservedTag||Oi;var o=e?Br(e):'_c("div")';return hs=n,ms=i,{render:"with(this){return "+o+"}",staticRenderFns:r}}function Br(e){if(e.staticRoot&&!e.staticProcessed)return Vr(e);if(e.once&&!e.onceProcessed)return zr(e);if(e.for&&!e.forProcessed)return qr(e);if(e.if&&!e.ifProcessed)return Jr(e);if("template"!==e.tag||e.slotTarget){if("slot"===e.tag)return oi(e);var t;if(e.component)t=ai(e.component,e);else{var n=e.plain?void 0:Wr(e),r=e.inlineTemplate?null:Xr(e,!0);t="_c('"+e.tag+"'"+(n?","+n:"")+(r?","+r:"")+")"}for(var i=0;i<fs.length;i++)t=fs[i](e,t);return t}return Xr(e)||"void 0"}function Vr(e){return e.staticProcessed=!0,hs.push("with(this){return "+Br(e)+"}"),"_m("+(hs.length-1)+(e.staticInFor?",true":"")+")"}function zr(e){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Jr(e);if(e.staticInFor){for(var t="",n=e.parent;n;){if(n.for){t=n.key;break}n=n.parent}return t?"_o("+Br(e)+","+ms+++(t?","+t:"")+")":Br(e)}return Vr(e)}function Jr(e){return e.ifProcessed=!0,Kr(e.ifConditions.slice())}function Kr(e){function t(e){return e.once?zr(e):Br(e)}if(!e.length)return"_e()";var n=e.shift();return n.exp?"("+n.exp+")?"+t(n.block)+":"+Kr(e):""+t(n.block)}function qr(e){var t=e.for,n=e.alias,r=e.iterator1?","+e.iterator1:"",i=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,"_l(("+t+"),function("+n+r+i+"){return "+Br(e)+"})"}function Wr(e){var t="{",n=Zr(e);n&&(t+=n+","),e.key&&(t+="key:"+e.key+","),e.ref&&(t+="ref:"+e.ref+","),e.refInFor&&(t+="refInFor:true,"),e.pre&&(t+="pre:true,"),e.component&&(t+='tag:"'+e.tag+'",');for(var r=0;r<ps.length;r++)t+=ps[r](e);if(e.attrs&&(t+="attrs:{"+si(e.attrs)+"},"),e.props&&(t+="domProps:{"+si(e.props)+"},"),e.events&&(t+=Mr(e.events)+","),e.nativeEvents&&(t+=Mr(e.nativeEvents,!0)+","),e.slotTarget&&(t+="slot:"+e.slotTarget+","),e.scopedSlots&&(t+=Yr(e.scopedSlots)+","),e.model&&(t+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var i=Gr(e);i&&(t+=i+",")}return t=t.replace(/,$/,"")+"}",e.wrapData&&(t=e.wrapData(t)),t}function Zr(e){var t=e.directives;if(t){var n,r,i,o,a="directives:[",s=!1;for(n=0,r=t.length;n<r;n++){i=t[n],o=!0;var c=ds[i.name]||Us[i.name];c&&(o=!!c(e,i,ls)),o&&(s=!0,a+='{name:"'+i.name+'",rawName:"'+i.rawName+'"'+(i.value?",value:("+i.value+"),expression:"+JSON.stringify(i.value):"")+(i.arg?',arg:"'+i.arg+'"':"")+(i.modifiers?",modifiers:"+JSON.stringify(i.modifiers):"")+"},")}return s?a.slice(0,-1)+"]":void 0}}function Gr(e){var t=e.children[0];if(1===t.type){var n=Ur(t,gs);return"inlineTemplate:{render:function(){"+n.render+"},staticRenderFns:["+n.staticRenderFns.map(function(e){return"function(){"+e+"}"}).join(",")+"]}"}}function Yr(e){return"scopedSlots:_u(["+Object.keys(e).map(function(t){return Qr(t,e[t])}).join(",")+"])"}function Qr(e,t){return"["+e+",function("+String(t.attrsMap.scope)+"){return "+("template"===t.tag?Xr(t)||"void 0":Br(t))+"}]"}function Xr(e,t){var n=e.children;if(n.length){var r=n[0];if(1===n.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag)return Br(r);var i=t?ei(n):0;return"["+n.map(ri).join(",")+"]"+(i?","+i:"")}}function ei(e){for(var t=0,n=0;n<e.length;n++){var r=e[n];if(1===r.type){if(ti(r)||r.ifConditions&&r.ifConditions.some(function(e){return ti(e.block)})){t=2;break}(ni(r)||r.ifConditions&&r.ifConditions.some(function(e){return ni(e.block)}))&&(t=1)}}return t}function ti(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ni(e){return!vs(e.tag)}function ri(e){return 1===e.type?Br(e):ii(e)}function ii(e){return"_v("+(2===e.type?e.expression:ci(JSON.stringify(e.text)))+")"}function oi(e){var t=e.slotName||'"default"',n=Xr(e),r="_t("+t+(n?","+n:""),i=e.attrs&&"{"+e.attrs.map(function(e){return wi(e.name)+":"+e.value}).join(",")+"}",o=e.attrsMap["v-bind"];return!i&&!o||n||(r+=",null"),i&&(r+=","+i),o&&(r+=(i?"":",null")+","+o),r+")"}function ai(e,t){var n=t.inlineTemplate?null:Xr(t,!0);return"_c("+e+","+Wr(t)+(n?","+n:"")+")"}function si(e){for(var t="",n=0;n<e.length;n++){var r=e[n];t+='"'+r.name+'":'+ci(r.value)+","}return t.slice(0,-1)}function ci(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function ui(e,t){var n=lr(e.trim(),t);Sr(n,t);var r=Ur(n,t);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}}function li(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),d}}function fi(e,t){var n=(t.warn,rn(e,"class"));n&&(e.staticClass=JSON.stringify(n));var r=nn(e,"class",!1);r&&(e.classBinding=r)}function pi(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}function di(e,t){var n=(t.warn,rn(e,"style"));n&&(e.staticStyle=JSON.stringify(la(n)));var r=nn(e,"style",!1);r&&(e.styleBinding=r)}function vi(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}function hi(e,t){t.value&&Qt(e,"textContent","_s("+t.value+")")}function mi(e,t){t.value&&Qt(e,"innerHTML","_s("+t.value+")")}function gi(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}var yi,_i,bi=n("slot,component",!0),$i=Object.prototype.hasOwnProperty,wi=a(function(e){return e.replace(/-(\w)/g,function(e,t){return t?t.toUpperCase():""})}),xi=a(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),Ci=a(function(e){return e.replace(/([^-])([A-Z])/g,"$1-$2").replace(/([^-])([A-Z])/g,"$1-$2").toLowerCase()}),ki=Object.prototype.toString,Ai="[object Object]",Oi=function(){return!1},Ti=function(e){return e},Si={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:Oi,isUnknownElement:Oi,getTagNamespace:d,parsePlatformTagName:Ti,mustUseProp:Oi,_assetTypes:["component","directive","filter"],_lifecycleHooks:["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated"],_maxUpdateCount:100},Ei=Object.freeze({}),ji=/[^\w.$]/,Ni="__proto__"in{},Ii="undefined"!=typeof window,Li=Ii&&window.navigator.userAgent.toLowerCase(),Di=Li&&/msie|trident/.test(Li),Mi=Li&&Li.indexOf("msie 9.0")>0,Pi=Li&&Li.indexOf("edge/")>0,Ri=Li&&Li.indexOf("android")>0,Fi=Li&&/iphone|ipad|ipod|ios/.test(Li),Hi=Li&&/chrome\/\d+/.test(Li)&&!Pi,Ui=function(){return void 0===yi&&(yi=!Ii&&"undefined"!=typeof global&&"server"===global.process.env.VUE_ENV),yi},Bi=Ii&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,Vi="undefined"!=typeof Symbol&&b(Symbol)&&"undefined"!=typeof Reflect&&b(Reflect.ownKeys),zi=function(){function e(){r=!1;var e=n.slice(0);n.length=0;for(var t=0;t<e.length;t++)e[t]()}var t,n=[],r=!1;if("undefined"!=typeof Promise&&b(Promise)){var i=Promise.resolve(),o=function(e){console.error(e)};t=function(){i.then(e).catch(o),Fi&&setTimeout(d)}}else if("undefined"==typeof MutationObserver||!b(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())t=function(){setTimeout(e,0)};else{var a=1,s=new MutationObserver(e),c=document.createTextNode(String(a));s.observe(c,{characterData:!0}),t=function(){a=(a+1)%2,c.data=String(a)}}return function(e,i){var o;if(n.push(function(){e&&e.call(i),o&&o(i)}),r||(r=!0,t()),!e&&"undefined"!=typeof Promise)return new Promise(function(e){o=e})}}();_i="undefined"!=typeof Set&&b(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return this.set[e]===!0},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var Ji=d,Ki=0,qi=function(){this.id=Ki++,this.subs=[]};qi.prototype.addSub=function(e){this.subs.push(e)},qi.prototype.removeSub=function(e){r(this.subs,e)},qi.prototype.depend=function(){qi.target&&qi.target.addDep(this)},qi.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},qi.target=null;var Wi=[],Zi=Array.prototype,Gi=Object.create(Zi);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(e){var t=Zi[e];y(Gi,e,function(){for(var n=arguments,r=arguments.length,i=new Array(r);r--;)i[r]=n[r];var o,a=t.apply(this,i),s=this.__ob__;switch(e){case"push":o=i;break;case"unshift":o=i;break;case"splice":o=i.slice(2)}return o&&s.observeArray(o),s.dep.notify(),a})});var Yi=Object.getOwnPropertyNames(Gi),Qi={shouldConvert:!0,isSettingProps:!1},Xi=function(e){if(this.value=e,this.dep=new qi,this.vmCount=0,y(e,"__ob__",this),Array.isArray(e)){(Ni?x:C)(e,Gi,Yi),this.observeArray(e)}else this.walk(e)};Xi.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)A(e,t[n],e[t[n]])},Xi.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)k(e[t])};var eo=Si.optionMergeStrategies;eo.data=function(e,t,n){return n?e||t?function(){var r="function"==typeof t?t.call(n):t,i="function"==typeof e?e.call(n):void 0;return r?E(r,i):i}:void 0:t?"function"!=typeof t?e:e?function(){return E(t.call(this),e.call(this))}:t:e},Si._lifecycleHooks.forEach(function(e){eo[e]=j}),Si._assetTypes.forEach(function(e){eo[e+"s"]=N}),eo.watch=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n={};u(n,e);for(var r in t){var i=n[r],o=t[r];i&&!Array.isArray(i)&&(i=[i]),n[r]=i?i.concat(o):[o]}return n},eo.props=eo.methods=eo.computed=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n=Object.create(null);return u(n,e),u(n,t),n};var to=function(e,t){return void 0===t?e:t},no=function(e,t,n,r,i,o,a){this.tag=e,this.data=t,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.functionalContext=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1},ro={child:{}};ro.child.get=function(){return this.componentInstance},Object.defineProperties(no.prototype,ro);var io,oo=function(){var e=new no;return e.text="",e.isComment=!0,e},ao=a(function(e){var t="~"===e.charAt(0);e=t?e.slice(1):e;var n="!"===e.charAt(0);return e=n?e.slice(1):e,{name:e,once:t,capture:n}}),so=null,co=[],uo={},lo=!1,fo=!1,po=0,vo=0,ho=function(e,t,n,r){this.vm=e,e._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++vo,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new _i,this.newDepIds=new _i,this.expression="","function"==typeof t?this.getter=t:(this.getter=_(t),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};ho.prototype.get=function(){$(this);var e,t=this.vm;if(this.user)try{e=this.getter.call(t,t)}catch(e){U(e,t,'getter for watcher "'+this.expression+'"')}else e=this.getter.call(t,t);return this.deep&&he(e),w(),this.cleanupDeps(),e},ho.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},ho.prototype.cleanupDeps=function(){for(var e=this,t=this.deps.length;t--;){var n=e.deps[t];e.newDepIds.has(n.id)||n.removeSub(e)}var r=this.depIds;this.depIds=this.newDepIds,this.newDepIds=r,this.newDepIds.clear(),r=this.deps,this.deps=this.newDeps,this.newDeps=r,this.newDeps.length=0},ho.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ve(this)},ho.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||l(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){U(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},ho.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ho.prototype.depend=function(){for(var e=this,t=this.deps.length;t--;)e.deps[t].depend()},ho.prototype.teardown=function(){var e=this;if(this.active){this.vm._isBeingDestroyed||r(this.vm._watchers,this);for(var t=this.deps.length;t--;)e.deps[t].removeSub(e);this.active=!1}};var mo=new _i,go={enumerable:!0,configurable:!0,get:d,set:d},yo={lazy:!0},_o={init:function(e,t,n,r){if(!e.componentInstance||e.componentInstance._isDestroyed){(e.componentInstance=Ee(e,so,n,r)).$mount(t?e.elm:void 0,t)}else if(e.data.keepAlive){var i=e;_o.prepatch(i,i)}},prepatch:function(e,t){var n=t.componentOptions;se(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){e.componentInstance._isMounted||(e.componentInstance._isMounted=!0,fe(e.componentInstance,"mounted")),e.data.keepAlive&&ue(e.componentInstance,!0)},destroy:function(e){e.componentInstance._isDestroyed||(e.data.keepAlive?le(e.componentInstance,!0):e.componentInstance.$destroy())}},bo=Object.keys(_o),$o=1,wo=2,xo=0;!function(e){e.prototype._init=function(e){var t=this;t._uid=xo++,t._isVue=!0,e&&e._isComponent?Qe(t,e):t.$options=D(Xe(t.constructor),e||{},t),t._renderProxy=t,t._self=t,oe(t),Q(t),Ze(t),fe(t,"beforeCreate"),Ye(t),ye(t),Ge(t),fe(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(nt),function(e){var t={};t.get=function(){return this._data};var n={};n.get=function(){return this._props},Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=O,e.prototype.$delete=T,e.prototype.$watch=function(e,t,n){var r=this;n=n||{},n.user=!0;var i=new ho(r,e,t,n);return n.immediate&&t.call(r,i.value),function(){i.teardown()}}}(nt),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var r=this,i=this;if(Array.isArray(e))for(var o=0,a=e.length;o<a;o++)r.$on(e[o],n);else(i._events[e]||(i._events[e]=[])).push(n),t.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){function n(){r.$off(e,n),t.apply(r,arguments)}var r=this;return n.fn=t,r.$on(e,n),r},e.prototype.$off=function(e,t){var n=this,r=this;if(!arguments.length)return r._events=Object.create(null),r;if(Array.isArray(e)){for(var i=0,o=e.length;i<o;i++)n.$off(e[i],t);return r}var a=r._events[e];if(!a)return r;if(1===arguments.length)return r._events[e]=null,r;for(var s,c=a.length;c--;)if((s=a[c])===t||s.fn===t){a.splice(c,1);break}return r},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?c(n):n;for(var r=c(arguments,1),i=0,o=n.length;i<o;i++)n[i].apply(t,r)}return t}}(nt),function(e){e.prototype._update=function(e,t){var n=this;n._isMounted&&fe(n,"beforeUpdate");var r=n.$el,i=n._vnode,o=so;so=n,n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1,n.$options._parentElm,n.$options._refElm),so=o,r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){var e=this;e._watcher&&e._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){fe(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||r(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),fe(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$options._parentElm=e.$options._refElm=null}}}(nt),function(n){n.prototype.$nextTick=function(e){return zi(e,this)},n.prototype._render=function(){var e=this,t=e.$options,n=t.render,r=t.staticRenderFns,i=t._parentVnode;if(e._isMounted)for(var o in e.$slots)e.$slots[o]=z(e.$slots[o]);e.$scopedSlots=i&&i.data.scopedSlots||Ei,r&&!e._staticTrees&&(e._staticTrees=[]),e.$vnode=i;var a;try{a=n.call(e._renderProxy,e.$createElement)}catch(t){U(t,e,"render function"),a=e._vnode}return a instanceof no||(a=oo()),a.parent=i,a},n.prototype._o=Ke,n.prototype._n=t,n.prototype._s=e,n.prototype._l=He,n.prototype._t=Ue,n.prototype._q=v,n.prototype._i=h,n.prototype._m=Je,n.prototype._f=Be,n.prototype._k=Ve,n.prototype._b=ze,n.prototype._v=B,n.prototype._e=oo,n.prototype._u=ie}(nt);var Co=[String,RegExp],ko={name:"keep-alive",abstract:!0,props:{include:Co,exclude:Co},created:function(){this.cache=Object.create(null)},destroyed:function(){var e=this;for(var t in e.cache)pt(e.cache[t])},watch:{include:function(e){ft(this.cache,function(t){return lt(e,t)})},exclude:function(e){ft(this.cache,function(t){return!lt(e,t)})}},render:function(){var e=Y(this.$slots.default),t=e&&e.componentOptions;if(t){var n=ut(t);if(n&&(this.include&&!lt(this.include,n)||this.exclude&&lt(this.exclude,n)))return e;var r=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;this.cache[r]?e.componentInstance=this.cache[r].componentInstance:this.cache[r]=e,e.data.keepAlive=!0}return e}},Ao={KeepAlive:ko};!function(e){var t={};t.get=function(){return Si},Object.defineProperty(e,"config",t),e.util={warn:Ji,extend:u,mergeOptions:D,defineReactive:A},e.set=O,e.delete=T,e.nextTick=zi,e.options=Object.create(null),Si._assetTypes.forEach(function(t){e.options[t+"s"]=Object.create(null)}),e.options._base=e,u(e.options.components,Ao),rt(e),it(e),ot(e),ct(e)}(nt),Object.defineProperty(nt.prototype,"$isServer",{get:Ui}),nt.version="2.2.6";var Oo,To,So,Eo,jo,No,Io,Lo,Do,Mo=n("input,textarea,option,select"),Po=function(e,t,n){return"value"===n&&Mo(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Ro=n("contenteditable,draggable,spellcheck"),Fo=n("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Ho="http://www.w3.org/1999/xlink",Uo=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},Bo=function(e){return Uo(e)?e.slice(6,e.length):""},Vo=function(e){return null==e||e===!1},zo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Jo=n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template"),Ko=n("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),qo=function(e){return"pre"===e},Wo=function(e){return Jo(e)||Ko(e)},Zo=Object.create(null),Go=Object.freeze({createElement:$t,createElementNS:wt,createTextNode:xt,createComment:Ct,insertBefore:kt,removeChild:At,appendChild:Ot,parentNode:Tt,nextSibling:St,tagName:Et,setTextContent:jt,setAttribute:Nt}),Yo={create:function(e,t){It(t)},update:function(e,t){e.data.ref!==t.data.ref&&(It(e,!0),It(t))},destroy:function(e){It(e,!0)}},Qo=new no("",{},[]),Xo=["create","activate","update","remove","destroy"],ea={create:Ht,update:Ht,destroy:function(e){Ht(e,Qo)}},ta=Object.create(null),na=[Yo,ea],ra={create:Jt,update:Jt},ia={create:qt,update:qt},oa=/[\w).+\-_$\]]/,aa="__r",sa="__c",ca={create:$n,update:$n},ua={create:wn,update:wn},la=a(function(e){var t={};return e.split(/;(?![^(]*\))/g).forEach(function(e){if(e){var n=e.split(/:(.+)/);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}),fa=/^--/,pa=/\s*!important$/,da=function(e,t,n){fa.test(t)?e.style.setProperty(t,n):pa.test(n)?e.style.setProperty(t,n.replace(pa,""),"important"):e.style[ha(t)]=n},va=["Webkit","Moz","ms"],ha=a(function(e){if(Do=Do||document.createElement("div"),"filter"!==(e=wi(e))&&e in Do.style)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<va.length;n++){var r=va[n]+t;if(r in Do.style)return r}}),ma={create:Sn,update:Sn},ga=a(function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}}),ya=Ii&&!Mi,_a="transition",ba="animation",$a="transition",wa="transitionend",xa="animation",Ca="animationend";ya&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&($a="WebkitTransition",wa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(xa="WebkitAnimation",Ca="webkitAnimationEnd"));var ka=Ii&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout,Aa=/\b(transform|all)(,|$)/,Oa=Ii?{create:zn,activate:zn,remove:function(e,t){e.data.show?t():Un(e,t)}}:{},Ta=[ra,ia,ca,ua,ma,Oa],Sa=Ta.concat(na),Ea=function(e){function t(e){return new no(O.tagName(e).toLowerCase(),{},[],void 0,e)}function r(e,t){function n(){0==--n.listeners&&i(e)}return n.listeners=t,n}function i(e){var t=O.parentNode(e);Dt(t)&&O.removeChild(t,e)}function a(e,t,n,r,i){if(e.isRootInsert=!i,!s(e,t,n,r)){var o=e.data,a=e.children,c=e.tag;Dt(c)?(e.elm=e.ns?O.createElementNS(e.ns,c):O.createElement(c,e),v(e),f(e,a,t),Dt(o)&&d(e,t),l(n,e.elm,r)):Mt(e.isComment)?(e.elm=O.createComment(e.text),
	l(n,e.elm,r)):(e.elm=O.createTextNode(e.text),l(n,e.elm,r))}}function s(e,t,n,r){var i=e.data;if(Dt(i)){var o=Dt(e.componentInstance)&&i.keepAlive;if(Dt(i=i.hook)&&Dt(i=i.init)&&i(e,!1,n,r),Dt(e.componentInstance))return c(e,t),Mt(o)&&u(e,t,n,r),!0}}function c(e,t){Dt(e.data.pendingInsert)&&t.push.apply(t,e.data.pendingInsert),e.elm=e.componentInstance.$el,p(e)?(d(e,t),v(e)):(It(e),t.push(e))}function u(e,t,n,r){for(var i,o=e;o.componentInstance;)if(o=o.componentInstance._vnode,Dt(i=o.data)&&Dt(i=i.transition)){for(i=0;i<k.activate.length;++i)k.activate[i](Qo,o);t.push(o);break}l(n,e.elm,r)}function l(e,t,n){Dt(e)&&(Dt(n)?O.insertBefore(e,t,n):O.appendChild(e,t))}function f(e,t,n){if(Array.isArray(t))for(var r=0;r<t.length;++r)a(t[r],n,e.elm,null,!0);else o(e.text)&&O.appendChild(e.elm,O.createTextNode(e.text))}function p(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return Dt(e.tag)}function d(e,t){for(var n=0;n<k.create.length;++n)k.create[n](Qo,e);x=e.data.hook,Dt(x)&&(Dt(x.create)&&x.create(Qo,e),Dt(x.insert)&&t.push(e))}function v(e){for(var t,n=e;n;)Dt(t=n.context)&&Dt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,""),n=n.parent;Dt(t=so)&&t!==e.context&&Dt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,"")}function h(e,t,n,r,i,o){for(;r<=i;++r)a(n[r],o,e,t)}function m(e){var t,n,r=e.data;if(Dt(r))for(Dt(t=r.hook)&&Dt(t=t.destroy)&&t(e),t=0;t<k.destroy.length;++t)k.destroy[t](e);if(Dt(t=e.children))for(n=0;n<e.children.length;++n)m(e.children[n])}function g(e,t,n,r){for(;n<=r;++n){var o=t[n];Dt(o)&&(Dt(o.tag)?(y(o),m(o)):i(o.elm))}}function y(e,t){if(Dt(t)||Dt(e.data)){var n=k.remove.length+1;for(Dt(t)?t.listeners+=n:t=r(e.elm,n),Dt(x=e.componentInstance)&&Dt(x=x._vnode)&&Dt(x.data)&&y(x,t),x=0;x<k.remove.length;++x)k.remove[x](e,t);Dt(x=e.data.hook)&&Dt(x=x.remove)?x(e,t):t()}else i(e.elm)}function _(e,t,n,r,i){for(var o,s,c,u,l=0,f=0,p=t.length-1,d=t[0],v=t[p],m=n.length-1,y=n[0],_=n[m],$=!i;l<=p&&f<=m;)Lt(d)?d=t[++l]:Lt(v)?v=t[--p]:Pt(d,y)?(b(d,y,r),d=t[++l],y=n[++f]):Pt(v,_)?(b(v,_,r),v=t[--p],_=n[--m]):Pt(d,_)?(b(d,_,r),$&&O.insertBefore(e,d.elm,O.nextSibling(v.elm)),d=t[++l],_=n[--m]):Pt(v,y)?(b(v,y,r),$&&O.insertBefore(e,v.elm,d.elm),v=t[--p],y=n[++f]):(Lt(o)&&(o=Ft(t,l,p)),s=Dt(y.key)?o[y.key]:null,Lt(s)?(a(y,r,e,d.elm),y=n[++f]):(c=t[s],Pt(c,y)?(b(c,y,r),t[s]=void 0,$&&O.insertBefore(e,y.elm,d.elm),y=n[++f]):(a(y,r,e,d.elm),y=n[++f])));l>p?(u=Lt(n[m+1])?null:n[m+1].elm,h(e,u,n,f,m,r)):f>m&&g(e,t,l,p)}function b(e,t,n,r){if(e!==t){if(Mt(t.isStatic)&&Mt(e.isStatic)&&t.key===e.key&&(Mt(t.isCloned)||Mt(t.isOnce)))return t.elm=e.elm,void(t.componentInstance=e.componentInstance);var i,o=t.data;Dt(o)&&Dt(i=o.hook)&&Dt(i=i.prepatch)&&i(e,t);var a=t.elm=e.elm,s=e.children,c=t.children;if(Dt(o)&&p(t)){for(i=0;i<k.update.length;++i)k.update[i](e,t);Dt(i=o.hook)&&Dt(i=i.update)&&i(e,t)}Lt(t.text)?Dt(s)&&Dt(c)?s!==c&&_(a,s,c,n,r):Dt(c)?(Dt(e.text)&&O.setTextContent(a,""),h(a,null,c,0,c.length-1,n)):Dt(s)?g(a,s,0,s.length-1):Dt(e.text)&&O.setTextContent(a,""):e.text!==t.text&&O.setTextContent(a,t.text),Dt(o)&&Dt(i=o.hook)&&Dt(i=i.postpatch)&&i(e,t)}}function $(e,t,n){if(Mt(n)&&Dt(e.parent))e.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}function w(e,t,n){t.elm=e;var r=t.tag,i=t.data,o=t.children;if(Dt(i)&&(Dt(x=i.hook)&&Dt(x=x.init)&&x(t,!0),Dt(x=t.componentInstance)))return c(t,n),!0;if(Dt(r)){if(Dt(o))if(e.hasChildNodes()){for(var a=!0,s=e.firstChild,u=0;u<o.length;u++){if(!s||!w(s,o[u],n)){a=!1;break}s=s.nextSibling}if(!a||s)return!1}else f(t,o,n);if(Dt(i))for(var l in i)if(!T(l)){d(t,n);break}}else e.data!==t.text&&(e.data=t.text);return!0}var x,C,k={},A=e.modules,O=e.nodeOps;for(x=0;x<Xo.length;++x)for(k[Xo[x]]=[],C=0;C<A.length;++C)Dt(A[C][Xo[x]])&&k[Xo[x]].push(A[C][Xo[x]]);var T=n("attrs,style,class,staticClass,staticStyle,key");return function(e,n,r,i,o,s){if(Lt(n))return void(Dt(e)&&m(e));var c=!1,u=[];if(Lt(e))c=!0,a(n,u,o,s);else{var l=Dt(e.nodeType);if(!l&&Pt(e,n))b(e,n,u,i);else{if(l){if(1===e.nodeType&&e.hasAttribute("server-rendered")&&(e.removeAttribute("server-rendered"),r=!0),Mt(r)&&w(e,n,u))return $(n,u,!0),e;e=t(e)}var f=e.elm,d=O.parentNode(f);if(a(n,u,f._leaveCb?null:d,O.nextSibling(f)),Dt(n.parent)){for(var v=n.parent;v;)v.elm=n.elm,v=v.parent;if(p(n))for(var h=0;h<k.create.length;++h)k.create[h](Qo,n.parent)}Dt(d)?g(d,[e],0,0):Dt(e.tag)&&m(e)}}return $(n,u,c),n.elm}}({nodeOps:Go,modules:Sa});Mi&&document.addEventListener("selectionchange",function(){var e=document.activeElement;e&&e.vmodel&&Gn(e,"input")});var ja={inserted:function(e,t,n){if("select"===n.tag){var r=function(){Jn(e,t,n.context)};r(),(Di||Pi)&&setTimeout(r,0)}else"textarea"!==n.tag&&"text"!==e.type&&"password"!==e.type||(e._vModifiers=t.modifiers,t.modifiers.lazy||(Ri||(e.addEventListener("compositionstart",Wn),e.addEventListener("compositionend",Zn)),Mi&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Jn(e,t,n.context);(e.multiple?t.value.some(function(t){return Kn(t,e.options)}):t.value!==t.oldValue&&Kn(t.value,e.options))&&Gn(e,"change")}}},Na={bind:function(e,t,n){var r=t.value;n=Yn(n);var i=n.data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i&&!Mi?(n.data.show=!0,Hn(n,function(){e.style.display=o})):e.style.display=r?o:"none"},update:function(e,t,n){var r=t.value;r!==t.oldValue&&(n=Yn(n),n.data&&n.data.transition&&!Mi?(n.data.show=!0,r?Hn(n,function(){e.style.display=e.__vOriginalDisplay}):Un(n,function(){e.style.display="none"})):e.style.display=r?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,r,i){i||(e.style.display=e.__vOriginalDisplay)}},Ia={model:ja,show:Na},La={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]},Da={name:"transition",props:La,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(function(e){return e.tag}),n.length)){var r=this.mode,i=n[0];if(tr(this.$vnode))return i;var a=Qn(i);if(!a)return i;if(this._leaving)return er(e,i);var s="__transition-"+this._uid+"-";a.key=null==a.key?s+a.tag:o(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=Xn(this),l=this._vnode,f=Qn(l);if(a.data.directives&&a.data.directives.some(function(e){return"show"===e.name})&&(a.data.show=!0),f&&f.data&&!nr(a,f)){var p=f&&(f.data.transition=u({},c));if("out-in"===r)return this._leaving=!0,q(p,"afterLeave",function(){t._leaving=!1,t.$forceUpdate()}),er(e,i);if("in-out"===r){var d,v=function(){d()};q(c,"afterEnter",v),q(c,"enterCancelled",v),q(p,"delayLeave",function(e){d=e})}}return i}}},Ma=u({tag:String,moveClass:String},La);delete Ma.mode;var Pa={props:Ma,render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Xn(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=e(t,null,u),this.removed=l}return e(t,null,o)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";if(e.length&&this.hasMove(e[0].elm,t)){e.forEach(rr),e.forEach(ir),e.forEach(or);var n=document.body;n.offsetHeight;e.forEach(function(e){if(e.data.moved){var n=e.elm,r=n.style;Ln(n,t),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(wa,n._moveCb=function e(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(wa,e),n._moveCb=null,Dn(n,t))})}})}},methods:{hasMove:function(e,t){if(!ya)return!1;if(null!=this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach(function(e){jn(n,e)}),En(n,t),n.style.display="none",this.$el.appendChild(n);var r=Pn(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}},Ra={Transition:Da,TransitionGroup:Pa};nt.config.mustUseProp=Po,nt.config.isReservedTag=Wo,nt.config.getTagNamespace=yt,nt.config.isUnknownElement=_t,u(nt.options.directives,Ia),u(nt.options.components,Ra),nt.prototype.__patch__=Ii?Ea:d,nt.prototype.$mount=function(e,t){return e=e&&Ii?bt(e):void 0,ae(this,e,t)},setTimeout(function(){Si.devtools&&Bi&&Bi.emit("init",nt)},0);var Fa,Ha=!!Ii&&function(e,t){var n=document.createElement("div");return n.innerHTML='<div a="'+e+'">',n.innerHTML.indexOf(t)>0}("\n","&#10;"),Ua=n("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ba=n("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Va=n("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),za=[/"([^"]*)"+/.source,/'([^']*)'+/.source,/([^\s"'=<>`]+)/.source],Ja=new RegExp("^\\s*"+/([^\s"'<>\/=]+)/.source+"(?:\\s*("+/(?:=)/.source+")\\s*(?:"+za.join("|")+"))?"),Ka="[a-zA-Z_][\\w\\-\\.]*",qa=new RegExp("^<((?:"+Ka+"\\:)?"+Ka+")"),Wa=/^\s*(\/?)>/,Za=new RegExp("^<\\/((?:"+Ka+"\\:)?"+Ka+")[^>]*>"),Ga=/^<!DOCTYPE [^>]+>/i,Ya=/^<!--/,Qa=/^<!\[/,Xa=!1;"x".replace(/x(.)?/g,function(e,t){Xa=""===t});var es,ts,ns,rs,is,os,as,ss,cs,us,ls,fs,ps,ds,vs,hs,ms,gs,ys=n("script,style,textarea",!0),_s={},bs={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n"},$s=/&(?:lt|gt|quot|amp);/g,ws=/&(?:lt|gt|quot|amp|#10);/g,xs=/\{\{((?:.|\n)+?)\}\}/g,Cs=a(function(e){var t=e[0].replace(/[-.*+?^${}()|[\]\/\\]/g,"\\$&"),n=e[1].replace(/[-.*+?^${}()|[\]\/\\]/g,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")}),ks=/^@|^v-on:/,As=/^v-|^@|^:/,Os=/(.*?)\s+(?:in|of)\s+(.*)/,Ts=/\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/,Ss=/:(.*)$/,Es=/^:|^v-bind:/,js=/\.[^.]+/g,Ns=a(ar),Is=/^xmlns:NS\d+/,Ls=/^NS\d+:/,Ds=a(Er),Ms=/^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,Ps=/^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/,Rs={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Fs=function(e){return"if("+e+")return null;"},Hs={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Fs("$event.target !== $event.currentTarget"),ctrl:Fs("!$event.ctrlKey"),shift:Fs("!$event.shiftKey"),alt:Fs("!$event.altKey"),meta:Fs("!$event.metaKey"),left:Fs("'button' in $event && $event.button !== 0"),middle:Fs("'button' in $event && $event.button !== 1"),right:Fs("'button' in $event && $event.button !== 2")},Us={bind:Hr,cloak:d},Bs={staticKeys:["staticClass"],transformNode:fi,genData:pi},Vs={staticKeys:["staticStyle"],transformNode:di,genData:vi},zs=[Bs,Vs],Js={model:dn,text:hi,html:mi},Ks={expectHTML:!0,modules:zs,directives:Js,isPreTag:qo,isUnaryTag:Ua,mustUseProp:Po,canBeLeftOpenTag:Ba,isReservedTag:Wo,getTagNamespace:yt,staticKeys:function(e){return e.reduce(function(e,t){return e.concat(t.staticKeys||[])},[]).join(",")}(zs)},qs=function(e){function t(t,n){var r=Object.create(e),i=[],o=[];if(r.warn=function(e,t){(t?o:i).push(e)},n){n.modules&&(r.modules=(e.modules||[]).concat(n.modules)),n.directives&&(r.directives=u(Object.create(e.directives),n.directives));for(var a in n)"modules"!==a&&"directives"!==a&&(r[a]=n[a])}var s=ui(t,r);return s.errors=i,s.tips=o,s}function n(e,n,i){n=n||{};var o=n.delimiters?String(n.delimiters)+e:e;if(r[o])return r[o];var a=t(e,n),s={},c=[];s.render=li(a.render,c);var u=a.staticRenderFns.length;s.staticRenderFns=new Array(u);for(var l=0;l<u;l++)s.staticRenderFns[l]=li(a.staticRenderFns[l],c);return r[o]=s}var r=Object.create(null);return{compile:t,compileToFunctions:n}}(Ks),Ws=qs.compileToFunctions,Zs=a(function(e){var t=bt(e);return t&&t.innerHTML}),Gs=nt.prototype.$mount;return nt.prototype.$mount=function(e,t){if((e=e&&bt(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=Zs(r));else{if(!r.nodeType)return this;r=r.innerHTML}else e&&(r=gi(e));if(r){var i=Ws(r,{shouldDecodeNewlines:Ha,delimiters:n.delimiters},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return Gs.call(this,e,t)},nt.compile=Ws,nt});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	/* eslint valid-jsdoc: ["error", {"requireReturnDescription": false}] */

	var _Gist = __webpack_require__(4);

	var _Gist2 = _interopRequireDefault(_Gist);

	var _User = __webpack_require__(40);

	var _User2 = _interopRequireDefault(_User);

	var _Issue = __webpack_require__(41);

	var _Issue2 = _interopRequireDefault(_Issue);

	var _Search = __webpack_require__(42);

	var _Search2 = _interopRequireDefault(_Search);

	var _RateLimit = __webpack_require__(43);

	var _RateLimit2 = _interopRequireDefault(_RateLimit);

	var _Repository = __webpack_require__(44);

	var _Repository2 = _interopRequireDefault(_Repository);

	var _Organization = __webpack_require__(47);

	var _Organization2 = _interopRequireDefault(_Organization);

	var _Team = __webpack_require__(48);

	var _Team2 = _interopRequireDefault(_Team);

	var _Markdown = __webpack_require__(49);

	var _Markdown2 = _interopRequireDefault(_Markdown);

	var _Project = __webpack_require__(50);

	var _Project2 = _interopRequireDefault(_Project);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * GitHub encapsulates the functionality to create various API wrapper objects.
	 */
	var GitHub = function () {
	  /**
	   * Create a new GitHub.
	   * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is
	   *                                  not provided requests will be made unauthenticated
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function GitHub(auth) {
	    var apiBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'https://api.github.com';

	    _classCallCheck(this, GitHub);

	    this.__apiBase = apiBase;
	    this.__auth = auth || {};
	  }

	  /**
	   * Create a new Gist wrapper
	   * @param {number} [id] - the id for the gist, leave undefined when creating a new gist
	   * @return {Gist}
	   */


	  _createClass(GitHub, [{
	    key: 'getGist',
	    value: function getGist(id) {
	      return new _Gist2.default(id, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new User wrapper
	     * @param {string} [user] - the name of the user to get information about
	     *                        leave undefined for the authenticated user
	     * @return {User}
	     */

	  }, {
	    key: 'getUser',
	    value: function getUser(user) {
	      return new _User2.default(user, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Organization wrapper
	     * @param {string} organization - the name of the organization
	     * @return {Organization}
	     */

	  }, {
	    key: 'getOrganization',
	    value: function getOrganization(organization) {
	      return new _Organization2.default(organization, this.__auth, this.__apiBase);
	    }

	    /**
	     * create a new Team wrapper
	     * @param {string} teamId - the name of the team
	     * @return {team}
	     */

	  }, {
	    key: 'getTeam',
	    value: function getTeam(teamId) {
	      return new _Team2.default(teamId, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Repository wrapper
	     * @param {string} user - the user who owns the respository
	     * @param {string} repo - the name of the repository
	     * @return {Repository}
	     */

	  }, {
	    key: 'getRepo',
	    value: function getRepo(user, repo) {
	      return new _Repository2.default(this._getFullName(user, repo), this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Issue wrapper
	     * @param {string} user - the user who owns the respository
	     * @param {string} repo - the name of the repository
	     * @return {Issue}
	     */

	  }, {
	    key: 'getIssues',
	    value: function getIssues(user, repo) {
	      return new _Issue2.default(this._getFullName(user, repo), this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Search wrapper
	     * @param {string} query - the query to search for
	     * @return {Search}
	     */

	  }, {
	    key: 'search',
	    value: function search(query) {
	      return new _Search2.default(query, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new RateLimit wrapper
	     * @return {RateLimit}
	     */

	  }, {
	    key: 'getRateLimit',
	    value: function getRateLimit() {
	      return new _RateLimit2.default(this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Markdown wrapper
	     * @return {Markdown}
	     */

	  }, {
	    key: 'getMarkdown',
	    value: function getMarkdown() {
	      return new _Markdown2.default(this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Project wrapper
	     * @param {string} id - the id of the project
	     * @return {Markdown}
	     */

	  }, {
	    key: 'getProject',
	    value: function getProject(id) {
	      return new _Project2.default(id, this.__auth, this.__apiBase);
	    }

	    /**
	     * Computes the full repository name
	     * @param {string} user - the username (or the full name)
	     * @param {string} repo - the repository name, must not be passed if `user` is the full name
	     * @return {string} the repository's full name
	     */

	  }, {
	    key: '_getFullName',
	    value: function _getFullName(user, repo) {
	      var fullname = user;

	      if (repo) {
	        fullname = user + '/' + repo;
	      }

	      return fullname;
	    }
	  }]);

	  return GitHub;
	}();

	module.exports = GitHub;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkdpdEh1Yi5qcyJdLCJuYW1lcyI6WyJHaXRIdWIiLCJhdXRoIiwiYXBpQmFzZSIsIl9fYXBpQmFzZSIsIl9fYXV0aCIsImlkIiwidXNlciIsIm9yZ2FuaXphdGlvbiIsInRlYW1JZCIsInJlcG8iLCJfZ2V0RnVsbE5hbWUiLCJxdWVyeSIsImZ1bGxuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7cWpCQUFBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7O0lBR01BLE07QUFDSDs7Ozs7O0FBTUEsa0JBQVlDLElBQVosRUFBc0Q7QUFBQSxRQUFwQ0MsT0FBb0MsdUVBQTFCLHdCQUEwQjs7QUFBQTs7QUFDbkQsU0FBS0MsU0FBTCxHQUFpQkQsT0FBakI7QUFDQSxTQUFLRSxNQUFMLEdBQWNILFFBQVEsRUFBdEI7QUFDRjs7QUFFRDs7Ozs7Ozs7OzRCQUtRSSxFLEVBQUk7QUFDVCxhQUFPLG1CQUFTQSxFQUFULEVBQWEsS0FBS0QsTUFBbEIsRUFBMEIsS0FBS0QsU0FBL0IsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NEJBTVFHLEksRUFBTTtBQUNYLGFBQU8sbUJBQVNBLElBQVQsRUFBZSxLQUFLRixNQUFwQixFQUE0QixLQUFLRCxTQUFqQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O29DQUtnQkksWSxFQUFjO0FBQzNCLGFBQU8sMkJBQWlCQSxZQUFqQixFQUErQixLQUFLSCxNQUFwQyxFQUE0QyxLQUFLRCxTQUFqRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzRCQUtRSyxNLEVBQVE7QUFDYixhQUFPLG1CQUFTQSxNQUFULEVBQWlCLEtBQUtKLE1BQXRCLEVBQThCLEtBQUtELFNBQW5DLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzRCQU1RRyxJLEVBQU1HLEksRUFBTTtBQUNqQixhQUFPLHlCQUFlLEtBQUtDLFlBQUwsQ0FBa0JKLElBQWxCLEVBQXdCRyxJQUF4QixDQUFmLEVBQThDLEtBQUtMLE1BQW5ELEVBQTJELEtBQUtELFNBQWhFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzhCQU1VRyxJLEVBQU1HLEksRUFBTTtBQUNuQixhQUFPLG9CQUFVLEtBQUtDLFlBQUwsQ0FBa0JKLElBQWxCLEVBQXdCRyxJQUF4QixDQUFWLEVBQXlDLEtBQUtMLE1BQTlDLEVBQXNELEtBQUtELFNBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7MkJBS09RLEssRUFBTztBQUNYLGFBQU8scUJBQVdBLEtBQVgsRUFBa0IsS0FBS1AsTUFBdkIsRUFBK0IsS0FBS0QsU0FBcEMsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7O21DQUllO0FBQ1osYUFBTyx3QkFBYyxLQUFLQyxNQUFuQixFQUEyQixLQUFLRCxTQUFoQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7a0NBSWM7QUFDWCxhQUFPLHVCQUFhLEtBQUtDLE1BQWxCLEVBQTBCLEtBQUtELFNBQS9CLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7K0JBS1dFLEUsRUFBSTtBQUNaLGFBQU8sc0JBQVlBLEVBQVosRUFBZ0IsS0FBS0QsTUFBckIsRUFBNkIsS0FBS0QsU0FBbEMsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTWFHLEksRUFBTUcsSSxFQUFNO0FBQ3RCLFVBQUlHLFdBQVdOLElBQWY7O0FBRUEsVUFBSUcsSUFBSixFQUFVO0FBQ1BHLG1CQUFjTixJQUFkLFNBQXNCRyxJQUF0QjtBQUNGOztBQUVELGFBQU9HLFFBQVA7QUFDRjs7Ozs7O0FBR0pDLE9BQU9DLE9BQVAsR0FBaUJkLE1BQWpCIiwiZmlsZSI6IkdpdEh1Yi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cbi8qIGVzbGludCB2YWxpZC1qc2RvYzogW1wiZXJyb3JcIiwge1wicmVxdWlyZVJldHVybkRlc2NyaXB0aW9uXCI6IGZhbHNlfV0gKi9cblxuaW1wb3J0IEdpc3QgZnJvbSAnLi9HaXN0JztcbmltcG9ydCBVc2VyIGZyb20gJy4vVXNlcic7XG5pbXBvcnQgSXNzdWUgZnJvbSAnLi9Jc3N1ZSc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vU2VhcmNoJztcbmltcG9ydCBSYXRlTGltaXQgZnJvbSAnLi9SYXRlTGltaXQnO1xuaW1wb3J0IFJlcG9zaXRvcnkgZnJvbSAnLi9SZXBvc2l0b3J5JztcbmltcG9ydCBPcmdhbml6YXRpb24gZnJvbSAnLi9Pcmdhbml6YXRpb24nO1xuaW1wb3J0IFRlYW0gZnJvbSAnLi9UZWFtJztcbmltcG9ydCBNYXJrZG93biBmcm9tICcuL01hcmtkb3duJztcbmltcG9ydCBQcm9qZWN0IGZyb20gJy4vUHJvamVjdCc7XG5cbi8qKlxuICogR2l0SHViIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBjcmVhdGUgdmFyaW91cyBBUEkgd3JhcHBlciBvYmplY3RzLlxuICovXG5jbGFzcyBHaXRIdWIge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgR2l0SHViLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1Yi4gSWYgYXV0aCBpc1xuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHByb3ZpZGVkIHJlcXVlc3RzIHdpbGwgYmUgbWFkZSB1bmF1dGhlbnRpY2F0ZWRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGF1dGgsIGFwaUJhc2UgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbScpIHtcbiAgICAgIHRoaXMuX19hcGlCYXNlID0gYXBpQmFzZTtcbiAgICAgIHRoaXMuX19hdXRoID0gYXV0aCB8fCB7fTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgR2lzdCB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2lkXSAtIHRoZSBpZCBmb3IgdGhlIGdpc3QsIGxlYXZlIHVuZGVmaW5lZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGdpc3RcbiAgICAqIEByZXR1cm4ge0dpc3R9XG4gICAgKi9cbiAgIGdldEdpc3QoaWQpIHtcbiAgICAgIHJldHVybiBuZXcgR2lzdChpZCwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgVXNlciB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJdIC0gdGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0XG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZlIHVuZGVmaW5lZCBmb3IgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICogQHJldHVybiB7VXNlcn1cbiAgICAqL1xuICAgZ2V0VXNlcih1c2VyKSB7XG4gICAgICByZXR1cm4gbmV3IFVzZXIodXNlciwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgT3JnYW5pemF0aW9uIHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmdhbml6YXRpb24gLSB0aGUgbmFtZSBvZiB0aGUgb3JnYW5pemF0aW9uXG4gICAgKiBAcmV0dXJuIHtPcmdhbml6YXRpb259XG4gICAgKi9cbiAgIGdldE9yZ2FuaXphdGlvbihvcmdhbml6YXRpb24pIHtcbiAgICAgIHJldHVybiBuZXcgT3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbiwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBjcmVhdGUgYSBuZXcgVGVhbSB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkIC0gdGhlIG5hbWUgb2YgdGhlIHRlYW1cbiAgICAqIEByZXR1cm4ge3RlYW19XG4gICAgKi9cbiAgIGdldFRlYW0odGVhbUlkKSB7XG4gICAgICByZXR1cm4gbmV3IFRlYW0odGVhbUlkLCB0aGlzLl9fYXV0aCwgdGhpcy5fX2FwaUJhc2UpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBSZXBvc2l0b3J5IHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIC0gdGhlIHVzZXIgd2hvIG93bnMgdGhlIHJlc3Bvc2l0b3J5XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbyAtIHRoZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcmV0dXJuIHtSZXBvc2l0b3J5fVxuICAgICovXG4gICBnZXRSZXBvKHVzZXIsIHJlcG8pIHtcbiAgICAgIHJldHVybiBuZXcgUmVwb3NpdG9yeSh0aGlzLl9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgSXNzdWUgd3JhcHBlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXIgLSB0aGUgdXNlciB3aG8gb3ducyB0aGUgcmVzcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gdGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEByZXR1cm4ge0lzc3VlfVxuICAgICovXG4gICBnZXRJc3N1ZXModXNlciwgcmVwbykge1xuICAgICAgcmV0dXJuIG5ldyBJc3N1ZSh0aGlzLl9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgU2VhcmNoIHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIHRoZSBxdWVyeSB0byBzZWFyY2ggZm9yXG4gICAgKiBAcmV0dXJuIHtTZWFyY2h9XG4gICAgKi9cbiAgIHNlYXJjaChxdWVyeSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2gocXVlcnksIHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IFJhdGVMaW1pdCB3cmFwcGVyXG4gICAgKiBAcmV0dXJuIHtSYXRlTGltaXR9XG4gICAgKi9cbiAgIGdldFJhdGVMaW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0KHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IE1hcmtkb3duIHdyYXBwZXJcbiAgICAqIEByZXR1cm4ge01hcmtkb3dufVxuICAgICovXG4gICBnZXRNYXJrZG93bigpIHtcbiAgICAgIHJldHVybiBuZXcgTWFya2Rvd24odGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgUHJvamVjdCB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHByb2plY3RcbiAgICAqIEByZXR1cm4ge01hcmtkb3dufVxuICAgICovXG4gICBnZXRQcm9qZWN0KGlkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb2plY3QoaWQsIHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ29tcHV0ZXMgdGhlIGZ1bGwgcmVwb3NpdG9yeSBuYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlciAtIHRoZSB1c2VybmFtZSAob3IgdGhlIGZ1bGwgbmFtZSlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gdGhlIHJlcG9zaXRvcnkgbmFtZSwgbXVzdCBub3QgYmUgcGFzc2VkIGlmIGB1c2VyYCBpcyB0aGUgZnVsbCBuYW1lXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXBvc2l0b3J5J3MgZnVsbCBuYW1lXG4gICAgKi9cbiAgIF9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSB7XG4gICAgICBsZXQgZnVsbG5hbWUgPSB1c2VyO1xuXG4gICAgICBpZiAocmVwbykge1xuICAgICAgICAgZnVsbG5hbWUgPSBgJHt1c2VyfS8ke3JlcG99YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bGxuYW1lO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpdEh1YjtcbiJdfQ==
	//# sourceMappingURL=GitHub.js.map


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * A Gist can retrieve and modify gists.
	 */
	var Gist = function (_Requestable) {
	  _inherits(Gist, _Requestable);

	  /**
	   * Create a Gist.
	   * @param {string} id - the id of the gist (not required when creating a gist)
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Gist(id, auth, apiBase) {
	    _classCallCheck(this, Gist);

	    var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase));

	    _this.__id = id;
	    return _this;
	  }

	  /**
	   * Fetch a gist.
	   * @see https://developer.github.com/v3/gists/#get-a-single-gist
	   * @param {Requestable.callback} [cb] - will receive the gist
	   * @return {Promise} - the Promise for the http request
	   */


	  _createClass(Gist, [{
	    key: 'read',
	    value: function read(cb) {
	      return this._request('GET', '/gists/' + this.__id, null, cb);
	    }

	    /**
	     * Create a new gist.
	     * @see https://developer.github.com/v3/gists/#create-a-gist
	     * @param {Object} gist - the data for the new gist
	     * @param {Requestable.callback} [cb] - will receive the new gist upon creation
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'create',
	    value: function create(gist, cb) {
	      var _this2 = this;

	      return this._request('POST', '/gists', gist, cb).then(function (response) {
	        _this2.__id = response.data.id;
	        return response;
	      });
	    }

	    /**
	     * Delete a gist.
	     * @see https://developer.github.com/v3/gists/#delete-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'delete',
	    value: function _delete(cb) {
	      return this._request('DELETE', '/gists/' + this.__id, null, cb);
	    }

	    /**
	     * Fork a gist.
	     * @see https://developer.github.com/v3/gists/#fork-a-gist
	     * @param {Requestable.callback} [cb] - the function that will receive the gist
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'fork',
	    value: function fork(cb) {
	      return this._request('POST', '/gists/' + this.__id + '/forks', null, cb);
	    }

	    /**
	     * Update a gist.
	     * @see https://developer.github.com/v3/gists/#edit-a-gist
	     * @param {Object} gist - the new data for the gist
	     * @param {Requestable.callback} [cb] - the function that receives the API result
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'update',
	    value: function update(gist, cb) {
	      return this._request('PATCH', '/gists/' + this.__id, gist, cb);
	    }

	    /**
	     * Star a gist.
	     * @see https://developer.github.com/v3/gists/#star-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'star',
	    value: function star(cb) {
	      return this._request('PUT', '/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * Unstar a gist.
	     * @see https://developer.github.com/v3/gists/#unstar-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'unstar',
	    value: function unstar(cb) {
	      return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * Check if a gist is starred by the user.
	     * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
	     * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'isStarred',
	    value: function isStarred(cb) {
	      return this._request204or404('/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * List the gist's comments
	     * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
	     * @param {Requestable.callback} [cb] - will receive the array of comments
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listComments',
	    value: function listComments(cb) {
	      return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb);
	    }

	    /**
	     * Fetch one of the gist's comments
	     * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment
	     * @param {number} comment - the id of the comment
	     * @param {Requestable.callback} [cb] - will receive the comment
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'getComment',
	    value: function getComment(comment, cb) {
	      return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb);
	    }

	    /**
	     * Comment on a gist
	     * @see https://developer.github.com/v3/gists/comments/#create-a-comment
	     * @param {string} comment - the comment to add
	     * @param {Requestable.callback} [cb] - the function that receives the API result
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'createComment',
	    value: function createComment(comment, cb) {
	      return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb);
	    }

	    /**
	     * Edit a comment on the gist
	     * @see https://developer.github.com/v3/gists/comments/#edit-a-comment
	     * @param {number} comment - the id of the comment
	     * @param {string} body - the new comment
	     * @param {Requestable.callback} [cb] - will receive the modified comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editComment',
	    value: function editComment(comment, body, cb) {
	      return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb);
	    }

	    /**
	     * Delete a comment on the gist.
	     * @see https://developer.github.com/v3/gists/comments/#delete-a-comment
	     * @param {number} comment - the id of the comment
	     * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'deleteComment',
	    value: function deleteComment(comment, cb) {
	      return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb);
	    }
	  }]);

	  return Gist;
	}(_Requestable3.default);

	module.exports = Gist;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkdpc3QuanMiXSwibmFtZXMiOlsiR2lzdCIsImlkIiwiYXV0aCIsImFwaUJhc2UiLCJfX2lkIiwiY2IiLCJfcmVxdWVzdCIsImdpc3QiLCJ0aGVuIiwicmVzcG9uc2UiLCJkYXRhIiwiX3JlcXVlc3QyMDRvcjQwNCIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJjb21tZW50IiwiYm9keSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7OztBQVNBOzs7SUFHTUEsSTs7O0FBQ0g7Ozs7OztBQU1BLGdCQUFZQyxFQUFaLEVBQWdCQyxJQUFoQixFQUFzQkMsT0FBdEIsRUFBK0I7QUFBQTs7QUFBQSw0R0FDdEJELElBRHNCLEVBQ2hCQyxPQURnQjs7QUFFNUIsVUFBS0MsSUFBTCxHQUFZSCxFQUFaO0FBRjRCO0FBRzlCOztBQUVEOzs7Ozs7Ozs7O3lCQU1LSSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLEVBQTRDLElBQTVDLEVBQWtEQyxFQUFsRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MkJBT09FLEksRUFBTUYsRSxFQUFJO0FBQUE7O0FBQ2QsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxFQUFzQixRQUF0QixFQUFnQ0MsSUFBaEMsRUFBc0NGLEVBQXRDLEVBQ0hHLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakIsZUFBS0wsSUFBTCxHQUFZSyxTQUFTQyxJQUFULENBQWNULEVBQTFCO0FBQ0EsZUFBT1EsUUFBUDtBQUNGLE9BSkcsQ0FBUDtBQUtGOztBQUVEOzs7Ozs7Ozs7NEJBTU9KLEUsRUFBSTtBQUNSLGFBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS0YsSUFBdkMsRUFBK0MsSUFBL0MsRUFBcURDLEVBQXJELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lCQU1LQSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtGLElBQXJDLGFBQW1ELElBQW5ELEVBQXlEQyxFQUF6RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MkJBT09FLEksRUFBTUYsRSxFQUFJO0FBQ2QsYUFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLRixJQUF0QyxFQUE4Q0csSUFBOUMsRUFBb0RGLEVBQXBELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lCQU1LQSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLFlBQWlELElBQWpELEVBQXVEQyxFQUF2RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsyQkFNT0EsRSxFQUFJO0FBQ1IsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLRixJQUF2QyxZQUFvRCxJQUFwRCxFQUEwREMsRUFBMUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OEJBTVVBLEUsRUFBSTtBQUNYLGFBQU8sS0FBS00sZ0JBQUwsYUFBZ0MsS0FBS1AsSUFBckMsWUFBa0QsSUFBbEQsRUFBd0RDLEVBQXhELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O2lDQU1hQSxFLEVBQUk7QUFDZCxhQUFPLEtBQUtPLGdCQUFMLGFBQWdDLEtBQUtSLElBQXJDLGdCQUFzRCxJQUF0RCxFQUE0REMsRUFBNUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OytCQU9XUSxPLEVBQVNSLEUsRUFBSTtBQUNyQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLGtCQUFxRFMsT0FBckQsRUFBZ0UsSUFBaEUsRUFBc0VSLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztrQ0FPY1EsTyxFQUFTUixFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLRixJQUFyQyxnQkFBc0QsRUFBQ1UsTUFBTUQsT0FBUCxFQUF0RCxFQUF1RVIsRUFBdkUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztnQ0FRWVEsTyxFQUFTQyxJLEVBQU1ULEUsRUFBSTtBQUM1QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtGLElBQXRDLGtCQUF1RFMsT0FBdkQsRUFBa0UsRUFBQ0MsTUFBTUEsSUFBUCxFQUFsRSxFQUFnRlQsRUFBaEYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2tDQU9jUSxPLEVBQVNSLEUsRUFBSTtBQUN4QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtGLElBQXZDLGtCQUF3RFMsT0FBeEQsRUFBbUUsSUFBbkUsRUFBeUVSLEVBQXpFLENBQVA7QUFDRjs7Ozs7O0FBR0pVLE9BQU9DLE9BQVAsR0FBaUJoQixJQUFqQiIsImZpbGUiOiJHaXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogQSBHaXN0IGNhbiByZXRyaWV2ZSBhbmQgbW9kaWZ5IGdpc3RzLlxuICovXG5jbGFzcyBHaXN0IGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBHaXN0LlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSBnaXN0IChub3QgcmVxdWlyZWQgd2hlbiBjcmVhdGluZyBhIGdpc3QpXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IFthdXRoXSAtIGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvIGF1dGhlbnRpY2F0ZSB0byBHaXRodWJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGlkLCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX19pZCA9IGlkO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEZldGNoIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jZ2V0LWEtc2luZ2xlLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGdpc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgcmVhZChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvZ2lzdHMvJHt0aGlzLl9faWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNjcmVhdGUtYS1naXN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gZ2lzdCAtIHRoZSBkYXRhIGZvciB0aGUgbmV3IGdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBnaXN0IHVwb24gY3JlYXRpb25cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlKGdpc3QsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsICcvZ2lzdHMnLCBnaXN0LCBjYilcbiAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGdpc3QuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI2RlbGV0ZS1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgUHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGUoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBGb3JrIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jZm9yay1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGdpc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9yayhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9mb3Jrc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBVcGRhdGUgYSBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNlZGl0LWEtZ2lzdFxuICAgICogQHBhcmFtIHtPYmplY3R9IGdpc3QgLSB0aGUgbmV3IGRhdGEgZm9yIHRoZSBnaXN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gdGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIEFQSSByZXN1bHRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlKGdpc3QsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfWAsIGdpc3QsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTdGFyIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jc3Rhci1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9zdGFyYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVuc3RhciBhIGdpc3QuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI3Vuc3Rhci1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVuc3RhcihjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvZ2lzdHMvJHt0aGlzLl9faWR9L3N0YXJgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSBnaXN0IGlzIHN0YXJyZWQgYnkgdGhlIHVzZXIuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI2NoZWNrLWlmLWEtZ2lzdC1pcy1zdGFycmVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIGdpc3QgaXMgc3RhcnJlZCBhbmQgZmFsc2UgaWYgdGhlIGdpc3QgaXMgbm90IHN0YXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNTdGFycmVkKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvZ2lzdHMvJHt0aGlzLl9faWR9L3N0YXJgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgZ2lzdCdzIGNvbW1lbnRzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2xpc3QtY29tbWVudHMtb24tYS1naXN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBhcnJheSBvZiBjb21tZW50c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0Q29tbWVudHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9naXN0cy8ke3RoaXMuX19pZH0vY29tbWVudHNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRmV0Y2ggb25lIG9mIHRoZSBnaXN0J3MgY29tbWVudHNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy9jb21tZW50cy8jZ2V0LWEtc2luZ2xlLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb21tZW50IC0gdGhlIGlkIG9mIHRoZSBjb21tZW50XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb21tZW50XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbW1lbnQoY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50cy8ke2NvbW1lbnR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENvbW1lbnQgb24gYSBnaXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2NyZWF0ZS1hLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50IC0gdGhlIGNvbW1lbnQgdG8gYWRkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gdGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIEFQSSByZXN1bHRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlQ29tbWVudChjb21tZW50LCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50c2AsIHtib2R5OiBjb21tZW50fSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEVkaXQgYSBjb21tZW50IG9uIHRoZSBnaXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2VkaXQtYS1jb21tZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gY29tbWVudCAtIHRoZSBpZCBvZiB0aGUgY29tbWVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgLSB0aGUgbmV3IGNvbW1lbnRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1vZGlmaWVkIGNvbW1lbnRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdENvbW1lbnQoY29tbWVudCwgYm9keSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvZ2lzdHMvJHt0aGlzLl9faWR9L2NvbW1lbnRzLyR7Y29tbWVudH1gLCB7Ym9keTogYm9keX0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSBjb21tZW50IG9uIHRoZSBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzL2NvbW1lbnRzLyNkZWxldGUtYS1jb21tZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gY29tbWVudCAtIHRoZSBpZCBvZiB0aGUgY29tbWVudFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZUNvbW1lbnQoY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50cy8ke2NvbW1lbnR9YCwgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpc3Q7XG4iXX0=
	//# sourceMappingURL=Gist.js.map


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _axios = __webpack_require__(6);

	var _axios2 = _interopRequireDefault(_axios);

	var _debug = __webpack_require__(32);

	var _debug2 = _interopRequireDefault(_debug);

	var _jsBase = __webpack_require__(35);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:request');

	/**
	 * The error structure returned when a network call fails
	 */

	var ResponseError = function (_Error) {
	   _inherits(ResponseError, _Error);

	   /**
	    * Construct a new ResponseError
	    * @param {string} message - an message to return instead of the the default error message
	    * @param {string} path - the requested path
	    * @param {Object} response - the object returned by Axios
	    */
	   function ResponseError(message, path, response) {
	      _classCallCheck(this, ResponseError);

	      var _this = _possibleConstructorReturn(this, (ResponseError.__proto__ || Object.getPrototypeOf(ResponseError)).call(this, message));

	      _this.path = path;
	      _this.request = response.config;
	      _this.response = (response || {}).response || response;
	      _this.status = response.status;
	      return _this;
	   }

	   return ResponseError;
	}(Error);

	/**
	 * Requestable wraps the logic for making http requests to the API
	 */


	var Requestable = function () {
	   /**
	    * Either a username and password or an oauth token for Github
	    * @typedef {Object} Requestable.auth
	    * @prop {string} [username] - the Github username
	    * @prop {string} [password] - the user's password
	    * @prop {token} [token] - an OAuth token
	    */
	   /**
	    * Initialize the http internals.
	    * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is
	    *                                  not provided request will be made unauthenticated
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    * @param {string} [AcceptHeader=v3] - the accept header for the requests
	    */
	   function Requestable(auth, apiBase, AcceptHeader) {
	      _classCallCheck(this, Requestable);

	      this.__apiBase = apiBase || 'https://api.github.com';
	      this.__auth = {
	         token: auth.token,
	         username: auth.username,
	         password: auth.password
	      };
	      this.__AcceptHeader = AcceptHeader || 'v3';

	      if (auth.token) {
	         this.__authorizationHeader = 'token ' + auth.token;
	      } else if (auth.username && auth.password) {
	         this.__authorizationHeader = 'Basic ' + _jsBase.Base64.encode(auth.username + ':' + auth.password);
	      }
	   }

	   /**
	    * Compute the URL to use to make a request.
	    * @private
	    * @param {string} path - either a URL relative to the API base or an absolute URL
	    * @return {string} - the URL to use
	    */


	   _createClass(Requestable, [{
	      key: '__getURL',
	      value: function __getURL(path) {
	         var url = path;

	         if (path.indexOf('//') === -1) {
	            url = this.__apiBase + path;
	         }

	         var newCacheBuster = 'timestamp=' + new Date().getTime();
	         return url.replace(/(timestamp=\d+)/, newCacheBuster);
	      }

	      /**
	       * Compute the headers required for an API request.
	       * @private
	       * @param {boolean} raw - if the request should be treated as JSON or as a raw request
	       * @param {string} AcceptHeader - the accept header for the request
	       * @return {Object} - the headers to use in the request
	       */

	   }, {
	      key: '__getRequestHeaders',
	      value: function __getRequestHeaders(raw, AcceptHeader) {
	         var headers = {
	            'Content-Type': 'application/json;charset=UTF-8',
	            'Accept': 'application/vnd.github.' + (AcceptHeader || this.__AcceptHeader)
	         };

	         if (raw) {
	            headers.Accept += '.raw';
	         }
	         headers.Accept += '+json';

	         if (this.__authorizationHeader) {
	            headers.Authorization = this.__authorizationHeader;
	         }

	         return headers;
	      }

	      /**
	       * Sets the default options for API requests
	       * @protected
	       * @param {Object} [requestOptions={}] - the current options for the request
	       * @return {Object} - the options to pass to the request
	       */

	   }, {
	      key: '_getOptionsWithDefaults',
	      value: function _getOptionsWithDefaults() {
	         var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	         if (!(requestOptions.visibility || requestOptions.affiliation)) {
	            requestOptions.type = requestOptions.type || 'all';
	         }
	         requestOptions.sort = requestOptions.sort || 'updated';
	         requestOptions.per_page = requestOptions.per_page || '100'; // eslint-disable-line

	         return requestOptions;
	      }

	      /**
	       * if a `Date` is passed to this function it will be converted to an ISO string
	       * @param {*} date - the object to attempt to cooerce into an ISO date string
	       * @return {string} - the ISO representation of `date` or whatever was passed in if it was not a date
	       */

	   }, {
	      key: '_dateToISO',
	      value: function _dateToISO(date) {
	         if (date && date instanceof Date) {
	            date = date.toISOString();
	         }

	         return date;
	      }

	      /**
	       * A function that receives the result of the API request.
	       * @callback Requestable.callback
	       * @param {Requestable.Error} error - the error returned by the API or `null`
	       * @param {(Object|true)} result - the data returned by the API or `true` if the API returns `204 No Content`
	       * @param {Object} request - the raw {@linkcode https://github.com/mzabriskie/axios#response-schema Response}
	       */
	      /**
	       * Make a request.
	       * @param {string} method - the method for the request (GET, PUT, POST, DELETE)
	       * @param {string} path - the path for the request
	       * @param {*} [data] - the data to send to the server. For HTTP methods that don't have a body the data
	       *                   will be sent as query parameters
	       * @param {Requestable.callback} [cb] - the callback for the request
	       * @param {boolean} [raw=false] - if the request should be sent as raw. If this is a falsy value then the
	       *                              request will be made as JSON
	       * @return {Promise} - the Promise for the http request
	       */

	   }, {
	      key: '_request',
	      value: function _request(method, path, data, cb, raw) {
	         var url = this.__getURL(path);

	         var AcceptHeader = (data || {}).AcceptHeader;
	         if (AcceptHeader) {
	            delete data.AcceptHeader;
	         }
	         var headers = this.__getRequestHeaders(raw, AcceptHeader);

	         var queryParams = {};

	         var shouldUseDataAsParams = data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && methodHasNoBody(method);
	         if (shouldUseDataAsParams) {
	            queryParams = data;
	            data = undefined;
	         }

	         var config = {
	            url: url,
	            method: method,
	            headers: headers,
	            params: queryParams,
	            data: data,
	            responseType: raw ? 'text' : 'json'
	         };

	         log(config.method + ' to ' + config.url);
	         var requestPromise = (0, _axios2.default)(config).catch(callbackErrorOrThrow(cb, path));

	         if (cb) {
	            requestPromise.then(function (response) {
	               if (response.data && Object.keys(response.data).length > 0) {
	                  // When data has results
	                  cb(null, response.data, response);
	               } else if (config.method !== 'GET' && Object.keys(response.data).length < 1) {
	                  // True when successful submit a request and receive a empty object
	                  cb(null, response.status < 300, response);
	               } else {
	                  cb(null, response.data, response);
	               }
	            });
	         }

	         return requestPromise;
	      }

	      /**
	       * Make a request to an endpoint the returns 204 when true and 404 when false
	       * @param {string} path - the path to request
	       * @param {Object} data - any query parameters for the request
	       * @param {Requestable.callback} cb - the callback that will receive `true` or `false`
	       * @param {method} [method=GET] - HTTP Method to use
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: '_request204or404',
	      value: function _request204or404(path, data, cb) {
	         var method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'GET';

	         return this._request(method, path, data).then(function success(response) {
	            if (cb) {
	               cb(null, true, response);
	            }
	            return true;
	         }, function failure(response) {
	            if (response.response.status === 404) {
	               if (cb) {
	                  cb(null, false, response);
	               }
	               return false;
	            }

	            if (cb) {
	               cb(response);
	            }
	            throw response;
	         });
	      }

	      /**
	       * Make a request and fetch all the available data. Github will paginate responses so for queries
	       * that might span multiple pages this method is preferred to {@link Requestable#request}
	       * @param {string} path - the path to request
	       * @param {Object} options - the query parameters to include
	       * @param {Requestable.callback} [cb] - the function to receive the data. The returned data will always be an array.
	       * @param {Object[]} results - the partial results. This argument is intended for interal use only.
	       * @return {Promise} - a promise which will resolve when all pages have been fetched
	       * @deprecated This will be folded into {@link Requestable#_request} in the 2.0 release.
	       */

	   }, {
	      key: '_requestAllPages',
	      value: function _requestAllPages(path, options, cb, results) {
	         var _this2 = this;

	         results = results || [];

	         return this._request('GET', path, options).then(function (response) {
	            var _results;

	            var thisGroup = void 0;
	            if (response.data instanceof Array) {
	               thisGroup = response.data;
	            } else if (response.data.items instanceof Array) {
	               thisGroup = response.data.items;
	            } else {
	               var message = 'cannot figure out how to append ' + response.data + ' to the result set';
	               throw new ResponseError(message, path, response);
	            }
	            (_results = results).push.apply(_results, _toConsumableArray(thisGroup));

	            var nextUrl = getNextPage(response.headers.link);
	            if (nextUrl) {
	               log('getting next page: ' + nextUrl);
	               return _this2._requestAllPages(nextUrl, options, cb, results);
	            }

	            if (cb) {
	               cb(null, results, response);
	            }

	            response.data = results;
	            return response;
	         }).catch(callbackErrorOrThrow(cb, path));
	      }
	   }]);

	   return Requestable;
	}();

	module.exports = Requestable;

	// ////////////////////////// //
	//  Private helper functions  //
	// ////////////////////////// //
	var METHODS_WITH_NO_BODY = ['GET', 'HEAD', 'DELETE'];
	function methodHasNoBody(method) {
	   return METHODS_WITH_NO_BODY.indexOf(method) !== -1;
	}

	function getNextPage() {
	   var linksHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	   var links = linksHeader.split(/\s*,\s*/); // splits and strips the urls
	   return links.reduce(function (nextUrl, link) {
	      if (link.search(/rel="next"/) !== -1) {
	         return (link.match(/<(.*)>/) || [])[1];
	      }

	      return nextUrl;
	   }, undefined);
	}

	function callbackErrorOrThrow(cb, path) {
	   return function handler(object) {
	      var error = void 0;
	      if (object.hasOwnProperty('config')) {
	         var _object$response = object.response,
	             status = _object$response.status,
	             statusText = _object$response.statusText,
	             _object$config = object.config,
	             method = _object$config.method,
	             url = _object$config.url;

	         var message = status + ' error making request ' + method + ' ' + url + ': "' + statusText + '"';
	         error = new ResponseError(message, path, object);
	         log(message + ' ' + JSON.stringify(object.data));
	      } else {
	         error = object;
	      }
	      if (cb) {
	         log('going to error callback');
	         cb(error);
	      } else {
	         log('throwing error');
	         throw error;
	      }
	   };
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVlc3RhYmxlLmpzIl0sIm5hbWVzIjpbImxvZyIsIlJlc3BvbnNlRXJyb3IiLCJtZXNzYWdlIiwicGF0aCIsInJlc3BvbnNlIiwicmVxdWVzdCIsImNvbmZpZyIsInN0YXR1cyIsIkVycm9yIiwiUmVxdWVzdGFibGUiLCJhdXRoIiwiYXBpQmFzZSIsIkFjY2VwdEhlYWRlciIsIl9fYXBpQmFzZSIsIl9fYXV0aCIsInRva2VuIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIl9fQWNjZXB0SGVhZGVyIiwiX19hdXRob3JpemF0aW9uSGVhZGVyIiwiZW5jb2RlIiwidXJsIiwiaW5kZXhPZiIsIm5ld0NhY2hlQnVzdGVyIiwiRGF0ZSIsImdldFRpbWUiLCJyZXBsYWNlIiwicmF3IiwiaGVhZGVycyIsIkFjY2VwdCIsIkF1dGhvcml6YXRpb24iLCJyZXF1ZXN0T3B0aW9ucyIsInZpc2liaWxpdHkiLCJhZmZpbGlhdGlvbiIsInR5cGUiLCJzb3J0IiwicGVyX3BhZ2UiLCJkYXRlIiwidG9JU09TdHJpbmciLCJtZXRob2QiLCJkYXRhIiwiY2IiLCJfX2dldFVSTCIsIl9fZ2V0UmVxdWVzdEhlYWRlcnMiLCJxdWVyeVBhcmFtcyIsInNob3VsZFVzZURhdGFBc1BhcmFtcyIsIm1ldGhvZEhhc05vQm9keSIsInVuZGVmaW5lZCIsInBhcmFtcyIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RQcm9taXNlIiwiY2F0Y2giLCJjYWxsYmFja0Vycm9yT3JUaHJvdyIsInRoZW4iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiX3JlcXVlc3QiLCJzdWNjZXNzIiwiZmFpbHVyZSIsIm9wdGlvbnMiLCJyZXN1bHRzIiwidGhpc0dyb3VwIiwiQXJyYXkiLCJpdGVtcyIsInB1c2giLCJuZXh0VXJsIiwiZ2V0TmV4dFBhZ2UiLCJsaW5rIiwiX3JlcXVlc3RBbGxQYWdlcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJNRVRIT0RTX1dJVEhfTk9fQk9EWSIsImxpbmtzSGVhZGVyIiwibGlua3MiLCJzcGxpdCIsInJlZHVjZSIsInNlYXJjaCIsIm1hdGNoIiwiaGFuZGxlciIsIm9iamVjdCIsImVycm9yIiwiaGFzT3duUHJvcGVydHkiLCJzdGF0dXNUZXh0IiwiSlNPTiIsInN0cmluZ2lmeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVRBOzs7Ozs7O0FBV0EsSUFBTUEsTUFBTSxxQkFBTSxnQkFBTixDQUFaOztBQUVBOzs7O0lBR01DLGE7OztBQUNIOzs7Ozs7QUFNQSwwQkFBWUMsT0FBWixFQUFxQkMsSUFBckIsRUFBMkJDLFFBQTNCLEVBQXFDO0FBQUE7O0FBQUEsZ0lBQzVCRixPQUQ0Qjs7QUFFbEMsWUFBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsWUFBS0UsT0FBTCxHQUFlRCxTQUFTRSxNQUF4QjtBQUNBLFlBQUtGLFFBQUwsR0FBZ0IsQ0FBQ0EsWUFBWSxFQUFiLEVBQWlCQSxRQUFqQixJQUE2QkEsUUFBN0M7QUFDQSxZQUFLRyxNQUFMLEdBQWNILFNBQVNHLE1BQXZCO0FBTGtDO0FBTXBDOzs7RUFid0JDLEs7O0FBZ0I1Qjs7Ozs7SUFHTUMsVztBQUNIOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQSx3QkFBWUMsSUFBWixFQUFrQkMsT0FBbEIsRUFBMkJDLFlBQTNCLEVBQXlDO0FBQUE7O0FBQ3RDLFdBQUtDLFNBQUwsR0FBaUJGLFdBQVcsd0JBQTVCO0FBQ0EsV0FBS0csTUFBTCxHQUFjO0FBQ1hDLGdCQUFPTCxLQUFLSyxLQUREO0FBRVhDLG1CQUFVTixLQUFLTSxRQUZKO0FBR1hDLG1CQUFVUCxLQUFLTztBQUhKLE9BQWQ7QUFLQSxXQUFLQyxjQUFMLEdBQXNCTixnQkFBZ0IsSUFBdEM7O0FBRUEsVUFBSUYsS0FBS0ssS0FBVCxFQUFnQjtBQUNiLGNBQUtJLHFCQUFMLEdBQTZCLFdBQVdULEtBQUtLLEtBQTdDO0FBQ0YsT0FGRCxNQUVPLElBQUlMLEtBQUtNLFFBQUwsSUFBaUJOLEtBQUtPLFFBQTFCLEVBQW9DO0FBQ3hDLGNBQUtFLHFCQUFMLEdBQTZCLFdBQVcsZUFBT0MsTUFBUCxDQUFjVixLQUFLTSxRQUFMLEdBQWdCLEdBQWhCLEdBQXNCTixLQUFLTyxRQUF6QyxDQUF4QztBQUNGO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7K0JBTVNkLEksRUFBTTtBQUNaLGFBQUlrQixNQUFNbEIsSUFBVjs7QUFFQSxhQUFJQSxLQUFLbUIsT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBQyxDQUE1QixFQUErQjtBQUM1QkQsa0JBQU0sS0FBS1IsU0FBTCxHQUFpQlYsSUFBdkI7QUFDRjs7QUFFRCxhQUFJb0IsaUJBQWlCLGVBQWUsSUFBSUMsSUFBSixHQUFXQyxPQUFYLEVBQXBDO0FBQ0EsZ0JBQU9KLElBQUlLLE9BQUosQ0FBWSxpQkFBWixFQUErQkgsY0FBL0IsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzBDQU9vQkksRyxFQUFLZixZLEVBQWM7QUFDcEMsYUFBSWdCLFVBQVU7QUFDWCw0QkFBZ0IsZ0NBREw7QUFFWCxzQkFBVSw2QkFBNkJoQixnQkFBZ0IsS0FBS00sY0FBbEQ7QUFGQyxVQUFkOztBQUtBLGFBQUlTLEdBQUosRUFBUztBQUNOQyxvQkFBUUMsTUFBUixJQUFrQixNQUFsQjtBQUNGO0FBQ0RELGlCQUFRQyxNQUFSLElBQWtCLE9BQWxCOztBQUVBLGFBQUksS0FBS1YscUJBQVQsRUFBZ0M7QUFDN0JTLG9CQUFRRSxhQUFSLEdBQXdCLEtBQUtYLHFCQUE3QjtBQUNGOztBQUVELGdCQUFPUyxPQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnREFNNkM7QUFBQSxhQUFyQkcsY0FBcUIsdUVBQUosRUFBSTs7QUFDMUMsYUFBSSxFQUFFQSxlQUFlQyxVQUFmLElBQTZCRCxlQUFlRSxXQUE5QyxDQUFKLEVBQWdFO0FBQzdERiwyQkFBZUcsSUFBZixHQUFzQkgsZUFBZUcsSUFBZixJQUF1QixLQUE3QztBQUNGO0FBQ0RILHdCQUFlSSxJQUFmLEdBQXNCSixlQUFlSSxJQUFmLElBQXVCLFNBQTdDO0FBQ0FKLHdCQUFlSyxRQUFmLEdBQTBCTCxlQUFlSyxRQUFmLElBQTJCLEtBQXJELENBTDBDLENBS2tCOztBQUU1RCxnQkFBT0wsY0FBUDtBQUNGOztBQUVEOzs7Ozs7OztpQ0FLV00sSSxFQUFNO0FBQ2QsYUFBSUEsUUFBU0EsZ0JBQWdCYixJQUE3QixFQUFvQztBQUNqQ2EsbUJBQU9BLEtBQUtDLFdBQUwsRUFBUDtBQUNGOztBQUVELGdCQUFPRCxJQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7K0JBV1NFLE0sRUFBUXBDLEksRUFBTXFDLEksRUFBTUMsRSxFQUFJZCxHLEVBQUs7QUFDbkMsYUFBTU4sTUFBTSxLQUFLcUIsUUFBTCxDQUFjdkMsSUFBZCxDQUFaOztBQUVBLGFBQU1TLGVBQWUsQ0FBQzRCLFFBQVEsRUFBVCxFQUFhNUIsWUFBbEM7QUFDQSxhQUFJQSxZQUFKLEVBQWtCO0FBQ2YsbUJBQU80QixLQUFLNUIsWUFBWjtBQUNGO0FBQ0QsYUFBTWdCLFVBQVUsS0FBS2UsbUJBQUwsQ0FBeUJoQixHQUF6QixFQUE4QmYsWUFBOUIsQ0FBaEI7O0FBRUEsYUFBSWdDLGNBQWMsRUFBbEI7O0FBRUEsYUFBTUMsd0JBQXdCTCxRQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBekIsSUFBc0NNLGdCQUFnQlAsTUFBaEIsQ0FBcEU7QUFDQSxhQUFJTSxxQkFBSixFQUEyQjtBQUN4QkQsMEJBQWNKLElBQWQ7QUFDQUEsbUJBQU9PLFNBQVA7QUFDRjs7QUFFRCxhQUFNekMsU0FBUztBQUNaZSxpQkFBS0EsR0FETztBQUVaa0Isb0JBQVFBLE1BRkk7QUFHWlgscUJBQVNBLE9BSEc7QUFJWm9CLG9CQUFRSixXQUpJO0FBS1pKLGtCQUFNQSxJQUxNO0FBTVpTLDBCQUFjdEIsTUFBTSxNQUFOLEdBQWU7QUFOakIsVUFBZjs7QUFTQTNCLGFBQU9NLE9BQU9pQyxNQUFkLFlBQTJCakMsT0FBT2UsR0FBbEM7QUFDQSxhQUFNNkIsaUJBQWlCLHFCQUFNNUMsTUFBTixFQUFjNkMsS0FBZCxDQUFvQkMscUJBQXFCWCxFQUFyQixFQUF5QnRDLElBQXpCLENBQXBCLENBQXZCOztBQUVBLGFBQUlzQyxFQUFKLEVBQVE7QUFDTFMsMkJBQWVHLElBQWYsQ0FBb0IsVUFBQ2pELFFBQUQsRUFBYztBQUMvQixtQkFBSUEsU0FBU29DLElBQVQsSUFBaUJjLE9BQU9DLElBQVAsQ0FBWW5ELFNBQVNvQyxJQUFyQixFQUEyQmdCLE1BQTNCLEdBQW9DLENBQXpELEVBQTREO0FBQ3pEO0FBQ0FmLHFCQUFHLElBQUgsRUFBU3JDLFNBQVNvQyxJQUFsQixFQUF3QnBDLFFBQXhCO0FBQ0YsZ0JBSEQsTUFHTyxJQUFJRSxPQUFPaUMsTUFBUCxLQUFrQixLQUFsQixJQUEyQmUsT0FBT0MsSUFBUCxDQUFZbkQsU0FBU29DLElBQXJCLEVBQTJCZ0IsTUFBM0IsR0FBb0MsQ0FBbkUsRUFBc0U7QUFDMUU7QUFDQWYscUJBQUcsSUFBSCxFQUFVckMsU0FBU0csTUFBVCxHQUFrQixHQUE1QixFQUFrQ0gsUUFBbEM7QUFDRixnQkFITSxNQUdBO0FBQ0pxQyxxQkFBRyxJQUFILEVBQVNyQyxTQUFTb0MsSUFBbEIsRUFBd0JwQyxRQUF4QjtBQUNGO0FBQ0gsYUFWRDtBQVdGOztBQUVELGdCQUFPOEMsY0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRaUIvQyxJLEVBQU1xQyxJLEVBQU1DLEUsRUFBb0I7QUFBQSxhQUFoQkYsTUFBZ0IsdUVBQVAsS0FBTzs7QUFDOUMsZ0JBQU8sS0FBS2tCLFFBQUwsQ0FBY2xCLE1BQWQsRUFBc0JwQyxJQUF0QixFQUE0QnFDLElBQTVCLEVBQ0hhLElBREcsQ0FDRSxTQUFTSyxPQUFULENBQWlCdEQsUUFBakIsRUFBMkI7QUFDOUIsZ0JBQUlxQyxFQUFKLEVBQVE7QUFDTEEsa0JBQUcsSUFBSCxFQUFTLElBQVQsRUFBZXJDLFFBQWY7QUFDRjtBQUNELG1CQUFPLElBQVA7QUFDRixVQU5HLEVBTUQsU0FBU3VELE9BQVQsQ0FBaUJ2RCxRQUFqQixFQUEyQjtBQUMzQixnQkFBSUEsU0FBU0EsUUFBVCxDQUFrQkcsTUFBbEIsS0FBNkIsR0FBakMsRUFBc0M7QUFDbkMsbUJBQUlrQyxFQUFKLEVBQVE7QUFDTEEscUJBQUcsSUFBSCxFQUFTLEtBQVQsRUFBZ0JyQyxRQUFoQjtBQUNGO0FBQ0Qsc0JBQU8sS0FBUDtBQUNGOztBQUVELGdCQUFJcUMsRUFBSixFQUFRO0FBQ0xBLGtCQUFHckMsUUFBSDtBQUNGO0FBQ0Qsa0JBQU1BLFFBQU47QUFDRixVQWxCRyxDQUFQO0FBbUJGOztBQUVEOzs7Ozs7Ozs7Ozs7O3VDQVVpQkQsSSxFQUFNeUQsTyxFQUFTbkIsRSxFQUFJb0IsTyxFQUFTO0FBQUE7O0FBQzFDQSxtQkFBVUEsV0FBVyxFQUFyQjs7QUFFQSxnQkFBTyxLQUFLSixRQUFMLENBQWMsS0FBZCxFQUFxQnRELElBQXJCLEVBQTJCeUQsT0FBM0IsRUFDSFAsSUFERyxDQUNFLFVBQUNqRCxRQUFELEVBQWM7QUFBQTs7QUFDakIsZ0JBQUkwRCxrQkFBSjtBQUNBLGdCQUFJMUQsU0FBU29DLElBQVQsWUFBeUJ1QixLQUE3QixFQUFvQztBQUNqQ0QsMkJBQVkxRCxTQUFTb0MsSUFBckI7QUFDRixhQUZELE1BRU8sSUFBSXBDLFNBQVNvQyxJQUFULENBQWN3QixLQUFkLFlBQStCRCxLQUFuQyxFQUEwQztBQUM5Q0QsMkJBQVkxRCxTQUFTb0MsSUFBVCxDQUFjd0IsS0FBMUI7QUFDRixhQUZNLE1BRUE7QUFDSixtQkFBSTlELCtDQUE2Q0UsU0FBU29DLElBQXRELHVCQUFKO0FBQ0EscUJBQU0sSUFBSXZDLGFBQUosQ0FBa0JDLE9BQWxCLEVBQTJCQyxJQUEzQixFQUFpQ0MsUUFBakMsQ0FBTjtBQUNGO0FBQ0QsaUNBQVE2RCxJQUFSLG9DQUFnQkgsU0FBaEI7O0FBRUEsZ0JBQU1JLFVBQVVDLFlBQVkvRCxTQUFTd0IsT0FBVCxDQUFpQndDLElBQTdCLENBQWhCO0FBQ0EsZ0JBQUlGLE9BQUosRUFBYTtBQUNWbEUsMkNBQTBCa0UsT0FBMUI7QUFDQSxzQkFBTyxPQUFLRyxnQkFBTCxDQUFzQkgsT0FBdEIsRUFBK0JOLE9BQS9CLEVBQXdDbkIsRUFBeEMsRUFBNENvQixPQUE1QyxDQUFQO0FBQ0Y7O0FBRUQsZ0JBQUlwQixFQUFKLEVBQVE7QUFDTEEsa0JBQUcsSUFBSCxFQUFTb0IsT0FBVCxFQUFrQnpELFFBQWxCO0FBQ0Y7O0FBRURBLHFCQUFTb0MsSUFBVCxHQUFnQnFCLE9BQWhCO0FBQ0EsbUJBQU96RCxRQUFQO0FBQ0YsVUF6QkcsRUF5QkQrQyxLQXpCQyxDQXlCS0MscUJBQXFCWCxFQUFyQixFQUF5QnRDLElBQXpCLENBekJMLENBQVA7QUEwQkY7Ozs7OztBQUdKbUUsT0FBT0MsT0FBUCxHQUFpQjlELFdBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQU0rRCx1QkFBdUIsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQixRQUFoQixDQUE3QjtBQUNBLFNBQVMxQixlQUFULENBQXlCUCxNQUF6QixFQUFpQztBQUM5QixVQUFPaUMscUJBQXFCbEQsT0FBckIsQ0FBNkJpQixNQUE3QixNQUF5QyxDQUFDLENBQWpEO0FBQ0Y7O0FBRUQsU0FBUzRCLFdBQVQsR0FBdUM7QUFBQSxPQUFsQk0sV0FBa0IsdUVBQUosRUFBSTs7QUFDcEMsT0FBTUMsUUFBUUQsWUFBWUUsS0FBWixDQUFrQixTQUFsQixDQUFkLENBRG9DLENBQ1E7QUFDNUMsVUFBT0QsTUFBTUUsTUFBTixDQUFhLFVBQVNWLE9BQVQsRUFBa0JFLElBQWxCLEVBQXdCO0FBQ3pDLFVBQUlBLEtBQUtTLE1BQUwsQ0FBWSxZQUFaLE1BQThCLENBQUMsQ0FBbkMsRUFBc0M7QUFDbkMsZ0JBQU8sQ0FBQ1QsS0FBS1UsS0FBTCxDQUFXLFFBQVgsS0FBd0IsRUFBekIsRUFBNkIsQ0FBN0IsQ0FBUDtBQUNGOztBQUVELGFBQU9aLE9BQVA7QUFDRixJQU5NLEVBTUpuQixTQU5JLENBQVA7QUFPRjs7QUFFRCxTQUFTSyxvQkFBVCxDQUE4QlgsRUFBOUIsRUFBa0N0QyxJQUFsQyxFQUF3QztBQUNyQyxVQUFPLFNBQVM0RSxPQUFULENBQWlCQyxNQUFqQixFQUF5QjtBQUM3QixVQUFJQyxjQUFKO0FBQ0EsVUFBSUQsT0FBT0UsY0FBUCxDQUFzQixRQUF0QixDQUFKLEVBQXFDO0FBQUEsZ0NBQzhCRixNQUQ5QixDQUMzQjVFLFFBRDJCO0FBQUEsYUFDaEJHLE1BRGdCLG9CQUNoQkEsTUFEZ0I7QUFBQSxhQUNSNEUsVUFEUSxvQkFDUkEsVUFEUTtBQUFBLDhCQUM4QkgsTUFEOUIsQ0FDSzFFLE1BREw7QUFBQSxhQUNjaUMsTUFEZCxrQkFDY0EsTUFEZDtBQUFBLGFBQ3NCbEIsR0FEdEIsa0JBQ3NCQSxHQUR0Qjs7QUFFbEMsYUFBSW5CLFVBQWNLLE1BQWQsOEJBQTZDZ0MsTUFBN0MsU0FBdURsQixHQUF2RCxXQUFnRThELFVBQWhFLE1BQUo7QUFDQUYsaUJBQVEsSUFBSWhGLGFBQUosQ0FBa0JDLE9BQWxCLEVBQTJCQyxJQUEzQixFQUFpQzZFLE1BQWpDLENBQVI7QUFDQWhGLGFBQU9FLE9BQVAsU0FBa0JrRixLQUFLQyxTQUFMLENBQWVMLE9BQU94QyxJQUF0QixDQUFsQjtBQUNGLE9BTEQsTUFLTztBQUNKeUMsaUJBQVFELE1BQVI7QUFDRjtBQUNELFVBQUl2QyxFQUFKLEVBQVE7QUFDTHpDLGFBQUkseUJBQUo7QUFDQXlDLFlBQUd3QyxLQUFIO0FBQ0YsT0FIRCxNQUdPO0FBQ0pqRixhQUFJLGdCQUFKO0FBQ0EsZUFBTWlGLEtBQU47QUFDRjtBQUNILElBakJEO0FBa0JGIiwiZmlsZSI6IlJlcXVlc3RhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHtCYXNlNjR9IGZyb20gJ2pzLWJhc2U2NCc7XG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdnaXRodWI6cmVxdWVzdCcpO1xuXG4vKipcbiAqIFRoZSBlcnJvciBzdHJ1Y3R1cmUgcmV0dXJuZWQgd2hlbiBhIG5ldHdvcmsgY2FsbCBmYWlsc1xuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgLyoqXG4gICAgKiBDb25zdHJ1Y3QgYSBuZXcgUmVzcG9uc2VFcnJvclxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBhbiBtZXNzYWdlIHRvIHJldHVybiBpbnN0ZWFkIG9mIHRoZSB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSByZXF1ZXN0ZWQgcGF0aFxuICAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gdGhlIG9iamVjdCByZXR1cm5lZCBieSBBeGlvc1xuICAgICovXG4gICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCByZXNwb25zZSkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVzcG9uc2UuY29uZmlnO1xuICAgICAgdGhpcy5yZXNwb25zZSA9IChyZXNwb25zZSB8fCB7fSkucmVzcG9uc2UgfHwgcmVzcG9uc2U7XG4gICAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0YWJsZSB3cmFwcyB0aGUgbG9naWMgZm9yIG1ha2luZyBodHRwIHJlcXVlc3RzIHRvIHRoZSBBUElcbiAqL1xuY2xhc3MgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBFaXRoZXIgYSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgb3IgYW4gb2F1dGggdG9rZW4gZm9yIEdpdGh1YlxuICAgICogQHR5cGVkZWYge09iamVjdH0gUmVxdWVzdGFibGUuYXV0aFxuICAgICogQHByb3Age3N0cmluZ30gW3VzZXJuYW1lXSAtIHRoZSBHaXRodWIgdXNlcm5hbWVcbiAgICAqIEBwcm9wIHtzdHJpbmd9IFtwYXNzd29yZF0gLSB0aGUgdXNlcidzIHBhc3N3b3JkXG4gICAgKiBAcHJvcCB7dG9rZW59IFt0b2tlbl0gLSBhbiBPQXV0aCB0b2tlblxuICAgICovXG4gICAvKipcbiAgICAqIEluaXRpYWxpemUgdGhlIGh0dHAgaW50ZXJuYWxzLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1Yi4gSWYgYXV0aCBpc1xuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHByb3ZpZGVkIHJlcXVlc3Qgd2lsbCBiZSBtYWRlIHVuYXV0aGVudGljYXRlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlPWh0dHBzOi8vYXBpLmdpdGh1Yi5jb21dIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbQWNjZXB0SGVhZGVyPXYzXSAtIHRoZSBhY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdHNcbiAgICAqL1xuICAgY29uc3RydWN0b3IoYXV0aCwgYXBpQmFzZSwgQWNjZXB0SGVhZGVyKSB7XG4gICAgICB0aGlzLl9fYXBpQmFzZSA9IGFwaUJhc2UgfHwgJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xuICAgICAgdGhpcy5fX2F1dGggPSB7XG4gICAgICAgICB0b2tlbjogYXV0aC50b2tlbixcbiAgICAgICAgIHVzZXJuYW1lOiBhdXRoLnVzZXJuYW1lLFxuICAgICAgICAgcGFzc3dvcmQ6IGF1dGgucGFzc3dvcmQsXG4gICAgICB9O1xuICAgICAgdGhpcy5fX0FjY2VwdEhlYWRlciA9IEFjY2VwdEhlYWRlciB8fCAndjMnO1xuXG4gICAgICBpZiAoYXV0aC50b2tlbikge1xuICAgICAgICAgdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXIgPSAndG9rZW4gJyArIGF1dGgudG9rZW47XG4gICAgICB9IGVsc2UgaWYgKGF1dGgudXNlcm5hbWUgJiYgYXV0aC5wYXNzd29yZCkge1xuICAgICAgICAgdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXIgPSAnQmFzaWMgJyArIEJhc2U2NC5lbmNvZGUoYXV0aC51c2VybmFtZSArICc6JyArIGF1dGgucGFzc3dvcmQpO1xuICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIENvbXB1dGUgdGhlIFVSTCB0byB1c2UgdG8gbWFrZSBhIHJlcXVlc3QuXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBlaXRoZXIgYSBVUkwgcmVsYXRpdmUgdG8gdGhlIEFQSSBiYXNlIG9yIGFuIGFic29sdXRlIFVSTFxuICAgICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBVUkwgdG8gdXNlXG4gICAgKi9cbiAgIF9fZ2V0VVJMKHBhdGgpIHtcbiAgICAgIGxldCB1cmwgPSBwYXRoO1xuXG4gICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID09PSAtMSkge1xuICAgICAgICAgdXJsID0gdGhpcy5fX2FwaUJhc2UgKyBwYXRoO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3Q2FjaGVCdXN0ZXIgPSAndGltZXN0YW1wPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvKHRpbWVzdGFtcD1cXGQrKS8sIG5ld0NhY2hlQnVzdGVyKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBoZWFkZXJzIHJlcXVpcmVkIGZvciBhbiBBUEkgcmVxdWVzdC5cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJhdyAtIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSB0cmVhdGVkIGFzIEpTT04gb3IgYXMgYSByYXcgcmVxdWVzdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IEFjY2VwdEhlYWRlciAtIHRoZSBhY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBoZWFkZXJzIHRvIHVzZSBpbiB0aGUgcmVxdWVzdFxuICAgICovXG4gICBfX2dldFJlcXVlc3RIZWFkZXJzKHJhdywgQWNjZXB0SGVhZGVyKSB7XG4gICAgICBsZXQgaGVhZGVycyA9IHtcbiAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi4nICsgKEFjY2VwdEhlYWRlciB8fCB0aGlzLl9fQWNjZXB0SGVhZGVyKSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgIGhlYWRlcnMuQWNjZXB0ICs9ICcucmF3JztcbiAgICAgIH1cbiAgICAgIGhlYWRlcnMuQWNjZXB0ICs9ICcranNvbic7XG5cbiAgICAgIGlmICh0aGlzLl9fYXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgQVBJIHJlcXVlc3RzXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RPcHRpb25zPXt9XSAtIHRoZSBjdXJyZW50IG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcmVxdWVzdFxuICAgICovXG4gICBfZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cyhyZXF1ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgICBpZiAoIShyZXF1ZXN0T3B0aW9ucy52aXNpYmlsaXR5IHx8IHJlcXVlc3RPcHRpb25zLmFmZmlsaWF0aW9uKSkge1xuICAgICAgICAgcmVxdWVzdE9wdGlvbnMudHlwZSA9IHJlcXVlc3RPcHRpb25zLnR5cGUgfHwgJ2FsbCc7XG4gICAgICB9XG4gICAgICByZXF1ZXN0T3B0aW9ucy5zb3J0ID0gcmVxdWVzdE9wdGlvbnMuc29ydCB8fCAndXBkYXRlZCc7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5wZXJfcGFnZSA9IHJlcXVlc3RPcHRpb25zLnBlcl9wYWdlIHx8ICcxMDAnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIHJldHVybiByZXF1ZXN0T3B0aW9ucztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBpZiBhIGBEYXRlYCBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBJU08gc3RyaW5nXG4gICAgKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgb2JqZWN0IHRvIGF0dGVtcHQgdG8gY29vZXJjZSBpbnRvIGFuIElTTyBkYXRlIHN0cmluZ1xuICAgICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBJU08gcmVwcmVzZW50YXRpb24gb2YgYGRhdGVgIG9yIHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gaWYgaXQgd2FzIG5vdCBhIGRhdGVcbiAgICAqL1xuICAgX2RhdGVUb0lTTyhkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSAmJiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICBkYXRlID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIHJlc3VsdCBvZiB0aGUgQVBJIHJlcXVlc3QuXG4gICAgKiBAY2FsbGJhY2sgUmVxdWVzdGFibGUuY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuRXJyb3J9IGVycm9yIC0gdGhlIGVycm9yIHJldHVybmVkIGJ5IHRoZSBBUEkgb3IgYG51bGxgXG4gICAgKiBAcGFyYW0geyhPYmplY3R8dHJ1ZSl9IHJlc3VsdCAtIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBBUEkgb3IgYHRydWVgIGlmIHRoZSBBUEkgcmV0dXJucyBgMjA0IE5vIENvbnRlbnRgXG4gICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIHRoZSByYXcge0BsaW5rY29kZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9heGlvcyNyZXNwb25zZS1zY2hlbWEgUmVzcG9uc2V9XG4gICAgKi9cbiAgIC8qKlxuICAgICogTWFrZSBhIHJlcXVlc3QuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0gdGhlIG1ldGhvZCBmb3IgdGhlIHJlcXVlc3QgKEdFVCwgUFVULCBQT1NULCBERUxFVEUpXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGZvciB0aGUgcmVxdWVzdFxuICAgICogQHBhcmFtIHsqfSBbZGF0YV0gLSB0aGUgZGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIEZvciBIVFRQIG1ldGhvZHMgdGhhdCBkb24ndCBoYXZlIGEgYm9keSB0aGUgZGF0YVxuICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzZW50IGFzIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgY2FsbGJhY2sgZm9yIHRoZSByZXF1ZXN0XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyYXc9ZmFsc2VdIC0gaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHNlbnQgYXMgcmF3LiBJZiB0aGlzIGlzIGEgZmFsc3kgdmFsdWUgdGhlbiB0aGVcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCB3aWxsIGJlIG1hZGUgYXMgSlNPTlxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgUHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBfcmVxdWVzdChtZXRob2QsIHBhdGgsIGRhdGEsIGNiLCByYXcpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuX19nZXRVUkwocGF0aCk7XG5cbiAgICAgIGNvbnN0IEFjY2VwdEhlYWRlciA9IChkYXRhIHx8IHt9KS5BY2NlcHRIZWFkZXI7XG4gICAgICBpZiAoQWNjZXB0SGVhZGVyKSB7XG4gICAgICAgICBkZWxldGUgZGF0YS5BY2NlcHRIZWFkZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fX2dldFJlcXVlc3RIZWFkZXJzKHJhdywgQWNjZXB0SGVhZGVyKTtcblxuICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG5cbiAgICAgIGNvbnN0IHNob3VsZFVzZURhdGFBc1BhcmFtcyA9IGRhdGEgJiYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgJiYgbWV0aG9kSGFzTm9Cb2R5KG1ldGhvZCk7XG4gICAgICBpZiAoc2hvdWxkVXNlRGF0YUFzUGFyYW1zKSB7XG4gICAgICAgICBxdWVyeVBhcmFtcyA9IGRhdGE7XG4gICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgIHBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgcmVzcG9uc2VUeXBlOiByYXcgPyAndGV4dCcgOiAnanNvbicsXG4gICAgICB9O1xuXG4gICAgICBsb2coYCR7Y29uZmlnLm1ldGhvZH0gdG8gJHtjb25maWcudXJsfWApO1xuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2UgPSBheGlvcyhjb25maWcpLmNhdGNoKGNhbGxiYWNrRXJyb3JPclRocm93KGNiLCBwYXRoKSk7XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICAgcmVxdWVzdFByb21pc2UudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIE9iamVjdC5rZXlzKHJlc3BvbnNlLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgIC8vIFdoZW4gZGF0YSBoYXMgcmVzdWx0c1xuICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzcG9uc2UuZGF0YSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcubWV0aG9kICE9PSAnR0VUJyAmJiBPYmplY3Qua2V5cyhyZXNwb25zZS5kYXRhKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAvLyBUcnVlIHdoZW4gc3VjY2Vzc2Z1bCBzdWJtaXQgYSByZXF1ZXN0IGFuZCByZWNlaXZlIGEgZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICBjYihudWxsLCAocmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNiKG51bGwsIHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdFByb21pc2U7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTWFrZSBhIHJlcXVlc3QgdG8gYW4gZW5kcG9pbnQgdGhlIHJldHVybnMgMjA0IHdoZW4gdHJ1ZSBhbmQgNDA0IHdoZW4gZmFsc2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gcmVxdWVzdFxuICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBhbnkgcXVlcnkgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGB0cnVlYCBvciBgZmFsc2VgXG4gICAgKiBAcGFyYW0ge21ldGhvZH0gW21ldGhvZD1HRVRdIC0gSFRUUCBNZXRob2QgdG8gdXNlXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIF9yZXF1ZXN0MjA0b3I0MDQocGF0aCwgZGF0YSwgY2IsIG1ldGhvZCA9ICdHRVQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChtZXRob2QsIHBhdGgsIGRhdGEpXG4gICAgICAgICAudGhlbihmdW5jdGlvbiBzdWNjZXNzKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgIGNiKG51bGwsIHRydWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgfSwgZnVuY3Rpb24gZmFpbHVyZShyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZhbHNlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBNYWtlIGEgcmVxdWVzdCBhbmQgZmV0Y2ggYWxsIHRoZSBhdmFpbGFibGUgZGF0YS4gR2l0aHViIHdpbGwgcGFnaW5hdGUgcmVzcG9uc2VzIHNvIGZvciBxdWVyaWVzXG4gICAgKiB0aGF0IG1pZ2h0IHNwYW4gbXVsdGlwbGUgcGFnZXMgdGhpcyBtZXRob2QgaXMgcHJlZmVycmVkIHRvIHtAbGluayBSZXF1ZXN0YWJsZSNyZXF1ZXN0fVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0byByZXF1ZXN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgZnVuY3Rpb24gdG8gcmVjZWl2ZSB0aGUgZGF0YS4gVGhlIHJldHVybmVkIGRhdGEgd2lsbCBhbHdheXMgYmUgYW4gYXJyYXkuXG4gICAgKiBAcGFyYW0ge09iamVjdFtdfSByZXN1bHRzIC0gdGhlIHBhcnRpYWwgcmVzdWx0cy4gVGhpcyBhcmd1bWVudCBpcyBpbnRlbmRlZCBmb3IgaW50ZXJhbCB1c2Ugb25seS5cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCBwYWdlcyBoYXZlIGJlZW4gZmV0Y2hlZFxuICAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIGZvbGRlZCBpbnRvIHtAbGluayBSZXF1ZXN0YWJsZSNfcmVxdWVzdH0gaW4gdGhlIDIuMCByZWxlYXNlLlxuICAgICovXG4gICBfcmVxdWVzdEFsbFBhZ2VzKHBhdGgsIG9wdGlvbnMsIGNiLCByZXN1bHRzKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHBhdGgsIG9wdGlvbnMpXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCB0aGlzR3JvdXA7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICB0aGlzR3JvdXAgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhLml0ZW1zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgIHRoaXNHcm91cCA9IHJlc3BvbnNlLmRhdGEuaXRlbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgY2Fubm90IGZpZ3VyZSBvdXQgaG93IHRvIGFwcGVuZCAke3Jlc3BvbnNlLmRhdGF9IHRvIHRoZSByZXN1bHQgc2V0YDtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHBhdGgsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi50aGlzR3JvdXApO1xuXG4gICAgICAgICAgICBjb25zdCBuZXh0VXJsID0gZ2V0TmV4dFBhZ2UocmVzcG9uc2UuaGVhZGVycy5saW5rKTtcbiAgICAgICAgICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgICAgICAgICBsb2coYGdldHRpbmcgbmV4dCBwYWdlOiAke25leHRVcmx9YCk7XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKG5leHRVcmwsIG9wdGlvbnMsIGNiLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICBjYihudWxsLCByZXN1bHRzLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXN1bHRzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgfSkuY2F0Y2goY2FsbGJhY2tFcnJvck9yVGhyb3coY2IsIHBhdGgpKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0YWJsZTtcblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gLy9cbi8vICBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgIC8vXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAvL1xuY29uc3QgTUVUSE9EU19XSVRIX05PX0JPRFkgPSBbJ0dFVCcsICdIRUFEJywgJ0RFTEVURSddO1xuZnVuY3Rpb24gbWV0aG9kSGFzTm9Cb2R5KG1ldGhvZCkge1xuICAgcmV0dXJuIE1FVEhPRFNfV0lUSF9OT19CT0RZLmluZGV4T2YobWV0aG9kKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRQYWdlKGxpbmtzSGVhZGVyID0gJycpIHtcbiAgIGNvbnN0IGxpbmtzID0gbGlua3NIZWFkZXIuc3BsaXQoL1xccyosXFxzKi8pOyAvLyBzcGxpdHMgYW5kIHN0cmlwcyB0aGUgdXJsc1xuICAgcmV0dXJuIGxpbmtzLnJlZHVjZShmdW5jdGlvbihuZXh0VXJsLCBsaW5rKSB7XG4gICAgICBpZiAobGluay5zZWFyY2goL3JlbD1cIm5leHRcIi8pICE9PSAtMSkge1xuICAgICAgICAgcmV0dXJuIChsaW5rLm1hdGNoKC88KC4qKT4vKSB8fCBbXSlbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0VXJsO1xuICAgfSwgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tFcnJvck9yVGhyb3coY2IsIHBhdGgpIHtcbiAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKG9iamVjdCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY29uZmlnJykpIHtcbiAgICAgICAgIGNvbnN0IHtyZXNwb25zZToge3N0YXR1cywgc3RhdHVzVGV4dH0sIGNvbmZpZzoge21ldGhvZCwgdXJsfX0gPSBvYmplY3Q7XG4gICAgICAgICBsZXQgbWVzc2FnZSA9IChgJHtzdGF0dXN9IGVycm9yIG1ha2luZyByZXF1ZXN0ICR7bWV0aG9kfSAke3VybH06IFwiJHtzdGF0dXNUZXh0fVwiYCk7XG4gICAgICAgICBlcnJvciA9IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHBhdGgsIG9iamVjdCk7XG4gICAgICAgICBsb2coYCR7bWVzc2FnZX0gJHtKU09OLnN0cmluZ2lmeShvYmplY3QuZGF0YSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgZXJyb3IgPSBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgIGxvZygnZ29pbmcgdG8gZXJyb3IgY2FsbGJhY2snKTtcbiAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBsb2coJ3Rocm93aW5nIGVycm9yJyk7XG4gICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgIH07XG59XG4iXX0=
	//# sourceMappingURL=Requestable.js.map


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);
	var bind = __webpack_require__(9);
	var Axios = __webpack_require__(10);
	var defaults = __webpack_require__(11);

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(29);
	axios.CancelToken = __webpack_require__(30);
	axios.isCancel = __webpack_require__(26);

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(31);

	module.exports = axios;

	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bind = __webpack_require__(9);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(11);
	var utils = __webpack_require__(8);
	var InterceptorManager = __webpack_require__(23);
	var dispatchRequest = __webpack_require__(24);
	var isAbsoluteURL = __webpack_require__(27);
	var combineURLs = __webpack_require__(28);

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }

	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	module.exports = Axios;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(8);
	var normalizeHeaderName = __webpack_require__(13);

	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(14);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(14);
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	module.exports = defaults;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(8);
	var settle = __webpack_require__(15);
	var buildURL = __webpack_require__(18);
	var parseHeaders = __webpack_require__(19);
	var isURLSameOrigin = __webpack_require__(20);
	var createError = __webpack_require__(16);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(21);

	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;

	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(22);

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var createError = __webpack_require__(16);

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response
	    ));
	  }
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var enhanceError = __webpack_require__(17);

	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }

	      if (!utils.isArray(val)) {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;

	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));

	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }

	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }

	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }

	        if (secure === true) {
	          cookie.push('secure');
	        }

	        document.cookie = cookie.join('; ');
	      },

	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },

	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	module.exports = InterceptorManager;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);
	var transformData = __webpack_require__(25);
	var isCancel = __webpack_require__(26);
	var defaults = __webpack_require__(11);

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(8);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	module.exports = Cancel;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Cancel = __webpack_require__(29);

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	module.exports = CancelToken;


/***/ },
/* 31 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(33);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
	    return true;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return;

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  try {
	    return exports.storage.debug;
	  } catch(e) {}

	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug.default = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(34);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0, i;

	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  return debug;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
	 *
	 *  Licensed under the MIT license.
	 *    http://opensource.org/licenses/mit-license
	 *
	 *  References:
	 *    http://en.wikipedia.org/wiki/Base64
	 */

	(function(global) {
	    'use strict';
	    // existing version for noConflict()
	    var _Base64 = global.Base64;
	    var version = "2.1.9";
	    // if node.js, we use Buffer
	    var buffer;
	    if (typeof module !== 'undefined' && module.exports) {
	        try {
	            buffer = __webpack_require__(36).Buffer;
	        } catch (err) {}
	    }
	    // constants
	    var b64chars
	        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    var b64tab = function(bin) {
	        var t = {};
	        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
	        return t;
	    }(b64chars);
	    var fromCharCode = String.fromCharCode;
	    // encoder stuff
	    var cb_utob = function(c) {
	        if (c.length < 2) {
	            var cc = c.charCodeAt(0);
	            return cc < 0x80 ? c
	                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
	                                + fromCharCode(0x80 | (cc & 0x3f)))
	                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
	                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                   + fromCharCode(0x80 | ( cc         & 0x3f)));
	        } else {
	            var cc = 0x10000
	                + (c.charCodeAt(0) - 0xD800) * 0x400
	                + (c.charCodeAt(1) - 0xDC00);
	            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
	                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
	                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                    + fromCharCode(0x80 | ( cc         & 0x3f)));
	        }
	    };
	    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	    var utob = function(u) {
	        return u.replace(re_utob, cb_utob);
	    };
	    var cb_encode = function(ccc) {
	        var padlen = [0, 2, 1][ccc.length % 3],
	        ord = ccc.charCodeAt(0) << 16
	            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
	            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
	        chars = [
	            b64chars.charAt( ord >>> 18),
	            b64chars.charAt((ord >>> 12) & 63),
	            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	        ];
	        return chars.join('');
	    };
	    var btoa = global.btoa ? function(b) {
	        return global.btoa(b);
	    } : function(b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };
	    var _encode = buffer ? function (u) {
	        return (u.constructor === buffer.constructor ? u : new buffer(u))
	        .toString('base64')
	    }
	    : function (u) { return btoa(utob(u)) }
	    ;
	    var encode = function(u, urisafe) {
	        return !urisafe
	            ? _encode(String(u))
	            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
	                return m0 == '+' ? '-' : '_';
	            }).replace(/=/g, '');
	    };
	    var encodeURI = function(u) { return encode(u, true) };
	    // decoder stuff
	    var re_btou = new RegExp([
	        '[\xC0-\xDF][\x80-\xBF]',
	        '[\xE0-\xEF][\x80-\xBF]{2}',
	        '[\xF0-\xF7][\x80-\xBF]{3}'
	    ].join('|'), 'g');
	    var cb_btou = function(cccc) {
	        switch(cccc.length) {
	        case 4:
	            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
	                |    ((0x3f & cccc.charCodeAt(1)) << 12)
	                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
	                |     (0x3f & cccc.charCodeAt(3)),
	            offset = cp - 0x10000;
	            return (fromCharCode((offset  >>> 10) + 0xD800)
	                    + fromCharCode((offset & 0x3FF) + 0xDC00));
	        case 3:
	            return fromCharCode(
	                ((0x0f & cccc.charCodeAt(0)) << 12)
	                    | ((0x3f & cccc.charCodeAt(1)) << 6)
	                    |  (0x3f & cccc.charCodeAt(2))
	            );
	        default:
	            return  fromCharCode(
	                ((0x1f & cccc.charCodeAt(0)) << 6)
	                    |  (0x3f & cccc.charCodeAt(1))
	            );
	        }
	    };
	    var btou = function(b) {
	        return b.replace(re_btou, cb_btou);
	    };
	    var cb_decode = function(cccc) {
	        var len = cccc.length,
	        padlen = len % 4,
	        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
	            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
	            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
	            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
	        chars = [
	            fromCharCode( n >>> 16),
	            fromCharCode((n >>>  8) & 0xff),
	            fromCharCode( n         & 0xff)
	        ];
	        chars.length -= [0, 0, 2, 1][padlen];
	        return chars.join('');
	    };
	    var atob = global.atob ? function(a) {
	        return global.atob(a);
	    } : function(a){
	        return a.replace(/[\s\S]{1,4}/g, cb_decode);
	    };
	    var _decode = buffer ? function(a) {
	        return (a.constructor === buffer.constructor
	                ? a : new buffer(a, 'base64')).toString();
	    }
	    : function(a) { return btou(atob(a)) };
	    var decode = function(a){
	        return _decode(
	            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
	                .replace(/[^A-Za-z0-9\+\/]/g, '')
	        );
	    };
	    var noConflict = function() {
	        var Base64 = global.Base64;
	        global.Base64 = _Base64;
	        return Base64;
	    };
	    // export Base64
	    global.Base64 = {
	        VERSION: version,
	        atob: atob,
	        btoa: btoa,
	        fromBase64: decode,
	        toBase64: encode,
	        utob: utob,
	        encode: encode,
	        encodeURI: encodeURI,
	        btou: btou,
	        decode: decode,
	        noConflict: noConflict
	    };
	    // if ES5 is available, make Base64.extendString() available
	    if (typeof Object.defineProperty === 'function') {
	        var noEnum = function(v){
	            return {value:v,enumerable:false,writable:true,configurable:true};
	        };
	        global.Base64.extendString = function () {
	            Object.defineProperty(
	                String.prototype, 'fromBase64', noEnum(function () {
	                    return decode(this)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64', noEnum(function (urisafe) {
	                    return encode(this, urisafe)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64URI', noEnum(function () {
	                    return encode(this, true)
	                }));
	        };
	    }
	    // that's it!
	    if (global['Meteor']) {
	       Base64 = global.Base64; // for normal export in Meteor.js
	    }
	})(this);


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(37)
	var ieee754 = __webpack_require__(38)
	var isArray = __webpack_require__(39)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 39 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(32);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:user');

	/**
	 * A User allows scoping of API requests to a particular Github user.
	 */

	var User = function (_Requestable) {
	   _inherits(User, _Requestable);

	   /**
	    * Create a User.
	    * @param {string} [username] - the user to use for user-scoped queries
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function User(username, auth, apiBase) {
	      _classCallCheck(this, User);

	      var _this = _possibleConstructorReturn(this, (User.__proto__ || Object.getPrototypeOf(User)).call(this, auth, apiBase));

	      _this.__user = username;
	      return _this;
	   }

	   /**
	    * Get the url for the request. (dependent on if we're requesting for the authenticated user or not)
	    * @private
	    * @param {string} endpoint - the endpoint being requested
	    * @return {string} - the resolved endpoint
	    */


	   _createClass(User, [{
	      key: '__getScopedUrl',
	      value: function __getScopedUrl(endpoint) {
	         if (this.__user) {
	            return endpoint ? '/users/' + this.__user + '/' + endpoint : '/users/' + this.__user;
	         } else {
	            // eslint-disable-line
	            switch (endpoint) {
	               case '':
	                  return '/user';

	               case 'notifications':
	               case 'gists':
	                  return '/' + endpoint;

	               default:
	                  return '/user/' + endpoint;
	            }
	         }
	      }

	      /**
	       * List the user's repositories
	       * @see https://developer.github.com/v3/repos/#list-user-repositories
	       * @param {Object} [options={}] - any options to refine the search
	       * @param {Requestable.callback} [cb] - will receive the list of repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listRepos',
	      value: function listRepos(options, cb) {
	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }

	         options = this._getOptionsWithDefaults(options);

	         log('Fetching repositories with options: ' + JSON.stringify(options));
	         return this._requestAllPages(this.__getScopedUrl('repos'), options, cb);
	      }

	      /**
	       * List the orgs that the user belongs to
	       * @see https://developer.github.com/v3/orgs/#list-user-organizations
	       * @param {Requestable.callback} [cb] - will receive the list of organizations
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listOrgs',
	      value: function listOrgs(cb) {
	         return this._request('GET', this.__getScopedUrl('orgs'), null, cb);
	      }

	      /**
	       * List the user's gists
	       * @see https://developer.github.com/v3/gists/#list-a-users-gists
	       * @param {Requestable.callback} [cb] - will receive the list of gists
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listGists',
	      value: function listGists(cb) {
	         return this._request('GET', this.__getScopedUrl('gists'), null, cb);
	      }

	      /**
	       * List the user's notifications
	       * @see https://developer.github.com/v3/activity/notifications/#list-your-notifications
	       * @param {Object} [options={}] - any options to refine the search
	       * @param {Requestable.callback} [cb] - will receive the list of repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listNotifications',
	      value: function listNotifications(options, cb) {
	         options = options || {};
	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }

	         options.since = this._dateToISO(options.since);
	         options.before = this._dateToISO(options.before);

	         return this._request('GET', this.__getScopedUrl('notifications'), options, cb);
	      }

	      /**
	       * Show the user's profile
	       * @see https://developer.github.com/v3/users/#get-a-single-user
	       * @param {Requestable.callback} [cb] - will receive the user's information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getProfile',
	      value: function getProfile(cb) {
	         return this._request('GET', this.__getScopedUrl(''), null, cb);
	      }

	      /**
	       * Gets the list of starred repositories for the user
	       * @see https://developer.github.com/v3/activity/starring/#list-repositories-being-starred
	       * @param {Requestable.callback} [cb] - will receive the list of starred repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listStarredRepos',
	      value: function listStarredRepos(cb) {
	         var requestOptions = this._getOptionsWithDefaults();
	         return this._requestAllPages(this.__getScopedUrl('starred'), requestOptions, cb);
	      }

	      /**
	       * List email addresses for a user
	       * @see https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
	       * @param {Requestable.callback} [cb] - will receive the list of emails
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getEmails',
	      value: function getEmails(cb) {
	         return this._request('GET', '/user/emails', null, cb);
	      }

	      /**
	       * Have the authenticated user follow this user
	       * @see https://developer.github.com/v3/users/followers/#follow-a-user
	       * @param {string} username - the user to follow
	       * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'follow',
	      value: function follow(username, cb) {
	         return this._request('PUT', '/user/following/' + this.__user, null, cb);
	      }

	      /**
	       * Have the currently authenticated user unfollow this user
	       * @see https://developer.github.com/v3/users/followers/#follow-a-user
	       * @param {string} username - the user to unfollow
	       * @param {Requestable.callback} [cb] - receives true if the request succeeds
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'unfollow',
	      value: function unfollow(username, cb) {
	         return this._request('DELETE', '/user/following/' + this.__user, null, cb);
	      }

	      /**
	       * Create a new repository for the currently authenticated user
	       * @see https://developer.github.com/v3/repos/#create
	       * @param {object} options - the repository definition
	       * @param {Requestable.callback} [cb] - will receive the API response
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRepo',
	      value: function createRepo(options, cb) {
	         return this._request('POST', '/user/repos', options, cb);
	      }
	   }]);

	   return User;
	}(_Requestable3.default);

	module.exports = User;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlVzZXIuanMiXSwibmFtZXMiOlsibG9nIiwiVXNlciIsInVzZXJuYW1lIiwiYXV0aCIsImFwaUJhc2UiLCJfX3VzZXIiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJjYiIsIl9nZXRPcHRpb25zV2l0aERlZmF1bHRzIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJfX2dldFNjb3BlZFVybCIsIl9yZXF1ZXN0Iiwic2luY2UiLCJfZGF0ZVRvSVNPIiwiYmVmb3JlIiwicmVxdWVzdE9wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7OztBQVNBLElBQU1BLE1BQU0scUJBQU0sYUFBTixDQUFaOztBQUVBOzs7O0lBR01DLEk7OztBQUNIOzs7Ozs7QUFNQSxpQkFBWUMsUUFBWixFQUFzQkMsSUFBdEIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQUE7O0FBQUEsOEdBQzVCRCxJQUQ0QixFQUN0QkMsT0FEc0I7O0FBRWxDLFlBQUtDLE1BQUwsR0FBY0gsUUFBZDtBQUZrQztBQUdwQzs7QUFFRDs7Ozs7Ozs7OztxQ0FNZUksUSxFQUFVO0FBQ3RCLGFBQUksS0FBS0QsTUFBVCxFQUFpQjtBQUNkLG1CQUFPQyx1QkFDTSxLQUFLRCxNQURYLFNBQ3FCQyxRQURyQixlQUVNLEtBQUtELE1BRmxCO0FBS0YsVUFORCxNQU1PO0FBQUU7QUFDTixvQkFBUUMsUUFBUjtBQUNHLG9CQUFLLEVBQUw7QUFDRyx5QkFBTyxPQUFQOztBQUVILG9CQUFLLGVBQUw7QUFDQSxvQkFBSyxPQUFMO0FBQ0csK0JBQVdBLFFBQVg7O0FBRUg7QUFDRyxvQ0FBZ0JBLFFBQWhCO0FBVE47QUFXRjtBQUNIOztBQUVEOzs7Ozs7Ozs7O2dDQU9VQyxPLEVBQVNDLEUsRUFBSTtBQUNwQixhQUFJLE9BQU9ELE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDaENDLGlCQUFLRCxPQUFMO0FBQ0FBLHNCQUFVLEVBQVY7QUFDRjs7QUFFREEsbUJBQVUsS0FBS0UsdUJBQUwsQ0FBNkJGLE9BQTdCLENBQVY7O0FBRUFQLHNEQUEyQ1UsS0FBS0MsU0FBTCxDQUFlSixPQUFmLENBQTNDO0FBQ0EsZ0JBQU8sS0FBS0ssZ0JBQUwsQ0FBc0IsS0FBS0MsY0FBTCxDQUFvQixPQUFwQixDQUF0QixFQUFvRE4sT0FBcEQsRUFBNkRDLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OytCQU1TQSxFLEVBQUk7QUFDVixnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCxFQUFxQixLQUFLRCxjQUFMLENBQW9CLE1BQXBCLENBQXJCLEVBQWtELElBQWxELEVBQXdETCxFQUF4RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS00sUUFBTCxDQUFjLEtBQWQsRUFBcUIsS0FBS0QsY0FBTCxDQUFvQixPQUFwQixDQUFyQixFQUFtRCxJQUFuRCxFQUF5REwsRUFBekQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQkQsTyxFQUFTQyxFLEVBQUk7QUFDNUJELG1CQUFVQSxXQUFXLEVBQXJCO0FBQ0EsYUFBSSxPQUFPQSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2hDQyxpQkFBS0QsT0FBTDtBQUNBQSxzQkFBVSxFQUFWO0FBQ0Y7O0FBRURBLGlCQUFRUSxLQUFSLEdBQWdCLEtBQUtDLFVBQUwsQ0FBZ0JULFFBQVFRLEtBQXhCLENBQWhCO0FBQ0FSLGlCQUFRVSxNQUFSLEdBQWlCLEtBQUtELFVBQUwsQ0FBZ0JULFFBQVFVLE1BQXhCLENBQWpCOztBQUVBLGdCQUFPLEtBQUtILFFBQUwsQ0FBYyxLQUFkLEVBQXFCLEtBQUtELGNBQUwsQ0FBb0IsZUFBcEIsQ0FBckIsRUFBMkROLE9BQTNELEVBQW9FQyxFQUFwRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztpQ0FNV0EsRSxFQUFJO0FBQ1osZ0JBQU8sS0FBS00sUUFBTCxDQUFjLEtBQWQsRUFBcUIsS0FBS0QsY0FBTCxDQUFvQixFQUFwQixDQUFyQixFQUE4QyxJQUE5QyxFQUFvREwsRUFBcEQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7dUNBTWlCQSxFLEVBQUk7QUFDbEIsYUFBSVUsaUJBQWlCLEtBQUtULHVCQUFMLEVBQXJCO0FBQ0EsZ0JBQU8sS0FBS0csZ0JBQUwsQ0FBc0IsS0FBS0MsY0FBTCxDQUFvQixTQUFwQixDQUF0QixFQUFzREssY0FBdEQsRUFBc0VWLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O2dDQU1VQSxFLEVBQUk7QUFDWCxnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCxFQUFxQixjQUFyQixFQUFxQyxJQUFyQyxFQUEyQ04sRUFBM0MsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzZCQU9PTixRLEVBQVVNLEUsRUFBSTtBQUNsQixnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCx1QkFBd0MsS0FBS1QsTUFBN0MsRUFBdUQsSUFBdkQsRUFBNkRHLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzsrQkFPU04sUSxFQUFVTSxFLEVBQUk7QUFDcEIsZ0JBQU8sS0FBS00sUUFBTCxDQUFjLFFBQWQsdUJBQTJDLEtBQUtULE1BQWhELEVBQTBELElBQTFELEVBQWdFRyxFQUFoRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT1dELE8sRUFBU0MsRSxFQUFJO0FBQ3JCLGdCQUFPLEtBQUtNLFFBQUwsQ0FBYyxNQUFkLEVBQXNCLGFBQXRCLEVBQXFDUCxPQUFyQyxFQUE4Q0MsRUFBOUMsQ0FBUDtBQUNGOzs7Ozs7QUFHSlcsT0FBT0MsT0FBUCxHQUFpQm5CLElBQWpCIiwiZmlsZSI6IlVzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5jb25zdCBsb2cgPSBkZWJ1ZygnZ2l0aHViOnVzZXInKTtcblxuLyoqXG4gKiBBIFVzZXIgYWxsb3dzIHNjb3Bpbmcgb2YgQVBJIHJlcXVlc3RzIHRvIGEgcGFydGljdWxhciBHaXRodWIgdXNlci5cbiAqL1xuY2xhc3MgVXNlciBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgVXNlci5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcm5hbWVdIC0gdGhlIHVzZXIgdG8gdXNlIGZvciB1c2VyLXNjb3BlZCBxdWVyaWVzXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IFthdXRoXSAtIGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvIGF1dGhlbnRpY2F0ZSB0byBHaXRodWJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKHVzZXJuYW1lLCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX191c2VyID0gdXNlcm5hbWU7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSB1cmwgZm9yIHRoZSByZXF1ZXN0LiAoZGVwZW5kZW50IG9uIGlmIHdlJ3JlIHJlcXVlc3RpbmcgZm9yIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgb3Igbm90KVxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIHRoZSBlbmRwb2ludCBiZWluZyByZXF1ZXN0ZWRcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gLSB0aGUgcmVzb2x2ZWQgZW5kcG9pbnRcbiAgICAqL1xuICAgX19nZXRTY29wZWRVcmwoZW5kcG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLl9fdXNlcikge1xuICAgICAgICAgcmV0dXJuIGVuZHBvaW50ID9cbiAgICAgICAgICAgIGAvdXNlcnMvJHt0aGlzLl9fdXNlcn0vJHtlbmRwb2ludH1gIDpcbiAgICAgICAgICAgIGAvdXNlcnMvJHt0aGlzLl9fdXNlcn1gXG4gICAgICAgICAgICA7XG5cbiAgICAgIH0gZWxzZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgIHN3aXRjaCAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICByZXR1cm4gJy91c2VyJztcblxuICAgICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9ucyc6XG4gICAgICAgICAgICBjYXNlICdnaXN0cyc6XG4gICAgICAgICAgICAgICByZXR1cm4gYC8ke2VuZHBvaW50fWA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICByZXR1cm4gYC91c2VyLyR7ZW5kcG9pbnR9YDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSB1c2VyJ3MgcmVwb3NpdG9yaWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2xpc3QtdXNlci1yZXBvc2l0b3JpZXNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBhbnkgb3B0aW9ucyB0byByZWZpbmUgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFJlcG9zKG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG5cbiAgICAgIGxvZyhgRmV0Y2hpbmcgcmVwb3NpdG9yaWVzIHdpdGggb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXModGhpcy5fX2dldFNjb3BlZFVybCgncmVwb3MnKSwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIG9yZ3MgdGhhdCB0aGUgdXNlciBiZWxvbmdzIHRvXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy8jbGlzdC11c2VyLW9yZ2FuaXphdGlvbnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygb3JnYW5pemF0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0T3JncyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHRoaXMuX19nZXRTY29wZWRVcmwoJ29yZ3MnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXIncyBnaXN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNsaXN0LWEtdXNlcnMtZ2lzdHNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgZ2lzdHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdEdpc3RzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdGhpcy5fX2dldFNjb3BlZFVybCgnZ2lzdHMnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXIncyBub3RpZmljYXRpb25zXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvYWN0aXZpdHkvbm90aWZpY2F0aW9ucy8jbGlzdC15b3VyLW5vdGlmaWNhdGlvbnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBhbnkgb3B0aW9ucyB0byByZWZpbmUgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdE5vdGlmaWNhdGlvbnMob3B0aW9ucywgY2IpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuc2luY2UgPSB0aGlzLl9kYXRlVG9JU08ob3B0aW9ucy5zaW5jZSk7XG4gICAgICBvcHRpb25zLmJlZm9yZSA9IHRoaXMuX2RhdGVUb0lTTyhvcHRpb25zLmJlZm9yZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB0aGlzLl9fZ2V0U2NvcGVkVXJsKCdub3RpZmljYXRpb25zJyksIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTaG93IHRoZSB1c2VyJ3MgcHJvZmlsZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzLyNnZXQtYS1zaW5nbGUtdXNlclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXNlcidzIGluZm9ybWF0aW9uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFByb2ZpbGUoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB0aGlzLl9fZ2V0U2NvcGVkVXJsKCcnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygc3RhcnJlZCByZXBvc2l0b3JpZXMgZm9yIHRoZSB1c2VyXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvYWN0aXZpdHkvc3RhcnJpbmcvI2xpc3QtcmVwb3NpdG9yaWVzLWJlaW5nLXN0YXJyZWRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygc3RhcnJlZCByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFN0YXJyZWRSZXBvcyhjYikge1xuICAgICAgbGV0IHJlcXVlc3RPcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cygpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyh0aGlzLl9fZ2V0U2NvcGVkVXJsKCdzdGFycmVkJyksIHJlcXVlc3RPcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCBlbWFpbCBhZGRyZXNzZXMgZm9yIGEgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzL2VtYWlscy8jbGlzdC1lbWFpbC1hZGRyZXNzZXMtZm9yLWEtdXNlclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBlbWFpbHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0RW1haWxzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgJy91c2VyL2VtYWlscycsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBIYXZlIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgZm9sbG93IHRoaXMgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzL2ZvbGxvd2Vycy8jZm9sbG93LWEtdXNlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIC0gdGhlIHVzZXIgdG8gZm9sbG93XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9sbG93KHVzZXJuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BVVCcsIGAvdXNlci9mb2xsb3dpbmcvJHt0aGlzLl9fdXNlcn1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGF2ZSB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciB1bmZvbGxvdyB0aGlzIHVzZXJcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My91c2Vycy9mb2xsb3dlcnMvI2ZvbGxvdy1hLXVzZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIHRvIHVuZm9sbG93XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gcmVjZWl2ZXMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bmZvbGxvdyh1c2VybmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3VzZXIvZm9sbG93aW5nLyR7dGhpcy5fX3VzZXJ9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyByZXBvc2l0b3J5IGZvciB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNjcmVhdGVcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIHJlcG9zaXRvcnkgZGVmaW5pdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgQVBJIHJlc3BvbnNlXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZVJlcG8ob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgJy91c2VyL3JlcG9zJywgb3B0aW9ucywgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG4iXX0=
	//# sourceMappingURL=User.js.map


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Issue wraps the functionality to get issues for repositories
	 */
	var Issue = function (_Requestable) {
	  _inherits(Issue, _Requestable);

	  /**
	   * Create a new Issue
	   * @param {string} repository - the full name of the repository (`:user/:repo`) to get issues for
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Issue(repository, auth, apiBase) {
	    _classCallCheck(this, Issue);

	    var _this = _possibleConstructorReturn(this, (Issue.__proto__ || Object.getPrototypeOf(Issue)).call(this, auth, apiBase));

	    _this.__repository = repository;
	    return _this;
	  }

	  /**
	   * Create a new issue
	   * @see https://developer.github.com/v3/issues/#create-an-issue
	   * @param {Object} issueData - the issue to create
	   * @param {Requestable.callback} [cb] - will receive the created issue
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Issue, [{
	    key: 'createIssue',
	    value: function createIssue(issueData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/issues', issueData, cb);
	    }

	    /**
	     * List the issues for the repository
	     * @see https://developer.github.com/v3/issues/#list-issues-for-a-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of issues
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssues',
	    value: function listIssues(options, cb) {
	      return this._requestAllPages('/repos/' + this.__repository + '/issues', options, cb);
	    }

	    /**
	     * List the events for an issue
	     * @see https://developer.github.com/v3/issues/events/#list-events-for-an-issue
	     * @param {number} issue - the issue to get events for
	     * @param {Requestable.callback} [cb] - will receive the list of events
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssueEvents',
	    value: function listIssueEvents(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/events', null, cb);
	    }

	    /**
	     * List comments on an issue
	     * @see https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
	     * @param {number} issue - the id of the issue to get comments from
	     * @param {Requestable.callback} [cb] - will receive the comments
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssueComments',
	    value: function listIssueComments(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/comments', null, cb);
	    }

	    /**
	     * Get a single comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#get-a-single-comment
	     * @param {number} id - the comment id to get
	     * @param {Requestable.callback} [cb] - will receive the comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getIssueComment',
	    value: function getIssueComment(id, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb);
	    }

	    /**
	     * Comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#create-a-comment
	     * @param {number} issue - the id of the issue to comment on
	     * @param {string} comment - the comment to add
	     * @param {Requestable.callback} [cb] - will receive the created comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createIssueComment',
	    value: function createIssueComment(issue, comment, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/issues/' + issue + '/comments', { body: comment }, cb);
	    }

	    /**
	     * Edit a comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#edit-a-comment
	     * @param {number} id - the comment id to edit
	     * @param {string} comment - the comment to edit
	     * @param {Requestable.callback} [cb] - will receive the edited comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editIssueComment',
	    value: function editIssueComment(id, comment, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/issues/comments/' + id, { body: comment }, cb);
	    }

	    /**
	     * Delete a comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#delete-a-comment
	     * @param {number} id - the comment id to delete
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteIssueComment',
	    value: function deleteIssueComment(id, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb);
	    }

	    /**
	     * Edit an issue
	     * @see https://developer.github.com/v3/issues/#edit-an-issue
	     * @param {number} issue - the issue number to edit
	     * @param {Object} issueData - the new issue data
	     * @param {Requestable.callback} [cb] - will receive the modified issue
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editIssue',
	    value: function editIssue(issue, issueData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/issues/' + issue, issueData, cb);
	    }

	    /**
	     * Get a particular issue
	     * @see https://developer.github.com/v3/issues/#get-a-single-issue
	     * @param {number} issue - the issue number to fetch
	     * @param {Requestable.callback} [cb] - will receive the issue
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getIssue',
	    value: function getIssue(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue, null, cb);
	    }

	    /**
	     * List the milestones for the repository
	     * @see https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of milestones
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMilestones',
	    value: function listMilestones(options, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/milestones', options, cb);
	    }

	    /**
	     * Get a milestone
	     * @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
	     * @param {string} milestone - the id of the milestone to fetch
	     * @param {Requestable.callback} [cb] - will receive the milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getMilestone',
	    value: function getMilestone(milestone, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb);
	    }

	    /**
	     * Create a new milestone
	     * @see https://developer.github.com/v3/issues/milestones/#create-a-milestone
	     * @param {Object} milestoneData - the milestone definition
	     * @param {Requestable.callback} [cb] - will receive the milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createMilestone',
	    value: function createMilestone(milestoneData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/milestones', milestoneData, cb);
	    }

	    /**
	     * Edit a milestone
	     * @see https://developer.github.com/v3/issues/milestones/#update-a-milestone
	     * @param {string} milestone - the id of the milestone to edit
	     * @param {Object} milestoneData - the updates to make to the milestone
	     * @param {Requestable.callback} [cb] - will receive the updated milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editMilestone',
	    value: function editMilestone(milestone, milestoneData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/milestones/' + milestone, milestoneData, cb);
	    }

	    /**
	     * Delete a milestone (this is distinct from closing a milestone)
	     * @see https://developer.github.com/v3/issues/milestones/#delete-a-milestone
	     * @param {string} milestone - the id of the milestone to delete
	     * @param {Requestable.callback} [cb] - will receive the status
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteMilestone',
	    value: function deleteMilestone(milestone, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb);
	    }

	    /**
	     * Create a new label
	     * @see https://developer.github.com/v3/issues/labels/#create-a-label
	     * @param {Object} labelData - the label definition
	     * @param {Requestable.callback} [cb] - will receive the object representing the label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createLabel',
	    value: function createLabel(labelData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/labels', labelData, cb);
	    }

	    /**
	     * List the labels for the repository
	     * @see https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of labels
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listLabels',
	    value: function listLabels(options, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/labels', options, cb);
	    }

	    /**
	     * Get a label
	     * @see https://developer.github.com/v3/issues/labels/#get-a-single-label
	     * @param {string} label - the name of the label to fetch
	     * @param {Requestable.callback} [cb] - will receive the label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getLabel',
	    value: function getLabel(label, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/labels/' + label, null, cb);
	    }

	    /**
	     * Edit a label
	     * @see https://developer.github.com/v3/issues/labels/#update-a-label
	     * @param {string} label - the name of the label to edit
	     * @param {Object} labelData - the updates to make to the label
	     * @param {Requestable.callback} [cb] - will receive the updated label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editLabel',
	    value: function editLabel(label, labelData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/labels/' + label, labelData, cb);
	    }

	    /**
	     * Delete a label
	     * @see https://developer.github.com/v3/issues/labels/#delete-a-label
	     * @param {string} label - the name of the label to delete
	     * @param {Requestable.callback} [cb] - will receive the status
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteLabel',
	    value: function deleteLabel(label, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/labels/' + label, null, cb);
	    }
	  }]);

	  return Issue;
	}(_Requestable3.default);

	module.exports = Issue;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIklzc3VlLmpzIl0sIm5hbWVzIjpbIklzc3VlIiwicmVwb3NpdG9yeSIsImF1dGgiLCJhcGlCYXNlIiwiX19yZXBvc2l0b3J5IiwiaXNzdWVEYXRhIiwiY2IiLCJfcmVxdWVzdCIsIm9wdGlvbnMiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiaXNzdWUiLCJpZCIsImNvbW1lbnQiLCJib2R5IiwibWlsZXN0b25lIiwibWlsZXN0b25lRGF0YSIsImxhYmVsRGF0YSIsImxhYmVsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BOzs7Ozs7Ozs7OytlQVBBOzs7Ozs7O0FBU0E7OztJQUdNQSxLOzs7QUFDSDs7Ozs7O0FBTUEsaUJBQVlDLFVBQVosRUFBd0JDLElBQXhCLEVBQThCQyxPQUE5QixFQUF1QztBQUFBOztBQUFBLDhHQUM5QkQsSUFEOEIsRUFDeEJDLE9BRHdCOztBQUVwQyxVQUFLQyxZQUFMLEdBQW9CSCxVQUFwQjtBQUZvQztBQUd0Qzs7QUFFRDs7Ozs7Ozs7Ozs7Z0NBT1lJLFMsRUFBV0MsRSxFQUFJO0FBQ3hCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS0gsWUFBckMsY0FBNERDLFNBQTVELEVBQXVFQyxFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7K0JBT1dFLE8sRUFBU0YsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0csZ0JBQUwsYUFBZ0MsS0FBS0wsWUFBckMsY0FBNERJLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7b0NBT2dCSSxLLEVBQU9KLEUsRUFBSTtBQUN4QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtILFlBQXBDLGdCQUEyRE0sS0FBM0QsY0FBMkUsSUFBM0UsRUFBaUZKLEVBQWpGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztzQ0FPa0JJLEssRUFBT0osRSxFQUFJO0FBQzFCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMsZ0JBQTJETSxLQUEzRCxnQkFBNkUsSUFBN0UsRUFBbUZKLEVBQW5GLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JLLEUsRUFBSUwsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMseUJBQW9FTyxFQUFwRSxFQUEwRSxJQUExRSxFQUFnRkwsRUFBaEYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRbUJJLEssRUFBT0UsTyxFQUFTTixFLEVBQUk7QUFDcEMsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLSCxZQUFyQyxnQkFBNERNLEtBQTVELGdCQUE4RSxFQUFDRyxNQUFNRCxPQUFQLEVBQTlFLEVBQStGTixFQUEvRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O3FDQVFpQkssRSxFQUFJQyxPLEVBQVNOLEUsRUFBSTtBQUMvQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtILFlBQXRDLHlCQUFzRU8sRUFBdEUsRUFBNEUsRUFBQ0UsTUFBTUQsT0FBUCxFQUE1RSxFQUE2Rk4sRUFBN0YsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3VDQU9tQkssRSxFQUFJTCxFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLSCxZQUF2Qyx5QkFBdUVPLEVBQXZFLEVBQTZFLElBQTdFLEVBQW1GTCxFQUFuRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzhCQVFVSSxLLEVBQU9MLFMsRUFBV0MsRSxFQUFJO0FBQzdCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS0gsWUFBdEMsZ0JBQTZETSxLQUE3RCxFQUFzRUwsU0FBdEUsRUFBaUZDLEVBQWpGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs2QkFPU0ksSyxFQUFPSixFLEVBQUk7QUFDakIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxnQkFBMkRNLEtBQTNELEVBQW9FLElBQXBFLEVBQTBFSixFQUExRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7bUNBT2VFLE8sRUFBU0YsRSxFQUFJO0FBQ3pCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMsa0JBQStESSxPQUEvRCxFQUF3RUYsRUFBeEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9hUSxTLEVBQVdSLEUsRUFBSTtBQUN6QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtILFlBQXBDLG9CQUErRFUsU0FBL0QsRUFBNEUsSUFBNUUsRUFBa0ZSLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JTLGEsRUFBZVQsRSxFQUFJO0FBQ2hDLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS0gsWUFBckMsa0JBQWdFVyxhQUFoRSxFQUErRVQsRUFBL0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztrQ0FRY1EsUyxFQUFXQyxhLEVBQWVULEUsRUFBSTtBQUN6QyxhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtILFlBQXRDLG9CQUFpRVUsU0FBakUsRUFBOEVDLGFBQTlFLEVBQTZGVCxFQUE3RixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7b0NBT2dCUSxTLEVBQVdSLEUsRUFBSTtBQUM1QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtILFlBQXZDLG9CQUFrRVUsU0FBbEUsRUFBK0UsSUFBL0UsRUFBcUZSLEVBQXJGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPWVUsUyxFQUFXVixFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLSCxZQUFyQyxjQUE0RFksU0FBNUQsRUFBdUVWLEVBQXZFLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7OzsrQkFPWUUsTyxFQUFTRixFLEVBQUk7QUFDckIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxjQUEyREksT0FBM0QsRUFBb0VGLEVBQXBFLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7Ozs2QkFPVVcsSyxFQUFPWCxFLEVBQUk7QUFDakIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxnQkFBMkRhLEtBQTNELEVBQW9FLElBQXBFLEVBQTBFWCxFQUExRSxDQUFQO0FBQ0Y7O0FBRUY7Ozs7Ozs7Ozs7OzhCQVFXVyxLLEVBQU9ELFMsRUFBV1YsRSxFQUFJO0FBQzdCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS0gsWUFBdEMsZ0JBQTZEYSxLQUE3RCxFQUFzRUQsU0FBdEUsRUFBaUZWLEVBQWpGLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7OztnQ0FPYVcsSyxFQUFPWCxFLEVBQUk7QUFDcEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLSCxZQUF2QyxnQkFBOERhLEtBQTlELEVBQXVFLElBQXZFLEVBQTZFWCxFQUE3RSxDQUFQO0FBQ0Y7Ozs7OztBQUdKWSxPQUFPQyxPQUFQLEdBQWlCbkIsS0FBakIiLCJmaWxlIjoiSXNzdWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcblxuLyoqXG4gKiBJc3N1ZSB3cmFwcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBnZXQgaXNzdWVzIGZvciByZXBvc2l0b3JpZXNcbiAqL1xuY2xhc3MgSXNzdWUgZXh0ZW5kcyBSZXF1ZXN0YWJsZSB7XG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBJc3N1ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnkgLSB0aGUgZnVsbCBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IChgOnVzZXIvOnJlcG9gKSB0byBnZXQgaXNzdWVzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihyZXBvc2l0b3J5LCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX19yZXBvc2l0b3J5ID0gcmVwb3NpdG9yeTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgaXNzdWVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvI2NyZWF0ZS1hbi1pc3N1ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGlzc3VlRGF0YSAtIHRoZSBpc3N1ZSB0byBjcmVhdGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGNyZWF0ZWQgaXNzdWVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlSXNzdWUoaXNzdWVEYXRhLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlc2AsIGlzc3VlRGF0YSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGlzc3VlcyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvI2xpc3QtaXNzdWVzLWZvci1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZmlsdGVyaW5nIG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGFycmF5IG9mIGlzc3Vlc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0SXNzdWVzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGV2ZW50cyBmb3IgYW4gaXNzdWVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvZXZlbnRzLyNsaXN0LWV2ZW50cy1mb3ItYW4taXNzdWVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpc3N1ZSAtIHRoZSBpc3N1ZSB0byBnZXQgZXZlbnRzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBldmVudHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdElzc3VlRXZlbnRzKGlzc3VlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzLyR7aXNzdWV9L2V2ZW50c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IGNvbW1lbnRzIG9uIGFuIGlzc3VlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL2NvbW1lbnRzLyNsaXN0LWNvbW1lbnRzLW9uLWFuLWlzc3VlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaXNzdWUgLSB0aGUgaWQgb2YgdGhlIGlzc3VlIHRvIGdldCBjb21tZW50cyBmcm9tXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb21tZW50c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0SXNzdWVDb21tZW50cyhpc3N1ZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlcy8ke2lzc3VlfS9jb21tZW50c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBzaW5nbGUgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZ2V0LWEtc2luZ2xlLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBjb21tZW50IGlkIHRvIGdldFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWVudFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRJc3N1ZUNvbW1lbnQoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvY29tbWVudHMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jY3JlYXRlLWEtY29tbWVudFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlzc3VlIC0gdGhlIGlkIG9mIHRoZSBpc3N1ZSB0byBjb21tZW50IG9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudCAtIHRoZSBjb21tZW50IHRvIGFkZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgY3JlYXRlZCBjb21tZW50XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUlzc3VlQ29tbWVudChpc3N1ZSwgY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvJHtpc3N1ZX0vY29tbWVudHNgLCB7Ym9keTogY29tbWVudH0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGEgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZWRpdC1hLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBjb21tZW50IGlkIHRvIGVkaXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50IC0gdGhlIGNvbW1lbnQgdG8gZWRpdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgZWRpdGVkIGNvbW1lbnRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdElzc3VlQ29tbWVudChpZCwgY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzL2NvbW1lbnRzLyR7aWR9YCwge2JvZHk6IGNvbW1lbnR9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZGVsZXRlLWEtY29tbWVudFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gdGhlIGNvbW1lbnQgaWQgdG8gZGVsZXRlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVJc3N1ZUNvbW1lbnQoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvY29tbWVudHMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy8jZWRpdC1hbi1pc3N1ZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlzc3VlIC0gdGhlIGlzc3VlIG51bWJlciB0byBlZGl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gaXNzdWVEYXRhIC0gdGhlIG5ldyBpc3N1ZSBkYXRhXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBpc3N1ZVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBlZGl0SXNzdWUoaXNzdWUsIGlzc3VlRGF0YSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzLyR7aXNzdWV9YCwgaXNzdWVEYXRhLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgcGFydGljdWxhciBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy8jZ2V0LWEtc2luZ2xlLWlzc3VlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaXNzdWUgLSB0aGUgaXNzdWUgbnVtYmVyIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBpc3N1ZVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRJc3N1ZShpc3N1ZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlcy8ke2lzc3VlfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBtaWxlc3RvbmVzIGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9taWxlc3RvbmVzLyNsaXN0LW1pbGVzdG9uZXMtZm9yLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBmaWx0ZXJpbmcgb3B0aW9uc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgYXJyYXkgb2YgbWlsZXN0b25lc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0TWlsZXN0b25lcyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbWlsZXN0b25lc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBtaWxlc3RvbmVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbWlsZXN0b25lcy8jZ2V0LWEtc2luZ2xlLW1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbGVzdG9uZSAtIHRoZSBpZCBvZiB0aGUgbWlsZXN0b25lIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBtaWxlc3RvbmVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0TWlsZXN0b25lKG1pbGVzdG9uZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXMvJHttaWxlc3RvbmV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBtaWxlc3RvbmVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbWlsZXN0b25lcy8jY3JlYXRlLWEtbWlsZXN0b25lXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbWlsZXN0b25lRGF0YSAtIHRoZSBtaWxlc3RvbmUgZGVmaW5pdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWlsZXN0b25lXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZU1pbGVzdG9uZShtaWxlc3RvbmVEYXRhLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXNgLCBtaWxlc3RvbmVEYXRhLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIG1pbGVzdG9uZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9taWxlc3RvbmVzLyN1cGRhdGUtYS1taWxlc3RvbmVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaWxlc3RvbmUgLSB0aGUgaWQgb2YgdGhlIG1pbGVzdG9uZSB0byBlZGl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gbWlsZXN0b25lRGF0YSAtIHRoZSB1cGRhdGVzIHRvIG1ha2UgdG8gdGhlIG1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCBtaWxlc3RvbmVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdE1pbGVzdG9uZShtaWxlc3RvbmUsIG1pbGVzdG9uZURhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXMvJHttaWxlc3RvbmV9YCwgbWlsZXN0b25lRGF0YSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIG1pbGVzdG9uZSAodGhpcyBpcyBkaXN0aW5jdCBmcm9tIGNsb3NpbmcgYSBtaWxlc3RvbmUpXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL21pbGVzdG9uZXMvI2RlbGV0ZS1hLW1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbGVzdG9uZSAtIHRoZSBpZCBvZiB0aGUgbWlsZXN0b25lIHRvIGRlbGV0ZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgc3RhdHVzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZU1pbGVzdG9uZShtaWxlc3RvbmUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9taWxlc3RvbmVzLyR7bWlsZXN0b25lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgbGFiZWxcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyNjcmVhdGUtYS1sYWJlbFxuICAgICogQHBhcmFtIHtPYmplY3R9IGxhYmVsRGF0YSAtIHRoZSBsYWJlbCBkZWZpbml0aW9uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBsYWJlbFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVMYWJlbChsYWJlbERhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbGFiZWxzYCwgbGFiZWxEYXRhLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIGxhYmVscyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9sYWJlbHMvI2xpc3QtYWxsLWxhYmVscy1mb3ItdGhpcy1yZXBvc2l0b3J5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZmlsdGVyaW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgYXJyYXkgb2YgbGFiZWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBsaXN0TGFiZWxzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9sYWJlbHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxhYmVsXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyNnZXQtYS1zaW5nbGUtbGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gdGhlIG5hbWUgb2YgdGhlIGxhYmVsIHRvIGZldGNoXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxhYmVsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBnZXRMYWJlbChsYWJlbCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2xhYmVscy8ke2xhYmVsfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAvKipcbiAgICogRWRpdCBhIGxhYmVsXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyN1cGRhdGUtYS1sYWJlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgdG8gZWRpdFxuICAgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxEYXRhIC0gdGhlIHVwZGF0ZXMgdG8gbWFrZSB0byB0aGUgbGFiZWxcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCBsYWJlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgZWRpdExhYmVsKGxhYmVsLCBsYWJlbERhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2xhYmVscy8ke2xhYmVsfWAsIGxhYmVsRGF0YSwgY2IpO1xuICAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBsYWJlbFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL2xhYmVscy8jZGVsZXRlLWEtbGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gdGhlIG5hbWUgb2YgdGhlIGxhYmVsIHRvIGRlbGV0ZVxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBzdGF0dXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGRlbGV0ZUxhYmVsKGxhYmVsLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbGFiZWxzLyR7bGFiZWx9YCwgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElzc3VlO1xuIl19
	//# sourceMappingURL=Issue.js.map


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(32);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:search');

	/**
	 * Wrap the Search API
	 */

	var Search = function (_Requestable) {
	  _inherits(Search, _Requestable);

	  /**
	   * Create a Search
	   * @param {Object} defaults - defaults for the search
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Search(defaults, auth, apiBase) {
	    _classCallCheck(this, Search);

	    var _this = _possibleConstructorReturn(this, (Search.__proto__ || Object.getPrototypeOf(Search)).call(this, auth, apiBase));

	    _this.__defaults = _this._getOptionsWithDefaults(defaults);
	    return _this;
	  }

	  /**
	   * Available search options
	   * @see https://developer.github.com/v3/search/#parameters
	   * @typedef {Object} Search.Params
	   * @param {string} q - the query to make
	   * @param {string} sort - the sort field, one of `stars`, `forks`, or `updated`.
	   *                      Default is [best match](https://developer.github.com/v3/search/#ranking-search-results)
	   * @param {string} order - the ordering, either `asc` or `desc`
	   */
	  /**
	   * Perform a search on the GitHub API
	   * @private
	   * @param {string} path - the scope of the search
	   * @param {Search.Params} [withOptions] - additional parameters for the search
	   * @param {Requestable.callback} [cb] - will receive the results of the search
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Search, [{
	    key: '_search',
	    value: function _search(path) {
	      var _this2 = this;

	      var withOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

	      var requestOptions = {};
	      Object.keys(this.__defaults).forEach(function (prop) {
	        requestOptions[prop] = _this2.__defaults[prop];
	      });
	      Object.keys(withOptions).forEach(function (prop) {
	        requestOptions[prop] = withOptions[prop];
	      });

	      log('searching ' + path + ' with options:', requestOptions);
	      return this._requestAllPages('/search/' + path, requestOptions, cb);
	    }

	    /**
	     * Search for repositories
	     * @see https://developer.github.com/v3/search/#search-repositories
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forRepositories',
	    value: function forRepositories(options, cb) {
	      return this._search('repositories', options, cb);
	    }

	    /**
	     * Search for code
	     * @see https://developer.github.com/v3/search/#search-code
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forCode',
	    value: function forCode(options, cb) {
	      return this._search('code', options, cb);
	    }

	    /**
	     * Search for issues
	     * @see https://developer.github.com/v3/search/#search-issues
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forIssues',
	    value: function forIssues(options, cb) {
	      return this._search('issues', options, cb);
	    }

	    /**
	     * Search for users
	     * @see https://developer.github.com/v3/search/#search-users
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forUsers',
	    value: function forUsers(options, cb) {
	      return this._search('users', options, cb);
	    }
	  }]);

	  return Search;
	}(_Requestable3.default);

	module.exports = Search;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNlYXJjaC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJTZWFyY2giLCJkZWZhdWx0cyIsImF1dGgiLCJhcGlCYXNlIiwiX19kZWZhdWx0cyIsIl9nZXRPcHRpb25zV2l0aERlZmF1bHRzIiwicGF0aCIsIndpdGhPcHRpb25zIiwiY2IiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0T3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcCIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJvcHRpb25zIiwiX3NlYXJjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7Ozs7O0FBU0EsSUFBTUEsTUFBTSxxQkFBTSxlQUFOLENBQVo7O0FBRUE7Ozs7SUFHTUMsTTs7O0FBQ0g7Ozs7OztBQU1BLGtCQUFZQyxRQUFaLEVBQXNCQyxJQUF0QixFQUE0QkMsT0FBNUIsRUFBcUM7QUFBQTs7QUFBQSxnSEFDNUJELElBRDRCLEVBQ3RCQyxPQURzQjs7QUFFbEMsVUFBS0MsVUFBTCxHQUFrQixNQUFLQyx1QkFBTCxDQUE2QkosUUFBN0IsQ0FBbEI7QUFGa0M7QUFHcEM7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7NEJBUVFLLEksRUFBd0M7QUFBQTs7QUFBQSxVQUFsQ0MsV0FBa0MsdUVBQXBCLEVBQW9CO0FBQUEsVUFBaEJDLEVBQWdCLHVFQUFYQyxTQUFXOztBQUM3QyxVQUFJQyxpQkFBaUIsRUFBckI7QUFDQUMsYUFBT0MsSUFBUCxDQUFZLEtBQUtSLFVBQWpCLEVBQTZCUyxPQUE3QixDQUFxQyxVQUFDQyxJQUFELEVBQVU7QUFDNUNKLHVCQUFlSSxJQUFmLElBQXVCLE9BQUtWLFVBQUwsQ0FBZ0JVLElBQWhCLENBQXZCO0FBQ0YsT0FGRDtBQUdBSCxhQUFPQyxJQUFQLENBQVlMLFdBQVosRUFBeUJNLE9BQXpCLENBQWlDLFVBQUNDLElBQUQsRUFBVTtBQUN4Q0osdUJBQWVJLElBQWYsSUFBdUJQLFlBQVlPLElBQVosQ0FBdkI7QUFDRixPQUZEOztBQUlBZix5QkFBaUJPLElBQWpCLHFCQUF1Q0ksY0FBdkM7QUFDQSxhQUFPLEtBQUtLLGdCQUFMLGNBQWlDVCxJQUFqQyxFQUF5Q0ksY0FBekMsRUFBeURGLEVBQXpELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JRLE8sRUFBU1IsRSxFQUFJO0FBQzFCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLGNBQWIsRUFBNkJELE9BQTdCLEVBQXNDUixFQUF0QyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7NEJBT1FRLE8sRUFBU1IsRSxFQUFJO0FBQ2xCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLE1BQWIsRUFBcUJELE9BQXJCLEVBQThCUixFQUE5QixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OEJBT1VRLE8sRUFBU1IsRSxFQUFJO0FBQ3BCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLFFBQWIsRUFBdUJELE9BQXZCLEVBQWdDUixFQUFoQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7NkJBT1NRLE8sRUFBU1IsRSxFQUFJO0FBQ25CLGFBQU8sS0FBS1MsT0FBTCxDQUFhLE9BQWIsRUFBc0JELE9BQXRCLEVBQStCUixFQUEvQixDQUFQO0FBQ0Y7Ozs7OztBQUdKVSxPQUFPQyxPQUFQLEdBQWlCbkIsTUFBakIiLCJmaWxlIjoiU2VhcmNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuY29uc3QgbG9nID0gZGVidWcoJ2dpdGh1YjpzZWFyY2gnKTtcblxuLyoqXG4gKiBXcmFwIHRoZSBTZWFyY2ggQVBJXG4gKi9cbmNsYXNzIFNlYXJjaCBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgU2VhcmNoXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgLSBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihkZWZhdWx0cywgYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSk7XG4gICAgICB0aGlzLl9fZGVmYXVsdHMgPSB0aGlzLl9nZXRPcHRpb25zV2l0aERlZmF1bHRzKGRlZmF1bHRzKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBdmFpbGFibGUgc2VhcmNoIG9wdGlvbnNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3BhcmFtZXRlcnNcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNlYXJjaC5QYXJhbXNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBxIC0gdGhlIHF1ZXJ5IHRvIG1ha2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0IC0gdGhlIHNvcnQgZmllbGQsIG9uZSBvZiBgc3RhcnNgLCBgZm9ya3NgLCBvciBgdXBkYXRlZGAuXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIFtiZXN0IG1hdGNoXShodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3NlYXJjaC8jcmFua2luZy1zZWFyY2gtcmVzdWx0cylcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlciAtIHRoZSBvcmRlcmluZywgZWl0aGVyIGBhc2NgIG9yIGBkZXNjYFxuICAgICovXG4gICAvKipcbiAgICAqIFBlcmZvcm0gYSBzZWFyY2ggb24gdGhlIEdpdEh1YiBBUElcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoXG4gICAgKiBAcGFyYW0ge1NlYXJjaC5QYXJhbXN9IFt3aXRoT3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBfc2VhcmNoKHBhdGgsIHdpdGhPcHRpb25zID0ge30sIGNiID0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX19kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgcmVxdWVzdE9wdGlvbnNbcHJvcF0gPSB0aGlzLl9fZGVmYXVsdHNbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKHdpdGhPcHRpb25zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICByZXF1ZXN0T3B0aW9uc1twcm9wXSA9IHdpdGhPcHRpb25zW3Byb3BdO1xuICAgICAgfSk7XG5cbiAgICAgIGxvZyhgc2VhcmNoaW5nICR7cGF0aH0gd2l0aCBvcHRpb25zOmAsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9zZWFyY2gvJHtwYXRofWAsIHJlcXVlc3RPcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogU2VhcmNoIGZvciByZXBvc2l0b3JpZXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3NlYXJjaC1yZXBvc2l0b3JpZXNcbiAgICAqIEBwYXJhbSB7U2VhcmNoLlBhcmFtc30gW29wdGlvbnNdIC0gYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc2VhcmNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByZXN1bHRzIG9mIHRoZSBzZWFyY2hcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9yUmVwb3NpdG9yaWVzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKCdyZXBvc2l0b3JpZXMnLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogU2VhcmNoIGZvciBjb2RlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvc2VhcmNoLyNzZWFyY2gtY29kZVxuICAgICogQHBhcmFtIHtTZWFyY2guUGFyYW1zfSBbb3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JDb2RlKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKCdjb2RlJywgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNlYXJjaCBmb3IgaXNzdWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvc2VhcmNoLyNzZWFyY2gtaXNzdWVzXG4gICAgKiBAcGFyYW0ge1NlYXJjaC5QYXJhbXN9IFtvcHRpb25zXSAtIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0cyBvZiB0aGUgc2VhcmNoXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGZvcklzc3VlcyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCgnaXNzdWVzJywgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNlYXJjaCBmb3IgdXNlcnNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3NlYXJjaC11c2Vyc1xuICAgICogQHBhcmFtIHtTZWFyY2guUGFyYW1zfSBbb3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JVc2VycyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCgndXNlcnMnLCBvcHRpb25zLCBjYik7XG4gICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoO1xuIl19
	//# sourceMappingURL=Search.js.map


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * RateLimit allows users to query their rate-limit status
	 */
	var RateLimit = function (_Requestable) {
	  _inherits(RateLimit, _Requestable);

	  /**
	   * construct a RateLimit
	   * @param {Requestable.auth} auth - the credentials to authenticate to GitHub
	   * @param {string} [apiBase] - the base Github API URL
	   * @return {Promise} - the promise for the http request
	   */
	  function RateLimit(auth, apiBase) {
	    _classCallCheck(this, RateLimit);

	    return _possibleConstructorReturn(this, (RateLimit.__proto__ || Object.getPrototypeOf(RateLimit)).call(this, auth, apiBase));
	  }

	  /**
	   * Query the current rate limit
	   * @see https://developer.github.com/v3/rate_limit/
	   * @param {Requestable.callback} [cb] - will receive the rate-limit data
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(RateLimit, [{
	    key: 'getRateLimit',
	    value: function getRateLimit(cb) {
	      return this._request('GET', '/rate_limit', null, cb);
	    }
	  }]);

	  return RateLimit;
	}(_Requestable3.default);

	module.exports = RateLimit;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJhdGVMaW1pdC5qcyJdLCJuYW1lcyI6WyJSYXRlTGltaXQiLCJhdXRoIiwiYXBpQmFzZSIsImNiIiwiX3JlcXVlc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLFM7OztBQUNIOzs7Ozs7QUFNQSxxQkFBWUMsSUFBWixFQUFrQkMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQSxpSEFDbEJELElBRGtCLEVBQ1pDLE9BRFk7QUFFMUI7O0FBRUQ7Ozs7Ozs7Ozs7aUNBTWFDLEUsRUFBSTtBQUNkLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsRUFBcUIsYUFBckIsRUFBb0MsSUFBcEMsRUFBMENELEVBQTFDLENBQVA7QUFDRjs7Ozs7O0FBR0pFLE9BQU9DLE9BQVAsR0FBaUJOLFNBQWpCIiwiZmlsZSI6IlJhdGVMaW1pdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cblxuaW1wb3J0IFJlcXVlc3RhYmxlIGZyb20gJy4vUmVxdWVzdGFibGUnO1xuXG4vKipcbiAqIFJhdGVMaW1pdCBhbGxvd3MgdXNlcnMgdG8gcXVlcnkgdGhlaXIgcmF0ZS1saW1pdCBzdGF0dXNcbiAqL1xuY2xhc3MgUmF0ZUxpbWl0IGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBjb25zdHJ1Y3QgYSBSYXRlTGltaXRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuYXV0aH0gYXV0aCAtIHRoZSBjcmVkZW50aWFscyB0byBhdXRoZW50aWNhdGUgdG8gR2l0SHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2VdIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY29uc3RydWN0b3IoYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogUXVlcnkgdGhlIGN1cnJlbnQgcmF0ZSBsaW1pdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JhdGVfbGltaXQvXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByYXRlLWxpbWl0IGRhdGFcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UmF0ZUxpbWl0KGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgJy9yYXRlX2xpbWl0JywgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhdGVMaW1pdDtcbiJdfQ==
	//# sourceMappingURL=RateLimit.js.map


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _utf = __webpack_require__(45);

	var _utf2 = _interopRequireDefault(_utf);

	var _jsBase = __webpack_require__(35);

	var _debug = __webpack_require__(32);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:repository');

	/**
	 * Respository encapsulates the functionality to create, query, and modify files.
	 */

	var Repository = function (_Requestable) {
	   _inherits(Repository, _Requestable);

	   /**
	    * Create a Repository.
	    * @param {string} fullname - the full name of the repository
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function Repository(fullname, auth, apiBase) {
	      _classCallCheck(this, Repository);

	      var _this = _possibleConstructorReturn(this, (Repository.__proto__ || Object.getPrototypeOf(Repository)).call(this, auth, apiBase));

	      _this.__fullname = fullname;
	      _this.__currentTree = {
	         branch: null,
	         sha: null
	      };
	      return _this;
	   }

	   /**
	    * Get a reference
	    * @see https://developer.github.com/v3/git/refs/#get-a-reference
	    * @param {string} ref - the reference to get
	    * @param {Requestable.callback} [cb] - will receive the reference's refSpec or a list of refSpecs that match `ref`
	    * @return {Promise} - the promise for the http request
	    */


	   _createClass(Repository, [{
	      key: 'getRef',
	      value: function getRef(ref, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb);
	      }

	      /**
	       * Create a reference
	       * @see https://developer.github.com/v3/git/refs/#create-a-reference
	       * @param {Object} options - the object describing the ref
	       * @param {Requestable.callback} [cb] - will receive the ref
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRef',
	      value: function createRef(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/git/refs', options, cb);
	      }

	      /**
	       * Delete a reference
	       * @see https://developer.github.com/v3/git/refs/#delete-a-reference
	       * @param {string} ref - the name of the ref to delte
	       * @param {Requestable.callback} [cb] - will receive true if the request is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRef',
	      value: function deleteRef(ref, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb);
	      }

	      /**
	       * Delete a repository
	       * @see https://developer.github.com/v3/repos/#delete-a-repository
	       * @param {Requestable.callback} [cb] - will receive true if the request is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRepo',
	      value: function deleteRepo(cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname, null, cb);
	      }

	      /**
	       * List the tags on a repository
	       * @see https://developer.github.com/v3/repos/#list-tags
	       * @param {Requestable.callback} [cb] - will receive the tag data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listTags',
	      value: function listTags(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/tags', null, cb);
	      }

	      /**
	       * List the open pull requests on the repository
	       * @see https://developer.github.com/v3/pulls/#list-pull-requests
	       * @param {Object} options - options to filter the search
	       * @param {Requestable.callback} [cb] - will receive the list of PRs
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listPullRequests',
	      value: function listPullRequests(options, cb) {
	         options = options || {};
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls', options, cb);
	      }

	      /**
	       * Get information about a specific pull request
	       * @see https://developer.github.com/v3/pulls/#get-a-single-pull-request
	       * @param {number} number - the PR you wish to fetch
	       * @param {Requestable.callback} [cb] - will receive the PR from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getPullRequest',
	      value: function getPullRequest(number, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number, null, cb);
	      }

	      /**
	       * List the files of a specific pull request
	       * @see https://developer.github.com/v3/pulls/#list-pull-requests-files
	       * @param {number|string} number - the PR you wish to fetch
	       * @param {Requestable.callback} [cb] - will receive the list of files from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listPullRequestFiles',
	      value: function listPullRequestFiles(number, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number + '/files', null, cb);
	      }

	      /**
	       * Compare two branches/commits/repositories
	       * @see https://developer.github.com/v3/repos/commits/#compare-two-commits
	       * @param {string} base - the base commit
	       * @param {string} head - the head commit
	       * @param {Requestable.callback} cb - will receive the comparison
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'compareBranches',
	      value: function compareBranches(base, head, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/compare/' + base + '...' + head, null, cb);
	      }

	      /**
	       * List all the branches for the repository
	       * @see https://developer.github.com/v3/repos/#list-branches
	       * @param {Requestable.callback} cb - will receive the list of branches
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listBranches',
	      value: function listBranches(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/branches', null, cb);
	      }

	      /**
	       * Get a raw blob from the repository
	       * @see https://developer.github.com/v3/git/blobs/#get-a-blob
	       * @param {string} sha - the sha of the blob to fetch
	       * @param {Requestable.callback} cb - will receive the blob from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getBlob',
	      value: function getBlob(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/blobs/' + sha, null, cb, 'raw');
	      }

	      /**
	       * Get a single branch
	       * @see https://developer.github.com/v3/repos/branches/#get-branch
	       * @param {string} branch - the name of the branch to fetch
	       * @param {Requestable.callback} cb - will receive the branch from the API
	       * @returns {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getBranch',
	      value: function getBranch(branch, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/branches/' + branch, null, cb);
	      }

	      /**
	       * Get a commit from the repository
	       * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit
	       * @param {string} sha - the sha for the commit to fetch
	       * @param {Requestable.callback} cb - will receive the commit data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getCommit',
	      value: function getCommit(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/commits/' + sha, null, cb);
	      }

	      /**
	       * List the commits on a repository, optionally filtering by path, author or time range
	       * @see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
	       * @param {Object} [options] - the filtering options for commits
	       * @param {string} [options.sha] - the SHA or branch to start from
	       * @param {string} [options.path] - the path to search on
	       * @param {string} [options.author] - the commit author
	       * @param {(Date|string)} [options.since] - only commits after this date will be returned
	       * @param {(Date|string)} [options.until] - only commits before this date will be returned
	       * @param {Requestable.callback} cb - will receive the list of commits found matching the criteria
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listCommits',
	      value: function listCommits(options, cb) {
	         options = options || {};

	         options.since = this._dateToISO(options.since);
	         options.until = this._dateToISO(options.until);

	         return this._request('GET', '/repos/' + this.__fullname + '/commits', options, cb);
	      }

	      /**
	       * Gets a single commit information for a repository
	       * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit
	       * @param {string} ref - the reference for the commit-ish
	       * @param {Requestable.callback} cb - will receive the commit information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getSingleCommit',
	      value: function getSingleCommit(ref, cb) {
	         ref = ref || '';
	         return this._request('GET', '/repos/' + this.__fullname + '/commits/' + ref, null, cb);
	      }

	      /**
	       * Get tha sha for a particular object in the repository. This is a convenience function
	       * @see https://developer.github.com/v3/repos/contents/#get-contents
	       * @param {string} [branch] - the branch to look in, or the repository's default branch if omitted
	       * @param {string} path - the path of the file or directory
	       * @param {Requestable.callback} cb - will receive a description of the requested object, including a `SHA` property
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getSha',
	      value: function getSha(branch, path, cb) {
	         branch = branch ? '?ref=' + branch : '';
	         return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path + branch, null, cb);
	      }

	      /**
	       * List the commit statuses for a particular sha, branch, or tag
	       * @see https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
	       * @param {string} sha - the sha, branch, or tag to get statuses for
	       * @param {Requestable.callback} cb - will receive the list of statuses
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listStatuses',
	      value: function listStatuses(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/commits/' + sha + '/statuses', null, cb);
	      }

	      /**
	       * Get a description of a git tree
	       * @see https://developer.github.com/v3/git/trees/#get-a-tree
	       * @param {string} treeSHA - the SHA of the tree to fetch
	       * @param {Requestable.callback} cb - will receive the callback data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getTree',
	      value: function getTree(treeSHA, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/trees/' + treeSHA, null, cb);
	      }

	      /**
	       * Create a blob
	       * @see https://developer.github.com/v3/git/blobs/#create-a-blob
	       * @param {(string|Buffer|Blob)} content - the content to add to the repository
	       * @param {Requestable.callback} cb - will receive the details of the created blob
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createBlob',
	      value: function createBlob(content, cb) {
	         var postBody = this._getContentObject(content);

	         log('sending content', postBody);
	         return this._request('POST', '/repos/' + this.__fullname + '/git/blobs', postBody, cb);
	      }

	      /**
	       * Get the object that represents the provided content
	       * @param {string|Buffer|Blob} content - the content to send to the server
	       * @return {Object} the representation of `content` for the GitHub API
	       */

	   }, {
	      key: '_getContentObject',
	      value: function _getContentObject(content) {
	         if (typeof content === 'string') {
	            log('contet is a string');
	            return {
	               content: _utf2.default.encode(content),
	               encoding: 'utf-8'
	            };
	         } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
	            log('We appear to be in Node');
	            return {
	               content: content.toString('base64'),
	               encoding: 'base64'
	            };
	         } else if (typeof Blob !== 'undefined' && content instanceof Blob) {
	            log('We appear to be in the browser');
	            return {
	               content: _jsBase.Base64.encode(content),
	               encoding: 'base64'
	            };
	         } else {
	            // eslint-disable-line
	            log('Not sure what this content is: ' + (typeof content === 'undefined' ? 'undefined' : _typeof(content)) + ', ' + JSON.stringify(content));
	            throw new Error('Unknown content passed to postBlob. Must be string or Buffer (node) or Blob (web)');
	         }
	      }

	      /**
	       * Update a tree in Git
	       * @see https://developer.github.com/v3/git/trees/#create-a-tree
	       * @param {string} baseTreeSHA - the SHA of the tree to update
	       * @param {string} path - the path for the new file
	       * @param {string} blobSHA - the SHA for the blob to put at `path`
	       * @param {Requestable.callback} cb - will receive the new tree that is created
	       * @return {Promise} - the promise for the http request
	       * @deprecated use {@link Repository#createTree} instead
	       */

	   }, {
	      key: 'updateTree',
	      value: function updateTree(baseTreeSHA, path, blobSHA, cb) {
	         var newTree = {
	            base_tree: baseTreeSHA, // eslint-disable-line
	            tree: [{
	               path: path,
	               sha: blobSHA,
	               mode: '100644',
	               type: 'blob'
	            }]
	         };

	         return this._request('POST', '/repos/' + this.__fullname + '/git/trees', newTree, cb);
	      }

	      /**
	       * Create a new tree in git
	       * @see https://developer.github.com/v3/git/trees/#create-a-tree
	       * @param {Object} tree - the tree to create
	       * @param {string} baseSHA - the root sha of the tree
	       * @param {Requestable.callback} cb - will receive the new tree that is created
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createTree',
	      value: function createTree(tree, baseSHA, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/git/trees', {
	            tree: tree,
	            base_tree: baseSHA }, cb);
	      }

	      /**
	       * Add a commit to the repository
	       * @see https://developer.github.com/v3/git/commits/#create-a-commit
	       * @param {string} parent - the SHA of the parent commit
	       * @param {string} tree - the SHA of the tree for this commit
	       * @param {string} message - the commit message
	       * @param {Requestable.callback} cb - will receive the commit that is created
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'commit',
	      value: function commit(parent, tree, message, cb) {
	         var _this2 = this;

	         var data = {
	            message: message,
	            tree: tree,
	            parents: [parent]
	         };

	         return this._request('POST', '/repos/' + this.__fullname + '/git/commits', data, cb).then(function (response) {
	            _this2.__currentTree.sha = response.data.sha; // Update latest commit
	            return response;
	         });
	      }

	      /**
	       * Update a ref
	       * @see https://developer.github.com/v3/git/refs/#update-a-reference
	       * @param {string} ref - the ref to update
	       * @param {string} commitSHA - the SHA to point the reference to
	       * @param {boolean} force - indicates whether to force or ensure a fast-forward update
	       * @param {Requestable.callback} cb - will receive the updated ref back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateHead',
	      value: function updateHead(ref, commitSHA, force, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/git/refs/' + ref, {
	            sha: commitSHA,
	            force: force
	         }, cb);
	      }

	      /**
	       * Update commit status
	       * @see https://developer.github.com/v3/repos/statuses/
	       * @param {string} commitSHA - the SHA of the commit that should be updated
	       * @param {object} options - Commit status parameters
	       * @param {string} options.state - The state of the status. Can be one of: pending, success, error, or failure.
	       * @param {string} [options.target_url] - The target URL to associate with this status.
	       * @param {string} [options.description] - A short description of the status.
	       * @param {string} [options.context] - A string label to differentiate this status among CI systems.
	       * @param {Requestable.callback} cb - will receive the updated commit back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateStatus',
	      value: function updateStatus(commitSHA, options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/statuses/' + commitSHA, options, cb);
	      }

	      /**
	       * Update repository information
	       * @see https://developer.github.com/v3/repos/#edit
	       * @param {object} options - New parameters that will be set to the repository
	       * @param {string} options.name - Name of the repository
	       * @param {string} [options.description] - A short description of the repository
	       * @param {string} [options.homepage] - A URL with more information about the repository
	       * @param {boolean} [options.private] - Either true to make the repository private, or false to make it public.
	       * @param {boolean} [options.has_issues] - Either true to enable issues for this repository, false to disable them.
	       * @param {boolean} [options.has_wiki] - Either true to enable the wiki for this repository, false to disable it.
	       * @param {boolean} [options.has_downloads] - Either true to enable downloads, false to disable them.
	       * @param {string} [options.default_branch] - Updates the default branch for this repository.
	       * @param {Requestable.callback} cb - will receive the updated repository back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateRepository',
	      value: function updateRepository(options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname, options, cb);
	      }

	      /**
	        * Get information about the repository
	        * @see https://developer.github.com/v3/repos/#get
	        * @param {Requestable.callback} cb - will receive the information about the repository
	        * @return {Promise} - the promise for the http request
	        */

	   }, {
	      key: 'getDetails',
	      value: function getDetails(cb) {
	         return this._request('GET', '/repos/' + this.__fullname, null, cb);
	      }

	      /**
	       * List the contributors to the repository
	       * @see https://developer.github.com/v3/repos/#list-contributors
	       * @param {Requestable.callback} cb - will receive the list of contributors
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContributors',
	      value: function getContributors(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/contributors', null, cb);
	      }

	      /**
	       * List the contributor stats to the repository
	       * @see https://developer.github.com/v3/repos/#list-contributors
	       * @param {Requestable.callback} cb - will receive the list of contributors
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContributorStats',
	      value: function getContributorStats(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/stats/contributors', null, cb);
	      }

	      /**
	       * List the users who are collaborators on the repository. The currently authenticated user must have
	       * push access to use this method
	       * @see https://developer.github.com/v3/repos/collaborators/#list-collaborators
	       * @param {Requestable.callback} cb - will receive the list of collaborators
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getCollaborators',
	      value: function getCollaborators(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/collaborators', null, cb);
	      }

	      /**
	       * Check if a user is a collaborator on the repository
	       * @see https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
	       * @param {string} username - the user to check
	       * @param {Requestable.callback} cb - will receive true if the user is a collaborator and false if they are not
	       * @return {Promise} - the promise for the http request {Boolean} [description]
	       */

	   }, {
	      key: 'isCollaborator',
	      value: function isCollaborator(username, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/collaborators/' + username, null, cb);
	      }

	      /**
	       * Get the contents of a repository
	       * @see https://developer.github.com/v3/repos/contents/#get-contents
	       * @param {string} ref - the ref to check
	       * @param {string} path - the path containing the content to fetch
	       * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format
	       * @param {Requestable.callback} cb - will receive the fetched data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContents',
	      value: function getContents(ref, path, raw, cb) {
	         path = path ? '' + encodeURI(path) : '';
	         return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path, {
	            ref: ref
	         }, cb, raw);
	      }

	      /**
	       * Get the README of a repository
	       * @see https://developer.github.com/v3/repos/contents/#get-the-readme
	       * @param {string} ref - the ref to check
	       * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format
	       * @param {Requestable.callback} cb - will receive the fetched data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getReadme',
	      value: function getReadme(ref, raw, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/readme', {
	            ref: ref
	         }, cb, raw);
	      }

	      /**
	       * Fork a repository
	       * @see https://developer.github.com/v3/repos/forks/#create-a-fork
	       * @param {Requestable.callback} cb - will receive the information about the newly created fork
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'fork',
	      value: function fork(cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/forks', null, cb);
	      }

	      /**
	       * List a repository's forks
	       * @see https://developer.github.com/v3/repos/forks/#list-forks
	       * @param {Requestable.callback} cb - will receive the list of repositories forked from this one
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listForks',
	      value: function listForks(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/forks', null, cb);
	      }

	      /**
	       * Create a new branch from an existing branch.
	       * @param {string} [oldBranch=master] - the name of the existing branch
	       * @param {string} newBranch - the name of the new branch
	       * @param {Requestable.callback} cb - will receive the commit data for the head of the new branch
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createBranch',
	      value: function createBranch(oldBranch, newBranch, cb) {
	         var _this3 = this;

	         if (typeof newBranch === 'function') {
	            cb = newBranch;
	            newBranch = oldBranch;
	            oldBranch = 'master';
	         }

	         return this.getRef('heads/' + oldBranch).then(function (response) {
	            var sha = response.data.object.sha;
	            return _this3.createRef({
	               sha: sha,
	               ref: 'refs/heads/' + newBranch
	            }, cb);
	         });
	      }

	      /**
	       * Create a new pull request
	       * @see https://developer.github.com/v3/pulls/#create-a-pull-request
	       * @param {Object} options - the pull request description
	       * @param {Requestable.callback} cb - will receive the new pull request
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createPullRequest',
	      value: function createPullRequest(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/pulls', options, cb);
	      }

	      /**
	       * Update a pull request
	       * @see https://developer.github.com/v3/pulls/#update-a-pull-request
	       * @param {number|string} number - the number of the pull request to update
	       * @param {Object} options - the pull request description
	       * @param {Requestable.callback} [cb] - will receive the pull request information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updatePullRequest',
	      value: function updatePullRequest(number, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/pulls/' + number, options, cb);
	      }

	      /**
	       * List the hooks for the repository
	       * @see https://developer.github.com/v3/repos/hooks/#list-hooks
	       * @param {Requestable.callback} cb - will receive the list of hooks
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listHooks',
	      value: function listHooks(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/hooks', null, cb);
	      }

	      /**
	       * Get a hook for the repository
	       * @see https://developer.github.com/v3/repos/hooks/#get-single-hook
	       * @param {number} id - the id of the webook
	       * @param {Requestable.callback} cb - will receive the details of the webook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getHook',
	      value: function getHook(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/hooks/' + id, null, cb);
	      }

	      /**
	       * Add a new hook to the repository
	       * @see https://developer.github.com/v3/repos/hooks/#create-a-hook
	       * @param {Object} options - the configuration describing the new hook
	       * @param {Requestable.callback} cb - will receive the new webhook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createHook',
	      value: function createHook(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/hooks', options, cb);
	      }

	      /**
	       * Edit an existing webhook
	       * @see https://developer.github.com/v3/repos/hooks/#edit-a-hook
	       * @param {number} id - the id of the webhook
	       * @param {Object} options - the new description of the webhook
	       * @param {Requestable.callback} cb - will receive the updated webhook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateHook',
	      value: function updateHook(id, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/hooks/' + id, options, cb);
	      }

	      /**
	       * Delete a webhook
	       * @see https://developer.github.com/v3/repos/hooks/#delete-a-hook
	       * @param {number} id - the id of the webhook to be deleted
	       * @param {Requestable.callback} cb - will receive true if the call is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteHook',
	      value: function deleteHook(id, cb) {
	         return this._request('DELETE', this.__fullname + '/hooks/' + id, null, cb);
	      }

	      /**
	       * List the deploy keys for the repository
	       * @see https://developer.github.com/v3/repos/keys/#list-deploy-keys
	       * @param {Requestable.callback} cb - will receive the list of deploy keys
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listKeys',
	      value: function listKeys(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/keys', null, cb);
	      }

	      /**
	       * Get a deploy key for the repository
	       * @see https://developer.github.com/v3/repos/keys/#get-a-deploy-key
	       * @param {number} id - the id of the deploy key
	       * @param {Requestable.callback} cb - will receive the details of the deploy key
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getKey',
	      value: function getKey(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/keys/' + id, null, cb);
	      }

	      /**
	       * Add a new deploy key to the repository
	       * @see https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
	       * @param {Object} options - the configuration describing the new deploy key
	       * @param {Requestable.callback} cb - will receive the new deploy key
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createKey',
	      value: function createKey(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/keys', options, cb);
	      }

	      /**
	       * Delete a deploy key
	       * @see https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
	       * @param {number} id - the id of the deploy key to be deleted
	       * @param {Requestable.callback} cb - will receive true if the call is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteKey',
	      value: function deleteKey(id, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/keys/' + id, null, cb);
	      }

	      /**
	       * Delete a file from a branch
	       * @see https://developer.github.com/v3/repos/contents/#delete-a-file
	       * @param {string} branch - the branch to delete from, or the default branch if not specified
	       * @param {string} path - the path of the file to remove
	       * @param {Requestable.callback} cb - will receive the commit in which the delete occurred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteFile',
	      value: function deleteFile(branch, path, cb) {
	         var _this4 = this;

	         return this.getSha(branch, path).then(function (response) {
	            var deleteCommit = {
	               message: 'Delete the file at \'' + path + '\'',
	               sha: response.data.sha,
	               branch: branch
	            };
	            return _this4._request('DELETE', '/repos/' + _this4.__fullname + '/contents/' + path, deleteCommit, cb);
	         });
	      }

	      /**
	       * Change all references in a repo from oldPath to new_path
	       * @param {string} branch - the branch to carry out the reference change, or the default branch if not specified
	       * @param {string} oldPath - original path
	       * @param {string} newPath - new reference path
	       * @param {Requestable.callback} cb - will receive the commit in which the move occurred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'move',
	      value: function move(branch, oldPath, newPath, cb) {
	         var _this5 = this;

	         var oldSha = void 0;
	         return this.getRef('heads/' + branch).then(function (_ref) {
	            var object = _ref.data.object;
	            return _this5.getTree(object.sha + '?recursive=true');
	         }).then(function (_ref2) {
	            var _ref2$data = _ref2.data,
	                tree = _ref2$data.tree,
	                sha = _ref2$data.sha;

	            oldSha = sha;
	            var newTree = tree.map(function (ref) {
	               if (ref.path === oldPath) {
	                  ref.path = newPath;
	               }
	               if (ref.type === 'tree') {
	                  delete ref.sha;
	               }
	               return ref;
	            });
	            return _this5.createTree(newTree);
	         }).then(function (_ref3) {
	            var tree = _ref3.data;
	            return _this5.commit(oldSha, tree.sha, 'Renamed \'' + oldPath + '\' to \'' + newPath + '\'');
	         }).then(function (_ref4) {
	            var commit = _ref4.data;
	            return _this5.updateHead('heads/' + branch, commit.sha, true, cb);
	         });
	      }

	      /**
	       * Write a file to the repository
	       * @see https://developer.github.com/v3/repos/contents/#update-a-file
	       * @param {string} branch - the name of the branch
	       * @param {string} path - the path for the file
	       * @param {string} content - the contents of the file
	       * @param {string} message - the commit message
	       * @param {Object} [options] - commit options
	       * @param {Object} [options.author] - the author of the commit
	       * @param {Object} [options.commiter] - the committer
	       * @param {boolean} [options.encode] - true if the content should be base64 encoded
	       * @param {Requestable.callback} cb - will receive the new commit
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'writeFile',
	      value: function writeFile(branch, path, content, message, options, cb) {
	         var _this6 = this;

	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }
	         var filePath = path ? encodeURI(path) : '';
	         var shouldEncode = options.encode !== false;
	         var commit = {
	            branch: branch,
	            message: message,
	            author: options.author,
	            committer: options.committer,
	            content: shouldEncode ? _jsBase.Base64.encode(content) : content
	         };

	         return this.getSha(branch, filePath).then(function (response) {
	            commit.sha = response.data.sha;
	            return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb);
	         }, function () {
	            return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb);
	         });
	      }

	      /**
	       * Check if a repository is starred by you
	       * @see https://developer.github.com/v3/activity/starring/#check-if-you-are-starring-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is starred and false if the repository
	       *                                  is not starred
	       * @return {Promise} - the promise for the http request {Boolean} [description]
	       */

	   }, {
	      key: 'isStarred',
	      value: function isStarred(cb) {
	         return this._request204or404('/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Star a repository
	       * @see https://developer.github.com/v3/activity/starring/#star-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is starred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'star',
	      value: function star(cb) {
	         return this._request('PUT', '/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Unstar a repository
	       * @see https://developer.github.com/v3/activity/starring/#unstar-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is unstarred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'unstar',
	      value: function unstar(cb) {
	         return this._request('DELETE', '/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Create a new release
	       * @see https://developer.github.com/v3/repos/releases/#create-a-release
	       * @param {Object} options - the description of the release
	       * @param {Requestable.callback} cb - will receive the newly created release
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRelease',
	      value: function createRelease(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/releases', options, cb);
	      }

	      /**
	       * Edit a release
	       * @see https://developer.github.com/v3/repos/releases/#edit-a-release
	       * @param {string} id - the id of the release
	       * @param {Object} options - the description of the release
	       * @param {Requestable.callback} cb - will receive the modified release
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateRelease',
	      value: function updateRelease(id, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/releases/' + id, options, cb);
	      }

	      /**
	       * Get information about all releases
	       * @see https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
	       * @param {Requestable.callback} cb - will receive the release information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listReleases',
	      value: function listReleases(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/releases', null, cb);
	      }

	      /**
	       * Get information about a release
	       * @see https://developer.github.com/v3/repos/releases/#get-a-single-release
	       * @param {string} id - the id of the release
	       * @param {Requestable.callback} cb - will receive the release information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getRelease',
	      value: function getRelease(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/releases/' + id, null, cb);
	      }

	      /**
	       * Delete a release
	       * @see https://developer.github.com/v3/repos/releases/#delete-a-release
	       * @param {string} id - the release to be deleted
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRelease',
	      value: function deleteRelease(id, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/releases/' + id, null, cb);
	      }

	      /**
	       * Merge a pull request
	       * @see https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
	       * @param {number|string} number - the number of the pull request to merge
	       * @param {Object} options - the merge options for the pull request
	       * @param {Requestable.callback} [cb] - will receive the merge information if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'mergePullRequest',
	      value: function mergePullRequest(number, options, cb) {
	         return this._request('PUT', '/repos/' + this.__fullname + '/pulls/' + number + '/merge', options, cb);
	      }

	      /**
	       * Get information about all projects
	       * @see https://developer.github.com/v3/projects/#list-repository-projects
	       * @param {Requestable.callback} [cb] - will receive the list of projects
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjects',
	      value: function listProjects(cb) {
	         return this._requestAllPages('/repos/' + this.__fullname + '/projects', { AcceptHeader: 'inertia-preview' }, cb);
	      }

	      /**
	       * Create a new project
	       * @see https://developer.github.com/v3/projects/#create-a-repository-project
	       * @param {Object} options - the description of the project
	       * @param {Requestable.callback} cb - will receive the newly created project
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createProject',
	      value: function createProject(options, cb) {
	         options = options || {};
	         options.AcceptHeader = 'inertia-preview';
	         return this._request('POST', '/repos/' + this.__fullname + '/projects', options, cb);
	      }
	   }]);

	   return Repository;
	}(_Requestable3.default);

	module.exports = Repository;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcG9zaXRvcnkuanMiXSwibmFtZXMiOlsibG9nIiwiUmVwb3NpdG9yeSIsImZ1bGxuYW1lIiwiYXV0aCIsImFwaUJhc2UiLCJfX2Z1bGxuYW1lIiwiX19jdXJyZW50VHJlZSIsImJyYW5jaCIsInNoYSIsInJlZiIsImNiIiwiX3JlcXVlc3QiLCJvcHRpb25zIiwibnVtYmVyIiwiYmFzZSIsImhlYWQiLCJzaW5jZSIsIl9kYXRlVG9JU08iLCJ1bnRpbCIsInBhdGgiLCJ0cmVlU0hBIiwiY29udGVudCIsInBvc3RCb2R5IiwiX2dldENvbnRlbnRPYmplY3QiLCJlbmNvZGUiLCJlbmNvZGluZyIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiQmxvYiIsIkpTT04iLCJzdHJpbmdpZnkiLCJFcnJvciIsImJhc2VUcmVlU0hBIiwiYmxvYlNIQSIsIm5ld1RyZWUiLCJiYXNlX3RyZWUiLCJ0cmVlIiwibW9kZSIsInR5cGUiLCJiYXNlU0hBIiwicGFyZW50IiwibWVzc2FnZSIsImRhdGEiLCJwYXJlbnRzIiwidGhlbiIsInJlc3BvbnNlIiwiY29tbWl0U0hBIiwiZm9yY2UiLCJ1c2VybmFtZSIsInJhdyIsImVuY29kZVVSSSIsIm9sZEJyYW5jaCIsIm5ld0JyYW5jaCIsImdldFJlZiIsIm9iamVjdCIsImNyZWF0ZVJlZiIsImlkIiwiZ2V0U2hhIiwiZGVsZXRlQ29tbWl0Iiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRTaGEiLCJnZXRUcmVlIiwibWFwIiwiY3JlYXRlVHJlZSIsImNvbW1pdCIsInVwZGF0ZUhlYWQiLCJmaWxlUGF0aCIsInNob3VsZEVuY29kZSIsImF1dGhvciIsImNvbW1pdHRlciIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiQWNjZXB0SGVhZGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7Ozs7QUFDQTs7OztBQUNBOztBQUdBOzs7Ozs7Ozs7OytlQVpBOzs7Ozs7O0FBYUEsSUFBTUEsTUFBTSxxQkFBTSxtQkFBTixDQUFaOztBQUVBOzs7O0lBR01DLFU7OztBQUNIOzs7Ozs7QUFNQSx1QkFBWUMsUUFBWixFQUFzQkMsSUFBdEIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQUE7O0FBQUEsMEhBQzVCRCxJQUQ0QixFQUN0QkMsT0FEc0I7O0FBRWxDLFlBQUtDLFVBQUwsR0FBa0JILFFBQWxCO0FBQ0EsWUFBS0ksYUFBTCxHQUFxQjtBQUNsQkMsaUJBQVEsSUFEVTtBQUVsQkMsY0FBSztBQUZhLE9BQXJCO0FBSGtDO0FBT3BDOztBQUVEOzs7Ozs7Ozs7Ozs2QkFPT0MsRyxFQUFLQyxFLEVBQUk7QUFDYixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxrQkFBMkRJLEdBQTNELEVBQWtFLElBQWxFLEVBQXdFQyxFQUF4RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VFLE8sRUFBU0YsRSxFQUFJO0FBQ3BCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGdCQUE0RE8sT0FBNUQsRUFBcUVGLEVBQXJFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPVUQsRyxFQUFLQyxFLEVBQUk7QUFDaEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS04sVUFBdkMsa0JBQThESSxHQUE5RCxFQUFxRSxJQUFyRSxFQUEyRUMsRUFBM0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTVdBLEUsRUFBSTtBQUNaLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtOLFVBQXZDLEVBQXFELElBQXJELEVBQTJESyxFQUEzRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNU0EsRSxFQUFJO0FBQ1YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsWUFBdUQsSUFBdkQsRUFBNkRLLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozt1Q0FPaUJFLE8sRUFBU0YsRSxFQUFJO0FBQzNCRSxtQkFBVUEsV0FBVyxFQUFyQjtBQUNBLGdCQUFPLEtBQUtELFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGFBQXdETyxPQUF4RCxFQUFpRUYsRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3FDQU9lRyxNLEVBQVFILEUsRUFBSTtBQUN4QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxlQUF3RFEsTUFBeEQsRUFBa0UsSUFBbEUsRUFBd0VILEVBQXhFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzsyQ0FPcUJHLE0sRUFBUUgsRSxFQUFJO0FBQzlCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGVBQXdEUSxNQUF4RCxhQUF3RSxJQUF4RSxFQUE4RUgsRUFBOUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztzQ0FRZ0JJLEksRUFBTUMsSSxFQUFNTCxFLEVBQUk7QUFDN0IsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsaUJBQTBEUyxJQUExRCxXQUFvRUMsSUFBcEUsRUFBNEUsSUFBNUUsRUFBa0ZMLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O21DQU1hQSxFLEVBQUk7QUFDZCxnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxnQkFBMkQsSUFBM0QsRUFBaUVLLEVBQWpFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs4QkFPUUYsRyxFQUFLRSxFLEVBQUk7QUFDZCxnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxtQkFBNERHLEdBQTVELEVBQW1FLElBQW5FLEVBQXlFRSxFQUF6RSxFQUE2RSxLQUE3RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VILE0sRUFBUUcsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyREUsTUFBM0QsRUFBcUUsSUFBckUsRUFBMkVHLEVBQTNFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPVUYsRyxFQUFLRSxFLEVBQUk7QUFDaEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMscUJBQThERyxHQUE5RCxFQUFxRSxJQUFyRSxFQUEyRUUsRUFBM0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7a0NBWVlFLE8sRUFBU0YsRSxFQUFJO0FBQ3RCRSxtQkFBVUEsV0FBVyxFQUFyQjs7QUFFQUEsaUJBQVFJLEtBQVIsR0FBZ0IsS0FBS0MsVUFBTCxDQUFnQkwsUUFBUUksS0FBeEIsQ0FBaEI7QUFDQUosaUJBQVFNLEtBQVIsR0FBZ0IsS0FBS0QsVUFBTCxDQUFnQkwsUUFBUU0sS0FBeEIsQ0FBaEI7O0FBRUEsZ0JBQU8sS0FBS1AsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsZUFBMERPLE9BQTFELEVBQW1FRixFQUFuRSxDQUFQO0FBQ0Y7O0FBRUE7Ozs7Ozs7Ozs7c0NBT2VELEcsRUFBS0MsRSxFQUFJO0FBQ3RCRCxlQUFNQSxPQUFPLEVBQWI7QUFDQSxnQkFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxpQkFBMERJLEdBQTFELEVBQWlFLElBQWpFLEVBQXVFQyxFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzZCQVFPSCxNLEVBQVFZLEksRUFBTVQsRSxFQUFJO0FBQ3RCSCxrQkFBU0EsbUJBQWlCQSxNQUFqQixHQUE0QixFQUFyQztBQUNBLGdCQUFPLEtBQUtJLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRGMsSUFBM0QsR0FBa0VaLE1BQWxFLEVBQTRFLElBQTVFLEVBQWtGRyxFQUFsRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7bUNBT2FGLEcsRUFBS0UsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGlCQUEwREcsR0FBMUQsZ0JBQTBFLElBQTFFLEVBQWdGRSxFQUFoRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OEJBT1FVLE8sRUFBU1YsRSxFQUFJO0FBQ2xCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLG1CQUE0RGUsT0FBNUQsRUFBdUUsSUFBdkUsRUFBNkVWLEVBQTdFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztpQ0FPV1csTyxFQUFTWCxFLEVBQUk7QUFDckIsYUFBSVksV0FBVyxLQUFLQyxpQkFBTCxDQUF1QkYsT0FBdkIsQ0FBZjs7QUFFQXJCLGFBQUksaUJBQUosRUFBdUJzQixRQUF2QjtBQUNBLGdCQUFPLEtBQUtYLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RGlCLFFBQTdELEVBQXVFWixFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3dDQUtrQlcsTyxFQUFTO0FBQ3hCLGFBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUM5QnJCLGdCQUFJLG9CQUFKO0FBQ0EsbUJBQU87QUFDSnFCLHdCQUFTLGNBQUtHLE1BQUwsQ0FBWUgsT0FBWixDQURMO0FBRUpJLHlCQUFVO0FBRk4sYUFBUDtBQUtGLFVBUEQsTUFPTyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNMLG1CQUFtQkssTUFBeEQsRUFBZ0U7QUFDcEUxQixnQkFBSSx5QkFBSjtBQUNBLG1CQUFPO0FBQ0pxQix3QkFBU0EsUUFBUU0sUUFBUixDQUFpQixRQUFqQixDQURMO0FBRUpGLHlCQUFVO0FBRk4sYUFBUDtBQUtGLFVBUE0sTUFPQSxJQUFJLE9BQU9HLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JQLG1CQUFtQk8sSUFBdEQsRUFBNEQ7QUFDaEU1QixnQkFBSSxnQ0FBSjtBQUNBLG1CQUFPO0FBQ0pxQix3QkFBUyxlQUFPRyxNQUFQLENBQWNILE9BQWQsQ0FETDtBQUVKSSx5QkFBVTtBQUZOLGFBQVA7QUFLRixVQVBNLE1BT0E7QUFBRTtBQUNOekIsNERBQTZDcUIsT0FBN0MseUNBQTZDQSxPQUE3QyxZQUF5RFEsS0FBS0MsU0FBTCxDQUFlVCxPQUFmLENBQXpEO0FBQ0Esa0JBQU0sSUFBSVUsS0FBSixDQUFVLG1GQUFWLENBQU47QUFDRjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7O2lDQVVXQyxXLEVBQWFiLEksRUFBTWMsTyxFQUFTdkIsRSxFQUFJO0FBQ3hDLGFBQUl3QixVQUFVO0FBQ1hDLHVCQUFXSCxXQURBLEVBQ2E7QUFDeEJJLGtCQUFNLENBQUM7QUFDSmpCLHFCQUFNQSxJQURGO0FBRUpYLG9CQUFLeUIsT0FGRDtBQUdKSSxxQkFBTSxRQUhGO0FBSUpDLHFCQUFNO0FBSkYsYUFBRDtBQUZLLFVBQWQ7O0FBVUEsZ0JBQU8sS0FBSzNCLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RDZCLE9BQTdELEVBQXNFeEIsRUFBdEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRVzBCLEksRUFBTUcsTyxFQUFTN0IsRSxFQUFJO0FBQzNCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RDtBQUNqRStCLHNCQURpRTtBQUVqRUQsdUJBQVdJLE9BRnNELEVBQTdELEVBR0o3QixFQUhJLENBQVA7QUFJRjs7QUFFRDs7Ozs7Ozs7Ozs7OzZCQVNPOEIsTSxFQUFRSixJLEVBQU1LLE8sRUFBUy9CLEUsRUFBSTtBQUFBOztBQUMvQixhQUFJZ0MsT0FBTztBQUNSRCw0QkFEUTtBQUVSTCxzQkFGUTtBQUdSTyxxQkFBUyxDQUFDSCxNQUFEO0FBSEQsVUFBWDs7QUFNQSxnQkFBTyxLQUFLN0IsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS04sVUFBckMsbUJBQStEcUMsSUFBL0QsRUFBcUVoQyxFQUFyRSxFQUNIa0MsSUFERyxDQUNFLFVBQUNDLFFBQUQsRUFBYztBQUNqQixtQkFBS3ZDLGFBQUwsQ0FBbUJFLEdBQW5CLEdBQXlCcUMsU0FBU0gsSUFBVCxDQUFjbEMsR0FBdkMsQ0FEaUIsQ0FDMkI7QUFDNUMsbUJBQU9xQyxRQUFQO0FBQ0YsVUFKRyxDQUFQO0FBS0Y7O0FBRUQ7Ozs7Ozs7Ozs7OztpQ0FTV3BDLEcsRUFBS3FDLFMsRUFBV0MsSyxFQUFPckMsRSxFQUFJO0FBQ25DLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtOLFVBQXRDLGtCQUE2REksR0FBN0QsRUFBb0U7QUFDeEVELGlCQUFLc0MsU0FEbUU7QUFFeEVDLG1CQUFPQTtBQUZpRSxVQUFwRSxFQUdKckMsRUFISSxDQUFQO0FBSUY7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzttQ0FZYW9DLFMsRUFBV2xDLE8sRUFBU0YsRSxFQUFJO0FBQ2xDLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGtCQUE0RHlDLFNBQTVELEVBQXlFbEMsT0FBekUsRUFBa0ZGLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQWVpQkUsTyxFQUFTRixFLEVBQUk7QUFDM0IsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS04sVUFBdEMsRUFBb0RPLE9BQXBELEVBQTZERixFQUE3RCxDQUFQO0FBQ0Y7O0FBRUY7Ozs7Ozs7OztpQ0FNWUEsRSxFQUFJO0FBQ1osZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsRUFBa0QsSUFBbEQsRUFBd0RLLEVBQXhELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3NDQU1nQkEsRSxFQUFJO0FBQ2pCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLG9CQUErRCxJQUEvRCxFQUFxRUssRUFBckUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7MENBTW9CQSxFLEVBQUk7QUFDckIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsMEJBQXFFLElBQXJFLEVBQTJFSyxFQUEzRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7dUNBT2lCQSxFLEVBQUk7QUFDbEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMscUJBQWdFLElBQWhFLEVBQXNFSyxFQUF0RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7cUNBT2VzQyxRLEVBQVV0QyxFLEVBQUk7QUFDMUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsdUJBQWdFMkMsUUFBaEUsRUFBNEUsSUFBNUUsRUFBa0Z0QyxFQUFsRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OztrQ0FTWUQsRyxFQUFLVSxJLEVBQU04QixHLEVBQUt2QyxFLEVBQUk7QUFDN0JTLGdCQUFPQSxZQUFVK0IsVUFBVS9CLElBQVYsQ0FBVixHQUE4QixFQUFyQztBQUNBLGdCQUFPLEtBQUtSLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRGMsSUFBM0QsRUFBbUU7QUFDdkVWO0FBRHVFLFVBQW5FLEVBRUpDLEVBRkksRUFFQXVDLEdBRkEsQ0FBUDtBQUdGOztBQUVEOzs7Ozs7Ozs7OztnQ0FRVXhDLEcsRUFBS3dDLEcsRUFBS3ZDLEUsRUFBSTtBQUNyQixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxjQUF5RDtBQUM3REk7QUFENkQsVUFBekQsRUFFSkMsRUFGSSxFQUVBdUMsR0FGQSxDQUFQO0FBR0Y7O0FBRUQ7Ozs7Ozs7OzsyQkFNS3ZDLEUsRUFBSTtBQUNOLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGFBQXlELElBQXpELEVBQStESyxFQUEvRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsYUFBd0QsSUFBeEQsRUFBOERLLEVBQTlELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzttQ0FPYXlDLFMsRUFBV0MsUyxFQUFXMUMsRSxFQUFJO0FBQUE7O0FBQ3BDLGFBQUksT0FBTzBDLFNBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDbEMxQyxpQkFBSzBDLFNBQUw7QUFDQUEsd0JBQVlELFNBQVo7QUFDQUEsd0JBQVksUUFBWjtBQUNGOztBQUVELGdCQUFPLEtBQUtFLE1BQUwsWUFBcUJGLFNBQXJCLEVBQ0hQLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakIsZ0JBQUlyQyxNQUFNcUMsU0FBU0gsSUFBVCxDQUFjWSxNQUFkLENBQXFCOUMsR0FBL0I7QUFDQSxtQkFBTyxPQUFLK0MsU0FBTCxDQUFlO0FBQ25CL0MsdUJBRG1CO0FBRW5CQyxvQ0FBbUIyQztBQUZBLGFBQWYsRUFHSjFDLEVBSEksQ0FBUDtBQUlGLFVBUEcsQ0FBUDtBQVFGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQkUsTyxFQUFTRixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS04sVUFBckMsYUFBeURPLE9BQXpELEVBQWtFRixFQUFsRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O3dDQVFrQkcsTSxFQUFRRCxPLEVBQVNGLEUsRUFBSTtBQUNwQyxnQkFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLTixVQUF0QyxlQUEwRFEsTUFBMUQsRUFBb0VELE9BQXBFLEVBQTZFRixFQUE3RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsYUFBd0QsSUFBeEQsRUFBOERLLEVBQTlELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs4QkFPUThDLEUsRUFBSTlDLEUsRUFBSTtBQUNiLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGVBQXdEbUQsRUFBeEQsRUFBOEQsSUFBOUQsRUFBb0U5QyxFQUFwRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT1dFLE8sRUFBU0YsRSxFQUFJO0FBQ3JCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGFBQXlETyxPQUF6RCxFQUFrRUYsRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRVzhDLEUsRUFBSTVDLE8sRUFBU0YsRSxFQUFJO0FBQ3pCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtOLFVBQXRDLGVBQTBEbUQsRUFBMUQsRUFBZ0U1QyxPQUFoRSxFQUF5RUYsRUFBekUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9XOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLEVBQTJCLEtBQUtOLFVBQWhDLGVBQW9EbUQsRUFBcEQsRUFBMEQsSUFBMUQsRUFBZ0U5QyxFQUFoRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNU0EsRSxFQUFJO0FBQ1YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsWUFBdUQsSUFBdkQsRUFBNkRLLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs2QkFPTzhDLEUsRUFBSTlDLEUsRUFBSTtBQUNaLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGNBQXVEbUQsRUFBdkQsRUFBNkQsSUFBN0QsRUFBbUU5QyxFQUFuRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VFLE8sRUFBU0YsRSxFQUFJO0FBQ3BCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLFlBQXdETyxPQUF4RCxFQUFpRUYsRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2dDQU9VOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS04sVUFBdkMsY0FBMERtRCxFQUExRCxFQUFnRSxJQUFoRSxFQUFzRTlDLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUVdILE0sRUFBUVksSSxFQUFNVCxFLEVBQUk7QUFBQTs7QUFDMUIsZ0JBQU8sS0FBSytDLE1BQUwsQ0FBWWxELE1BQVosRUFBb0JZLElBQXBCLEVBQ0h5QixJQURHLENBQ0UsVUFBQ0MsUUFBRCxFQUFjO0FBQ2pCLGdCQUFNYSxlQUFlO0FBQ2xCakIsa0RBQWdDdEIsSUFBaEMsT0FEa0I7QUFFbEJYLG9CQUFLcUMsU0FBU0gsSUFBVCxDQUFjbEMsR0FGRDtBQUdsQkQ7QUFIa0IsYUFBckI7QUFLQSxtQkFBTyxPQUFLSSxRQUFMLENBQWMsUUFBZCxjQUFrQyxPQUFLTixVQUF2QyxrQkFBOERjLElBQTlELEVBQXNFdUMsWUFBdEUsRUFBb0ZoRCxFQUFwRixDQUFQO0FBQ0YsVUFSRyxDQUFQO0FBU0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFLSCxNLEVBQVFvRCxPLEVBQVNDLE8sRUFBU2xELEUsRUFBSTtBQUFBOztBQUNoQyxhQUFJbUQsZUFBSjtBQUNBLGdCQUFPLEtBQUtSLE1BQUwsWUFBcUI5QyxNQUFyQixFQUNIcUMsSUFERyxDQUNFO0FBQUEsZ0JBQVNVLE1BQVQsUUFBRVosSUFBRixDQUFTWSxNQUFUO0FBQUEsbUJBQXNCLE9BQUtRLE9BQUwsQ0FBZ0JSLE9BQU85QyxHQUF2QixxQkFBdEI7QUFBQSxVQURGLEVBRUhvQyxJQUZHLENBRUUsaUJBQXlCO0FBQUEsbUNBQXZCRixJQUF1QjtBQUFBLGdCQUFoQk4sSUFBZ0IsY0FBaEJBLElBQWdCO0FBQUEsZ0JBQVY1QixHQUFVLGNBQVZBLEdBQVU7O0FBQzVCcUQscUJBQVNyRCxHQUFUO0FBQ0EsZ0JBQUkwQixVQUFVRSxLQUFLMkIsR0FBTCxDQUFTLFVBQUN0RCxHQUFELEVBQVM7QUFDN0IsbUJBQUlBLElBQUlVLElBQUosS0FBYXdDLE9BQWpCLEVBQTBCO0FBQ3ZCbEQsc0JBQUlVLElBQUosR0FBV3lDLE9BQVg7QUFDRjtBQUNELG1CQUFJbkQsSUFBSTZCLElBQUosS0FBYSxNQUFqQixFQUF5QjtBQUN0Qix5QkFBTzdCLElBQUlELEdBQVg7QUFDRjtBQUNELHNCQUFPQyxHQUFQO0FBQ0YsYUFSYSxDQUFkO0FBU0EsbUJBQU8sT0FBS3VELFVBQUwsQ0FBZ0I5QixPQUFoQixDQUFQO0FBQ0YsVUFkRyxFQWVIVSxJQWZHLENBZUU7QUFBQSxnQkFBUVIsSUFBUixTQUFFTSxJQUFGO0FBQUEsbUJBQWtCLE9BQUt1QixNQUFMLENBQVlKLE1BQVosRUFBb0J6QixLQUFLNUIsR0FBekIsaUJBQTBDbUQsT0FBMUMsZ0JBQTBEQyxPQUExRCxRQUFsQjtBQUFBLFVBZkYsRUFnQkhoQixJQWhCRyxDQWdCRTtBQUFBLGdCQUFRcUIsTUFBUixTQUFFdkIsSUFBRjtBQUFBLG1CQUFvQixPQUFLd0IsVUFBTCxZQUF5QjNELE1BQXpCLEVBQW1DMEQsT0FBT3pELEdBQTFDLEVBQStDLElBQS9DLEVBQXFERSxFQUFyRCxDQUFwQjtBQUFBLFVBaEJGLENBQVA7QUFpQkY7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWNVSCxNLEVBQVFZLEksRUFBTUUsTyxFQUFTb0IsTyxFQUFTN0IsTyxFQUFTRixFLEVBQUk7QUFBQTs7QUFDcEQsYUFBSSxPQUFPRSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2hDRixpQkFBS0UsT0FBTDtBQUNBQSxzQkFBVSxFQUFWO0FBQ0Y7QUFDRCxhQUFJdUQsV0FBV2hELE9BQU8rQixVQUFVL0IsSUFBVixDQUFQLEdBQXlCLEVBQXhDO0FBQ0EsYUFBSWlELGVBQWV4RCxRQUFRWSxNQUFSLEtBQW1CLEtBQXRDO0FBQ0EsYUFBSXlDLFNBQVM7QUFDVjFELDBCQURVO0FBRVZrQyw0QkFGVTtBQUdWNEIsb0JBQVF6RCxRQUFReUQsTUFITjtBQUlWQyx1QkFBVzFELFFBQVEwRCxTQUpUO0FBS1ZqRCxxQkFBUytDLGVBQWUsZUFBTzVDLE1BQVAsQ0FBY0gsT0FBZCxDQUFmLEdBQXdDQTtBQUx2QyxVQUFiOztBQVFBLGdCQUFPLEtBQUtvQyxNQUFMLENBQVlsRCxNQUFaLEVBQW9CNEQsUUFBcEIsRUFDSHZCLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakJvQixtQkFBT3pELEdBQVAsR0FBYXFDLFNBQVNILElBQVQsQ0FBY2xDLEdBQTNCO0FBQ0EsbUJBQU8sT0FBS0csUUFBTCxDQUFjLEtBQWQsY0FBK0IsT0FBS04sVUFBcEMsa0JBQTJEOEQsUUFBM0QsRUFBdUVGLE1BQXZFLEVBQStFdkQsRUFBL0UsQ0FBUDtBQUNGLFVBSkcsRUFJRCxZQUFNO0FBQ04sbUJBQU8sT0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsT0FBS04sVUFBcEMsa0JBQTJEOEQsUUFBM0QsRUFBdUVGLE1BQXZFLEVBQStFdkQsRUFBL0UsQ0FBUDtBQUNGLFVBTkcsQ0FBUDtBQU9GOztBQUVEOzs7Ozs7Ozs7O2dDQU9VQSxFLEVBQUk7QUFDWCxnQkFBTyxLQUFLNkQsZ0JBQUwsb0JBQXVDLEtBQUtsRSxVQUE1QyxFQUEwRCxJQUExRCxFQUFnRUssRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7MkJBTUtBLEUsRUFBSTtBQUNOLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLHFCQUFzQyxLQUFLTixVQUEzQyxFQUF5RCxJQUF6RCxFQUErREssRUFBL0QsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NkJBTU9BLEUsRUFBSTtBQUNSLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLHFCQUF5QyxLQUFLTixVQUE5QyxFQUE0RCxJQUE1RCxFQUFrRUssRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jRSxPLEVBQVNGLEUsRUFBSTtBQUN4QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLTixVQUFyQyxnQkFBNERPLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O29DQVFjOEMsRSxFQUFJNUMsTyxFQUFTRixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS04sVUFBdEMsa0JBQTZEbUQsRUFBN0QsRUFBbUU1QyxPQUFuRSxFQUE0RUYsRUFBNUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7bUNBTWFBLEUsRUFBSTtBQUNkLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGdCQUEyRCxJQUEzRCxFQUFpRUssRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9XOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRG1ELEVBQTNELEVBQWlFLElBQWpFLEVBQXVFOUMsRUFBdkUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtOLFVBQXZDLGtCQUE4RG1ELEVBQTlELEVBQW9FLElBQXBFLEVBQTBFOUMsRUFBMUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRaUJHLE0sRUFBUUQsTyxFQUFTRixFLEVBQUk7QUFDbkMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsZUFBd0RRLE1BQXhELGFBQXdFRCxPQUF4RSxFQUFpRkYsRUFBakYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7bUNBTWFBLEUsRUFBSTtBQUNkLGdCQUFPLEtBQUs4RCxnQkFBTCxhQUFnQyxLQUFLbkUsVUFBckMsZ0JBQTRELEVBQUNvRSxjQUFjLGlCQUFmLEVBQTVELEVBQStGL0QsRUFBL0YsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jRSxPLEVBQVNGLEUsRUFBSTtBQUN4QkUsbUJBQVVBLFdBQVcsRUFBckI7QUFDQUEsaUJBQVE2RCxZQUFSLEdBQXVCLGlCQUF2QjtBQUNBLGdCQUFPLEtBQUs5RCxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLTixVQUFyQyxnQkFBNERPLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7Ozs7OztBQUlKZ0UsT0FBT0MsT0FBUCxHQUFpQjFFLFVBQWpCIiwiZmlsZSI6IlJlcG9zaXRvcnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcbmltcG9ydCBVdGY4IGZyb20gJ3V0ZjgnO1xuaW1wb3J0IHtcbiAgIEJhc2U2NCxcbn0gZnJvbSAnanMtYmFzZTY0JztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5jb25zdCBsb2cgPSBkZWJ1ZygnZ2l0aHViOnJlcG9zaXRvcnknKTtcblxuLyoqXG4gKiBSZXNwb3NpdG9yeSBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gY3JlYXRlLCBxdWVyeSwgYW5kIG1vZGlmeSBmaWxlcy5cbiAqL1xuY2xhc3MgUmVwb3NpdG9yeSBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgUmVwb3NpdG9yeS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsbmFtZSAtIHRoZSBmdWxsIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuYXV0aH0gW2F1dGhdIC0gaW5mb3JtYXRpb24gcmVxdWlyZWQgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1YlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlPWh0dHBzOi8vYXBpLmdpdGh1Yi5jb21dIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqL1xuICAgY29uc3RydWN0b3IoZnVsbG5hbWUsIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX2Z1bGxuYW1lID0gZnVsbG5hbWU7XG4gICAgICB0aGlzLl9fY3VycmVudFRyZWUgPSB7XG4gICAgICAgICBicmFuY2g6IG51bGwsXG4gICAgICAgICBzaGE6IG51bGwsXG4gICAgICB9O1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhIHJlZmVyZW5jZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyNnZXQtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmZXJlbmNlIHRvIGdldFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVmZXJlbmNlJ3MgcmVmU3BlYyBvciBhIGxpc3Qgb2YgcmVmU3BlY3MgdGhhdCBtYXRjaCBgcmVmYFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRSZWYocmVmLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzLyR7cmVmfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSByZWZlcmVuY2VcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXQvcmVmcy8jY3JlYXRlLWEtcmVmZXJlbmNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBvYmplY3QgZGVzY3JpYmluZyB0aGUgcmVmXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByZWZcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUmVmKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIHJlZmVyZW5jZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyNkZWxldGUtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgbmFtZSBvZiB0aGUgcmVmIHRvIGRlbHRlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVSZWYocmVmLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzLyR7cmVmfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2RlbGV0ZS1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZVJlcG8oY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSB0YWdzIG9uIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LXRhZ3NcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHRhZyBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RUYWdzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vdGFnc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBvcGVuIHB1bGwgcmVxdWVzdHMgb24gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wdWxscy8jbGlzdC1wdWxsLXJlcXVlc3RzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gZmlsdGVyIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgUFJzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RQdWxsUmVxdWVzdHMob3B0aW9ucywgY2IpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3B1bGxzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNnZXQtYS1zaW5nbGUtcHVsbC1yZXF1ZXN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIC0gdGhlIFBSIHlvdSB3aXNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBQUiBmcm9tIHRoZSBBUElcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UHVsbFJlcXVlc3QobnVtYmVyLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3B1bGxzLyR7bnVtYmVyfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBmaWxlcyBvZiBhIHNwZWNpZmljIHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNsaXN0LXB1bGwtcmVxdWVzdHMtZmlsZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIC0gdGhlIFBSIHlvdSB3aXNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGZpbGVzIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UHVsbFJlcXVlc3RGaWxlcyhudW1iZXIsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcHVsbHMvJHtudW1iZXJ9L2ZpbGVzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENvbXBhcmUgdHdvIGJyYW5jaGVzL2NvbW1pdHMvcmVwb3NpdG9yaWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29tbWl0cy8jY29tcGFyZS10d28tY29tbWl0c1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgLSB0aGUgYmFzZSBjb21taXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkIC0gdGhlIGhlYWQgY29tbWl0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tcGFyaXNvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjb21wYXJlQnJhbmNoZXMoYmFzZSwgaGVhZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb21wYXJlLyR7YmFzZX0uLi4ke2hlYWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgYWxsIHRoZSBicmFuY2hlcyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jbGlzdC1icmFuY2hlc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgYnJhbmNoZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdEJyYW5jaGVzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vYnJhbmNoZXNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgcmF3IGJsb2IgZnJvbSB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9ibG9icy8jZ2V0LWEtYmxvYlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYSAtIHRoZSBzaGEgb2YgdGhlIGJsb2IgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBibG9iIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRCbG9iKHNoYSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvYmxvYnMvJHtzaGF9YCwgbnVsbCwgY2IsICdyYXcnKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBzaW5nbGUgYnJhbmNoXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvYnJhbmNoZXMvI2dldC1icmFuY2hcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggLSB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgYnJhbmNoIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybnMge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0QnJhbmNoKGJyYW5jaCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9icmFuY2hlcy8ke2JyYW5jaH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgY29tbWl0IGZyb20gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb21taXRzLyNnZXQtYS1zaW5nbGUtY29tbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhIC0gdGhlIHNoYSBmb3IgdGhlIGNvbW1pdCB0byBmZXRjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbW1pdCBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbW1pdChzaGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L2NvbW1pdHMvJHtzaGF9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGNvbW1pdHMgb24gYSByZXBvc2l0b3J5LCBvcHRpb25hbGx5IGZpbHRlcmluZyBieSBwYXRoLCBhdXRob3Igb3IgdGltZSByYW5nZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbW1pdHMvI2xpc3QtY29tbWl0cy1vbi1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSB0aGUgZmlsdGVyaW5nIG9wdGlvbnMgZm9yIGNvbW1pdHNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zaGFdIC0gdGhlIFNIQSBvciBicmFuY2ggdG8gc3RhcnQgZnJvbVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhdGhdIC0gdGhlIHBhdGggdG8gc2VhcmNoIG9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXV0aG9yXSAtIHRoZSBjb21taXQgYXV0aG9yXG4gICAgKiBAcGFyYW0geyhEYXRlfHN0cmluZyl9IFtvcHRpb25zLnNpbmNlXSAtIG9ubHkgY29tbWl0cyBhZnRlciB0aGlzIGRhdGUgd2lsbCBiZSByZXR1cm5lZFxuICAgICogQHBhcmFtIHsoRGF0ZXxzdHJpbmcpfSBbb3B0aW9ucy51bnRpbF0gLSBvbmx5IGNvbW1pdHMgYmVmb3JlIHRoaXMgZGF0ZSB3aWxsIGJlIHJldHVybmVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjb21taXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBjcml0ZXJpYVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0Q29tbWl0cyhvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIG9wdGlvbnMuc2luY2UgPSB0aGlzLl9kYXRlVG9JU08ob3B0aW9ucy5zaW5jZSk7XG4gICAgICBvcHRpb25zLnVudGlsID0gdGhpcy5fZGF0ZVRvSVNPKG9wdGlvbnMudW50aWwpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29tbWl0c2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzaW5nbGUgY29tbWl0IGluZm9ybWF0aW9uIGZvciBhIHJlcG9zaXRvcnlcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29tbWl0cy8jZ2V0LWEtc2luZ2xlLWNvbW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmZXJlbmNlIGZvciB0aGUgY29tbWl0LWlzaFxuICAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjb21taXQgaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgICovXG4gICBnZXRTaW5nbGVDb21taXQocmVmLCBjYikge1xuICAgICAgcmVmID0gcmVmIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbW1pdHMvJHtyZWZ9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCB0aGEgc2hhIGZvciBhIHBhcnRpY3VsYXIgb2JqZWN0IGluIHRoZSByZXBvc2l0b3J5LiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb250ZW50cy8jZ2V0LWNvbnRlbnRzXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2JyYW5jaF0gLSB0aGUgYnJhbmNoIHRvIGxvb2sgaW4sIG9yIHRoZSByZXBvc2l0b3J5J3MgZGVmYXVsdCBicmFuY2ggaWYgb21pdHRlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIGEgZGVzY3JpcHRpb24gb2YgdGhlIHJlcXVlc3RlZCBvYmplY3QsIGluY2x1ZGluZyBhIGBTSEFgIHByb3BlcnR5XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFNoYShicmFuY2gsIHBhdGgsIGNiKSB7XG4gICAgICBicmFuY2ggPSBicmFuY2ggPyBgP3JlZj0ke2JyYW5jaH1gIDogJyc7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29udGVudHMvJHtwYXRofSR7YnJhbmNofWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBjb21taXQgc3RhdHVzZXMgZm9yIGEgcGFydGljdWxhciBzaGEsIGJyYW5jaCwgb3IgdGFnXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3Mvc3RhdHVzZXMvI2xpc3Qtc3RhdHVzZXMtZm9yLWEtc3BlY2lmaWMtcmVmXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhIC0gdGhlIHNoYSwgYnJhbmNoLCBvciB0YWcgdG8gZ2V0IHN0YXR1c2VzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygc3RhdHVzZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFN0YXR1c2VzKHNoYSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb21taXRzLyR7c2hhfS9zdGF0dXNlc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBkZXNjcmlwdGlvbiBvZiBhIGdpdCB0cmVlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L3RyZWVzLyNnZXQtYS10cmVlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdHJlZVNIQSAtIHRoZSBTSEEgb2YgdGhlIHRyZWUgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjYWxsYmFjayBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFRyZWUodHJlZVNIQSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvdHJlZXMvJHt0cmVlU0hBfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBibG9iXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L2Jsb2JzLyNjcmVhdGUtYS1ibG9iXG4gICAgKiBAcGFyYW0geyhzdHJpbmd8QnVmZmVyfEJsb2IpfSBjb250ZW50IC0gdGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgZGV0YWlscyBvZiB0aGUgY3JlYXRlZCBibG9iXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUJsb2IoY29udGVudCwgY2IpIHtcbiAgICAgIGxldCBwb3N0Qm9keSA9IHRoaXMuX2dldENvbnRlbnRPYmplY3QoY29udGVudCk7XG5cbiAgICAgIGxvZygnc2VuZGluZyBjb250ZW50JywgcG9zdEJvZHkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvYmxvYnNgLCBwb3N0Qm9keSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCB0aGUgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvdmlkZWQgY29udGVudFxuICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfEJsb2J9IGNvbnRlbnQgLSB0aGUgY29udGVudCB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBjb250ZW50YCBmb3IgdGhlIEdpdEh1YiBBUElcbiAgICAqL1xuICAgX2dldENvbnRlbnRPYmplY3QoY29udGVudCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgbG9nKCdjb250ZXQgaXMgYSBzdHJpbmcnKTtcbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBVdGY4LmVuY29kZShjb250ZW50KSxcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZW50IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICBsb2coJ1dlIGFwcGVhciB0byBiZSBpbiBOb2RlJyk7XG4gICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudC50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgICB9O1xuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZW50IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgbG9nKCdXZSBhcHBlYXIgdG8gYmUgaW4gdGhlIGJyb3dzZXInKTtcbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBCYXNlNjQuZW5jb2RlKGNvbnRlbnQpLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgbG9nKGBOb3Qgc3VyZSB3aGF0IHRoaXMgY29udGVudCBpczogJHt0eXBlb2YgY29udGVudH0sICR7SlNPTi5zdHJpbmdpZnkoY29udGVudCl9YCk7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29udGVudCBwYXNzZWQgdG8gcG9zdEJsb2IuIE11c3QgYmUgc3RyaW5nIG9yIEJ1ZmZlciAobm9kZSkgb3IgQmxvYiAod2ViKScpO1xuICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSBhIHRyZWUgaW4gR2l0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L3RyZWVzLyNjcmVhdGUtYS10cmVlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVRyZWVTSEEgLSB0aGUgU0hBIG9mIHRoZSB0cmVlIHRvIHVwZGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCBmb3IgdGhlIG5ldyBmaWxlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvYlNIQSAtIHRoZSBTSEEgZm9yIHRoZSBibG9iIHRvIHB1dCBhdCBgcGF0aGBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXcgdHJlZSB0aGF0IGlzIGNyZWF0ZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgUmVwb3NpdG9yeSNjcmVhdGVUcmVlfSBpbnN0ZWFkXG4gICAgKi9cbiAgIHVwZGF0ZVRyZWUoYmFzZVRyZWVTSEEsIHBhdGgsIGJsb2JTSEEsIGNiKSB7XG4gICAgICBsZXQgbmV3VHJlZSA9IHtcbiAgICAgICAgIGJhc2VfdHJlZTogYmFzZVRyZWVTSEEsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgIHRyZWU6IFt7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgc2hhOiBibG9iU0hBLFxuICAgICAgICAgICAgbW9kZTogJzEwMDY0NCcsXG4gICAgICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgICB9XSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3RyZWVzYCwgbmV3VHJlZSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyB0cmVlIGluIGdpdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC90cmVlcy8jY3JlYXRlLWEtdHJlZVxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWUgLSB0aGUgdHJlZSB0byBjcmVhdGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlU0hBIC0gdGhlIHJvb3Qgc2hhIG9mIHRoZSB0cmVlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3IHRyZWUgdGhhdCBpcyBjcmVhdGVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZVRyZWUodHJlZSwgYmFzZVNIQSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3RyZWVzYCwge1xuICAgICAgICAgdHJlZSxcbiAgICAgICAgIGJhc2VfdHJlZTogYmFzZVNIQSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBjb21taXQgdG8gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXQvY29tbWl0cy8jY3JlYXRlLWEtY29tbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50IC0gdGhlIFNIQSBvZiB0aGUgcGFyZW50IGNvbW1pdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRyZWUgLSB0aGUgU0hBIG9mIHRoZSB0cmVlIGZvciB0aGlzIGNvbW1pdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSB0aGUgY29tbWl0IG1lc3NhZ2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjb21taXQgdGhhdCBpcyBjcmVhdGVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNvbW1pdChwYXJlbnQsIHRyZWUsIG1lc3NhZ2UsIGNiKSB7XG4gICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICB0cmVlLFxuICAgICAgICAgcGFyZW50czogW3BhcmVudF0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9jb21taXRzYCwgZGF0YSwgY2IpXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50VHJlZS5zaGEgPSByZXNwb25zZS5kYXRhLnNoYTsgLy8gVXBkYXRlIGxhdGVzdCBjb21taXRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSBhIHJlZlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyN1cGRhdGUtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmIHRvIHVwZGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1pdFNIQSAtIHRoZSBTSEEgdG8gcG9pbnQgdGhlIHJlZmVyZW5jZSB0b1xuICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGluZGljYXRlcyB3aGV0aGVyIHRvIGZvcmNlIG9yIGVuc3VyZSBhIGZhc3QtZm9yd2FyZCB1cGRhdGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSB1cGRhdGVkIHJlZiBiYWNrXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZUhlYWQocmVmLCBjb21taXRTSEEsIGZvcmNlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BBVENIJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3JlZnMvJHtyZWZ9YCwge1xuICAgICAgICAgc2hhOiBjb21taXRTSEEsXG4gICAgICAgICBmb3JjZTogZm9yY2UsXG4gICAgICB9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVXBkYXRlIGNvbW1pdCBzdGF0dXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9zdGF0dXNlcy9cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21taXRTSEEgLSB0aGUgU0hBIG9mIHRoZSBjb21taXQgdGhhdCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBDb21taXQgc3RhdHVzIHBhcmFtZXRlcnNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN0YXRlIC0gVGhlIHN0YXRlIG9mIHRoZSBzdGF0dXMuIENhbiBiZSBvbmUgb2Y6IHBlbmRpbmcsIHN1Y2Nlc3MsIGVycm9yLCBvciBmYWlsdXJlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRhcmdldF91cmxdIC0gVGhlIHRhcmdldCBVUkwgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBzdGF0dXMuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIC0gQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhdHVzLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRleHRdIC0gQSBzdHJpbmcgbGFiZWwgdG8gZGlmZmVyZW50aWF0ZSB0aGlzIHN0YXR1cyBhbW9uZyBDSSBzeXN0ZW1zLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIHVwZGF0ZWQgY29tbWl0IGJhY2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlU3RhdHVzKGNvbW1pdFNIQSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vc3RhdHVzZXMvJHtjb21taXRTSEF9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSByZXBvc2l0b3J5IGluZm9ybWF0aW9uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2VkaXRcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gTmV3IHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNldCB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl0gLSBBIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaG9tZXBhZ2VdIC0gQSBVUkwgd2l0aCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByaXZhdGVdIC0gRWl0aGVyIHRydWUgdG8gbWFrZSB0aGUgcmVwb3NpdG9yeSBwcml2YXRlLCBvciBmYWxzZSB0byBtYWtlIGl0IHB1YmxpYy5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzX2lzc3Vlc10gLSBFaXRoZXIgdHJ1ZSB0byBlbmFibGUgaXNzdWVzIGZvciB0aGlzIHJlcG9zaXRvcnksIGZhbHNlIHRvIGRpc2FibGUgdGhlbS5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzX3dpa2ldIC0gRWl0aGVyIHRydWUgdG8gZW5hYmxlIHRoZSB3aWtpIGZvciB0aGlzIHJlcG9zaXRvcnksIGZhbHNlIHRvIGRpc2FibGUgaXQuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhhc19kb3dubG9hZHNdIC0gRWl0aGVyIHRydWUgdG8gZW5hYmxlIGRvd25sb2FkcywgZmFsc2UgdG8gZGlzYWJsZSB0aGVtLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRfYnJhbmNoXSAtIFVwZGF0ZXMgdGhlIGRlZmF1bHQgYnJhbmNoIGZvciB0aGlzIHJlcG9zaXRvcnkuXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCByZXBvc2l0b3J5IGJhY2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlUmVwb3NpdG9yeShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BBVENIJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jZ2V0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0RGV0YWlscyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGNvbnRyaWJ1dG9ycyB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LWNvbnRyaWJ1dG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29udHJpYnV0b3JzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbnRyaWJ1dG9ycyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbnRyaWJ1dG9yc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBjb250cmlidXRvciBzdGF0cyB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LWNvbnRyaWJ1dG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29udHJpYnV0b3JzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbnRyaWJ1dG9yU3RhdHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9zdGF0cy9jb250cmlidXRvcnNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgdXNlcnMgd2hvIGFyZSBjb2xsYWJvcmF0b3JzIG9uIHRoZSByZXBvc2l0b3J5LiBUaGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBtdXN0IGhhdmVcbiAgICAqIHB1c2ggYWNjZXNzIHRvIHVzZSB0aGlzIG1ldGhvZFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbGxhYm9yYXRvcnMvI2xpc3QtY29sbGFib3JhdG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29sbGFib3JhdG9yc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRDb2xsYWJvcmF0b3JzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29sbGFib3JhdG9yc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHVzZXIgaXMgYSBjb2xsYWJvcmF0b3Igb24gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb2xsYWJvcmF0b3JzLyNjaGVjay1pZi1hLXVzZXItaXMtYS1jb2xsYWJvcmF0b3JcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIHRvIGNoZWNrXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSB1c2VyIGlzIGEgY29sbGFib3JhdG9yIGFuZCBmYWxzZSBpZiB0aGV5IGFyZSBub3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3Qge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAqL1xuICAgaXNDb2xsYWJvcmF0b3IodXNlcm5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29sbGFib3JhdG9ycy8ke3VzZXJuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbnRlbnRzLyNnZXQtY29udGVudHNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmIHRvIGNoZWNrXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmF3IC0gYHRydWVgIGlmIHRoZSByZXN1bHRzIHNob3VsZCBiZSByZXR1cm5lZCByYXcgaW5zdGVhZCBvZiBHaXRIdWIncyBub3JtYWxpemVkIGZvcm1hdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGZldGNoZWQgZGF0YVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRDb250ZW50cyhyZWYsIHBhdGgsIHJhdywgY2IpIHtcbiAgICAgIHBhdGggPSBwYXRoID8gYCR7ZW5jb2RlVVJJKHBhdGgpfWAgOiAnJztcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb250ZW50cy8ke3BhdGh9YCwge1xuICAgICAgICAgcmVmLFxuICAgICAgfSwgY2IsIHJhdyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSBSRUFETUUgb2YgYSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29udGVudHMvI2dldC10aGUtcmVhZG1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIC0gdGhlIHJlZiB0byBjaGVja1xuICAgICogQHBhcmFtIHtib29sZWFufSByYXcgLSBgdHJ1ZWAgaWYgdGhlIHJlc3VsdHMgc2hvdWxkIGJlIHJldHVybmVkIHJhdyBpbnN0ZWFkIG9mIEdpdEh1YidzIG5vcm1hbGl6ZWQgZm9ybWF0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgZmV0Y2hlZCBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFJlYWRtZShyZWYsIHJhdywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWFkbWVgLCB7XG4gICAgICAgICByZWYsXG4gICAgICB9LCBjYiwgcmF3KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBGb3JrIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2ZvcmtzLyNjcmVhdGUtYS1mb3JrXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ld2x5IGNyZWF0ZWQgZm9ya1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JrKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2ZvcmtzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgYSByZXBvc2l0b3J5J3MgZm9ya3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9mb3Jrcy8jbGlzdC1mb3Jrc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgcmVwb3NpdG9yaWVzIGZvcmtlZCBmcm9tIHRoaXMgb25lXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RGb3JrcyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2ZvcmtzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBicmFuY2ggZnJvbSBhbiBleGlzdGluZyBicmFuY2guXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29sZEJyYW5jaD1tYXN0ZXJdIC0gdGhlIG5hbWUgb2YgdGhlIGV4aXN0aW5nIGJyYW5jaFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0JyYW5jaCAtIHRoZSBuYW1lIG9mIHRoZSBuZXcgYnJhbmNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWl0IGRhdGEgZm9yIHRoZSBoZWFkIG9mIHRoZSBuZXcgYnJhbmNoXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUJyYW5jaChvbGRCcmFuY2gsIG5ld0JyYW5jaCwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3QnJhbmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICBjYiA9IG5ld0JyYW5jaDtcbiAgICAgICAgIG5ld0JyYW5jaCA9IG9sZEJyYW5jaDtcbiAgICAgICAgIG9sZEJyYW5jaCA9ICdtYXN0ZXInO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRSZWYoYGhlYWRzLyR7b2xkQnJhbmNofWApXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCBzaGEgPSByZXNwb25zZS5kYXRhLm9iamVjdC5zaGE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZWYoe1xuICAgICAgICAgICAgICAgc2hhLFxuICAgICAgICAgICAgICAgcmVmOiBgcmVmcy9oZWFkcy8ke25ld0JyYW5jaH1gLFxuICAgICAgICAgICAgfSwgY2IpO1xuICAgICAgICAgfSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNjcmVhdGUtYS1wdWxsLXJlcXVlc3RcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIHB1bGwgcmVxdWVzdCBkZXNjcmlwdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBwdWxsIHJlcXVlc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUHVsbFJlcXVlc3Qob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcHVsbHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVXBkYXRlIGEgcHVsbCByZXF1ZXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHVsbHMvI3VwZGF0ZS1hLXB1bGwtcmVxdWVzdFxuICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSBwdWxsIHJlcXVlc3QgdG8gdXBkYXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBwdWxsIHJlcXVlc3QgZGVzY3JpcHRpb25cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHB1bGwgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1cGRhdGVQdWxsUmVxdWVzdChudW1iZXIsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9wdWxscy8ke251bWJlcn1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgaG9va3MgZm9yIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2xpc3QtaG9va3NcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGhvb2tzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RIb29rcyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2hvb2tzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhIGhvb2sgZm9yIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2dldC1zaW5nbGUtaG9va1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gdGhlIGlkIG9mIHRoZSB3ZWJvb2tcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBkZXRhaWxzIG9mIHRoZSB3ZWJvb2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0SG9vayhpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rcy8ke2lkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBuZXcgaG9vayB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2hvb2tzLyNjcmVhdGUtYS1ob29rXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBjb25maWd1cmF0aW9uIGRlc2NyaWJpbmcgdGhlIG5ldyBob29rXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3IHdlYmhvb2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlSG9vayhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGFuIGV4aXN0aW5nIHdlYmhvb2tcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9ob29rcy8jZWRpdC1hLWhvb2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgd2ViaG9va1xuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGRlc2NyaXB0aW9uIG9mIHRoZSB3ZWJob29rXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCB3ZWJob29rXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZUhvb2soaWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rcy8ke2lkfWAsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2RlbGV0ZS1hLWhvb2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgd2ViaG9vayB0byBiZSBkZWxldGVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBjYWxsIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlSG9vayhpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgJHt0aGlzLl9fZnVsbG5hbWV9L2hvb2tzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGRlcGxveSBrZXlzIGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2tleXMvI2xpc3QtZGVwbG95LWtleXNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGRlcGxveSBrZXlzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RLZXlzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0va2V5c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBkZXBsb3kga2V5IGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2tleXMvI2dldC1hLWRlcGxveS1rZXlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgZGVwbG95IGtleVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGRldGFpbHMgb2YgdGhlIGRlcGxveSBrZXlcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0S2V5KGlkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2tleXMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQWRkIGEgbmV3IGRlcGxveSBrZXkgdG8gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9rZXlzLyNhZGQtYS1uZXctZGVwbG95LWtleVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgY29uZmlndXJhdGlvbiBkZXNjcmliaW5nIHRoZSBuZXcgZGVwbG95IGtleVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBkZXBsb3kga2V5XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUtleShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9rZXlzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGRlcGxveSBrZXlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9rZXlzLyNyZW1vdmUtYS1kZXBsb3kta2V5XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSB0aGUgaWQgb2YgdGhlIGRlcGxveSBrZXkgdG8gYmUgZGVsZXRlZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgY2FsbCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZUtleShpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9rZXlzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGZpbGUgZnJvbSBhIGJyYW5jaFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbnRlbnRzLyNkZWxldGUtYS1maWxlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoIC0gdGhlIGJyYW5jaCB0byBkZWxldGUgZnJvbSwgb3IgdGhlIGRlZmF1bHQgYnJhbmNoIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gcmVtb3ZlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWl0IGluIHdoaWNoIHRoZSBkZWxldGUgb2NjdXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlRmlsZShicmFuY2gsIHBhdGgsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTaGEoYnJhbmNoLCBwYXRoKVxuICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVDb21taXQgPSB7XG4gICAgICAgICAgICAgICBtZXNzYWdlOiBgRGVsZXRlIHRoZSBmaWxlIGF0ICcke3BhdGh9J2AsXG4gICAgICAgICAgICAgICBzaGE6IHJlc3BvbnNlLmRhdGEuc2hhLFxuICAgICAgICAgICAgICAgYnJhbmNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb250ZW50cy8ke3BhdGh9YCwgZGVsZXRlQ29tbWl0LCBjYik7XG4gICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2UgYWxsIHJlZmVyZW5jZXMgaW4gYSByZXBvIGZyb20gb2xkUGF0aCB0byBuZXdfcGF0aFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJyYW5jaCAtIHRoZSBicmFuY2ggdG8gY2Fycnkgb3V0IHRoZSByZWZlcmVuY2UgY2hhbmdlLCBvciB0aGUgZGVmYXVsdCBicmFuY2ggaWYgbm90IHNwZWNpZmllZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhdGggLSBvcmlnaW5hbCBwYXRoXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGF0aCAtIG5ldyByZWZlcmVuY2UgcGF0aFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbW1pdCBpbiB3aGljaCB0aGUgbW92ZSBvY2N1cnJlZFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtb3ZlKGJyYW5jaCwgb2xkUGF0aCwgbmV3UGF0aCwgY2IpIHtcbiAgICAgIGxldCBvbGRTaGE7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSZWYoYGhlYWRzLyR7YnJhbmNofWApXG4gICAgICAgICAudGhlbigoe2RhdGE6IHtvYmplY3R9fSkgPT4gdGhpcy5nZXRUcmVlKGAke29iamVjdC5zaGF9P3JlY3Vyc2l2ZT10cnVlYCkpXG4gICAgICAgICAudGhlbigoe2RhdGE6IHt0cmVlLCBzaGF9fSkgPT4ge1xuICAgICAgICAgICAgb2xkU2hhID0gc2hhO1xuICAgICAgICAgICAgbGV0IG5ld1RyZWUgPSB0cmVlLm1hcCgocmVmKSA9PiB7XG4gICAgICAgICAgICAgICBpZiAocmVmLnBhdGggPT09IG9sZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlZi5wYXRoID0gbmV3UGF0aDtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChyZWYudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcmVmLnNoYTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRyZWUobmV3VHJlZSk7XG4gICAgICAgICB9KVxuICAgICAgICAgLnRoZW4oKHtkYXRhOiB0cmVlfSkgPT4gdGhpcy5jb21taXQob2xkU2hhLCB0cmVlLnNoYSwgYFJlbmFtZWQgJyR7b2xkUGF0aH0nIHRvICcke25ld1BhdGh9J2ApKVxuICAgICAgICAgLnRoZW4oKHtkYXRhOiBjb21taXR9KSA9PiB0aGlzLnVwZGF0ZUhlYWQoYGhlYWRzLyR7YnJhbmNofWAsIGNvbW1pdC5zaGEsIHRydWUsIGNiKSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogV3JpdGUgYSBmaWxlIHRvIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29udGVudHMvI3VwZGF0ZS1hLWZpbGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggLSB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGZvciB0aGUgZmlsZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSB0aGUgY29udGVudHMgb2YgdGhlIGZpbGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gdGhlIGNvbW1pdCBtZXNzYWdlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gY29tbWl0IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hdXRob3JdIC0gdGhlIGF1dGhvciBvZiB0aGUgY29tbWl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29tbWl0ZXJdIC0gdGhlIGNvbW1pdHRlclxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmNvZGVdIC0gdHJ1ZSBpZiB0aGUgY29udGVudCBzaG91bGQgYmUgYmFzZTY0IGVuY29kZWRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXcgY29tbWl0XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHdyaXRlRmlsZShicmFuY2gsIHBhdGgsIGNvbnRlbnQsIG1lc3NhZ2UsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWxlUGF0aCA9IHBhdGggPyBlbmNvZGVVUkkocGF0aCkgOiAnJztcbiAgICAgIGxldCBzaG91bGRFbmNvZGUgPSBvcHRpb25zLmVuY29kZSAhPT0gZmFsc2U7XG4gICAgICBsZXQgY29tbWl0ID0ge1xuICAgICAgICAgYnJhbmNoLFxuICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgIGF1dGhvcjogb3B0aW9ucy5hdXRob3IsXG4gICAgICAgICBjb21taXR0ZXI6IG9wdGlvbnMuY29tbWl0dGVyLFxuICAgICAgICAgY29udGVudDogc2hvdWxkRW5jb2RlID8gQmFzZTY0LmVuY29kZShjb250ZW50KSA6IGNvbnRlbnQsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5nZXRTaGEoYnJhbmNoLCBmaWxlUGF0aClcbiAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29tbWl0LnNoYSA9IHJlc3BvbnNlLmRhdGEuc2hhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BVVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbnRlbnRzLyR7ZmlsZVBhdGh9YCwgY29tbWl0LCBjYik7XG4gICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUFVUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29udGVudHMvJHtmaWxlUGF0aH1gLCBjb21taXQsIGNiKTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgcmVwb3NpdG9yeSBpcyBzdGFycmVkIGJ5IHlvdVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyNjaGVjay1pZi15b3UtYXJlLXN0YXJyaW5nLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVwb3NpdG9yeSBpcyBzdGFycmVkIGFuZCBmYWxzZSBpZiB0aGUgcmVwb3NpdG9yeVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IHN0YXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3Qge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAqL1xuICAgaXNTdGFycmVkKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvdXNlci9zdGFycmVkLyR7dGhpcy5fX2Z1bGxuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTdGFyIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyNzdGFyLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVwb3NpdG9yeSBpcyBzdGFycmVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3VzZXIvc3RhcnJlZC8ke3RoaXMuX19mdWxsbmFtZX1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVW5zdGFyIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyN1bnN0YXItYS1yZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSByZXBvc2l0b3J5IGlzIHVuc3RhcnJlZFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bnN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3VzZXIvc3RhcnJlZC8ke3RoaXMuX19mdWxsbmFtZX1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHJlbGVhc2VcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9yZWxlYXNlcy8jY3JlYXRlLWEtcmVsZWFzZVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJlbGVhc2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIHJlbGVhc2VcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUmVsZWFzZShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWxlYXNlc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGEgcmVsZWFzZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL3JlbGVhc2VzLyNlZGl0LWEtcmVsZWFzZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSByZWxlYXNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcmVsZWFzZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG1vZGlmaWVkIHJlbGVhc2VcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlUmVsZWFzZShpZCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3JlbGVhc2VzLyR7aWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgcmVsZWFzZXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9yZWxlYXNlcy8jbGlzdC1yZWxlYXNlcy1mb3ItYS1yZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVsZWFzZSBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UmVsZWFzZXMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWxlYXNlc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSByZWxlYXNlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvcmVsZWFzZXMvI2dldC1hLXNpbmdsZS1yZWxlYXNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHJlbGVhc2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSByZWxlYXNlIGluZm9ybWF0aW9uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFJlbGVhc2UoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcmVsZWFzZXMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgcmVsZWFzZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL3JlbGVhc2VzLyNkZWxldGUtYS1yZWxlYXNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgcmVsZWFzZSB0byBiZSBkZWxldGVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVSZWxlYXNlKGlkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3JlbGVhc2VzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIE1lcmdlIGEgcHVsbCByZXF1ZXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHVsbHMvI21lcmdlLWEtcHVsbC1yZXF1ZXN0LW1lcmdlLWJ1dHRvblxuICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSBwdWxsIHJlcXVlc3QgdG8gbWVyZ2VcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIG1lcmdlIG9wdGlvbnMgZm9yIHRoZSBwdWxsIHJlcXVlc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lcmdlIGluZm9ybWF0aW9uIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtZXJnZVB1bGxSZXF1ZXN0KG51bWJlciwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9wdWxscy8ke251bWJlcn0vbWVyZ2VgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCBwcm9qZWN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNsaXN0LXJlcG9zaXRvcnktcHJvamVjdHNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgcHJvamVjdHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFByb2plY3RzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3Byb2plY3RzYCwge0FjY2VwdEhlYWRlcjogJ2luZXJ0aWEtcHJldmlldyd9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jY3JlYXRlLWEtcmVwb3NpdG9yeS1wcm9qZWN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvamVjdFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVQcm9qZWN0KG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMuQWNjZXB0SGVhZGVyID0gJ2luZXJ0aWEtcHJldmlldyc7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3Byb2plY3RzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVwb3NpdG9yeTtcbiJdfQ==
	//# sourceMappingURL=Repository.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).Buffer))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.1.2 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.1.2',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module), (function() { return this; }())))

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Organization encapsulates the functionality to create repositories in organizations
	 */
	var Organization = function (_Requestable) {
	  _inherits(Organization, _Requestable);

	  /**
	   * Create a new Organization
	   * @param {string} organization - the name of the organization
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Organization(organization, auth, apiBase) {
	    _classCallCheck(this, Organization);

	    var _this = _possibleConstructorReturn(this, (Organization.__proto__ || Object.getPrototypeOf(Organization)).call(this, auth, apiBase));

	    _this.__name = organization;
	    return _this;
	  }

	  /**
	   * Create a repository in an organization
	   * @see https://developer.github.com/v3/repos/#create
	   * @param {Object} options - the repository definition
	   * @param {Requestable.callback} [cb] - will receive the created repository
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Organization, [{
	    key: 'createRepo',
	    value: function createRepo(options, cb) {
	      return this._request('POST', '/orgs/' + this.__name + '/repos', options, cb);
	    }

	    /**
	     * List the repositories in an organization
	     * @see https://developer.github.com/v3/repos/#list-organization-repositories
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getRepos',
	    value: function getRepos(cb) {
	      var requestOptions = this._getOptionsWithDefaults({ direction: 'desc' });

	      return this._requestAllPages('/orgs/' + this.__name + '/repos', requestOptions, cb);
	    }

	    /**
	     * Query if the user is a member or not
	     * @param {string} username - the user in question
	     * @param {Requestable.callback} [cb] - will receive true if the user is a member
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'isMember',
	    value: function isMember(username, cb) {
	      return this._request204or404('/orgs/' + this.__name + '/members/' + username, null, cb);
	    }

	    /**
	     * List the users who are members of the company
	     * @see https://developer.github.com/v3/orgs/members/#members-list
	     * @param {object} options - filtering options
	     * @param {string} [options.filter=all] - can be either `2fa_disabled` or `all`
	     * @param {string} [options.role=all] - can be one of: `all`, `admin`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the list of users
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMembers',
	    value: function listMembers(options, cb) {
	      return this._request('GET', '/orgs/' + this.__name + '/members', options, cb);
	    }

	    /**
	     * List the Teams in the Organization
	     * @see https://developer.github.com/v3/orgs/teams/#list-teams
	     * @param {Requestable.callback} [cb] - will receive the list of teams
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getTeams',
	    value: function getTeams(cb) {
	      return this._requestAllPages('/orgs/' + this.__name + '/teams', undefined, cb);
	    }

	    /**
	     * Create a team
	     * @see https://developer.github.com/v3/orgs/teams/#create-team
	     * @param {object} options - Team creation parameters
	     * @param {string} options.name - The name of the team
	     * @param {string} [options.description] - Team description
	     * @param {string} [options.repo_names] - Repos to add the team to
	     * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one
	     * of: `secret`, or `closed`
	     * @param {Requestable.callback} [cb] - will receive the created team
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createTeam',
	    value: function createTeam(options, cb) {
	      return this._request('POST', '/orgs/' + this.__name + '/teams', options, cb);
	    }

	    /**
	     * Get information about all projects
	     * @see https://developer.github.com/v3/projects/#list-organization-projects
	     * @param {Requestable.callback} [cb] - will receive the list of projects
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listProjects',
	    value: function listProjects(cb) {
	      return this._requestAllPages('/orgs/' + this.__name + '/projects', { AcceptHeader: 'inertia-preview' }, cb);
	    }

	    /**
	     * Create a new project
	     * @see https://developer.github.com/v3/repos/projects/#create-a-project
	     * @param {Object} options - the description of the project
	     * @param {Requestable.callback} cb - will receive the newly created project
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createProject',
	    value: function createProject(options, cb) {
	      options = options || {};
	      options.AcceptHeader = 'inertia-preview';
	      return this._request('POST', '/orgs/' + this.__name + '/projects', options, cb);
	    }
	  }]);

	  return Organization;
	}(_Requestable3.default);

	module.exports = Organization;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9yZ2FuaXphdGlvbi5qcyJdLCJuYW1lcyI6WyJPcmdhbml6YXRpb24iLCJvcmdhbml6YXRpb24iLCJhdXRoIiwiYXBpQmFzZSIsIl9fbmFtZSIsIm9wdGlvbnMiLCJjYiIsIl9yZXF1ZXN0IiwicmVxdWVzdE9wdGlvbnMiLCJfZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cyIsImRpcmVjdGlvbiIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJ1c2VybmFtZSIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJ1bmRlZmluZWQiLCJBY2NlcHRIZWFkZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLFk7OztBQUNIOzs7Ozs7QUFNQSx3QkFBWUMsWUFBWixFQUEwQkMsSUFBMUIsRUFBZ0NDLE9BQWhDLEVBQXlDO0FBQUE7O0FBQUEsNEhBQ2hDRCxJQURnQyxFQUMxQkMsT0FEMEI7O0FBRXRDLFVBQUtDLE1BQUwsR0FBY0gsWUFBZDtBQUZzQztBQUd4Qzs7QUFFRDs7Ozs7Ozs7Ozs7K0JBT1dJLE8sRUFBU0MsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsYUFBK0IsS0FBS0gsTUFBcEMsYUFBb0RDLE9BQXBELEVBQTZEQyxFQUE3RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs2QkFNU0EsRSxFQUFJO0FBQ1YsVUFBSUUsaUJBQWlCLEtBQUtDLHVCQUFMLENBQTZCLEVBQUNDLFdBQVcsTUFBWixFQUE3QixDQUFyQjs7QUFFQSxhQUFPLEtBQUtDLGdCQUFMLFlBQStCLEtBQUtQLE1BQXBDLGFBQW9ESSxjQUFwRCxFQUFvRUYsRUFBcEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NkJBTVNNLFEsRUFBVU4sRSxFQUFJO0FBQ3BCLGFBQU8sS0FBS08sZ0JBQUwsWUFBK0IsS0FBS1QsTUFBcEMsaUJBQXNEUSxRQUF0RCxFQUFrRSxJQUFsRSxFQUF3RU4sRUFBeEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Z0NBU1lELE8sRUFBU0MsRSxFQUFJO0FBQ3RCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsYUFBOEIsS0FBS0gsTUFBbkMsZUFBcURDLE9BQXJELEVBQThEQyxFQUE5RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs2QkFNU0EsRSxFQUFJO0FBQ1YsYUFBTyxLQUFLSyxnQkFBTCxZQUErQixLQUFLUCxNQUFwQyxhQUFvRFUsU0FBcEQsRUFBK0RSLEVBQS9ELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OytCQVlXRCxPLEVBQVNDLEUsRUFBSTtBQUNyQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGFBQStCLEtBQUtILE1BQXBDLGFBQW9EQyxPQUFwRCxFQUE2REMsRUFBN0QsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTWFBLEUsRUFBSTtBQUNkLGFBQU8sS0FBS0ssZ0JBQUwsWUFBK0IsS0FBS1AsTUFBcEMsZ0JBQXVELEVBQUNXLGNBQWMsaUJBQWYsRUFBdkQsRUFBMEZULEVBQTFGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztrQ0FPY0QsTyxFQUFTQyxFLEVBQUk7QUFDeEJELGdCQUFVQSxXQUFXLEVBQXJCO0FBQ0FBLGNBQVFVLFlBQVIsR0FBdUIsaUJBQXZCO0FBQ0EsYUFBTyxLQUFLUixRQUFMLENBQWMsTUFBZCxhQUErQixLQUFLSCxNQUFwQyxnQkFBdURDLE9BQXZELEVBQWdFQyxFQUFoRSxDQUFQO0FBQ0Y7Ozs7OztBQUdKVSxPQUFPQyxPQUFQLEdBQWlCakIsWUFBakIiLCJmaWxlIjoiT3JnYW5pemF0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogT3JnYW5pemF0aW9uIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBjcmVhdGUgcmVwb3NpdG9yaWVzIGluIG9yZ2FuaXphdGlvbnNcbiAqL1xuY2xhc3MgT3JnYW5pemF0aW9uIGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgT3JnYW5pemF0aW9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3JnYW5pemF0aW9uIC0gdGhlIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3Rvcihvcmdhbml6YXRpb24sIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX25hbWUgPSBvcmdhbml6YXRpb247XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBpbiBhbiBvcmdhbml6YXRpb25cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jY3JlYXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSByZXBvc2l0b3J5IGRlZmluaXRpb25cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGNyZWF0ZWQgcmVwb3NpdG9yeVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVSZXBvKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvb3Jncy8ke3RoaXMuX19uYW1lfS9yZXBvc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSByZXBvc2l0b3JpZXMgaW4gYW4gb3JnYW5pemF0aW9uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2xpc3Qtb3JnYW5pemF0aW9uLXJlcG9zaXRvcmllc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UmVwb3MoY2IpIHtcbiAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNXaXRoRGVmYXVsdHMoe2RpcmVjdGlvbjogJ2Rlc2MnfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3JlcG9zYCwgcmVxdWVzdE9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBRdWVyeSBpZiB0aGUgdXNlciBpcyBhIG1lbWJlciBvciBub3RcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIGluIHF1ZXN0aW9uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHVzZXIgaXMgYSBtZW1iZXJcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNNZW1iZXIodXNlcm5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvb3Jncy8ke3RoaXMuX19uYW1lfS9tZW1iZXJzLyR7dXNlcm5hbWV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXJzIHdobyBhcmUgbWVtYmVycyBvZiB0aGUgY29tcGFueVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvbWVtYmVycy8jbWVtYmVycy1saXN0XG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGZpbHRlcmluZyBvcHRpb25zXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsdGVyPWFsbF0gLSBjYW4gYmUgZWl0aGVyIGAyZmFfZGlzYWJsZWRgIG9yIGBhbGxgXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm9sZT1hbGxdIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBhZG1pbmAsIG9yIGBtZW1iZXJgXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIHVzZXJzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RNZW1iZXJzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9vcmdzLyR7dGhpcy5fX25hbWV9L21lbWJlcnNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgVGVhbXMgaW4gdGhlIE9yZ2FuaXphdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2xpc3QtdGVhbXNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgdGVhbXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0VGVhbXMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3RlYW1zYCwgdW5kZWZpbmVkLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgdGVhbVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2NyZWF0ZS10ZWFtXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRlYW0gY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0ZWFtXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIC0gVGVhbSBkZXNjcmlwdGlvblxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlcG9fbmFtZXNdIC0gUmVwb3MgdG8gYWRkIHRoZSB0ZWFtIHRvXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJpdmFjeT1zZWNyZXRdIC0gVGhlIGxldmVsIG9mIHByaXZhY3kgdGhlIHRlYW0gc2hvdWxkIGhhdmUuIENhbiBiZSBlaXRoZXIgb25lXG4gICAgKiBvZjogYHNlY3JldGAsIG9yIGBjbG9zZWRgXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjcmVhdGVkIHRlYW1cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlVGVhbShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL29yZ3MvJHt0aGlzLl9fbmFtZX0vdGVhbXNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCBwcm9qZWN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNsaXN0LW9yZ2FuaXphdGlvbi1wcm9qZWN0c1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBwcm9qZWN0c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UHJvamVjdHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3Byb2plY3RzYCwge0FjY2VwdEhlYWRlcjogJ2luZXJ0aWEtcHJldmlldyd9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9wcm9qZWN0cy8jY3JlYXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIHByb2plY3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUHJvamVjdChvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLkFjY2VwdEhlYWRlciA9ICdpbmVydGlhLXByZXZpZXcnO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL29yZ3MvJHt0aGlzLl9fbmFtZX0vcHJvamVjdHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3JnYW5pemF0aW9uO1xuIl19
	//# sourceMappingURL=Organization.js.map


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(32);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2016 Matt Smith (Development Seed)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:team');

	/**
	 * A Team allows scoping of API requests to a particular Github Organization Team.
	 */

	var Team = function (_Requestable) {
	  _inherits(Team, _Requestable);

	  /**
	   * Create a Team.
	   * @param {string} [teamId] - the id for the team
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Team(teamId, auth, apiBase) {
	    _classCallCheck(this, Team);

	    var _this = _possibleConstructorReturn(this, (Team.__proto__ || Object.getPrototypeOf(Team)).call(this, auth, apiBase));

	    _this.__teamId = teamId;
	    return _this;
	  }

	  /**
	   * Get Team information
	   * @see https://developer.github.com/v3/orgs/teams/#get-team
	   * @param {Requestable.callback} [cb] - will receive the team
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Team, [{
	    key: 'getTeam',
	    value: function getTeam(cb) {
	      log('Fetching Team ' + this.__teamId);
	      return this._request('Get', '/teams/' + this.__teamId, undefined, cb);
	    }

	    /**
	     * List the Team's repositories
	     * @see https://developer.github.com/v3/orgs/teams/#list-team-repos
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listRepos',
	    value: function listRepos(cb) {
	      log('Fetching repositories for Team ' + this.__teamId);
	      return this._requestAllPages('/teams/' + this.__teamId + '/repos', undefined, cb);
	    }

	    /**
	     * Edit Team information
	     * @see https://developer.github.com/v3/orgs/teams/#edit-team
	     * @param {object} options - Parameters for team edit
	     * @param {string} options.name - The name of the team
	     * @param {string} [options.description] - Team description
	     * @param {string} [options.repo_names] - Repos to add the team to
	     * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one
	     * of: `secret`, or `closed`
	     * @param {Requestable.callback} [cb] - will receive the updated team
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editTeam',
	    value: function editTeam(options, cb) {
	      log('Editing Team ' + this.__teamId);
	      return this._request('PATCH', '/teams/' + this.__teamId, options, cb);
	    }

	    /**
	     * List the users who are members of the Team
	     * @see https://developer.github.com/v3/orgs/teams/#list-team-members
	     * @param {object} options - Parameters for listing team users
	     * @param {string} [options.role=all] - can be one of: `all`, `maintainer`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the list of users
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMembers',
	    value: function listMembers(options, cb) {
	      log('Getting members of Team ' + this.__teamId);
	      return this._requestAllPages('/teams/' + this.__teamId + '/members', options, cb);
	    }

	    /**
	     * Get Team membership status for a user
	     * @see https://developer.github.com/v3/orgs/teams/#get-team-membership
	     * @param {string} username - can be one of: `all`, `maintainer`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the membership status of a user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getMembership',
	    value: function getMembership(username, cb) {
	      log('Getting membership of user ' + username + ' in Team ' + this.__teamId);
	      return this._request('GET', '/teams/' + this.__teamId + '/memberships/' + username, undefined, cb);
	    }

	    /**
	     * Add a member to the Team
	     * @see https://developer.github.com/v3/orgs/teams/#add-team-membership
	     * @param {string} username - can be one of: `all`, `maintainer`, or `member`
	     * @param {object} options - Parameters for adding a team member
	     * @param {string} [options.role=member] - The role that this user should have in the team. Can be one
	     * of: `member`, or `maintainer`
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'addMembership',
	    value: function addMembership(username, options, cb) {
	      log('Adding user ' + username + ' to Team ' + this.__teamId);
	      return this._request('PUT', '/teams/' + this.__teamId + '/memberships/' + username, options, cb);
	    }

	    /**
	     * Get repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#remove-team-membership
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'isManagedRepo',
	    value: function isManagedRepo(owner, repo, cb) {
	      log('Getting repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, undefined, cb);
	    }

	    /**
	     * Add or Update repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#add-or-update-team-repository
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {object} options - Parameters for adding or updating repo management for the team
	     * @param {string} [options.permission] - The permission to grant the team on this repository. Can be one
	     * of: `pull`, `push`, or `admin`
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'manageRepo',
	    value: function manageRepo(owner, repo, options, cb) {
	      log('Adding or Updating repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, options, cb, 'PUT');
	    }

	    /**
	     * Remove repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#remove-team-repository
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'unmanageRepo',
	    value: function unmanageRepo(owner, repo, cb) {
	      log('Remove repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, undefined, cb, 'DELETE');
	    }

	    /**
	     * Delete Team
	     * @see https://developer.github.com/v3/orgs/teams/#delete-team
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteTeam',
	    value: function deleteTeam(cb) {
	      log('Deleting Team ' + this.__teamId);
	      return this._request204or404('/teams/' + this.__teamId, undefined, cb, 'DELETE');
	    }
	  }]);

	  return Team;
	}(_Requestable3.default);

	module.exports = Team;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlRlYW0uanMiXSwibmFtZXMiOlsibG9nIiwiVGVhbSIsInRlYW1JZCIsImF1dGgiLCJhcGlCYXNlIiwiX190ZWFtSWQiLCJjYiIsIl9yZXF1ZXN0IiwidW5kZWZpbmVkIiwiX3JlcXVlc3RBbGxQYWdlcyIsIm9wdGlvbnMiLCJ1c2VybmFtZSIsIm93bmVyIiwicmVwbyIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7OztBQVNBLElBQU1BLE1BQU0scUJBQU0sYUFBTixDQUFaOztBQUVBOzs7O0lBR01DLEk7OztBQUNIOzs7Ozs7QUFNQSxnQkFBWUMsTUFBWixFQUFvQkMsSUFBcEIsRUFBMEJDLE9BQTFCLEVBQW1DO0FBQUE7O0FBQUEsNEdBQzFCRCxJQUQwQixFQUNwQkMsT0FEb0I7O0FBRWhDLFVBQUtDLFFBQUwsR0FBZ0JILE1BQWhCO0FBRmdDO0FBR2xDOztBQUVEOzs7Ozs7Ozs7OzRCQU1RSSxFLEVBQUk7QUFDVE4sNkJBQXFCLEtBQUtLLFFBQTFCO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLRixRQUFwQyxFQUFnREcsU0FBaEQsRUFBMkRGLEVBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzhCQU1VQSxFLEVBQUk7QUFDWE4sOENBQXNDLEtBQUtLLFFBQTNDO0FBQ0EsYUFBTyxLQUFLSSxnQkFBTCxhQUFnQyxLQUFLSixRQUFyQyxhQUF1REcsU0FBdkQsRUFBa0VGLEVBQWxFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OzZCQVlTSSxPLEVBQVNKLEUsRUFBSTtBQUNuQk4sNEJBQW9CLEtBQUtLLFFBQXpCO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLRixRQUF0QyxFQUFrREssT0FBbEQsRUFBMkRKLEVBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Z0NBUVlJLE8sRUFBU0osRSxFQUFJO0FBQ3RCTix1Q0FBK0IsS0FBS0ssUUFBcEM7QUFDQSxhQUFPLEtBQUtJLGdCQUFMLGFBQWdDLEtBQUtKLFFBQXJDLGVBQXlESyxPQUF6RCxFQUFrRUosRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2tDQU9jSyxRLEVBQVVMLEUsRUFBSTtBQUN6Qk4sMENBQWtDVyxRQUFsQyxpQkFBc0QsS0FBS04sUUFBM0Q7QUFDQSxhQUFPLEtBQUtFLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLFFBQXBDLHFCQUE0RE0sUUFBNUQsRUFBd0VILFNBQXhFLEVBQW1GRixFQUFuRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7a0NBVWNLLFEsRUFBVUQsTyxFQUFTSixFLEVBQUk7QUFDbENOLDJCQUFtQlcsUUFBbkIsaUJBQXVDLEtBQUtOLFFBQTVDO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLRixRQUFwQyxxQkFBNERNLFFBQTVELEVBQXdFRCxPQUF4RSxFQUFpRkosRUFBakYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztrQ0FRY00sSyxFQUFPQyxJLEVBQU1QLEUsRUFBSTtBQUM1Qk4sK0NBQXVDLEtBQUtLLFFBQTVDLGtCQUFpRU8sS0FBakUsU0FBMEVDLElBQTFFO0FBQ0EsYUFBTyxLQUFLQyxnQkFBTCxhQUFnQyxLQUFLVCxRQUFyQyxlQUF1RE8sS0FBdkQsU0FBZ0VDLElBQWhFLEVBQXdFTCxTQUF4RSxFQUFtRkYsRUFBbkYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7OzsrQkFXV00sSyxFQUFPQyxJLEVBQU1ILE8sRUFBU0osRSxFQUFJO0FBQ2xDTiwwREFBa0QsS0FBS0ssUUFBdkQsa0JBQTRFTyxLQUE1RSxTQUFxRkMsSUFBckY7QUFDQSxhQUFPLEtBQUtDLGdCQUFMLGFBQWdDLEtBQUtULFFBQXJDLGVBQXVETyxLQUF2RCxTQUFnRUMsSUFBaEUsRUFBd0VILE9BQXhFLEVBQWlGSixFQUFqRixFQUFxRixLQUFyRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFhTSxLLEVBQU9DLEksRUFBTVAsRSxFQUFJO0FBQzNCTiw4Q0FBc0MsS0FBS0ssUUFBM0Msa0JBQWdFTyxLQUFoRSxTQUF5RUMsSUFBekU7QUFDQSxhQUFPLEtBQUtDLGdCQUFMLGFBQWdDLEtBQUtULFFBQXJDLGVBQXVETyxLQUF2RCxTQUFnRUMsSUFBaEUsRUFBd0VMLFNBQXhFLEVBQW1GRixFQUFuRixFQUF1RixRQUF2RixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNV0EsRSxFQUFJO0FBQ1pOLDZCQUFxQixLQUFLSyxRQUExQjtBQUNBLGFBQU8sS0FBS1MsZ0JBQUwsYUFBZ0MsS0FBS1QsUUFBckMsRUFBaURHLFNBQWpELEVBQTRERixFQUE1RCxFQUFnRSxRQUFoRSxDQUFQO0FBQ0Y7Ozs7OztBQUdKUyxPQUFPQyxPQUFQLEdBQWlCZixJQUFqQiIsImZpbGUiOiJUZWFtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxNiBNYXR0IFNtaXRoIChEZXZlbG9wbWVudCBTZWVkKVxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuY29uc3QgbG9nID0gZGVidWcoJ2dpdGh1Yjp0ZWFtJyk7XG5cbi8qKlxuICogQSBUZWFtIGFsbG93cyBzY29waW5nIG9mIEFQSSByZXF1ZXN0cyB0byBhIHBhcnRpY3VsYXIgR2l0aHViIE9yZ2FuaXphdGlvbiBUZWFtLlxuICovXG5jbGFzcyBUZWFtIGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBUZWFtLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZWFtSWRdIC0gdGhlIGlkIGZvciB0aGUgdGVhbVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3Rvcih0ZWFtSWQsIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX3RlYW1JZCA9IHRlYW1JZDtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgVGVhbSBpbmZvcm1hdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2dldC10ZWFtXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSB0ZWFtXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFRlYW0oY2IpIHtcbiAgICAgIGxvZyhgRmV0Y2hpbmcgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR2V0JywgYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9YCwgdW5kZWZpbmVkLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgVGVhbSdzIHJlcG9zaXRvcmllc1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2xpc3QtdGVhbS1yZXBvc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFJlcG9zKGNiKSB7XG4gICAgICBsb2coYEZldGNoaW5nIHJlcG9zaXRvcmllcyBmb3IgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvdGVhbXMvJHt0aGlzLl9fdGVhbUlkfS9yZXBvc2AsIHVuZGVmaW5lZCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEVkaXQgVGVhbSBpbmZvcm1hdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2VkaXQtdGVhbVxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIGZvciB0ZWFtIGVkaXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGVhbVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSAtIFRlYW0gZGVzY3JpcHRpb25cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXBvX25hbWVzXSAtIFJlcG9zIHRvIGFkZCB0aGUgdGVhbSB0b1xuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByaXZhY3k9c2VjcmV0XSAtIFRoZSBsZXZlbCBvZiBwcml2YWN5IHRoZSB0ZWFtIHNob3VsZCBoYXZlLiBDYW4gYmUgZWl0aGVyIG9uZVxuICAgICogb2Y6IGBzZWNyZXRgLCBvciBgY2xvc2VkYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCB0ZWFtXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGVkaXRUZWFtKG9wdGlvbnMsIGNiKSB7XG4gICAgICBsb2coYEVkaXRpbmcgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgdXNlcnMgd2hvIGFyZSBtZW1iZXJzIG9mIHRoZSBUZWFtXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy90ZWFtcy8jbGlzdC10ZWFtLW1lbWJlcnNcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gUGFyYW1ldGVycyBmb3IgbGlzdGluZyB0ZWFtIHVzZXJzXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm9sZT1hbGxdIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBtYWludGFpbmVyYCwgb3IgYG1lbWJlcmBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgdXNlcnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdE1lbWJlcnMob3B0aW9ucywgY2IpIHtcbiAgICAgIGxvZyhgR2V0dGluZyBtZW1iZXJzIG9mIFRlYW0gJHt0aGlzLl9fdGVhbUlkfWApO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgVGVhbSBtZW1iZXJzaGlwIHN0YXR1cyBmb3IgYSB1c2VyXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy90ZWFtcy8jZ2V0LXRlYW0tbWVtYmVyc2hpcFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBtYWludGFpbmVyYCwgb3IgYG1lbWJlcmBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lbWJlcnNoaXAgc3RhdHVzIG9mIGEgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRNZW1iZXJzaGlwKHVzZXJuYW1lLCBjYikge1xuICAgICAgbG9nKGBHZXR0aW5nIG1lbWJlcnNoaXAgb2YgdXNlciAke3VzZXJuYW1lfSBpbiBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2hpcHMvJHt1c2VybmFtZX1gLCB1bmRlZmluZWQsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBtZW1iZXIgdG8gdGhlIFRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNhZGQtdGVhbS1tZW1iZXJzaGlwXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgLSBjYW4gYmUgb25lIG9mOiBgYWxsYCwgYG1haW50YWluZXJgLCBvciBgbWVtYmVyYFxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIGZvciBhZGRpbmcgYSB0ZWFtIG1lbWJlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJvbGU9bWVtYmVyXSAtIFRoZSByb2xlIHRoYXQgdGhpcyB1c2VyIHNob3VsZCBoYXZlIGluIHRoZSB0ZWFtLiBDYW4gYmUgb25lXG4gICAgKiBvZjogYG1lbWJlcmAsIG9yIGBtYWludGFpbmVyYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBhZGRNZW1iZXJzaGlwKHVzZXJuYW1lLCBvcHRpb25zLCBjYikge1xuICAgICAgbG9nKGBBZGRpbmcgdXNlciAke3VzZXJuYW1lfSB0byBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2hpcHMvJHt1c2VybmFtZX1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHJlcG8gbWFuYWdlbWVudCBzdGF0dXMgZm9yIHRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNyZW1vdmUtdGVhbS1tZW1iZXJzaGlwXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXIgLSBPcmdhbml6YXRpb24gbmFtZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcG8gLSBSZXBvIG5hbWVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lbWJlcnNoaXAgc3RhdHVzIG9mIGFkZGVkIHVzZXJcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNNYW5hZ2VkUmVwbyhvd25lciwgcmVwbywgY2IpIHtcbiAgICAgIGxvZyhgR2V0dGluZyByZXBvIG1hbmFnZW1lbnQgYnkgVGVhbSAke3RoaXMuX190ZWFtSWR9IGZvciByZXBvICR7b3duZXJ9LyR7cmVwb31gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9L3JlcG9zLyR7b3duZXJ9LyR7cmVwb31gLCB1bmRlZmluZWQsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgb3IgVXBkYXRlIHJlcG8gbWFuYWdlbWVudCBzdGF0dXMgZm9yIHRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNhZGQtb3ItdXBkYXRlLXRlYW0tcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG93bmVyIC0gT3JnYW5pemF0aW9uIG5hbWVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gUmVwbyBuYW1lXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgZm9yIGFkZGluZyBvciB1cGRhdGluZyByZXBvIG1hbmFnZW1lbnQgZm9yIHRoZSB0ZWFtXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVybWlzc2lvbl0gLSBUaGUgcGVybWlzc2lvbiB0byBncmFudCB0aGUgdGVhbSBvbiB0aGlzIHJlcG9zaXRvcnkuIENhbiBiZSBvbmVcbiAgICAqIG9mOiBgcHVsbGAsIGBwdXNoYCwgb3IgYGFkbWluYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtYW5hZ2VSZXBvKG93bmVyLCByZXBvLCBvcHRpb25zLCBjYikge1xuICAgICAgbG9nKGBBZGRpbmcgb3IgVXBkYXRpbmcgcmVwbyBtYW5hZ2VtZW50IGJ5IFRlYW0gJHt0aGlzLl9fdGVhbUlkfSBmb3IgcmVwbyAke293bmVyfS8ke3JlcG99YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvdGVhbXMvJHt0aGlzLl9fdGVhbUlkfS9yZXBvcy8ke293bmVyfS8ke3JlcG99YCwgb3B0aW9ucywgY2IsICdQVVQnKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBSZW1vdmUgcmVwbyBtYW5hZ2VtZW50IHN0YXR1cyBmb3IgdGVhbVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI3JlbW92ZS10ZWFtLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lciAtIE9yZ2FuaXphdGlvbiBuYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbyAtIFJlcG8gbmFtZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bm1hbmFnZVJlcG8ob3duZXIsIHJlcG8sIGNiKSB7XG4gICAgICBsb2coYFJlbW92ZSByZXBvIG1hbmFnZW1lbnQgYnkgVGVhbSAke3RoaXMuX190ZWFtSWR9IGZvciByZXBvICR7b3duZXJ9LyR7cmVwb31gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9L3JlcG9zLyR7b3duZXJ9LyR7cmVwb31gLCB1bmRlZmluZWQsIGNiLCAnREVMRVRFJyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIFRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNkZWxldGUtdGVhbVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlVGVhbShjYikge1xuICAgICAgbG9nKGBEZWxldGluZyBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9YCwgdW5kZWZpbmVkLCBjYiwgJ0RFTEVURScpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlYW07XG4iXX0=
	//# sourceMappingURL=Team.js.map


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Renders html from Markdown text
	 */
	var Markdown = function (_Requestable) {
	  _inherits(Markdown, _Requestable);

	  /**
	   * construct a Markdown
	   * @param {Requestable.auth} auth - the credentials to authenticate to GitHub
	   * @param {string} [apiBase] - the base Github API URL
	   * @return {Promise} - the promise for the http request
	   */
	  function Markdown(auth, apiBase) {
	    _classCallCheck(this, Markdown);

	    return _possibleConstructorReturn(this, (Markdown.__proto__ || Object.getPrototypeOf(Markdown)).call(this, auth, apiBase));
	  }

	  /**
	   * Render html from Markdown text.
	   * @see https://developer.github.com/v3/markdown/#render-an-arbitrary-markdown-document
	   * @param {Object} options - conversion options
	   * @param {string} [options.text] - the markdown text to convert
	   * @param {string} [options.mode=markdown] - can be either `markdown` or `gfm`
	   * @param {string} [options.context] - repository name if mode is gfm
	   * @param {Requestable.callback} [cb] - will receive the converted html
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Markdown, [{
	    key: 'render',
	    value: function render(options, cb) {
	      return this._request('POST', '/markdown', options, cb);
	    }
	  }]);

	  return Markdown;
	}(_Requestable3.default);

	module.exports = Markdown;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1hcmtkb3duLmpzIl0sIm5hbWVzIjpbIk1hcmtkb3duIiwiYXV0aCIsImFwaUJhc2UiLCJvcHRpb25zIiwiY2IiLCJfcmVxdWVzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7OztBQVNBOzs7SUFHTUEsUTs7O0FBQ0g7Ozs7OztBQU1BLG9CQUFZQyxJQUFaLEVBQWtCQyxPQUFsQixFQUEyQjtBQUFBOztBQUFBLCtHQUNsQkQsSUFEa0IsRUFDWkMsT0FEWTtBQUUxQjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7MkJBVU9DLE8sRUFBU0MsRSxFQUFJO0FBQ2pCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsRUFBc0IsV0FBdEIsRUFBbUNGLE9BQW5DLEVBQTRDQyxFQUE1QyxDQUFQO0FBQ0Y7Ozs7OztBQUdKRSxPQUFPQyxPQUFQLEdBQWlCUCxRQUFqQiIsImZpbGUiOiJNYXJrZG93bi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cblxuaW1wb3J0IFJlcXVlc3RhYmxlIGZyb20gJy4vUmVxdWVzdGFibGUnO1xuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCBmcm9tIE1hcmtkb3duIHRleHRcbiAqL1xuY2xhc3MgTWFya2Rvd24gZXh0ZW5kcyBSZXF1ZXN0YWJsZSB7XG4gICAvKipcbiAgICAqIGNvbnN0cnVjdCBhIE1hcmtkb3duXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IGF1dGggLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdEh1YlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFJlbmRlciBodG1sIGZyb20gTWFya2Rvd24gdGV4dC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9tYXJrZG93bi8jcmVuZGVyLWFuLWFyYml0cmFyeS1tYXJrZG93bi1kb2N1bWVudFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb252ZXJzaW9uIG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0XSAtIHRoZSBtYXJrZG93biB0ZXh0IHRvIGNvbnZlcnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tb2RlPW1hcmtkb3duXSAtIGNhbiBiZSBlaXRoZXIgYG1hcmtkb3duYCBvciBgZ2ZtYFxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRleHRdIC0gcmVwb3NpdG9yeSBuYW1lIGlmIG1vZGUgaXMgZ2ZtXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb252ZXJ0ZWQgaHRtbFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICByZW5kZXIob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgJy9tYXJrZG93bicsIG9wdGlvbnMsIGNiKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcbiJdfQ==
	//# sourceMappingURL=Markdown.js.map


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(5);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Project encapsulates the functionality to create, query, and modify cards and columns.
	 */
	var Project = function (_Requestable) {
	   _inherits(Project, _Requestable);

	   /**
	    * Create a Project.
	    * @param {string} id - the id of the project
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function Project(id, auth, apiBase) {
	      _classCallCheck(this, Project);

	      var _this = _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).call(this, auth, apiBase, 'inertia-preview'));

	      _this.__id = id;
	      return _this;
	   }

	   /**
	    * Get information about a project
	    * @see https://developer.github.com/v3/projects/#get-a-project
	    * @param {Requestable.callback} cb - will receive the project information
	    * @return {Promise} - the promise for the http request
	    */


	   _createClass(Project, [{
	      key: 'getProject',
	      value: function getProject(cb) {
	         return this._request('GET', '/projects/' + this.__id, null, cb);
	      }

	      /**
	       * Edit a project
	       * @see https://developer.github.com/v3/projects/#update-a-project
	       * @param {Object} options - the description of the project
	       * @param {Requestable.callback} cb - will receive the modified project
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateProject',
	      value: function updateProject(options, cb) {
	         return this._request('PATCH', '/projects/' + this.__id, options, cb);
	      }

	      /**
	       * Delete a project
	       * @see https://developer.github.com/v3/projects/#delete-a-project
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteProject',
	      value: function deleteProject(cb) {
	         return this._request('DELETE', '/projects/' + this.__id, null, cb);
	      }

	      /**
	       * Get information about all columns of a project
	       * @see https://developer.github.com/v3/projects/columns/#list-project-columns
	       * @param {Requestable.callback} [cb] - will receive the list of columns
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjectColumns',
	      value: function listProjectColumns(cb) {
	         return this._requestAllPages('/projects/' + this.__id + '/columns', null, cb);
	      }

	      /**
	       * Get information about a column
	       * @see https://developer.github.com/v3/projects/columns/#get-a-project-column
	       * @param {string} colId - the id of the column
	       * @param {Requestable.callback} cb - will receive the column information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getProjectColumn',
	      value: function getProjectColumn(colId, cb) {
	         return this._request('GET', '/projects/columns/' + colId, null, cb);
	      }

	      /**
	       * Create a new column
	       * @see https://developer.github.com/v3/projects/columns/#create-a-project-column
	       * @param {Object} options - the description of the column
	       * @param {Requestable.callback} cb - will receive the newly created column
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createProjectColumn',
	      value: function createProjectColumn(options, cb) {
	         return this._request('POST', '/projects/' + this.__id + '/columns', options, cb);
	      }

	      /**
	       * Edit a column
	       * @see https://developer.github.com/v3/projects/columns/#update-a-project-column
	       * @param {string} colId - the column id
	       * @param {Object} options - the description of the column
	       * @param {Requestable.callback} cb - will receive the modified column
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateProjectColumn',
	      value: function updateProjectColumn(colId, options, cb) {
	         return this._request('PATCH', '/projects/columns/' + colId, options, cb);
	      }

	      /**
	       * Delete a column
	       * @see https://developer.github.com/v3/projects/columns/#delete-a-project-column
	       * @param {string} colId - the column to be deleted
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteProjectColumn',
	      value: function deleteProjectColumn(colId, cb) {
	         return this._request('DELETE', '/projects/columns/' + colId, null, cb);
	      }

	      /**
	       * Move a column
	       * @see https://developer.github.com/v3/projects/columns/#move-a-project-column
	       * @param {string} colId - the column to be moved
	       * @param {string} position - can be one of first, last, or after:<column-id>,
	       * where <column-id> is the id value of a column in the same project.
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'moveProjectColumn',
	      value: function moveProjectColumn(colId, position, cb) {
	         return this._request('POST', '/projects/columns/' + colId + '/moves', { position: position }, cb);
	      }

	      /**
	       * Get information about all cards of a project
	       * @see https://developer.github.com/v3/projects/cards/#list-project-cards
	       * @param {Requestable.callback} [cb] - will receive the list of cards
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjectCards',
	      value: function listProjectCards(cb) {
	         var _this2 = this;

	         return this.listProjectColumns().then(function (_ref) {
	            var data = _ref.data;

	            return Promise.all(data.map(function (column) {
	               return _this2._requestAllPages('/projects/columns/' + column.id + '/cards', null);
	            }));
	         }).then(function (cardsInColumns) {
	            var cards = cardsInColumns.reduce(function (prev, _ref2) {
	               var data = _ref2.data;

	               prev.push.apply(prev, _toConsumableArray(data));
	               return prev;
	            }, []);
	            if (cb) {
	               cb(null, cards);
	            }
	            return cards;
	         }).catch(function (err) {
	            if (cb) {
	               cb(err);
	               return;
	            }
	            throw err;
	         });
	      }

	      /**
	      * Get information about all cards of a column
	      * @see https://developer.github.com/v3/projects/cards/#list-project-cards
	      * @param {string} colId - the id of the column
	      * @param {Requestable.callback} [cb] - will receive the list of cards
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'listColumnCards',
	      value: function listColumnCards(colId, cb) {
	         return this._requestAllPages('/projects/columns/' + colId + '/cards', null, cb);
	      }

	      /**
	      * Get information about a card
	      * @see https://developer.github.com/v3/projects/cards/#get-a-project-card
	      * @param {string} cardId - the id of the card
	      * @param {Requestable.callback} cb - will receive the card information
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'getProjectCard',
	      value: function getProjectCard(cardId, cb) {
	         return this._request('GET', '/projects/columns/cards/' + cardId, null, cb);
	      }

	      /**
	      * Create a new card
	      * @see https://developer.github.com/v3/projects/cards/#create-a-project-card
	      * @param {string} colId - the column id
	      * @param {Object} options - the description of the card
	      * @param {Requestable.callback} cb - will receive the newly created card
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'createProjectCard',
	      value: function createProjectCard(colId, options, cb) {
	         return this._request('POST', '/projects/columns/' + colId + '/cards', options, cb);
	      }

	      /**
	      * Edit a card
	      * @see https://developer.github.com/v3/projects/cards/#update-a-project-card
	      * @param {string} cardId - the card id
	      * @param {Object} options - the description of the card
	      * @param {Requestable.callback} cb - will receive the modified card
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'updateProjectCard',
	      value: function updateProjectCard(cardId, options, cb) {
	         return this._request('PATCH', '/projects/columns/cards/' + cardId, options, cb);
	      }

	      /**
	      * Delete a card
	      * @see https://developer.github.com/v3/projects/cards/#delete-a-project-card
	      * @param {string} cardId - the card to be deleted
	      * @param {Requestable.callback} cb - will receive true if the operation is successful
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'deleteProjectCard',
	      value: function deleteProjectCard(cardId, cb) {
	         return this._request('DELETE', '/projects/columns/cards/' + cardId, null, cb);
	      }

	      /**
	      * Move a card
	      * @see https://developer.github.com/v3/projects/cards/#move-a-project-card
	      * @param {string} cardId - the card to be moved
	      * @param {string} position - can be one of top, bottom, or after:<card-id>,
	      * where <card-id> is the id value of a card in the same project.
	      * @param {string} colId - the id value of a column in the same project.
	      * @param {Requestable.callback} cb - will receive true if the operation is successful
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'moveProjectCard',
	      value: function moveProjectCard(cardId, position, colId, cb) {
	         return this._request('POST', '/projects/columns/cards/' + cardId + '/moves', { position: position, column_id: colId }, // eslint-disable-line camelcase
	         cb);
	      }
	   }]);

	   return Project;
	}(_Requestable3.default);

	module.exports = Project;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlByb2plY3QuanMiXSwibmFtZXMiOlsiUHJvamVjdCIsImlkIiwiYXV0aCIsImFwaUJhc2UiLCJfX2lkIiwiY2IiLCJfcmVxdWVzdCIsIm9wdGlvbnMiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiY29sSWQiLCJwb3NpdGlvbiIsImxpc3RQcm9qZWN0Q29sdW1ucyIsInRoZW4iLCJkYXRhIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNvbHVtbiIsImNhcmRzSW5Db2x1bW5zIiwiY2FyZHMiLCJyZWR1Y2UiLCJwcmV2IiwicHVzaCIsImNhdGNoIiwiZXJyIiwiY2FyZElkIiwiY29sdW1uX2lkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BOzs7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLE87OztBQUNIOzs7Ozs7QUFNQSxvQkFBWUMsRUFBWixFQUFnQkMsSUFBaEIsRUFBc0JDLE9BQXRCLEVBQStCO0FBQUE7O0FBQUEsb0hBQ3RCRCxJQURzQixFQUNoQkMsT0FEZ0IsRUFDUCxpQkFETzs7QUFFNUIsWUFBS0MsSUFBTCxHQUFZSCxFQUFaO0FBRjRCO0FBRzlCOztBQUVEOzs7Ozs7Ozs7O2lDQU1XSSxFLEVBQUk7QUFDWixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxpQkFBa0MsS0FBS0YsSUFBdkMsRUFBK0MsSUFBL0MsRUFBcURDLEVBQXJELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPY0UsTyxFQUFTRixFLEVBQUk7QUFDeEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsaUJBQW9DLEtBQUtGLElBQXpDLEVBQWlERyxPQUFqRCxFQUEwREYsRUFBMUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7b0NBTWNBLEUsRUFBSTtBQUNmLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGlCQUFxQyxLQUFLRixJQUExQyxFQUFrRCxJQUFsRCxFQUF3REMsRUFBeEQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7eUNBTW1CQSxFLEVBQUk7QUFDcEIsZ0JBQU8sS0FBS0csZ0JBQUwsZ0JBQW1DLEtBQUtKLElBQXhDLGVBQXdELElBQXhELEVBQThEQyxFQUE5RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7dUNBT2lCSSxLLEVBQU9KLEUsRUFBSTtBQUN6QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCx5QkFBMENHLEtBQTFDLEVBQW1ELElBQW5ELEVBQXlESixFQUF6RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MENBT29CRSxPLEVBQVNGLEUsRUFBSTtBQUM5QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxpQkFBbUMsS0FBS0YsSUFBeEMsZUFBd0RHLE9BQXhELEVBQWlFRixFQUFqRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzBDQVFvQkksSyxFQUFPRixPLEVBQVNGLEUsRUFBSTtBQUNyQyxnQkFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCx5QkFBNENHLEtBQTVDLEVBQXFERixPQUFyRCxFQUE4REYsRUFBOUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzBDQU9vQkksSyxFQUFPSixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQseUJBQTZDRyxLQUE3QyxFQUFzRCxJQUF0RCxFQUE0REosRUFBNUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7d0NBU2tCSSxLLEVBQU9DLFEsRUFBVUwsRSxFQUFJO0FBQ3BDLGdCQUFPLEtBQUtDLFFBQUwsQ0FDSixNQURJLHlCQUVpQkcsS0FGakIsYUFHSixFQUFDQyxVQUFVQSxRQUFYLEVBSEksRUFJSkwsRUFKSSxDQUFQO0FBTUY7O0FBRUY7Ozs7Ozs7Ozt1Q0FNa0JBLEUsRUFBSTtBQUFBOztBQUNsQixnQkFBTyxLQUFLTSxrQkFBTCxHQUNKQyxJQURJLENBQ0MsZ0JBQVk7QUFBQSxnQkFBVkMsSUFBVSxRQUFWQSxJQUFVOztBQUNmLG1CQUFPQyxRQUFRQyxHQUFSLENBQVlGLEtBQUtHLEdBQUwsQ0FBUyxVQUFDQyxNQUFELEVBQVk7QUFDckMsc0JBQU8sT0FBS1QsZ0JBQUwsd0JBQTJDUyxPQUFPaEIsRUFBbEQsYUFBOEQsSUFBOUQsQ0FBUDtBQUNGLGFBRmtCLENBQVosQ0FBUDtBQUdGLFVBTEksRUFLRlcsSUFMRSxDQUtHLFVBQUNNLGNBQUQsRUFBb0I7QUFDekIsZ0JBQU1DLFFBQVFELGVBQWVFLE1BQWYsQ0FBc0IsVUFBQ0MsSUFBRCxTQUFrQjtBQUFBLG1CQUFWUixJQUFVLFNBQVZBLElBQVU7O0FBQ25EUSxvQkFBS0MsSUFBTCxnQ0FBYVQsSUFBYjtBQUNBLHNCQUFPUSxJQUFQO0FBQ0YsYUFIYSxFQUdYLEVBSFcsQ0FBZDtBQUlBLGdCQUFJaEIsRUFBSixFQUFRO0FBQ0xBLGtCQUFHLElBQUgsRUFBU2MsS0FBVDtBQUNGO0FBQ0QsbUJBQU9BLEtBQVA7QUFDRixVQWRJLEVBY0ZJLEtBZEUsQ0FjSSxVQUFDQyxHQUFELEVBQVM7QUFDZixnQkFBSW5CLEVBQUosRUFBUTtBQUNMQSxrQkFBR21CLEdBQUg7QUFDQTtBQUNGO0FBQ0Qsa0JBQU1BLEdBQU47QUFDRixVQXBCSSxDQUFQO0FBcUJGOztBQUVEOzs7Ozs7Ozs7O3NDQU9nQmYsSyxFQUFPSixFLEVBQUk7QUFDeEIsZ0JBQU8sS0FBS0csZ0JBQUwsd0JBQTJDQyxLQUEzQyxhQUEwRCxJQUExRCxFQUFnRUosRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3FDQU9lb0IsTSxFQUFRcEIsRSxFQUFJO0FBQ3hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLCtCQUFnRG1CLE1BQWhELEVBQTBELElBQTFELEVBQWdFcEIsRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt3Q0FRa0JJLEssRUFBT0YsTyxFQUFTRixFLEVBQUk7QUFDbkMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQseUJBQTJDRyxLQUEzQyxhQUEwREYsT0FBMUQsRUFBbUVGLEVBQW5FLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7d0NBUWtCb0IsTSxFQUFRbEIsTyxFQUFTRixFLEVBQUk7QUFDcEMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsK0JBQWtEbUIsTUFBbEQsRUFBNERsQixPQUE1RCxFQUFxRUYsRUFBckUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQm9CLE0sRUFBUXBCLEUsRUFBSTtBQUMzQixnQkFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCwrQkFBbURtQixNQUFuRCxFQUE2RCxJQUE3RCxFQUFtRXBCLEVBQW5FLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OztzQ0FVZ0JvQixNLEVBQVFmLFEsRUFBVUQsSyxFQUFPSixFLEVBQUk7QUFDMUMsZ0JBQU8sS0FBS0MsUUFBTCxDQUNKLE1BREksK0JBRXVCbUIsTUFGdkIsYUFHSixFQUFDZixVQUFVQSxRQUFYLEVBQXFCZ0IsV0FBV2pCLEtBQWhDLEVBSEksRUFHb0M7QUFDeENKLFdBSkksQ0FBUDtBQU1GOzs7Ozs7QUFHSnNCLE9BQU9DLE9BQVAsR0FBaUI1QixPQUFqQiIsImZpbGUiOiJQcm9qZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogUHJvamVjdCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gY3JlYXRlLCBxdWVyeSwgYW5kIG1vZGlmeSBjYXJkcyBhbmQgY29sdW1ucy5cbiAqL1xuY2xhc3MgUHJvamVjdCBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgUHJvamVjdC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihpZCwgYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSwgJ2luZXJ0aWEtcHJldmlldycpO1xuICAgICAgdGhpcy5fX2lkID0gaWQ7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvamVjdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNnZXQtYS1wcm9qZWN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgcHJvamVjdCBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRQcm9qZWN0KGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9wcm9qZWN0cy8ke3RoaXMuX19pZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jdXBkYXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBwcm9qZWN0XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZVByb2plY3Qob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jZGVsZXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlUHJvamVjdChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY29sdW1ucyBvZiBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jb2x1bW5zLyNsaXN0LXByb2plY3QtY29sdW1uc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjb2x1bW5zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RQcm9qZWN0Q29sdW1ucyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzLyR7dGhpcy5fX2lkfS9jb2x1bW5zYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI2dldC1hLXByb2plY3QtY29sdW1uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29sSWQgLSB0aGUgaWQgb2YgdGhlIGNvbHVtblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbHVtbiBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRQcm9qZWN0Q29sdW1uKGNvbElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcHJvamVjdHMvY29sdW1ucy8ke2NvbElkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgY29sdW1uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY29sdW1ucy8jY3JlYXRlLWEtcHJvamVjdC1jb2x1bW5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjb2x1bW5cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIGNvbHVtblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVQcm9qZWN0Q29sdW1uKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9L2NvbHVtbnNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI3VwZGF0ZS1hLXByb2plY3QtY29sdW1uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29sSWQgLSB0aGUgY29sdW1uIGlkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29sdW1uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbW9kaWZpZWQgY29sdW1uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZVByb2plY3RDb2x1bW4oY29sSWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgY29sdW1uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY29sdW1ucy8jZGVsZXRlLWEtcHJvamVjdC1jb2x1bW5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xJZCAtIHRoZSBjb2x1bW4gdG8gYmUgZGVsZXRlZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlUHJvamVjdENvbHVtbihjb2xJZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTW92ZSBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI21vdmUtYS1wcm9qZWN0LWNvbHVtblxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGNvbHVtbiB0byBiZSBtb3ZlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIC0gY2FuIGJlIG9uZSBvZiBmaXJzdCwgbGFzdCwgb3IgYWZ0ZXI6PGNvbHVtbi1pZD4sXG4gICAgKiB3aGVyZSA8Y29sdW1uLWlkPiBpcyB0aGUgaWQgdmFsdWUgb2YgYSBjb2x1bW4gaW4gdGhlIHNhbWUgcHJvamVjdC5cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIG1vdmVQcm9qZWN0Q29sdW1uKGNvbElkLCBwb3NpdGlvbiwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KFxuICAgICAgICAgJ1BPU1QnLFxuICAgICAgICAgYC9wcm9qZWN0cy9jb2x1bW5zLyR7Y29sSWR9L21vdmVzYCxcbiAgICAgICAgIHtwb3NpdGlvbjogcG9zaXRpb259LFxuICAgICAgICAgY2JcbiAgICAgICk7XG4gICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2FyZHMgb2YgYSBwcm9qZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jYXJkcy8jbGlzdC1wcm9qZWN0LWNhcmRzXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY2FyZHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGxpc3RQcm9qZWN0Q2FyZHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RQcm9qZWN0Q29sdW1ucygpXG4gICAgICAgIC50aGVuKCh7ZGF0YX0pID0+IHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGRhdGEubWFwKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2x1bW4uaWR9L2NhcmRzYCwgbnVsbCk7XG4gICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkudGhlbigoY2FyZHNJbkNvbHVtbnMpID0+IHtcbiAgICAgICAgICAgY29uc3QgY2FyZHMgPSBjYXJkc0luQ29sdW1ucy5yZWR1Y2UoKHByZXYsIHtkYXRhfSkgPT4ge1xuICAgICAgICAgICAgICBwcmV2LnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihudWxsLCBjYXJkcyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIGNhcmRzO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2FyZHMgb2YgYSBjb2x1bW5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyNsaXN0LXByb2plY3QtY2FyZHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGlkIG9mIHRoZSBjb2x1bW5cbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjYXJkc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgbGlzdENvbHVtbkNhcmRzKGNvbElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH0vY2FyZHNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSBjYXJkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jYXJkcy8jZ2V0LWEtcHJvamVjdC1jYXJkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXJkSWQgLSB0aGUgaWQgb2YgdGhlIGNhcmRcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNhcmQgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGdldFByb2plY3RDYXJkKGNhcmRJZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMvJHtjYXJkSWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNhcmRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyNjcmVhdGUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGNvbHVtbiBpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY2FyZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3bHkgY3JlYXRlZCBjYXJkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBjcmVhdGVQcm9qZWN0Q2FyZChjb2xJZCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9wcm9qZWN0cy9jb2x1bW5zLyR7Y29sSWR9L2NhcmRzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogRWRpdCBhIGNhcmRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyN1cGRhdGUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhcmRJZCAtIHRoZSBjYXJkIGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjYXJkXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBjYXJkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICB1cGRhdGVQcm9qZWN0Q2FyZChjYXJkSWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMvJHtjYXJkSWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogRGVsZXRlIGEgY2FyZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY2FyZHMvI2RlbGV0ZS1hLXByb2plY3QtY2FyZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FyZElkIC0gdGhlIGNhcmQgdG8gYmUgZGVsZXRlZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgZGVsZXRlUHJvamVjdENhcmQoY2FyZElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcHJvamVjdHMvY29sdW1ucy9jYXJkcy8ke2NhcmRJZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgKiBNb3ZlIGEgY2FyZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY2FyZHMvI21vdmUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhcmRJZCAtIHRoZSBjYXJkIHRvIGJlIG1vdmVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAtIGNhbiBiZSBvbmUgb2YgdG9wLCBib3R0b20sIG9yIGFmdGVyOjxjYXJkLWlkPixcbiAgICogd2hlcmUgPGNhcmQtaWQ+IGlzIHRoZSBpZCB2YWx1ZSBvZiBhIGNhcmQgaW4gdGhlIHNhbWUgcHJvamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGlkIHZhbHVlIG9mIGEgY29sdW1uIGluIHRoZSBzYW1lIHByb2plY3QuXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBtb3ZlUHJvamVjdENhcmQoY2FyZElkLCBwb3NpdGlvbiwgY29sSWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChcbiAgICAgICAgICdQT1NUJyxcbiAgICAgICAgIGAvcHJvamVjdHMvY29sdW1ucy9jYXJkcy8ke2NhcmRJZH0vbW92ZXNgLFxuICAgICAgICAge3Bvc2l0aW9uOiBwb3NpdGlvbiwgY29sdW1uX2lkOiBjb2xJZH0sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICBjYlxuICAgICAgKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xuIl19
	//# sourceMappingURL=Project.js.map


/***/ },
/* 51 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	 */
	// @version 0.7.24
	(function() {
	  window.WebComponents = window.WebComponents || {
	    flags: {}
	  };
	  var file = "webcomponents-lite.js";
	  var script = document.querySelector('script[src*="' + file + '"]');
	  var flags = {};
	  if (!flags.noOpts) {
	    location.search.slice(1).split("&").forEach(function(option) {
	      var parts = option.split("=");
	      var match;
	      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
	        flags[match[1]] = parts[1] || true;
	      }
	    });
	    if (script) {
	      for (var i = 0, a; a = script.attributes[i]; i++) {
	        if (a.name !== "src") {
	          flags[a.name] = a.value || true;
	        }
	      }
	    }
	    if (flags.log && flags.log.split) {
	      var parts = flags.log.split(",");
	      flags.log = {};
	      parts.forEach(function(f) {
	        flags.log[f] = true;
	      });
	    } else {
	      flags.log = {};
	    }
	  }
	  if (flags.register) {
	    window.CustomElements = window.CustomElements || {
	      flags: {}
	    };
	    window.CustomElements.flags.register = flags.register;
	  }
	  WebComponents.flags = flags;
	})();

	(function(scope) {
	  "use strict";
	  var hasWorkingUrl = false;
	  if (!scope.forceJURL) {
	    try {
	      var u = new URL("b", "http://a");
	      u.pathname = "c%20d";
	      hasWorkingUrl = u.href === "http://a/c%20d";
	    } catch (e) {}
	  }
	  if (hasWorkingUrl) return;
	  var relative = Object.create(null);
	  relative["ftp"] = 21;
	  relative["file"] = 0;
	  relative["gopher"] = 70;
	  relative["http"] = 80;
	  relative["https"] = 443;
	  relative["ws"] = 80;
	  relative["wss"] = 443;
	  var relativePathDotMapping = Object.create(null);
	  relativePathDotMapping["%2e"] = ".";
	  relativePathDotMapping[".%2e"] = "..";
	  relativePathDotMapping["%2e."] = "..";
	  relativePathDotMapping["%2e%2e"] = "..";
	  function isRelativeScheme(scheme) {
	    return relative[scheme] !== undefined;
	  }
	  function invalid() {
	    clear.call(this);
	    this._isInvalid = true;
	  }
	  function IDNAToASCII(h) {
	    if ("" == h) {
	      invalid.call(this);
	    }
	    return h.toLowerCase();
	  }
	  function percentEscape(c) {
	    var unicode = c.charCodeAt(0);
	    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {
	      return c;
	    }
	    return encodeURIComponent(c);
	  }
	  function percentEscapeQuery(c) {
	    var unicode = c.charCodeAt(0);
	    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {
	      return c;
	    }
	    return encodeURIComponent(c);
	  }
	  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
	  function parse(input, stateOverride, base) {
	    function err(message) {
	      errors.push(message);
	    }
	    var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];
	    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
	      var c = input[cursor];
	      switch (state) {
	       case "scheme start":
	        if (c && ALPHA.test(c)) {
	          buffer += c.toLowerCase();
	          state = "scheme";
	        } else if (!stateOverride) {
	          buffer = "";
	          state = "no scheme";
	          continue;
	        } else {
	          err("Invalid scheme.");
	          break loop;
	        }
	        break;

	       case "scheme":
	        if (c && ALPHANUMERIC.test(c)) {
	          buffer += c.toLowerCase();
	        } else if (":" == c) {
	          this._scheme = buffer;
	          buffer = "";
	          if (stateOverride) {
	            break loop;
	          }
	          if (isRelativeScheme(this._scheme)) {
	            this._isRelative = true;
	          }
	          if ("file" == this._scheme) {
	            state = "relative";
	          } else if (this._isRelative && base && base._scheme == this._scheme) {
	            state = "relative or authority";
	          } else if (this._isRelative) {
	            state = "authority first slash";
	          } else {
	            state = "scheme data";
	          }
	        } else if (!stateOverride) {
	          buffer = "";
	          cursor = 0;
	          state = "no scheme";
	          continue;
	        } else if (EOF == c) {
	          break loop;
	        } else {
	          err("Code point not allowed in scheme: " + c);
	          break loop;
	        }
	        break;

	       case "scheme data":
	        if ("?" == c) {
	          this._query = "?";
	          state = "query";
	        } else if ("#" == c) {
	          this._fragment = "#";
	          state = "fragment";
	        } else {
	          if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
	            this._schemeData += percentEscape(c);
	          }
	        }
	        break;

	       case "no scheme":
	        if (!base || !isRelativeScheme(base._scheme)) {
	          err("Missing scheme.");
	          invalid.call(this);
	        } else {
	          state = "relative";
	          continue;
	        }
	        break;

	       case "relative or authority":
	        if ("/" == c && "/" == input[cursor + 1]) {
	          state = "authority ignore slashes";
	        } else {
	          err("Expected /, got: " + c);
	          state = "relative";
	          continue;
	        }
	        break;

	       case "relative":
	        this._isRelative = true;
	        if ("file" != this._scheme) this._scheme = base._scheme;
	        if (EOF == c) {
	          this._host = base._host;
	          this._port = base._port;
	          this._path = base._path.slice();
	          this._query = base._query;
	          this._username = base._username;
	          this._password = base._password;
	          break loop;
	        } else if ("/" == c || "\\" == c) {
	          if ("\\" == c) err("\\ is an invalid code point.");
	          state = "relative slash";
	        } else if ("?" == c) {
	          this._host = base._host;
	          this._port = base._port;
	          this._path = base._path.slice();
	          this._query = "?";
	          this._username = base._username;
	          this._password = base._password;
	          state = "query";
	        } else if ("#" == c) {
	          this._host = base._host;
	          this._port = base._port;
	          this._path = base._path.slice();
	          this._query = base._query;
	          this._fragment = "#";
	          this._username = base._username;
	          this._password = base._password;
	          state = "fragment";
	        } else {
	          var nextC = input[cursor + 1];
	          var nextNextC = input[cursor + 2];
	          if ("file" != this._scheme || !ALPHA.test(c) || nextC != ":" && nextC != "|" || EOF != nextNextC && "/" != nextNextC && "\\" != nextNextC && "?" != nextNextC && "#" != nextNextC) {
	            this._host = base._host;
	            this._port = base._port;
	            this._username = base._username;
	            this._password = base._password;
	            this._path = base._path.slice();
	            this._path.pop();
	          }
	          state = "relative path";
	          continue;
	        }
	        break;

	       case "relative slash":
	        if ("/" == c || "\\" == c) {
	          if ("\\" == c) {
	            err("\\ is an invalid code point.");
	          }
	          if ("file" == this._scheme) {
	            state = "file host";
	          } else {
	            state = "authority ignore slashes";
	          }
	        } else {
	          if ("file" != this._scheme) {
	            this._host = base._host;
	            this._port = base._port;
	            this._username = base._username;
	            this._password = base._password;
	          }
	          state = "relative path";
	          continue;
	        }
	        break;

	       case "authority first slash":
	        if ("/" == c) {
	          state = "authority second slash";
	        } else {
	          err("Expected '/', got: " + c);
	          state = "authority ignore slashes";
	          continue;
	        }
	        break;

	       case "authority second slash":
	        state = "authority ignore slashes";
	        if ("/" != c) {
	          err("Expected '/', got: " + c);
	          continue;
	        }
	        break;

	       case "authority ignore slashes":
	        if ("/" != c && "\\" != c) {
	          state = "authority";
	          continue;
	        } else {
	          err("Expected authority, got: " + c);
	        }
	        break;

	       case "authority":
	        if ("@" == c) {
	          if (seenAt) {
	            err("@ already seen.");
	            buffer += "%40";
	          }
	          seenAt = true;
	          for (var i = 0; i < buffer.length; i++) {
	            var cp = buffer[i];
	            if ("\t" == cp || "\n" == cp || "\r" == cp) {
	              err("Invalid whitespace in authority.");
	              continue;
	            }
	            if (":" == cp && null === this._password) {
	              this._password = "";
	              continue;
	            }
	            var tempC = percentEscape(cp);
	            null !== this._password ? this._password += tempC : this._username += tempC;
	          }
	          buffer = "";
	        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
	          cursor -= buffer.length;
	          buffer = "";
	          state = "host";
	          continue;
	        } else {
	          buffer += c;
	        }
	        break;

	       case "file host":
	        if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
	          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ":" || buffer[1] == "|")) {
	            state = "relative path";
	          } else if (buffer.length == 0) {
	            state = "relative path start";
	          } else {
	            this._host = IDNAToASCII.call(this, buffer);
	            buffer = "";
	            state = "relative path start";
	          }
	          continue;
	        } else if ("\t" == c || "\n" == c || "\r" == c) {
	          err("Invalid whitespace in file host.");
	        } else {
	          buffer += c;
	        }
	        break;

	       case "host":
	       case "hostname":
	        if (":" == c && !seenBracket) {
	          this._host = IDNAToASCII.call(this, buffer);
	          buffer = "";
	          state = "port";
	          if ("hostname" == stateOverride) {
	            break loop;
	          }
	        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
	          this._host = IDNAToASCII.call(this, buffer);
	          buffer = "";
	          state = "relative path start";
	          if (stateOverride) {
	            break loop;
	          }
	          continue;
	        } else if ("\t" != c && "\n" != c && "\r" != c) {
	          if ("[" == c) {
	            seenBracket = true;
	          } else if ("]" == c) {
	            seenBracket = false;
	          }
	          buffer += c;
	        } else {
	          err("Invalid code point in host/hostname: " + c);
	        }
	        break;

	       case "port":
	        if (/[0-9]/.test(c)) {
	          buffer += c;
	        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c || stateOverride) {
	          if ("" != buffer) {
	            var temp = parseInt(buffer, 10);
	            if (temp != relative[this._scheme]) {
	              this._port = temp + "";
	            }
	            buffer = "";
	          }
	          if (stateOverride) {
	            break loop;
	          }
	          state = "relative path start";
	          continue;
	        } else if ("\t" == c || "\n" == c || "\r" == c) {
	          err("Invalid code point in port: " + c);
	        } else {
	          invalid.call(this);
	        }
	        break;

	       case "relative path start":
	        if ("\\" == c) err("'\\' not allowed in path.");
	        state = "relative path";
	        if ("/" != c && "\\" != c) {
	          continue;
	        }
	        break;

	       case "relative path":
	        if (EOF == c || "/" == c || "\\" == c || !stateOverride && ("?" == c || "#" == c)) {
	          if ("\\" == c) {
	            err("\\ not allowed in relative path.");
	          }
	          var tmp;
	          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
	            buffer = tmp;
	          }
	          if (".." == buffer) {
	            this._path.pop();
	            if ("/" != c && "\\" != c) {
	              this._path.push("");
	            }
	          } else if ("." == buffer && "/" != c && "\\" != c) {
	            this._path.push("");
	          } else if ("." != buffer) {
	            if ("file" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == "|") {
	              buffer = buffer[0] + ":";
	            }
	            this._path.push(buffer);
	          }
	          buffer = "";
	          if ("?" == c) {
	            this._query = "?";
	            state = "query";
	          } else if ("#" == c) {
	            this._fragment = "#";
	            state = "fragment";
	          }
	        } else if ("\t" != c && "\n" != c && "\r" != c) {
	          buffer += percentEscape(c);
	        }
	        break;

	       case "query":
	        if (!stateOverride && "#" == c) {
	          this._fragment = "#";
	          state = "fragment";
	        } else if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
	          this._query += percentEscapeQuery(c);
	        }
	        break;

	       case "fragment":
	        if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
	          this._fragment += c;
	        }
	        break;
	      }
	      cursor++;
	    }
	  }
	  function clear() {
	    this._scheme = "";
	    this._schemeData = "";
	    this._username = "";
	    this._password = null;
	    this._host = "";
	    this._port = "";
	    this._path = [];
	    this._query = "";
	    this._fragment = "";
	    this._isInvalid = false;
	    this._isRelative = false;
	  }
	  function jURL(url, base) {
	    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));
	    this._url = url;
	    clear.call(this);
	    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
	    parse.call(this, input, null, base);
	  }
	  jURL.prototype = {
	    toString: function() {
	      return this.href;
	    },
	    get href() {
	      if (this._isInvalid) return this._url;
	      var authority = "";
	      if ("" != this._username || null != this._password) {
	        authority = this._username + (null != this._password ? ":" + this._password : "") + "@";
	      }
	      return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
	    },
	    set href(href) {
	      clear.call(this);
	      parse.call(this, href);
	    },
	    get protocol() {
	      return this._scheme + ":";
	    },
	    set protocol(protocol) {
	      if (this._isInvalid) return;
	      parse.call(this, protocol + ":", "scheme start");
	    },
	    get host() {
	      return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
	    },
	    set host(host) {
	      if (this._isInvalid || !this._isRelative) return;
	      parse.call(this, host, "host");
	    },
	    get hostname() {
	      return this._host;
	    },
	    set hostname(hostname) {
	      if (this._isInvalid || !this._isRelative) return;
	      parse.call(this, hostname, "hostname");
	    },
	    get port() {
	      return this._port;
	    },
	    set port(port) {
	      if (this._isInvalid || !this._isRelative) return;
	      parse.call(this, port, "port");
	    },
	    get pathname() {
	      return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
	    },
	    set pathname(pathname) {
	      if (this._isInvalid || !this._isRelative) return;
	      this._path = [];
	      parse.call(this, pathname, "relative path start");
	    },
	    get search() {
	      return this._isInvalid || !this._query || "?" == this._query ? "" : this._query;
	    },
	    set search(search) {
	      if (this._isInvalid || !this._isRelative) return;
	      this._query = "?";
	      if ("?" == search[0]) search = search.slice(1);
	      parse.call(this, search, "query");
	    },
	    get hash() {
	      return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment;
	    },
	    set hash(hash) {
	      if (this._isInvalid) return;
	      this._fragment = "#";
	      if ("#" == hash[0]) hash = hash.slice(1);
	      parse.call(this, hash, "fragment");
	    },
	    get origin() {
	      var host;
	      if (this._isInvalid || !this._scheme) {
	        return "";
	      }
	      switch (this._scheme) {
	       case "data":
	       case "file":
	       case "javascript":
	       case "mailto":
	        return "null";
	      }
	      host = this.host;
	      if (!host) {
	        return "";
	      }
	      return this._scheme + "://" + host;
	    }
	  };
	  var OriginalURL = scope.URL;
	  if (OriginalURL) {
	    jURL.createObjectURL = function(blob) {
	      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
	    };
	    jURL.revokeObjectURL = function(url) {
	      OriginalURL.revokeObjectURL(url);
	    };
	  }
	  scope.URL = jURL;
	})(self);

	if (typeof WeakMap === "undefined") {
	  (function() {
	    var defineProperty = Object.defineProperty;
	    var counter = Date.now() % 1e9;
	    var WeakMap = function() {
	      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
	    };
	    WeakMap.prototype = {
	      set: function(key, value) {
	        var entry = key[this.name];
	        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
	          value: [ key, value ],
	          writable: true
	        });
	        return this;
	      },
	      get: function(key) {
	        var entry;
	        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
	      },
	      "delete": function(key) {
	        var entry = key[this.name];
	        if (!entry || entry[0] !== key) return false;
	        entry[0] = entry[1] = undefined;
	        return true;
	      },
	      has: function(key) {
	        var entry = key[this.name];
	        if (!entry) return false;
	        return entry[0] === key;
	      }
	    };
	    window.WeakMap = WeakMap;
	  })();
	}

	(function(global) {
	  if (global.JsMutationObserver) {
	    return;
	  }
	  var registrationsTable = new WeakMap();
	  var setImmediate;
	  if (/Trident|Edge/.test(navigator.userAgent)) {
	    setImmediate = setTimeout;
	  } else if (window.setImmediate) {
	    setImmediate = window.setImmediate;
	  } else {
	    var setImmediateQueue = [];
	    var sentinel = String(Math.random());
	    window.addEventListener("message", function(e) {
	      if (e.data === sentinel) {
	        var queue = setImmediateQueue;
	        setImmediateQueue = [];
	        queue.forEach(function(func) {
	          func();
	        });
	      }
	    });
	    setImmediate = function(func) {
	      setImmediateQueue.push(func);
	      window.postMessage(sentinel, "*");
	    };
	  }
	  var isScheduled = false;
	  var scheduledObservers = [];
	  function scheduleCallback(observer) {
	    scheduledObservers.push(observer);
	    if (!isScheduled) {
	      isScheduled = true;
	      setImmediate(dispatchCallbacks);
	    }
	  }
	  function wrapIfNeeded(node) {
	    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
	  }
	  function dispatchCallbacks() {
	    isScheduled = false;
	    var observers = scheduledObservers;
	    scheduledObservers = [];
	    observers.sort(function(o1, o2) {
	      return o1.uid_ - o2.uid_;
	    });
	    var anyNonEmpty = false;
	    observers.forEach(function(observer) {
	      var queue = observer.takeRecords();
	      removeTransientObserversFor(observer);
	      if (queue.length) {
	        observer.callback_(queue, observer);
	        anyNonEmpty = true;
	      }
	    });
	    if (anyNonEmpty) dispatchCallbacks();
	  }
	  function removeTransientObserversFor(observer) {
	    observer.nodes_.forEach(function(node) {
	      var registrations = registrationsTable.get(node);
	      if (!registrations) return;
	      registrations.forEach(function(registration) {
	        if (registration.observer === observer) registration.removeTransientObservers();
	      });
	    });
	  }
	  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
	    for (var node = target; node; node = node.parentNode) {
	      var registrations = registrationsTable.get(node);
	      if (registrations) {
	        for (var j = 0; j < registrations.length; j++) {
	          var registration = registrations[j];
	          var options = registration.options;
	          if (node !== target && !options.subtree) continue;
	          var record = callback(options);
	          if (record) registration.enqueue(record);
	        }
	      }
	    }
	  }
	  var uidCounter = 0;
	  function JsMutationObserver(callback) {
	    this.callback_ = callback;
	    this.nodes_ = [];
	    this.records_ = [];
	    this.uid_ = ++uidCounter;
	  }
	  JsMutationObserver.prototype = {
	    observe: function(target, options) {
	      target = wrapIfNeeded(target);
	      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
	        throw new SyntaxError();
	      }
	      var registrations = registrationsTable.get(target);
	      if (!registrations) registrationsTable.set(target, registrations = []);
	      var registration;
	      for (var i = 0; i < registrations.length; i++) {
	        if (registrations[i].observer === this) {
	          registration = registrations[i];
	          registration.removeListeners();
	          registration.options = options;
	          break;
	        }
	      }
	      if (!registration) {
	        registration = new Registration(this, target, options);
	        registrations.push(registration);
	        this.nodes_.push(target);
	      }
	      registration.addListeners();
	    },
	    disconnect: function() {
	      this.nodes_.forEach(function(node) {
	        var registrations = registrationsTable.get(node);
	        for (var i = 0; i < registrations.length; i++) {
	          var registration = registrations[i];
	          if (registration.observer === this) {
	            registration.removeListeners();
	            registrations.splice(i, 1);
	            break;
	          }
	        }
	      }, this);
	      this.records_ = [];
	    },
	    takeRecords: function() {
	      var copyOfRecords = this.records_;
	      this.records_ = [];
	      return copyOfRecords;
	    }
	  };
	  function MutationRecord(type, target) {
	    this.type = type;
	    this.target = target;
	    this.addedNodes = [];
	    this.removedNodes = [];
	    this.previousSibling = null;
	    this.nextSibling = null;
	    this.attributeName = null;
	    this.attributeNamespace = null;
	    this.oldValue = null;
	  }
	  function copyMutationRecord(original) {
	    var record = new MutationRecord(original.type, original.target);
	    record.addedNodes = original.addedNodes.slice();
	    record.removedNodes = original.removedNodes.slice();
	    record.previousSibling = original.previousSibling;
	    record.nextSibling = original.nextSibling;
	    record.attributeName = original.attributeName;
	    record.attributeNamespace = original.attributeNamespace;
	    record.oldValue = original.oldValue;
	    return record;
	  }
	  var currentRecord, recordWithOldValue;
	  function getRecord(type, target) {
	    return currentRecord = new MutationRecord(type, target);
	  }
	  function getRecordWithOldValue(oldValue) {
	    if (recordWithOldValue) return recordWithOldValue;
	    recordWithOldValue = copyMutationRecord(currentRecord);
	    recordWithOldValue.oldValue = oldValue;
	    return recordWithOldValue;
	  }
	  function clearRecords() {
	    currentRecord = recordWithOldValue = undefined;
	  }
	  function recordRepresentsCurrentMutation(record) {
	    return record === recordWithOldValue || record === currentRecord;
	  }
	  function selectRecord(lastRecord, newRecord) {
	    if (lastRecord === newRecord) return lastRecord;
	    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
	    return null;
	  }
	  function Registration(observer, target, options) {
	    this.observer = observer;
	    this.target = target;
	    this.options = options;
	    this.transientObservedNodes = [];
	  }
	  Registration.prototype = {
	    enqueue: function(record) {
	      var records = this.observer.records_;
	      var length = records.length;
	      if (records.length > 0) {
	        var lastRecord = records[length - 1];
	        var recordToReplaceLast = selectRecord(lastRecord, record);
	        if (recordToReplaceLast) {
	          records[length - 1] = recordToReplaceLast;
	          return;
	        }
	      } else {
	        scheduleCallback(this.observer);
	      }
	      records[length] = record;
	    },
	    addListeners: function() {
	      this.addListeners_(this.target);
	    },
	    addListeners_: function(node) {
	      var options = this.options;
	      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
	      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
	      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
	      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
	    },
	    removeListeners: function() {
	      this.removeListeners_(this.target);
	    },
	    removeListeners_: function(node) {
	      var options = this.options;
	      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
	      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
	      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
	      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
	    },
	    addTransientObserver: function(node) {
	      if (node === this.target) return;
	      this.addListeners_(node);
	      this.transientObservedNodes.push(node);
	      var registrations = registrationsTable.get(node);
	      if (!registrations) registrationsTable.set(node, registrations = []);
	      registrations.push(this);
	    },
	    removeTransientObservers: function() {
	      var transientObservedNodes = this.transientObservedNodes;
	      this.transientObservedNodes = [];
	      transientObservedNodes.forEach(function(node) {
	        this.removeListeners_(node);
	        var registrations = registrationsTable.get(node);
	        for (var i = 0; i < registrations.length; i++) {
	          if (registrations[i] === this) {
	            registrations.splice(i, 1);
	            break;
	          }
	        }
	      }, this);
	    },
	    handleEvent: function(e) {
	      e.stopImmediatePropagation();
	      switch (e.type) {
	       case "DOMAttrModified":
	        var name = e.attrName;
	        var namespace = e.relatedNode.namespaceURI;
	        var target = e.target;
	        var record = new getRecord("attributes", target);
	        record.attributeName = name;
	        record.attributeNamespace = namespace;
	        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
	        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
	          if (!options.attributes) return;
	          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
	            return;
	          }
	          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
	          return record;
	        });
	        break;

	       case "DOMCharacterDataModified":
	        var target = e.target;
	        var record = getRecord("characterData", target);
	        var oldValue = e.prevValue;
	        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
	          if (!options.characterData) return;
	          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
	          return record;
	        });
	        break;

	       case "DOMNodeRemoved":
	        this.addTransientObserver(e.target);

	       case "DOMNodeInserted":
	        var changedNode = e.target;
	        var addedNodes, removedNodes;
	        if (e.type === "DOMNodeInserted") {
	          addedNodes = [ changedNode ];
	          removedNodes = [];
	        } else {
	          addedNodes = [];
	          removedNodes = [ changedNode ];
	        }
	        var previousSibling = changedNode.previousSibling;
	        var nextSibling = changedNode.nextSibling;
	        var record = getRecord("childList", e.target.parentNode);
	        record.addedNodes = addedNodes;
	        record.removedNodes = removedNodes;
	        record.previousSibling = previousSibling;
	        record.nextSibling = nextSibling;
	        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
	          if (!options.childList) return;
	          return record;
	        });
	      }
	      clearRecords();
	    }
	  };
	  global.JsMutationObserver = JsMutationObserver;
	  if (!global.MutationObserver) {
	    global.MutationObserver = JsMutationObserver;
	    JsMutationObserver._isPolyfilled = true;
	  }
	})(self);

	(function() {
	  var needsTemplate = typeof HTMLTemplateElement === "undefined";
	  if (/Trident/.test(navigator.userAgent)) {
	    (function() {
	      var importNode = document.importNode;
	      document.importNode = function() {
	        var n = importNode.apply(document, arguments);
	        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	          var f = document.createDocumentFragment();
	          f.appendChild(n);
	          return f;
	        } else {
	          return n;
	        }
	      };
	    })();
	  }
	  var needsCloning = function() {
	    if (!needsTemplate) {
	      var t = document.createElement("template");
	      var t2 = document.createElement("template");
	      t2.content.appendChild(document.createElement("div"));
	      t.content.appendChild(t2);
	      var clone = t.cloneNode(true);
	      return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0;
	    }
	  }();
	  var TEMPLATE_TAG = "template";
	  var TemplateImpl = function() {};
	  if (needsTemplate) {
	    var contentDoc = document.implementation.createHTMLDocument("template");
	    var canDecorate = true;
	    var templateStyle = document.createElement("style");
	    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";
	    var head = document.head;
	    head.insertBefore(templateStyle, head.firstElementChild);
	    TemplateImpl.prototype = Object.create(HTMLElement.prototype);
	    TemplateImpl.decorate = function(template) {
	      if (template.content) {
	        return;
	      }
	      template.content = contentDoc.createDocumentFragment();
	      var child;
	      while (child = template.firstChild) {
	        template.content.appendChild(child);
	      }
	      template.cloneNode = function(deep) {
	        return TemplateImpl.cloneNode(this, deep);
	      };
	      if (canDecorate) {
	        try {
	          Object.defineProperty(template, "innerHTML", {
	            get: function() {
	              var o = "";
	              for (var e = this.content.firstChild; e; e = e.nextSibling) {
	                o += e.outerHTML || escapeData(e.data);
	              }
	              return o;
	            },
	            set: function(text) {
	              contentDoc.body.innerHTML = text;
	              TemplateImpl.bootstrap(contentDoc);
	              while (this.content.firstChild) {
	                this.content.removeChild(this.content.firstChild);
	              }
	              while (contentDoc.body.firstChild) {
	                this.content.appendChild(contentDoc.body.firstChild);
	              }
	            },
	            configurable: true
	          });
	        } catch (err) {
	          canDecorate = false;
	        }
	      }
	      TemplateImpl.bootstrap(template.content);
	    };
	    TemplateImpl.bootstrap = function(doc) {
	      var templates = doc.querySelectorAll(TEMPLATE_TAG);
	      for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {
	        TemplateImpl.decorate(t);
	      }
	    };
	    document.addEventListener("DOMContentLoaded", function() {
	      TemplateImpl.bootstrap(document);
	    });
	    var createElement = document.createElement;
	    document.createElement = function() {
	      "use strict";
	      var el = createElement.apply(document, arguments);
	      if (el.localName === "template") {
	        TemplateImpl.decorate(el);
	      }
	      return el;
	    };
	    var escapeDataRegExp = /[&\u00A0<>]/g;
	    function escapeReplace(c) {
	      switch (c) {
	       case "&":
	        return "&amp;";

	       case "<":
	        return "&lt;";

	       case ">":
	        return "&gt;";

	       case " ":
	        return "&nbsp;";
	      }
	    }
	    function escapeData(s) {
	      return s.replace(escapeDataRegExp, escapeReplace);
	    }
	  }
	  if (needsTemplate || needsCloning) {
	    var nativeCloneNode = Node.prototype.cloneNode;
	    TemplateImpl.cloneNode = function(template, deep) {
	      var clone = nativeCloneNode.call(template, false);
	      if (this.decorate) {
	        this.decorate(clone);
	      }
	      if (deep) {
	        clone.content.appendChild(nativeCloneNode.call(template.content, true));
	        this.fixClonedDom(clone.content, template.content);
	      }
	      return clone;
	    };
	    TemplateImpl.fixClonedDom = function(clone, source) {
	      if (!source.querySelectorAll) return;
	      var s$ = source.querySelectorAll(TEMPLATE_TAG);
	      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
	      for (var i = 0, l = t$.length, t, s; i < l; i++) {
	        s = s$[i];
	        t = t$[i];
	        if (this.decorate) {
	          this.decorate(s);
	        }
	        t.parentNode.replaceChild(s.cloneNode(true), t);
	      }
	    };
	    var originalImportNode = document.importNode;
	    Node.prototype.cloneNode = function(deep) {
	      var dom = nativeCloneNode.call(this, deep);
	      if (deep) {
	        TemplateImpl.fixClonedDom(dom, this);
	      }
	      return dom;
	    };
	    document.importNode = function(element, deep) {
	      if (element.localName === TEMPLATE_TAG) {
	        return TemplateImpl.cloneNode(element, deep);
	      } else {
	        var dom = originalImportNode.call(document, element, deep);
	        if (deep) {
	          TemplateImpl.fixClonedDom(dom, element);
	        }
	        return dom;
	      }
	    };
	    if (needsCloning) {
	      HTMLTemplateElement.prototype.cloneNode = function(deep) {
	        return TemplateImpl.cloneNode(this, deep);
	      };
	    }
	  }
	  if (needsTemplate) {
	    window.HTMLTemplateElement = TemplateImpl;
	  }
	})();

	(function(scope) {
	  "use strict";
	  if (!(window.performance && window.performance.now)) {
	    var start = Date.now();
	    window.performance = {
	      now: function() {
	        return Date.now() - start;
	      }
	    };
	  }
	  if (!window.requestAnimationFrame) {
	    window.requestAnimationFrame = function() {
	      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
	      return nativeRaf ? function(callback) {
	        return nativeRaf(function() {
	          callback(performance.now());
	        });
	      } : function(callback) {
	        return window.setTimeout(callback, 1e3 / 60);
	      };
	    }();
	  }
	  if (!window.cancelAnimationFrame) {
	    window.cancelAnimationFrame = function() {
	      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {
	        clearTimeout(id);
	      };
	    }();
	  }
	  var workingDefaultPrevented = function() {
	    var e = document.createEvent("Event");
	    e.initEvent("foo", true, true);
	    e.preventDefault();
	    return e.defaultPrevented;
	  }();
	  if (!workingDefaultPrevented) {
	    var origPreventDefault = Event.prototype.preventDefault;
	    Event.prototype.preventDefault = function() {
	      if (!this.cancelable) {
	        return;
	      }
	      origPreventDefault.call(this);
	      Object.defineProperty(this, "defaultPrevented", {
	        get: function() {
	          return true;
	        },
	        configurable: true
	      });
	    };
	  }
	  var isIE = /Trident/.test(navigator.userAgent);
	  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
	    window.CustomEvent = function(inType, params) {
	      params = params || {};
	      var e = document.createEvent("CustomEvent");
	      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
	      return e;
	    };
	    window.CustomEvent.prototype = window.Event.prototype;
	  }
	  if (!window.Event || isIE && typeof window.Event !== "function") {
	    var origEvent = window.Event;
	    window.Event = function(inType, params) {
	      params = params || {};
	      var e = document.createEvent("Event");
	      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
	      return e;
	    };
	    window.Event.prototype = origEvent.prototype;
	  }
	})(window.WebComponents);

	window.HTMLImports = window.HTMLImports || {
	  flags: {}
	};

	(function(scope) {
	  var IMPORT_LINK_TYPE = "import";
	  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
	  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
	  var wrap = function(node) {
	    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
	  };
	  var rootDocument = wrap(document);
	  var currentScriptDescriptor = {
	    get: function() {
	      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
	      return wrap(script);
	    },
	    configurable: true
	  };
	  Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
	  Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
	  var isIE = /Trident/.test(navigator.userAgent);
	  function whenReady(callback, doc) {
	    doc = doc || rootDocument;
	    whenDocumentReady(function() {
	      watchImportsLoad(callback, doc);
	    }, doc);
	  }
	  var requiredReadyState = isIE ? "complete" : "interactive";
	  var READY_EVENT = "readystatechange";
	  function isDocumentReady(doc) {
	    return doc.readyState === "complete" || doc.readyState === requiredReadyState;
	  }
	  function whenDocumentReady(callback, doc) {
	    if (!isDocumentReady(doc)) {
	      var checkReady = function() {
	        if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
	          doc.removeEventListener(READY_EVENT, checkReady);
	          whenDocumentReady(callback, doc);
	        }
	      };
	      doc.addEventListener(READY_EVENT, checkReady);
	    } else if (callback) {
	      callback();
	    }
	  }
	  function markTargetLoaded(event) {
	    event.target.__loaded = true;
	  }
	  function watchImportsLoad(callback, doc) {
	    var imports = doc.querySelectorAll("link[rel=import]");
	    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
	    function checkDone() {
	      if (parsedCount == importCount && callback) {
	        callback({
	          allImports: imports,
	          loadedImports: newImports,
	          errorImports: errorImports
	        });
	      }
	    }
	    function loadedImport(e) {
	      markTargetLoaded(e);
	      newImports.push(this);
	      parsedCount++;
	      checkDone();
	    }
	    function errorLoadingImport(e) {
	      errorImports.push(this);
	      parsedCount++;
	      checkDone();
	    }
	    if (importCount) {
	      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {
	        if (isImportLoaded(imp)) {
	          newImports.push(this);
	          parsedCount++;
	          checkDone();
	        } else {
	          imp.addEventListener("load", loadedImport);
	          imp.addEventListener("error", errorLoadingImport);
	        }
	      }
	    } else {
	      checkDone();
	    }
	  }
	  function isImportLoaded(link) {
	    return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
	  }
	  if (useNative) {
	    new MutationObserver(function(mxns) {
	      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
	        if (m.addedNodes) {
	          handleImports(m.addedNodes);
	        }
	      }
	    }).observe(document.head, {
	      childList: true
	    });
	    function handleImports(nodes) {
	      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
	        if (isImport(n)) {
	          handleImport(n);
	        }
	      }
	    }
	    function isImport(element) {
	      return element.localName === "link" && element.rel === "import";
	    }
	    function handleImport(element) {
	      var loaded = element.import;
	      if (loaded) {
	        markTargetLoaded({
	          target: element
	        });
	      } else {
	        element.addEventListener("load", markTargetLoaded);
	        element.addEventListener("error", markTargetLoaded);
	      }
	    }
	    (function() {
	      if (document.readyState === "loading") {
	        var imports = document.querySelectorAll("link[rel=import]");
	        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
	          handleImport(imp);
	        }
	      }
	    })();
	  }
	  whenReady(function(detail) {
	    window.HTMLImports.ready = true;
	    window.HTMLImports.readyTime = new Date().getTime();
	    var evt = rootDocument.createEvent("CustomEvent");
	    evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
	    rootDocument.dispatchEvent(evt);
	  });
	  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
	  scope.useNative = useNative;
	  scope.rootDocument = rootDocument;
	  scope.whenReady = whenReady;
	  scope.isIE = isIE;
	})(window.HTMLImports);

	(function(scope) {
	  var modules = [];
	  var addModule = function(module) {
	    modules.push(module);
	  };
	  var initializeModules = function() {
	    modules.forEach(function(module) {
	      module(scope);
	    });
	  };
	  scope.addModule = addModule;
	  scope.initializeModules = initializeModules;
	})(window.HTMLImports);

	window.HTMLImports.addModule(function(scope) {
	  var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
	  var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
	  var path = {
	    resolveUrlsInStyle: function(style, linkUrl) {
	      var doc = style.ownerDocument;
	      var resolver = doc.createElement("a");
	      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
	      return style;
	    },
	    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
	      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
	      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
	      return r;
	    },
	    replaceUrls: function(text, urlObj, linkUrl, regexp) {
	      return text.replace(regexp, function(m, pre, url, post) {
	        var urlPath = url.replace(/["']/g, "");
	        if (linkUrl) {
	          urlPath = new URL(urlPath, linkUrl).href;
	        }
	        urlObj.href = urlPath;
	        urlPath = urlObj.href;
	        return pre + "'" + urlPath + "'" + post;
	      });
	    }
	  };
	  scope.path = path;
	});

	window.HTMLImports.addModule(function(scope) {
	  var xhr = {
	    async: true,
	    ok: function(request) {
	      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
	    },
	    load: function(url, next, nextContext) {
	      var request = new XMLHttpRequest();
	      if (scope.flags.debug || scope.flags.bust) {
	        url += "?" + Math.random();
	      }
	      request.open("GET", url, xhr.async);
	      request.addEventListener("readystatechange", function(e) {
	        if (request.readyState === 4) {
	          var redirectedUrl = null;
	          try {
	            var locationHeader = request.getResponseHeader("Location");
	            if (locationHeader) {
	              redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
	            }
	          } catch (e) {
	            console.error(e.message);
	          }
	          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
	        }
	      });
	      request.send();
	      return request;
	    },
	    loadDocument: function(url, next, nextContext) {
	      this.load(url, next, nextContext).responseType = "document";
	    }
	  };
	  scope.xhr = xhr;
	});

	window.HTMLImports.addModule(function(scope) {
	  var xhr = scope.xhr;
	  var flags = scope.flags;
	  var Loader = function(onLoad, onComplete) {
	    this.cache = {};
	    this.onload = onLoad;
	    this.oncomplete = onComplete;
	    this.inflight = 0;
	    this.pending = {};
	  };
	  Loader.prototype = {
	    addNodes: function(nodes) {
	      this.inflight += nodes.length;
	      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
	        this.require(n);
	      }
	      this.checkDone();
	    },
	    addNode: function(node) {
	      this.inflight++;
	      this.require(node);
	      this.checkDone();
	    },
	    require: function(elt) {
	      var url = elt.src || elt.href;
	      elt.__nodeUrl = url;
	      if (!this.dedupe(url, elt)) {
	        this.fetch(url, elt);
	      }
	    },
	    dedupe: function(url, elt) {
	      if (this.pending[url]) {
	        this.pending[url].push(elt);
	        return true;
	      }
	      var resource;
	      if (this.cache[url]) {
	        this.onload(url, elt, this.cache[url]);
	        this.tail();
	        return true;
	      }
	      this.pending[url] = [ elt ];
	      return false;
	    },
	    fetch: function(url, elt) {
	      flags.load && console.log("fetch", url, elt);
	      if (!url) {
	        setTimeout(function() {
	          this.receive(url, elt, {
	            error: "href must be specified"
	          }, null);
	        }.bind(this), 0);
	      } else if (url.match(/^data:/)) {
	        var pieces = url.split(",");
	        var header = pieces[0];
	        var body = pieces[1];
	        if (header.indexOf(";base64") > -1) {
	          body = atob(body);
	        } else {
	          body = decodeURIComponent(body);
	        }
	        setTimeout(function() {
	          this.receive(url, elt, null, body);
	        }.bind(this), 0);
	      } else {
	        var receiveXhr = function(err, resource, redirectedUrl) {
	          this.receive(url, elt, err, resource, redirectedUrl);
	        }.bind(this);
	        xhr.load(url, receiveXhr);
	      }
	    },
	    receive: function(url, elt, err, resource, redirectedUrl) {
	      this.cache[url] = resource;
	      var $p = this.pending[url];
	      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
	        this.onload(url, p, resource, err, redirectedUrl);
	        this.tail();
	      }
	      this.pending[url] = null;
	    },
	    tail: function() {
	      --this.inflight;
	      this.checkDone();
	    },
	    checkDone: function() {
	      if (!this.inflight) {
	        this.oncomplete();
	      }
	    }
	  };
	  scope.Loader = Loader;
	});

	window.HTMLImports.addModule(function(scope) {
	  var Observer = function(addCallback) {
	    this.addCallback = addCallback;
	    this.mo = new MutationObserver(this.handler.bind(this));
	  };
	  Observer.prototype = {
	    handler: function(mutations) {
	      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
	        if (m.type === "childList" && m.addedNodes.length) {
	          this.addedNodes(m.addedNodes);
	        }
	      }
	    },
	    addedNodes: function(nodes) {
	      if (this.addCallback) {
	        this.addCallback(nodes);
	      }
	      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
	        if (n.children && n.children.length) {
	          this.addedNodes(n.children);
	        }
	      }
	    },
	    observe: function(root) {
	      this.mo.observe(root, {
	        childList: true,
	        subtree: true
	      });
	    }
	  };
	  scope.Observer = Observer;
	});

	window.HTMLImports.addModule(function(scope) {
	  var path = scope.path;
	  var rootDocument = scope.rootDocument;
	  var flags = scope.flags;
	  var isIE = scope.isIE;
	  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
	  var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
	  var importParser = {
	    documentSelectors: IMPORT_SELECTOR,
	    importsSelectors: [ IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]' ].join(","),
	    map: {
	      link: "parseLink",
	      script: "parseScript",
	      style: "parseStyle"
	    },
	    dynamicElements: [],
	    parseNext: function() {
	      var next = this.nextToParse();
	      if (next) {
	        this.parse(next);
	      }
	    },
	    parse: function(elt) {
	      if (this.isParsed(elt)) {
	        flags.parse && console.log("[%s] is already parsed", elt.localName);
	        return;
	      }
	      var fn = this[this.map[elt.localName]];
	      if (fn) {
	        this.markParsing(elt);
	        fn.call(this, elt);
	      }
	    },
	    parseDynamic: function(elt, quiet) {
	      this.dynamicElements.push(elt);
	      if (!quiet) {
	        this.parseNext();
	      }
	    },
	    markParsing: function(elt) {
	      flags.parse && console.log("parsing", elt);
	      this.parsingElement = elt;
	    },
	    markParsingComplete: function(elt) {
	      elt.__importParsed = true;
	      this.markDynamicParsingComplete(elt);
	      if (elt.__importElement) {
	        elt.__importElement.__importParsed = true;
	        this.markDynamicParsingComplete(elt.__importElement);
	      }
	      this.parsingElement = null;
	      flags.parse && console.log("completed", elt);
	    },
	    markDynamicParsingComplete: function(elt) {
	      var i = this.dynamicElements.indexOf(elt);
	      if (i >= 0) {
	        this.dynamicElements.splice(i, 1);
	      }
	    },
	    parseImport: function(elt) {
	      elt.import = elt.__doc;
	      if (window.HTMLImports.__importsParsingHook) {
	        window.HTMLImports.__importsParsingHook(elt);
	      }
	      if (elt.import) {
	        elt.import.__importParsed = true;
	      }
	      this.markParsingComplete(elt);
	      if (elt.__resource && !elt.__error) {
	        elt.dispatchEvent(new CustomEvent("load", {
	          bubbles: false
	        }));
	      } else {
	        elt.dispatchEvent(new CustomEvent("error", {
	          bubbles: false
	        }));
	      }
	      if (elt.__pending) {
	        var fn;
	        while (elt.__pending.length) {
	          fn = elt.__pending.shift();
	          if (fn) {
	            fn({
	              target: elt
	            });
	          }
	        }
	      }
	      this.parseNext();
	    },
	    parseLink: function(linkElt) {
	      if (nodeIsImport(linkElt)) {
	        this.parseImport(linkElt);
	      } else {
	        linkElt.href = linkElt.href;
	        this.parseGeneric(linkElt);
	      }
	    },
	    parseStyle: function(elt) {
	      var src = elt;
	      elt = cloneStyle(elt);
	      src.__appliedElement = elt;
	      elt.__importElement = src;
	      this.parseGeneric(elt);
	    },
	    parseGeneric: function(elt) {
	      this.trackElement(elt);
	      this.addElementToDocument(elt);
	    },
	    rootImportForElement: function(elt) {
	      var n = elt;
	      while (n.ownerDocument.__importLink) {
	        n = n.ownerDocument.__importLink;
	      }
	      return n;
	    },
	    addElementToDocument: function(elt) {
	      var port = this.rootImportForElement(elt.__importElement || elt);
	      port.parentNode.insertBefore(elt, port);
	    },
	    trackElement: function(elt, callback) {
	      var self = this;
	      var done = function(e) {
	        elt.removeEventListener("load", done);
	        elt.removeEventListener("error", done);
	        if (callback) {
	          callback(e);
	        }
	        self.markParsingComplete(elt);
	        self.parseNext();
	      };
	      elt.addEventListener("load", done);
	      elt.addEventListener("error", done);
	      if (isIE && elt.localName === "style") {
	        var fakeLoad = false;
	        if (elt.textContent.indexOf("@import") == -1) {
	          fakeLoad = true;
	        } else if (elt.sheet) {
	          fakeLoad = true;
	          var csr = elt.sheet.cssRules;
	          var len = csr ? csr.length : 0;
	          for (var i = 0, r; i < len && (r = csr[i]); i++) {
	            if (r.type === CSSRule.IMPORT_RULE) {
	              fakeLoad = fakeLoad && Boolean(r.styleSheet);
	            }
	          }
	        }
	        if (fakeLoad) {
	          setTimeout(function() {
	            elt.dispatchEvent(new CustomEvent("load", {
	              bubbles: false
	            }));
	          });
	        }
	      }
	    },
	    parseScript: function(scriptElt) {
	      var script = document.createElement("script");
	      script.__importElement = scriptElt;
	      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
	      scope.currentScript = scriptElt;
	      this.trackElement(script, function(e) {
	        if (script.parentNode) {
	          script.parentNode.removeChild(script);
	        }
	        scope.currentScript = null;
	      });
	      this.addElementToDocument(script);
	    },
	    nextToParse: function() {
	      this._mayParse = [];
	      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
	    },
	    nextToParseInDoc: function(doc, link) {
	      if (doc && this._mayParse.indexOf(doc) < 0) {
	        this._mayParse.push(doc);
	        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
	        for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
	          if (!this.isParsed(n)) {
	            if (this.hasResource(n)) {
	              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
	            } else {
	              return;
	            }
	          }
	        }
	      }
	      return link;
	    },
	    nextToParseDynamic: function() {
	      return this.dynamicElements[0];
	    },
	    parseSelectorsForNode: function(node) {
	      var doc = node.ownerDocument || node;
	      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
	    },
	    isParsed: function(node) {
	      return node.__importParsed;
	    },
	    needsDynamicParsing: function(elt) {
	      return this.dynamicElements.indexOf(elt) >= 0;
	    },
	    hasResource: function(node) {
	      if (nodeIsImport(node) && node.__doc === undefined) {
	        return false;
	      }
	      return true;
	    }
	  };
	  function nodeIsImport(elt) {
	    return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
	  }
	  function generateScriptDataUrl(script) {
	    var scriptContent = generateScriptContent(script);
	    return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
	  }
	  function generateScriptContent(script) {
	    return script.textContent + generateSourceMapHint(script);
	  }
	  function generateSourceMapHint(script) {
	    var owner = script.ownerDocument;
	    owner.__importedScripts = owner.__importedScripts || 0;
	    var moniker = script.ownerDocument.baseURI;
	    var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
	    owner.__importedScripts++;
	    return "\n//# sourceURL=" + moniker + num + ".js\n";
	  }
	  function cloneStyle(style) {
	    var clone = style.ownerDocument.createElement("style");
	    clone.textContent = style.textContent;
	    path.resolveUrlsInStyle(clone);
	    return clone;
	  }
	  scope.parser = importParser;
	  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
	});

	window.HTMLImports.addModule(function(scope) {
	  var flags = scope.flags;
	  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
	  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
	  var rootDocument = scope.rootDocument;
	  var Loader = scope.Loader;
	  var Observer = scope.Observer;
	  var parser = scope.parser;
	  var importer = {
	    documents: {},
	    documentPreloadSelectors: IMPORT_SELECTOR,
	    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(","),
	    loadNode: function(node) {
	      importLoader.addNode(node);
	    },
	    loadSubtree: function(parent) {
	      var nodes = this.marshalNodes(parent);
	      importLoader.addNodes(nodes);
	    },
	    marshalNodes: function(parent) {
	      return parent.querySelectorAll(this.loadSelectorsForNode(parent));
	    },
	    loadSelectorsForNode: function(node) {
	      var doc = node.ownerDocument || node;
	      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
	    },
	    loaded: function(url, elt, resource, err, redirectedUrl) {
	      flags.load && console.log("loaded", url, elt);
	      elt.__resource = resource;
	      elt.__error = err;
	      if (isImportLink(elt)) {
	        var doc = this.documents[url];
	        if (doc === undefined) {
	          doc = err ? null : makeDocument(resource, redirectedUrl || url);
	          if (doc) {
	            doc.__importLink = elt;
	            this.bootDocument(doc);
	          }
	          this.documents[url] = doc;
	        }
	        elt.__doc = doc;
	      }
	      parser.parseNext();
	    },
	    bootDocument: function(doc) {
	      this.loadSubtree(doc);
	      this.observer.observe(doc);
	      parser.parseNext();
	    },
	    loadedAll: function() {
	      parser.parseNext();
	    }
	  };
	  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
	  importer.observer = new Observer();
	  function isImportLink(elt) {
	    return isLinkRel(elt, IMPORT_LINK_TYPE);
	  }
	  function isLinkRel(elt, rel) {
	    return elt.localName === "link" && elt.getAttribute("rel") === rel;
	  }
	  function hasBaseURIAccessor(doc) {
	    return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
	  }
	  function makeDocument(resource, url) {
	    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
	    doc._URL = url;
	    var base = doc.createElement("base");
	    base.setAttribute("href", url);
	    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
	      Object.defineProperty(doc, "baseURI", {
	        value: url
	      });
	    }
	    var meta = doc.createElement("meta");
	    meta.setAttribute("charset", "utf-8");
	    doc.head.appendChild(meta);
	    doc.head.appendChild(base);
	    doc.body.innerHTML = resource;
	    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
	      HTMLTemplateElement.bootstrap(doc);
	    }
	    return doc;
	  }
	  if (!document.baseURI) {
	    var baseURIDescriptor = {
	      get: function() {
	        var base = document.querySelector("base");
	        return base ? base.href : window.location.href;
	      },
	      configurable: true
	    };
	    Object.defineProperty(document, "baseURI", baseURIDescriptor);
	    Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
	  }
	  scope.importer = importer;
	  scope.importLoader = importLoader;
	});

	window.HTMLImports.addModule(function(scope) {
	  var parser = scope.parser;
	  var importer = scope.importer;
	  var dynamic = {
	    added: function(nodes) {
	      var owner, parsed, loading;
	      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
	        if (!owner) {
	          owner = n.ownerDocument;
	          parsed = parser.isParsed(owner);
	        }
	        loading = this.shouldLoadNode(n);
	        if (loading) {
	          importer.loadNode(n);
	        }
	        if (this.shouldParseNode(n) && parsed) {
	          parser.parseDynamic(n, loading);
	        }
	      }
	    },
	    shouldLoadNode: function(node) {
	      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
	    },
	    shouldParseNode: function(node) {
	      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
	    }
	  };
	  importer.observer.addCallback = dynamic.added.bind(dynamic);
	  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
	});

	(function(scope) {
	  var initializeModules = scope.initializeModules;
	  var isIE = scope.isIE;
	  if (scope.useNative) {
	    return;
	  }
	  initializeModules();
	  var rootDocument = scope.rootDocument;
	  function bootstrap() {
	    window.HTMLImports.importer.bootDocument(rootDocument);
	  }
	  if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
	    bootstrap();
	  } else {
	    document.addEventListener("DOMContentLoaded", bootstrap);
	  }
	})(window.HTMLImports);

	window.CustomElements = window.CustomElements || {
	  flags: {}
	};

	(function(scope) {
	  var flags = scope.flags;
	  var modules = [];
	  var addModule = function(module) {
	    modules.push(module);
	  };
	  var initializeModules = function() {
	    modules.forEach(function(module) {
	      module(scope);
	    });
	  };
	  scope.addModule = addModule;
	  scope.initializeModules = initializeModules;
	  scope.hasNative = Boolean(document.registerElement);
	  scope.isIE = /Trident/.test(navigator.userAgent);
	  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
	})(window.CustomElements);

	window.CustomElements.addModule(function(scope) {
	  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
	  function forSubtree(node, cb) {
	    findAllElements(node, function(e) {
	      if (cb(e)) {
	        return true;
	      }
	      forRoots(e, cb);
	    });
	    forRoots(node, cb);
	  }
	  function findAllElements(node, find, data) {
	    var e = node.firstElementChild;
	    if (!e) {
	      e = node.firstChild;
	      while (e && e.nodeType !== Node.ELEMENT_NODE) {
	        e = e.nextSibling;
	      }
	    }
	    while (e) {
	      if (find(e, data) !== true) {
	        findAllElements(e, find, data);
	      }
	      e = e.nextElementSibling;
	    }
	    return null;
	  }
	  function forRoots(node, cb) {
	    var root = node.shadowRoot;
	    while (root) {
	      forSubtree(root, cb);
	      root = root.olderShadowRoot;
	    }
	  }
	  function forDocumentTree(doc, cb) {
	    _forDocumentTree(doc, cb, []);
	  }
	  function _forDocumentTree(doc, cb, processingDocuments) {
	    doc = window.wrap(doc);
	    if (processingDocuments.indexOf(doc) >= 0) {
	      return;
	    }
	    processingDocuments.push(doc);
	    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
	    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
	      if (n.import) {
	        _forDocumentTree(n.import, cb, processingDocuments);
	      }
	    }
	    cb(doc);
	  }
	  scope.forDocumentTree = forDocumentTree;
	  scope.forSubtree = forSubtree;
	});

	window.CustomElements.addModule(function(scope) {
	  var flags = scope.flags;
	  var forSubtree = scope.forSubtree;
	  var forDocumentTree = scope.forDocumentTree;
	  function addedNode(node, isAttached) {
	    return added(node, isAttached) || addedSubtree(node, isAttached);
	  }
	  function added(node, isAttached) {
	    if (scope.upgrade(node, isAttached)) {
	      return true;
	    }
	    if (isAttached) {
	      attached(node);
	    }
	  }
	  function addedSubtree(node, isAttached) {
	    forSubtree(node, function(e) {
	      if (added(e, isAttached)) {
	        return true;
	      }
	    });
	  }
	  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags["throttle-attached"];
	  scope.hasPolyfillMutations = hasThrottledAttached;
	  scope.hasThrottledAttached = hasThrottledAttached;
	  var isPendingMutations = false;
	  var pendingMutations = [];
	  function deferMutation(fn) {
	    pendingMutations.push(fn);
	    if (!isPendingMutations) {
	      isPendingMutations = true;
	      setTimeout(takeMutations);
	    }
	  }
	  function takeMutations() {
	    isPendingMutations = false;
	    var $p = pendingMutations;
	    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
	      p();
	    }
	    pendingMutations = [];
	  }
	  function attached(element) {
	    if (hasThrottledAttached) {
	      deferMutation(function() {
	        _attached(element);
	      });
	    } else {
	      _attached(element);
	    }
	  }
	  function _attached(element) {
	    if (element.__upgraded__ && !element.__attached) {
	      element.__attached = true;
	      if (element.attachedCallback) {
	        element.attachedCallback();
	      }
	    }
	  }
	  function detachedNode(node) {
	    detached(node);
	    forSubtree(node, function(e) {
	      detached(e);
	    });
	  }
	  function detached(element) {
	    if (hasThrottledAttached) {
	      deferMutation(function() {
	        _detached(element);
	      });
	    } else {
	      _detached(element);
	    }
	  }
	  function _detached(element) {
	    if (element.__upgraded__ && element.__attached) {
	      element.__attached = false;
	      if (element.detachedCallback) {
	        element.detachedCallback();
	      }
	    }
	  }
	  function inDocument(element) {
	    var p = element;
	    var doc = window.wrap(document);
	    while (p) {
	      if (p == doc) {
	        return true;
	      }
	      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
	    }
	  }
	  function watchShadow(node) {
	    if (node.shadowRoot && !node.shadowRoot.__watched) {
	      flags.dom && console.log("watching shadow-root for: ", node.localName);
	      var root = node.shadowRoot;
	      while (root) {
	        observe(root);
	        root = root.olderShadowRoot;
	      }
	    }
	  }
	  function handler(root, mutations) {
	    if (flags.dom) {
	      var mx = mutations[0];
	      if (mx && mx.type === "childList" && mx.addedNodes) {
	        if (mx.addedNodes) {
	          var d = mx.addedNodes[0];
	          while (d && d !== document && !d.host) {
	            d = d.parentNode;
	          }
	          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
	          u = u.split("/?").shift().split("/").pop();
	        }
	      }
	      console.group("mutations (%d) [%s]", mutations.length, u || "");
	    }
	    var isAttached = inDocument(root);
	    mutations.forEach(function(mx) {
	      if (mx.type === "childList") {
	        forEach(mx.addedNodes, function(n) {
	          if (!n.localName) {
	            return;
	          }
	          addedNode(n, isAttached);
	        });
	        forEach(mx.removedNodes, function(n) {
	          if (!n.localName) {
	            return;
	          }
	          detachedNode(n);
	        });
	      }
	    });
	    flags.dom && console.groupEnd();
	  }
	  function takeRecords(node) {
	    node = window.wrap(node);
	    if (!node) {
	      node = window.wrap(document);
	    }
	    while (node.parentNode) {
	      node = node.parentNode;
	    }
	    var observer = node.__observer;
	    if (observer) {
	      handler(node, observer.takeRecords());
	      takeMutations();
	    }
	  }
	  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
	  function observe(inRoot) {
	    if (inRoot.__observer) {
	      return;
	    }
	    var observer = new MutationObserver(handler.bind(this, inRoot));
	    observer.observe(inRoot, {
	      childList: true,
	      subtree: true
	    });
	    inRoot.__observer = observer;
	  }
	  function upgradeDocument(doc) {
	    doc = window.wrap(doc);
	    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
	    var isMainDocument = doc === window.wrap(document);
	    addedNode(doc, isMainDocument);
	    observe(doc);
	    flags.dom && console.groupEnd();
	  }
	  function upgradeDocumentTree(doc) {
	    forDocumentTree(doc, upgradeDocument);
	  }
	  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
	  if (originalCreateShadowRoot) {
	    Element.prototype.createShadowRoot = function() {
	      var root = originalCreateShadowRoot.call(this);
	      window.CustomElements.watchShadow(this);
	      return root;
	    };
	  }
	  scope.watchShadow = watchShadow;
	  scope.upgradeDocumentTree = upgradeDocumentTree;
	  scope.upgradeDocument = upgradeDocument;
	  scope.upgradeSubtree = addedSubtree;
	  scope.upgradeAll = addedNode;
	  scope.attached = attached;
	  scope.takeRecords = takeRecords;
	});

	window.CustomElements.addModule(function(scope) {
	  var flags = scope.flags;
	  function upgrade(node, isAttached) {
	    if (node.localName === "template") {
	      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
	        HTMLTemplateElement.decorate(node);
	      }
	    }
	    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
	      var is = node.getAttribute("is");
	      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
	      if (definition) {
	        if (is && definition.tag == node.localName || !is && !definition.extends) {
	          return upgradeWithDefinition(node, definition, isAttached);
	        }
	      }
	    }
	  }
	  function upgradeWithDefinition(element, definition, isAttached) {
	    flags.upgrade && console.group("upgrade:", element.localName);
	    if (definition.is) {
	      element.setAttribute("is", definition.is);
	    }
	    implementPrototype(element, definition);
	    element.__upgraded__ = true;
	    created(element);
	    if (isAttached) {
	      scope.attached(element);
	    }
	    scope.upgradeSubtree(element, isAttached);
	    flags.upgrade && console.groupEnd();
	    return element;
	  }
	  function implementPrototype(element, definition) {
	    if (Object.__proto__) {
	      element.__proto__ = definition.prototype;
	    } else {
	      customMixin(element, definition.prototype, definition.native);
	      element.__proto__ = definition.prototype;
	    }
	  }
	  function customMixin(inTarget, inSrc, inNative) {
	    var used = {};
	    var p = inSrc;
	    while (p !== inNative && p !== HTMLElement.prototype) {
	      var keys = Object.getOwnPropertyNames(p);
	      for (var i = 0, k; k = keys[i]; i++) {
	        if (!used[k]) {
	          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
	          used[k] = 1;
	        }
	      }
	      p = Object.getPrototypeOf(p);
	    }
	  }
	  function created(element) {
	    if (element.createdCallback) {
	      element.createdCallback();
	    }
	  }
	  scope.upgrade = upgrade;
	  scope.upgradeWithDefinition = upgradeWithDefinition;
	  scope.implementPrototype = implementPrototype;
	});

	window.CustomElements.addModule(function(scope) {
	  var isIE = scope.isIE;
	  var upgradeDocumentTree = scope.upgradeDocumentTree;
	  var upgradeAll = scope.upgradeAll;
	  var upgradeWithDefinition = scope.upgradeWithDefinition;
	  var implementPrototype = scope.implementPrototype;
	  var useNative = scope.useNative;
	  function register(name, options) {
	    var definition = options || {};
	    if (!name) {
	      throw new Error("document.registerElement: first argument `name` must not be empty");
	    }
	    if (name.indexOf("-") < 0) {
	      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
	    }
	    if (isReservedTag(name)) {
	      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
	    }
	    if (getRegisteredDefinition(name)) {
	      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
	    }
	    if (!definition.prototype) {
	      definition.prototype = Object.create(HTMLElement.prototype);
	    }
	    definition.__name = name.toLowerCase();
	    if (definition.extends) {
	      definition.extends = definition.extends.toLowerCase();
	    }
	    definition.lifecycle = definition.lifecycle || {};
	    definition.ancestry = ancestry(definition.extends);
	    resolveTagName(definition);
	    resolvePrototypeChain(definition);
	    overrideAttributeApi(definition.prototype);
	    registerDefinition(definition.__name, definition);
	    definition.ctor = generateConstructor(definition);
	    definition.ctor.prototype = definition.prototype;
	    definition.prototype.constructor = definition.ctor;
	    if (scope.ready) {
	      upgradeDocumentTree(document);
	    }
	    return definition.ctor;
	  }
	  function overrideAttributeApi(prototype) {
	    if (prototype.setAttribute._polyfilled) {
	      return;
	    }
	    var setAttribute = prototype.setAttribute;
	    prototype.setAttribute = function(name, value) {
	      changeAttribute.call(this, name, value, setAttribute);
	    };
	    var removeAttribute = prototype.removeAttribute;
	    prototype.removeAttribute = function(name) {
	      changeAttribute.call(this, name, null, removeAttribute);
	    };
	    prototype.setAttribute._polyfilled = true;
	  }
	  function changeAttribute(name, value, operation) {
	    name = name.toLowerCase();
	    var oldValue = this.getAttribute(name);
	    operation.apply(this, arguments);
	    var newValue = this.getAttribute(name);
	    if (this.attributeChangedCallback && newValue !== oldValue) {
	      this.attributeChangedCallback(name, oldValue, newValue);
	    }
	  }
	  function isReservedTag(name) {
	    for (var i = 0; i < reservedTagList.length; i++) {
	      if (name === reservedTagList[i]) {
	        return true;
	      }
	    }
	  }
	  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
	  function ancestry(extnds) {
	    var extendee = getRegisteredDefinition(extnds);
	    if (extendee) {
	      return ancestry(extendee.extends).concat([ extendee ]);
	    }
	    return [];
	  }
	  function resolveTagName(definition) {
	    var baseTag = definition.extends;
	    for (var i = 0, a; a = definition.ancestry[i]; i++) {
	      baseTag = a.is && a.tag;
	    }
	    definition.tag = baseTag || definition.__name;
	    if (baseTag) {
	      definition.is = definition.__name;
	    }
	  }
	  function resolvePrototypeChain(definition) {
	    if (!Object.__proto__) {
	      var nativePrototype = HTMLElement.prototype;
	      if (definition.is) {
	        var inst = document.createElement(definition.tag);
	        nativePrototype = Object.getPrototypeOf(inst);
	      }
	      var proto = definition.prototype, ancestor;
	      var foundPrototype = false;
	      while (proto) {
	        if (proto == nativePrototype) {
	          foundPrototype = true;
	        }
	        ancestor = Object.getPrototypeOf(proto);
	        if (ancestor) {
	          proto.__proto__ = ancestor;
	        }
	        proto = ancestor;
	      }
	      if (!foundPrototype) {
	        console.warn(definition.tag + " prototype not found in prototype chain for " + definition.is);
	      }
	      definition.native = nativePrototype;
	    }
	  }
	  function instantiate(definition) {
	    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
	  }
	  var registry = {};
	  function getRegisteredDefinition(name) {
	    if (name) {
	      return registry[name.toLowerCase()];
	    }
	  }
	  function registerDefinition(name, definition) {
	    registry[name] = definition;
	  }
	  function generateConstructor(definition) {
	    return function() {
	      return instantiate(definition);
	    };
	  }
	  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
	  function createElementNS(namespace, tag, typeExtension) {
	    if (namespace === HTML_NAMESPACE) {
	      return createElement(tag, typeExtension);
	    } else {
	      return domCreateElementNS(namespace, tag);
	    }
	  }
	  function createElement(tag, typeExtension) {
	    if (tag) {
	      tag = tag.toLowerCase();
	    }
	    if (typeExtension) {
	      typeExtension = typeExtension.toLowerCase();
	    }
	    var definition = getRegisteredDefinition(typeExtension || tag);
	    if (definition) {
	      if (tag == definition.tag && typeExtension == definition.is) {
	        return new definition.ctor();
	      }
	      if (!typeExtension && !definition.is) {
	        return new definition.ctor();
	      }
	    }
	    var element;
	    if (typeExtension) {
	      element = createElement(tag);
	      element.setAttribute("is", typeExtension);
	      return element;
	    }
	    element = domCreateElement(tag);
	    if (tag.indexOf("-") >= 0) {
	      implementPrototype(element, HTMLElement);
	    }
	    return element;
	  }
	  var domCreateElement = document.createElement.bind(document);
	  var domCreateElementNS = document.createElementNS.bind(document);
	  var isInstance;
	  if (!Object.__proto__ && !useNative) {
	    isInstance = function(obj, ctor) {
	      if (obj instanceof ctor) {
	        return true;
	      }
	      var p = obj;
	      while (p) {
	        if (p === ctor.prototype) {
	          return true;
	        }
	        p = p.__proto__;
	      }
	      return false;
	    };
	  } else {
	    isInstance = function(obj, base) {
	      return obj instanceof base;
	    };
	  }
	  function wrapDomMethodToForceUpgrade(obj, methodName) {
	    var orig = obj[methodName];
	    obj[methodName] = function() {
	      var n = orig.apply(this, arguments);
	      upgradeAll(n);
	      return n;
	    };
	  }
	  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
	  wrapDomMethodToForceUpgrade(document, "importNode");
	  document.registerElement = register;
	  document.createElement = createElement;
	  document.createElementNS = createElementNS;
	  scope.registry = registry;
	  scope.instanceof = isInstance;
	  scope.reservedTagList = reservedTagList;
	  scope.getRegisteredDefinition = getRegisteredDefinition;
	  document.register = document.registerElement;
	});

	(function(scope) {
	  var useNative = scope.useNative;
	  var initializeModules = scope.initializeModules;
	  var isIE = scope.isIE;
	  if (useNative) {
	    var nop = function() {};
	    scope.watchShadow = nop;
	    scope.upgrade = nop;
	    scope.upgradeAll = nop;
	    scope.upgradeDocumentTree = nop;
	    scope.upgradeSubtree = nop;
	    scope.takeRecords = nop;
	    scope.instanceof = function(obj, base) {
	      return obj instanceof base;
	    };
	  } else {
	    initializeModules();
	  }
	  var upgradeDocumentTree = scope.upgradeDocumentTree;
	  var upgradeDocument = scope.upgradeDocument;
	  if (!window.wrap) {
	    if (window.ShadowDOMPolyfill) {
	      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
	      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
	    } else {
	      window.wrap = window.unwrap = function(node) {
	        return node;
	      };
	    }
	  }
	  if (window.HTMLImports) {
	    window.HTMLImports.__importsParsingHook = function(elt) {
	      if (elt.import) {
	        upgradeDocument(wrap(elt.import));
	      }
	    };
	  }
	  function bootstrap() {
	    upgradeDocumentTree(window.wrap(document));
	    window.CustomElements.ready = true;
	    var requestAnimationFrame = window.requestAnimationFrame || function(f) {
	      setTimeout(f, 16);
	    };
	    requestAnimationFrame(function() {
	      setTimeout(function() {
	        window.CustomElements.readyTime = Date.now();
	        if (window.HTMLImports) {
	          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
	        }
	        document.dispatchEvent(new CustomEvent("WebComponentsReady", {
	          bubbles: true
	        }));
	      });
	    });
	  }
	  if (document.readyState === "complete" || scope.flags.eager) {
	    bootstrap();
	  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
	    bootstrap();
	  } else {
	    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
	    window.addEventListener(loadEvent, bootstrap);
	  }
	})(window.CustomElements);

	(function(scope) {
	  var style = document.createElement("style");
	  style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \n";
	  var head = document.querySelector("head");
	  head.insertBefore(style, head.firstChild);
	})(window.WebComponents);

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var _SWebComponent = __webpack_require__(53);

	var _SWebComponent2 = _interopRequireDefault(_SWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_SWebComponent2.default.setDefaultProps({
		apiKey: 'AIzaSyDCD2MPJFbXBkc5hNB5p8v21XcpeIo_5Mw'
	}, ['s-google-map', 's-google-map-marker']);

	_SWebComponent2.default.setDefaultProps({
		mountWhen: 'isInViewport'
	}, 's-bodymovin');

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(54);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(55);

	var _SWebComponentMixin = __webpack_require__(56);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(55);

	var _autoCast = __webpack_require__(57);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(108);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(109);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(111);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(114);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(115);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(122);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(123);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(162);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 57 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(59);


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(60),
	    createAssigner = __webpack_require__(79),
	    keysIn = __webpack_require__(92);

	/**
	 * This method is like `_.assign` except that it iterates over own and
	 * inherited source properties.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assign
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	 */
	var assignIn = createAssigner(function(object, source) {
	  copyObject(source, keysIn(source), object);
	});

	module.exports = assignIn;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(61),
	    baseAssignValue = __webpack_require__(62);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(62),
	    eq = __webpack_require__(78);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(63);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(64);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(65),
	    getValue = __webpack_require__(77);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(66),
	    isMasked = __webpack_require__(74),
	    isObject = __webpack_require__(73),
	    toSource = __webpack_require__(76);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(67),
	    isObject = __webpack_require__(73);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(68),
	    getRawTag = __webpack_require__(71),
	    objectToString = __webpack_require__(72);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(69);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(70);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 70 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(68);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 72 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(75);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(69);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 76 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 77 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(80),
	    isIterateeCall = __webpack_require__(88);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(81),
	    overRest = __webpack_require__(82),
	    setToString = __webpack_require__(84);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 81 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(83);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(85),
	    shortOut = __webpack_require__(87);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(86),
	    defineProperty = __webpack_require__(63),
	    identity = __webpack_require__(81);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 87 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(78),
	    isArrayLike = __webpack_require__(89),
	    isIndex = __webpack_require__(91),
	    isObject = __webpack_require__(73);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(66),
	    isLength = __webpack_require__(90);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 90 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 91 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(93),
	    baseKeysIn = __webpack_require__(105),
	    isArrayLike = __webpack_require__(89);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(94),
	    isArguments = __webpack_require__(95),
	    isArray = __webpack_require__(98),
	    isBuffer = __webpack_require__(99),
	    isIndex = __webpack_require__(91),
	    isTypedArray = __webpack_require__(101);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 94 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(96),
	    isObjectLike = __webpack_require__(97);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(67),
	    isObjectLike = __webpack_require__(97);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(69),
	    stubFalse = __webpack_require__(100);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module)))

/***/ },
/* 100 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(102),
	    baseUnary = __webpack_require__(103),
	    nodeUtil = __webpack_require__(104);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(67),
	    isLength = __webpack_require__(90),
	    isObjectLike = __webpack_require__(97);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(70);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(73),
	    isPrototype = __webpack_require__(106),
	    nativeKeysIn = __webpack_require__(107);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ },
/* 106 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 107 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 109 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(function(win) {

	/**
	 * FastDom
	 *
	 * Eliminates layout thrashing
	 * by batching DOM read/write
	 * interactions.
	 *
	 * @author Wilson Page <wilsonpage@me.com>
	 * @author Kornel Lesinski <kornel.lesinski@ft.com>
	 */

	'use strict';

	/**
	 * Mini logger
	 *
	 * @return {Function}
	 */
	var debug = 0 ? console.log.bind(console, '[fastdom]') : function() {};

	/**
	 * Normalized rAF
	 *
	 * @type {Function}
	 */
	var raf = win.requestAnimationFrame
	  || win.webkitRequestAnimationFrame
	  || win.mozRequestAnimationFrame
	  || win.msRequestAnimationFrame
	  || function(cb) { return setTimeout(cb, 16); };

	/**
	 * Initialize a `FastDom`.
	 *
	 * @constructor
	 */
	function FastDom() {
	  var self = this;
	  self.reads = [];
	  self.writes = [];
	  self.raf = raf.bind(win); // test hook
	  debug('initialized', self);
	}

	FastDom.prototype = {
	  constructor: FastDom,

	  /**
	   * Adds a job to the read batch and
	   * schedules a new frame if need be.
	   *
	   * @param  {Function} fn
	   * @public
	   */
	  measure: function(fn, ctx) {
	    debug('measure');
	    var task = !ctx ? fn : fn.bind(ctx);
	    this.reads.push(task);
	    scheduleFlush(this);
	    return task;
	  },

	  /**
	   * Adds a job to the
	   * write batch and schedules
	   * a new frame if need be.
	   *
	   * @param  {Function} fn
	   * @public
	   */
	  mutate: function(fn, ctx) {
	    debug('mutate');
	    var task = !ctx ? fn : fn.bind(ctx);
	    this.writes.push(task);
	    scheduleFlush(this);
	    return task;
	  },

	  /**
	   * Clears a scheduled 'read' or 'write' task.
	   *
	   * @param {Object} task
	   * @return {Boolean} success
	   * @public
	   */
	  clear: function(task) {
	    debug('clear', task);
	    return remove(this.reads, task) || remove(this.writes, task);
	  },

	  /**
	   * Extend this FastDom with some
	   * custom functionality.
	   *
	   * Because fastdom must *always* be a
	   * singleton, we're actually extending
	   * the fastdom instance. This means tasks
	   * scheduled by an extension still enter
	   * fastdom's global task queue.
	   *
	   * The 'super' instance can be accessed
	   * from `this.fastdom`.
	   *
	   * @example
	   *
	   * var myFastdom = fastdom.extend({
	   *   initialize: function() {
	   *     // runs on creation
	   *   },
	   *
	   *   // override a method
	   *   measure: function(fn) {
	   *     // do extra stuff ...
	   *
	   *     // then call the original
	   *     return this.fastdom.measure(fn);
	   *   },
	   *
	   *   ...
	   * });
	   *
	   * @param  {Object} props  properties to mixin
	   * @return {FastDom}
	   */
	  extend: function(props) {
	    debug('extend', props);
	    if (typeof props != 'object') throw new Error('expected object');

	    var child = Object.create(this);
	    mixin(child, props);
	    child.fastdom = this;

	    // run optional creation hook
	    if (child.initialize) child.initialize();

	    return child;
	  },

	  // override this with a function
	  // to prevent Errors in console
	  // when tasks throw
	  catch: null
	};

	/**
	 * Schedules a new read/write
	 * batch if one isn't pending.
	 *
	 * @private
	 */
	function scheduleFlush(fastdom) {
	  if (!fastdom.scheduled) {
	    fastdom.scheduled = true;
	    fastdom.raf(flush.bind(null, fastdom));
	    debug('flush scheduled');
	  }
	}

	/**
	 * Runs queued `read` and `write` tasks.
	 *
	 * Errors are caught and thrown by default.
	 * If a `.catch` function has been defined
	 * it is called instead.
	 *
	 * @private
	 */
	function flush(fastdom) {
	  debug('flush');

	  var writes = fastdom.writes;
	  var reads = fastdom.reads;
	  var error;

	  try {
	    debug('flushing reads', reads.length);
	    runTasks(reads);
	    debug('flushing writes', writes.length);
	    runTasks(writes);
	  } catch (e) { error = e; }

	  fastdom.scheduled = false;

	  // If the batch errored we may still have tasks queued
	  if (reads.length || writes.length) scheduleFlush(fastdom);

	  if (error) {
	    debug('task errored', error.message);
	    if (fastdom.catch) fastdom.catch(error);
	    else throw error;
	  }
	}

	/**
	 * We run this inside a try catch
	 * so that if any jobs error, we
	 * are able to recover and continue
	 * to flush the batch until it's empty.
	 *
	 * @private
	 */
	function runTasks(tasks) {
	  debug('run tasks');
	  var task; while (task = tasks.shift()) task();
	}

	/**
	 * Remove an item from an Array.
	 *
	 * @param  {Array} array
	 * @param  {*} item
	 * @return {Boolean}
	 */
	function remove(array, item) {
	  var index = array.indexOf(item);
	  return !!~index && !!array.splice(index, 1);
	}

	/**
	 * Mixin own properties of source
	 * object into the target.
	 *
	 * @param  {Object} target
	 * @param  {Object} source
	 */
	function mixin(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) target[key] = source[key];
	  }
	}

	// There should never be more than
	// one instance of `FastDom` in an app
	var exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line

	// Expose to CJS & AMD
	if (("function")[0] == 'f') !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return exports; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	else if ((typeof module)[0] == 'o') module.exports = exports;

	})( typeof window !== 'undefined' ? window : this);


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(112);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 113 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;

	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}

	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */

	module.exports = useNative() ? NativeCustomEvent :

	// IE >= 9
	'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :

	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(115);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(118);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(119);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(120);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(116);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(117);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(116);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 119 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(121);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 121 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 122 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(124);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 124 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(126);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(127),
	    toKey = __webpack_require__(159);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(98),
	    isKey = __webpack_require__(128),
	    stringToPath = __webpack_require__(130),
	    toString = __webpack_require__(156);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(98),
	    isSymbol = __webpack_require__(129);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(67),
	    isObjectLike = __webpack_require__(97);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(131);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(132);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(133);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(134),
	    mapCacheDelete = __webpack_require__(150),
	    mapCacheGet = __webpack_require__(153),
	    mapCacheHas = __webpack_require__(154),
	    mapCacheSet = __webpack_require__(155);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(135),
	    ListCache = __webpack_require__(142),
	    Map = __webpack_require__(149);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(136),
	    hashDelete = __webpack_require__(138),
	    hashGet = __webpack_require__(139),
	    hashHas = __webpack_require__(140),
	    hashSet = __webpack_require__(141);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(137);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(137);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(137);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(137);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(143),
	    listCacheDelete = __webpack_require__(144),
	    listCacheGet = __webpack_require__(146),
	    listCacheHas = __webpack_require__(147),
	    listCacheSet = __webpack_require__(148);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(145);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(78);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(145);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(145);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(145);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(64),
	    root = __webpack_require__(69);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(151);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(152);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 152 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(151);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(151);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(151);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(157);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(68),
	    arrayMap = __webpack_require__(158),
	    isArray = __webpack_require__(98),
	    isSymbol = __webpack_require__(129);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(129);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var baseSet = __webpack_require__(161);

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	module.exports = set;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(61),
	    castPath = __webpack_require__(127),
	    isIndex = __webpack_require__(91),
	    isObject = __webpack_require__(73),
	    toKey = __webpack_require__(159);

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	module.exports = baseSet;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(111);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(166);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 166 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var _coffeekrakenSDatepickerComponent = __webpack_require__(168);

	var _coffeekrakenSDatepickerComponent2 = _interopRequireDefault(_coffeekrakenSDatepickerComponent);

	var _coffeekrakenSGoogleMapComponent = __webpack_require__(197);

	var _coffeekrakenSGoogleMapComponent2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponent);

	var _coffeekrakenSGoogleMapMarkerComponent = __webpack_require__(227);

	var _coffeekrakenSGoogleMapMarkerComponent2 = _interopRequireDefault(_coffeekrakenSGoogleMapMarkerComponent);

	var _coffeekrakenSCustomScrollbarComponent = __webpack_require__(246);

	var _coffeekrakenSCustomScrollbarComponent2 = _interopRequireDefault(_coffeekrakenSCustomScrollbarComponent);

	var _coffeekrakenSRippleComponent = __webpack_require__(274);

	var _coffeekrakenSRippleComponent2 = _interopRequireDefault(_coffeekrakenSRippleComponent);

	var _coffeekrakenSEqualizeComponent = __webpack_require__(366);

	var _coffeekrakenSEqualizeComponent2 = _interopRequireDefault(_coffeekrakenSEqualizeComponent);

	var _coffeekrakenSShareComponent = __webpack_require__(394);

	var _coffeekrakenSShareComponent2 = _interopRequireDefault(_coffeekrakenSShareComponent);

	var _coffeekrakenSBodymovinComponent = __webpack_require__(422);

	var _coffeekrakenSBodymovinComponent2 = _interopRequireDefault(_coffeekrakenSBodymovinComponent);

	var _coffeekrakenSITypedComponent = __webpack_require__(451);

	var _coffeekrakenSITypedComponent2 = _interopRequireDefault(_coffeekrakenSITypedComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SDatepickerComponent = __webpack_require__(169);

	var _SDatepickerComponent2 = _interopRequireDefault(_SDatepickerComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SDatepickerComponent2.default.define('s-datepicker', _SDatepickerComponent2.default);

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(170);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _flatpickr = __webpack_require__(195);

	var _flatpickr2 = _interopRequireDefault(_flatpickr);

	var _integer = __webpack_require__(196);

	var _integer2 = _interopRequireDefault(_integer);

	var _autoCast = __webpack_require__(174);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SDatepickerComponent
	 * @extends 	SWebComponent
	 * Provide a nice and powerful datepicker component around the nice flatpickr plugin.
	 * Features:
	 * - Fully featured datepicker (thanks to flatpick)
	 * - Ability to display inline as well as on field focus
	 * - Timepicker support
	 * - And more...
	 * @styleguide  	Form / Datepicker
	 * @example 	html
	 * <input name="my-cool-date" class="form-input" />
	 * <s-datepicker for="my-cool-date"></s-datepicker>
	 * @see 	http://github.coffeekraken.io/chmln/flatpickr/^v2.0.0 		Flatpickr documentation
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	/**
	 * @name 			Datepicker inline
	 * Provide a way to display a nice datepicker
	 * @styleguide  	Form / Datepicker
	 * @example 		html
	 * <div style="height:28em">
	 * 	<input name="my-cool-date" class="visually-hidden" />
	 *  <s-datepicker for="my-cool-date" inline></s-datepicker>
	 * </div>
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */

	/**
	 * @name 			Datepicker with time
	 * Provide a way to display a nice datepicker
	 * @styleguide  	Form / Datepicker
	 * @example 		html
	 * <div style="height:32em">
	 * 	<input name="my-cool-date" class="form-input" />
	 *  <s-datepicker for="my-cool-date" date-format="Y-m-d H:i" enable-time></s-datepicker>
	 * </div>
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SDatepickerComponent = function (_SWebComponent) {
		_inherits(SDatepickerComponent, _SWebComponent);

		function SDatepickerComponent() {
			_classCallCheck(this, SDatepickerComponent);

			return _possibleConstructorReturn(this, (SDatepickerComponent.__proto__ || Object.getPrototypeOf(SDatepickerComponent)).apply(this, arguments));
		}

		_createClass(SDatepickerComponent, [{
			key: 'componentMount',


			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */
			value: function componentMount() {
				_get(SDatepickerComponent.prototype.__proto__ || Object.getPrototypeOf(SDatepickerComponent.prototype), 'componentMount', this).call(this);

				// get the datepicker input target
				this._targetInput = this;
				if (this.props.for) {
					// try to get the input
					var input = document.querySelector('[name="' + this.props.for + '"],input#' + this.props.for);
					if (input) {
						this._targetInput = input;
					}
				}

				// instanciate the datepicker
				this._instanciateDatepicker();
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'color':
						break;
					default:
						// destroy and recreate the datepicker
						this._flatpickr.destroy();
						this._instanciateDatepicker();
						break;
				}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SDatepickerComponent.prototype.__proto__ || Object.getPrototypeOf(SDatepickerComponent.prototype), 'render', this).call(this);
				// copy props
				if (this.props.color) {
					this._flatpickr.calendarContainer.setAttribute('color', this.props.color);
				}
			}

			/**
	   * Create datepicker instance
	   */

		}, {
			key: '_instanciateDatepicker',
			value: function _instanciateDatepicker() {
				var _this2 = this;

				this._flatpickr = new _flatpickr2.default(this._targetInput, {
					clickOpens: this.props.openOnClick,
					dateFormat: this.props.dateFormat,
					defaultDate: this._targetInput.value || this.props.defaultDate,
					disable: this.props.disabledDates,
					enable: this.props.enabledDates,
					enableTime: this.props.enableTime,
					enableSeconds: this.props.enableSeconds,
					hourIncrement: this.props.hourIncrement,
					inline: this.props.inline,
					maxDate: this.props.maxDate,
					minDate: this.props.minDate,
					minuteIncrement: this.props.minuteIncrement,
					noCalendar: this.props.noCalendar,
					onChange: function onChange(dateObj, dateStr, instance) {
						_this2.props.onChange && _this2.props.onChange(dateObj, dateStr, instance);
						_this2.dispatchComponentEvent('change', {
							dateObj: dateObj,
							dateStr: dateStr,
							instance: instance
						});
					},
					onClose: this.props.onClose,
					onOpen: function onOpen(dateObj, dateStr, instance) {
						_this2.props.onOpen && _this2.props.onOpen(dateObj, dateStr, instance);
					},
					onReady: function onReady(dateObj, dateStr, instance) {
						_this2.props.onReady && _this2.props.onReady(dateObj, dateStr, instance);
						if (_this2._targetInput.tagName.toLowerCase() === 'input') {
							if (!_this2._targetInput.value) {
								instance.setDate(_this2.props.minDate || new Date());
							}
							instance.triggerChange();
						}
					},
					parseDate: this.props.parseDate ? this.props.parseDate.bind(this) : function (date) {
						// if the date is a time only
						if (this.props.noCalendar && this.props.enableTime) {
							return new Date(Date.parse('2000.01.01 ' + date));
						} else if ((0, _integer2.default)((0, _autoCast2.default)(date))) {
							// it's a timestamp
							return new Date(parseInt(date) * 1000);
						}
						return new Date(Date.parse(date));
					}.bind(this),
					shorthandCurrentMonth: this.props.shorthandCurrentMonth,
					time_24hr: this.props.time24hr,
					utc: this.props.utc,
					weekNumbers: this.props.weekNumbers,
					wrap: this.props.wrap,
					appendTo: this
				});
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay:inline-block;\n\t\t\t}\n\t\t\t.flatpickr-input {\n\t\t\t\tcursor: pointer;\n\t\t\t\tz-index: 1\n\t\t\t}\n\t\t\t.flatpickr-mobileInput {\n\t\t\t\topacity: 0;\n\t\t\t\tvisibility: hidden;\n\t\t\t\tposition: absolute;\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tpadding: 0\n\t\t\t}\n\t\t\t.flatpickr-calendar {\n\t\t\t\tbackground: #fff;\n\t\t\t\topacity:0;\n\t\t\t\tpointer-events: none;\n\t\t\t\tmargin-top:-20px;\n\t\t\t\ttext-align: center;\n\t\t\t\tpadding:1em;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop:0; left: -200vw;\n\t\t\t\tuser-select:none;\n\t\t\t}\n\t\t\t.flatpickr-calendar.open {\n\t\t\t\topacity: 1;\n\t\t\t\tz-index: 99999;\n\t\t\t\tmargin-top:0;\n\t\t\t\tpointer-events: all;\n\t\t\t\ttop:0; left:0;\n\t\t\t}\n\t\t\t.flatpickr-calendar.inline {\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tposition: relative;\n\t\t\t\topacity:1;\n\t\t\t\tmargin-top:0;\n\t\t\t\tpadding:0;\n\t\t\t\tpointer-events: all;\n\t\t\t\tleft:0;\n\t\t\t}\n\t\t\t.flatpickr-calendar.static {\n\t\t\t\tposition: relative\n\t\t\t}\n\t\t\t.flatpickr-calendar.static.open {\n\t\t\t\tdisplay: block\n\t\t\t}\n\t\t\t.flatpickr-calendar.hasWeeks {\n\t\t\t}\n\n\t\t\t.flatpickr-month,\n\t\t\t.flatpickr-next-month i,\n\t\t\t.flatpickr-prev-month i {\n\t\t\t\tposition: relative\n\t\t\t}\n\n\t\t\t.flatpickr-month {\n\t\t\t\tuser-select:none;\n\t\t\t\twidth:100%;\n\t\t\t\tdisplay: flex;\n\t\t\t\tpadding: 1em 0;\n\t\t\t}\n\t\t\t.flatpickr-month > span {\n\t\t\t\tvertical-align: middle;\n\t\t\t}\n\n\t\t\t.flatpickr-next-month,\n\t\t\t.flatpickr-prev-month {\n\t\t\t\ttext-decoration: none;\n\t\t\t\tcursor: pointer;\n\t\t\t\twidth: 3em;\n\t\t\t\tdisplay : inline-block !important;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\t.flatpickr-next-month[style*="none"],\n\t\t\t.flatpickr-prev-month[style*="none"] {\n\t\t\t\tpointer-events:none;\n\t\t\t\topacity: .4;\n\t\t\t}\n\t\t\t.flatpickr-next-month svg,\n\t\t\t.flatpickr-prev-month svg {\n\t\t\t\theight: 1em;\n\t\t\t}\n\t\t\t.flatpickr-next-month svg path,\n\t\t\t.flatpickr-prev-month svg path {\n\t\t\t\tfill: inherit\n\t\t\t}\n\t\t\t.flatpickr-current-month {\n\t\t\t\tflex: 1 auto;\n\t\t\t}\n\t\t\t.flatpickr-current-month .cur-month {\n\t\t\t\tfont-weight: bold;\n\t\t\t}\n\t\t\t.flatpickr-current-month .numInputWrapper {\n\t\t\t\tdisplay:inline;\n\t\t\t}\n\t\t\t.flatpickr-current-month .cur-year {\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\twidth: 3.2em;\n\t\t\t\tdisplay: inline;\n\t\t\t\tfont-size: inherit;\n\t\t\t\tline-height: 0;\n\t\t\t\theight: initial;\n\t\t\t\tborder: 0;\n\t\t\t\tborder-radius: 0;\n\t\t\t\tvertical-align: initial;\n\t\t\t\toutline:none;\n\t\t\t}\n\t\t\t.flatpickr-current-month .cur-year:hover {\n\t\t\t\tbackground: rgba(0, 0, 0, .05)\n\t\t\t}\n\t\t\t.flatpickr-weekdays {\n\t\t\t\tpadding:.5em 0;\n\t\t\t\toverflow: hidden;\n\t\t\t}\n\t\t\tspan.flatpickr-weekday {\n\t\t\t\tcursor: default;\n\t\t\t\tmargin: 0;\n\t\t\t\ttext-align: center;\n\t\t\t\tdisplay:inline-block;\n\t\t\t\twidth: 5em;\n\t\t\t\tfont-size:.6em;\n\t\t\t\tpadding:.5em 0;\n\t\t\t}\n\n\t\t\t.flatpickr-rContainer {\n\t\t\t\tdisplay: inline-block;\n\t\t\t\twidth: 21em;\n\t\t\t}\n\t\t\t.flatpickr-days {\n\t\t\t\toutline: 0;\n\t\t\t\ttext-align: left;\n\t\t\t}\n\t\t\t.flatpickr-day {\n\t\t\t\twidth: 3em;\n\t\t\t\theight: 3em;\n\t\t\t\tline-height: 3em;\n\t\t\t\tcursor: pointer;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tmargin: 0;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\t.flatpickr-day.disabled,\n\t\t\t.flatpickr-day.disabled:hover,\n\t\t\t.flatpickr-day.nextMonthDay,\n\t\t\t.flatpickr-day.notAllowed,\n\t\t\t.flatpickr-day.notAllowed.nextMonthDay,\n\t\t\t.flatpickr-day.notAllowed.prevMonthDay,\n\t\t\t.flatpickr-day.prevMonthDay {\n\t\t\t\tcolor: rgba(57, 57, 57, .3);\n\t\t\t\tbackground: 0 0;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tcursor: default\n\t\t\t}\n\t\t\t.flatpickr-weekwrapper {\n\t\t\t\tpadding-top:.5em;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tfloat: left\n\t\t\t}\n\t\t\t.flatpickr-weekwrapper .flatpickr-weeks {\n\t\t\t\tpadding: .5em .25rem 0 .25em;\n\t\t\t}\n\t\t\t.flatpickr-weekwrapper .flatpickr-weekday {\n\t\t\t\tfloat: none;\n\t\t\t\twidth: 100%\n\t\t\t}\n\t\t\t.flatpickr-weekwrapper span.flatpickr-day {\n\t\t\t\tdisplay: block;\n\t\t\t\twidth: 100%\n\t\t\t}\n\t\t\t.flatpickr-time {\n\t\t\t\toverflow: auto;\n\t\t\t\ttext-align: center;\n\t\t\t\tborder-top: 0;\n\t\t\t\toutline: 0;\n\t\t\t\tdisplay: block;\n\t\t\t\tdisplay: flex;\n\t\t\t\tmin-width:10em;\n\t\t\t}\n\t\t\t.flatpickr-am-pm {\n\t\t\t\tuser-select:none;\n\t\t\t}\n\t\t\t.flatpickr-am-pm,\n\t\t\t.flatpickr-time input,\n\t\t\t.flatpickr-time-separator {\n\t\t\t\theight: 3em;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tline-height: 3em;\n\t\t\t\tcolor: #393939\n\t\t\t}\n\t\t\t.flatpickr-time input {\n\t\t\t\tfont-size: 1em;\n\t\t\t\tbackground: 0 0;\n\t\t\t\tbox-shadow: none;\n\t\t\t\tborder: 0;\n\t\t\t\tborder-radius: 0;\n\t\t\t\tflex: 1;\n\t\t\t\twidth: 33%;\n\t\t\t\tmin-width: 33%;\n\t\t\t\ttext-align: center;\n\t\t\t\tmargin: 0;\n\t\t\t\tpadding: 0;\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t\t.flatpickr-time input.flatpickr-minute {\n\t\t\t\twidth: 26%;\n\t\t\t}\n\t\t\t.flatpickr-time input.flatpickr-second {\n\t\t\t}\n\t\t\t.flatpickr-time input:focus {\n\t\t\t\toutline: 0;\n\t\t\t\tborder: 0\n\t\t\t}\n\n\t\t\t.flatpickr-time.has-seconds input[type=number] {\n\t\t\t\twidth: 25%;\n\t\t\t\tmin-width: 25%\n\t\t\t}\n\t\t\t.hasTime .flatpickr-days,\n\t\t\t.hasWeeks .flatpickr-days {\n\t\t\t\tborder-bottom: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0\n\t\t\t}\n\t\t\t.hasWeeks .flatpickr-days {\n\t\t\t\tborder-left: 0\n\t\t\t}\n\n\t\t\t.flatpickr-am-pm {\n\t\t\t\toutline: 0;\n\t\t\t\twidth: 21%;\n\t\t\t\tpadding: 0 2%;\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-align: left;\n\t\t\t}\n\n\t\t\t@media all and (-ms-high-contrast: none) {\n\t\t\t\t.flatpickr-month {\n\t\t\t\t\tpadding: 0\n\t\t\t\t}\n\t\t\t\t.flatpickr-month svg {\n\t\t\t\t\ttop: 0 !important\n\t\t\t\t}\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	    * Specify the name or id of the field to link the datepicker to
	    * @prop
	    * @type  		{String}
	    */
					for: null,

					/**
	     * Displays the calendar inline
	     * @prop
	     * @type 		{Boolean}
	     */
					inline: false,

					/**
	     * Specify the color to use to skin the datepicker.
	     * @physicalProp
	     * @observed
	     * @prop
	     * @type		{String}
	     */
					color: null,

					/**
	     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
	     * @prop
	     * @type 		{Boolean}
	     */
					allowInput: false,

					/**
	     * Clicking on the input opens the date (time) picker. Disable this if you wish to open the calendar manually with `.open()`
	     * @prop
	     * @type 		{Boolean}
	     */
					openOnClick: true,

					/**
	     * A string of characters which are used to define how the date will be displayed in the input box. The supported characters are defined in the table below.
	     * @prop
	     * @type 		{String}
	     */
					dateFormat: 'Y-m-d',

					/**
	     * Set the initial selected date. Same as preloading a date string into an input's value attribute, but can also handle a Date object.
	     * @prop
	     * @type 		{Date|String}
	     */
					defaultDate: null,

					/**
	     * Disable some dates
	     * @see 		https://chmln.github.io/flatpickr/#disable
	     * @prop
	     * @type 		{Array}
	     */
					disabledDates: [],

					/**
	     * Specify if the datepicker is disabled or not
	     * @physicalProp
	     * @prop
	     * @type 		{Boolean}
	     */
					disabled: false,

					/**
	     * Disable all dates except the ones you specify.
	     * @see 		https://chmln.github.io/flatpickr/#enable
	     * @prop
	     * @type 		{Array}
	     */
					enabledDates: [],

					/**
	     * Enables time picker
	     * @prop
	     * @type 		{Boolean}
	     */
					enableTime: false,

					/**
	     * Enables seconds in the time picker.
	     * @prop
	     * @type 		{Boolean}
	     */
					enableSeconds: false,

					/**
	     * Adjusts the step for the hour input (incl. scrolling)
	     * @prop
	     * @type 		{Integer}
	     */
					hourIncrement: 1,

					/**
	     * Adjusts the step for the minute input (incl. scrolling)
	     * @prop
	     * @type 		{Integer}
	     */
					minuteIncrement: 5,

					/**
	     * The maximum date that a user can pick to.
	     * @prop
	     * @type 		{Date|String}
	     */
					maxDate: null,

					/**
	     * The minimum date that a user can start picking from
	     * @prop
	     * @type 		{Date|String}
	     */
					minDate: null,

					/**
	     * Hides the calendar. For use along with enableTime.
	     * @prop
	     * @type 		{Boolean}
	     */
					noCalendar: false,

					/**
	     * Function(s) to trigger on every date selection
	     * @see 		https://chmln.github.io/flatpickr/#eventsAPI
	     * @prop
	     * @type 		{Function}
	     */
					onChange: null,

					/**
	     * Function(s) to trigger on every time the calendar is closed
	     * @see 		https://chmln.github.io/flatpickr/#eventsAPI
	     * @prop
	     * @type 		{Function}
	     */
					onClose: null,

					/**
	     * Function(s) to trigger on every time the calendar is opened
	     * @see 		https://chmln.github.io/flatpickr/#eventsAPI
	     * @prop
	     * @type 		{Function}
	     */
					onOpen: null,

					/**
	     * Function to trigger when the calendar is ready
	     * @see 		https://chmln.github.io/flatpickr/#eventsAPI
	     * @prop
	     * @type 		{Function}
	     */
					onReady: null,

					/**
	     * Function that expects a date string and must return a Date object
	     * @prop
	     * @type 		{Function}
	     */
					parseDate: false,

					/**
	     * Show the month using the shorthand version (ie, Sep instead of September).
	     * @prop
	     * @type 		{Boolean}
	     */
					shorthandCurrentMonth: false,

					/**
	     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
	     * @prop
	     * @type 		{Boolean}
	     */
					time24hr: true,

					/**
	     * When true, dates will parsed, formatted, and displayed in UTC. It's recommended that date strings contain the timezone, but not necessary
	     * @prop
	     * @type 		{Boolean}
	     */
					utc: false,

					/**
	     * Enables display of week numbers in calendar
	     * @prop
	     * @type 		{Boolean}
	     */
					weekNumbers: false,

					/**
	     * flatpickr can parse an input group of textboxes and buttons, common in Bootstrap and other frameworks.
	     * @see 		https://chmln.github.io/flatpickr/#strap
	     * @prop
	     * @type 		{Boolean}
	     */
					wrap: false
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return ['color'];
			}
		}]);

		return SDatepickerComponent;
	}(_SWebComponent3.default);

	exports.default = SDatepickerComponent;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(171);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(172);

	var _SWebComponentMixin = __webpack_require__(173);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(172);

	var _autoCast = __webpack_require__(174);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(175);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(176);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(177);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(179);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(180);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(187);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(188);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(190);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 175 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 176 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(178);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(180);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(183);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(184);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(185);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(181);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(182);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 181 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(181);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 183 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 184 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(186);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 186 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(189);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 189 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(177);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(194);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*! flatpickr v2.3.3, @license MIT */
	function Flatpickr(element, config) {
		var self = this;

		function init() {
			if (element._flatpickr) destroy(element._flatpickr);

			element._flatpickr = self;

			self.element = element;
			self.instanceConfig = config || {};

			setupFormats();

			parseConfig();
			setupLocale();
			setupInputs();
			setupDates();
			setupHelperFunctions();

			self.isOpen = self.config.inline;
			self.changeMonth = changeMonth;
			self.clear = clear;
			self.close = close;
			self.destroy = destroy;
			self.formatDate = formatDate;
			self.jumpToDate = jumpToDate;
			self.open = open;
			self.redraw = redraw;
			self.set = set;
			self.setDate = setDate;
			self.toggle = toggle;

			self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

			if (!self.isMobile) build();

			bind();

			if (!self.isMobile) {
				Object.defineProperty(self, "dateIsPicked", {
					set: function set(bool) {
						if (bool) return self.calendarContainer.classList.add("dateIsPicked");
						self.calendarContainer.classList.remove("dateIsPicked");
					}
				});
			}

			self.dateIsPicked = self.selectedDates.length > 0 || self.config.noCalendar;

			if (self.selectedDates.length) {
				if (self.config.enableTime) setHoursFromDate();
				updateValue();
			}

			if (self.config.weekNumbers) {
				self.calendarContainer.style.width = self.days.clientWidth + self.weekWrapper.clientWidth + "px";
			}

			triggerEvent("Ready");
		}

		function updateTime(e) {
			if (self.config.noCalendar && !self.selectedDates.length)
				// picking time only
				self.selectedDates = [self.now];

			timeWrapper(e);

			if (!self.selectedDates.length) return;

			if (!self.minDateHasTime || e.type !== "input" || e.target.value.length >= 2) {
				setHoursFromInputs();
				updateValue();
			} else {
				setTimeout(function () {
					setHoursFromInputs();
					updateValue();
				}, 1000);
			}
		}

		function setHoursFromInputs() {
			if (!self.config.enableTime) return;

			var hours = parseInt(self.hourElement.value, 10) || 0,
			    minutes = parseInt(self.minuteElement.value, 10) || 0,
			    seconds = self.config.enableSeconds ? parseInt(self.secondElement.value, 10) || 0 : 0;

			if (self.amPM) hours = hours % 12 + 12 * (self.amPM.textContent === "PM");

			if (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {

				hours = Math.max(hours, self.config.minDate.getHours());
				if (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());
			} else if (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {
				hours = Math.min(hours, self.config.maxDate.getHours());
				if (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());
			}

			setHours(hours, minutes, seconds);
		}

		function setHoursFromDate(dateObj) {
			var date = dateObj || self.latestSelectedDateObj;

			if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
		}

		function setHours(hours, minutes, seconds) {
			if (self.selectedDates.length) {
				self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
			}

			if (!self.config.enableTime || self.isMobile) return;

			self.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);

			self.minuteElement.value = self.pad(minutes);

			if (!self.config.time_24hr && self.selectedDates.length) self.amPM.textContent = self.latestSelectedDateObj.getHours() >= 12 ? "PM" : "AM";

			if (self.config.enableSeconds) self.secondElement.value = self.pad(seconds);
		}

		function onYearInput(event) {
			if (event.target.value.length === 4) {
				self.currentYearElement.blur();
				handleYearChange(event.target.value);
				event.target.value = self.currentYear;
			}
		}

		function bind() {
			if (self.config.wrap) {
				["open", "close", "toggle", "clear"].forEach(function (el) {
					try {
						self.element.querySelector("[data-" + el + "]").addEventListener("click", self[el]);
					} catch (e) {
						//
					}
				});
			}

			if (window.document.createEvent !== undefined) {
				self.changeEvent = window.document.createEvent("HTMLEvents");
				self.changeEvent.initEvent("change", false, true);
			}

			if (self.isMobile) return setupMobile();

			self.debouncedResize = debounce(onResize, 50);
			self.triggerChange = function () {
				return triggerEvent("Change");
			};
			self.debouncedChange = debounce(self.triggerChange, 1000);

			if (self.config.mode === "range" && self.days) self.days.addEventListener("mouseover", onMouseOver);

			window.document.addEventListener("keydown", onKeyDown);

			if (!self.config.inline && !self.config.static) window.addEventListener("resize", self.debouncedResize);

			if (window.ontouchstart) window.document.addEventListener("touchstart", documentClick);

			window.document.addEventListener("click", documentClick);
			window.document.addEventListener("blur", documentClick);

			if (self.config.clickOpens) (self.altInput || self.input).addEventListener("focus", open);

			if (!self.config.noCalendar) {
				self.prevMonthNav.addEventListener("click", function () {
					return changeMonth(-1);
				});
				self.nextMonthNav.addEventListener("click", function () {
					return changeMonth(1);
				});

				self.currentYearElement.addEventListener("wheel", function (e) {
					return debounce(yearScroll(e), 50);
				});
				self.currentYearElement.addEventListener("focus", function () {
					self.currentYearElement.select();
				});

				self.currentYearElement.addEventListener("input", onYearInput);
				self.currentYearElement.addEventListener("increment", onYearInput);

				self.days.addEventListener("click", selectDate);
			}

			if (self.config.enableTime) {
				self.timeContainer.addEventListener("transitionend", positionCalendar);
				self.timeContainer.addEventListener("wheel", function (e) {
					return debounce(updateTime(e), 5);
				});
				self.timeContainer.addEventListener("input", updateTime);
				self.timeContainer.addEventListener("increment", updateTime);

				self.timeContainer.addEventListener("wheel", self.debouncedChange);
				self.timeContainer.addEventListener("input", self.triggerChange);

				self.hourElement.addEventListener("focus", function () {
					self.hourElement.select();
				});
				self.minuteElement.addEventListener("focus", function () {
					self.minuteElement.select();
				});

				if (self.secondElement) {
					self.secondElement.addEventListener("focus", function () {
						self.secondElement.select();
					});
				}

				if (self.amPM) {
					self.amPM.addEventListener("click", function (e) {
						updateTime(e);
						self.triggerChange(e);
					});
				}
			}
		}

		function jumpToDate(jumpDate) {
			jumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);

			try {
				self.currentYear = jumpDate.getFullYear();
				self.currentMonth = jumpDate.getMonth();
			} catch (e) {
				console.error(e.stack);
				console.warn("Invalid date supplied: " + jumpDate);
			}

			self.redraw();
		}

		function incrementNumInput(e, delta) {
			var input = e.target.parentNode.childNodes[0];
			input.value = parseInt(input.value, 10) + delta * (input.step || 1);

			try {
				input.dispatchEvent(new Event("increment", { "bubbles": true }));
			} catch (e) {
				var ev = window.document.createEvent("CustomEvent");
				ev.initCustomEvent("increment", true, true, {});
				input.dispatchEvent(ev);
			}
		}

		function createNumberInput(inputClassName) {
			var wrapper = createElement("div", "numInputWrapper"),
			    numInput = createElement("input", "numInput " + inputClassName),
			    arrowUp = createElement("span", "arrowUp"),
			    arrowDown = createElement("span", "arrowDown");

			numInput.type = "text";
			wrapper.appendChild(numInput);
			wrapper.appendChild(arrowUp);
			wrapper.appendChild(arrowDown);

			arrowUp.addEventListener("click", function (e) {
				return incrementNumInput(e, 1);
			});
			arrowDown.addEventListener("click", function (e) {
				return incrementNumInput(e, -1);
			});
			return wrapper;
		}

		function build() {
			var fragment = window.document.createDocumentFragment();
			self.calendarContainer = createElement("div", "flatpickr-calendar");
			self.numInputType = navigator.userAgent.indexOf("MSIE 9.0") > 0 ? "text" : "number";

			if (!self.config.noCalendar) {
				fragment.appendChild(buildMonthNav());
				self.innerContainer = createElement("div", "flatpickr-innerContainer");

				if (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());

				self.rContainer = createElement("div", "flatpickr-rContainer");
				self.rContainer.appendChild(buildWeekdays());
				self.rContainer.appendChild(buildDays());
				self.innerContainer.appendChild(self.rContainer);
				fragment.appendChild(self.innerContainer);
			}

			if (self.config.enableTime) fragment.appendChild(buildTime());

			if (self.config.mode === "range") self.calendarContainer.classList.add("rangeMode");

			self.calendarContainer.appendChild(fragment);

			if (self.config.inline || self.config.static) {
				self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
				positionCalendar();

				if (self.config.appendTo && self.config.appendTo.nodeType) self.config.appendTo.appendChild(self.calendarContainer);else {
					self.element.parentNode.insertBefore(self.calendarContainer, (self.altInput || self.input).nextSibling);
				}
			} else window.document.body.appendChild(self.calendarContainer);
		}

		function createDay(className, date, dayNumber) {
			var dateIsEnabled = isEnabled(date, true),
			    dayElement = createElement("span", "flatpickr-day " + className, date.getDate());

			dayElement.dateObj = date;

			if (compareDates(date, self.now) === 0) dayElement.classList.add("today");

			if (dateIsEnabled) {
				dayElement.tabIndex = 0;

				if (isDateSelected(date)) {
					dayElement.classList.add("selected");

					if (self.config.mode === "range") {
						dayElement.classList.add(compareDates(date, self.selectedDates[0]) === 0 ? "startRange" : "endRange");
					} else self.selectedDateElem = dayElement;
				}
			} else {
				dayElement.classList.add("disabled");
				if (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;
			}

			if (self.config.mode === "range") {
				if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");

				if (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add("notAllowed");
			}

			if (self.config.weekNumbers && className !== "prevMonthDay" && dayNumber % 7 === 1) {
				self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='disabled flatpickr-day'>" + self.config.getWeek(date) + "</span>");
			}

			triggerEvent("DayCreate", dayElement);

			return dayElement;
		}

		function buildDays() {
			if (!self.days) {
				self.days = createElement("div", "flatpickr-days");
				self.days.tabIndex = -1;
			}

			self.firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;

			self.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);

			var daysInMonth = self.utils.getDaysinMonth(),
			    days = window.document.createDocumentFragment();

			var dayNumber = self.prevMonthDays + 1 - self.firstOfMonth;

			if (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = "";

			if (self.config.mode === "range") {
				// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;
				self.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);
				self.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - self.firstOfMonth) % daysInMonth);
			}

			if (self.days.firstChild) self.days.textContent = "";

			// prepend days from the ending of previous month
			for (var i = 0; dayNumber <= self.prevMonthDays; i++, dayNumber++) {
				days.appendChild(createDay("prevMonthDay", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber));
			}

			// Start at 1 since there is no 0th day
			for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++) {
				days.appendChild(createDay("", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber));
			}

			// append days from the next month
			for (var dayNum = daysInMonth + 1; dayNum <= 42 - self.firstOfMonth; dayNum++) {
				days.appendChild(createDay("nextMonthDay", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum));
			}

			self.days.appendChild(days);
			return self.days;
		}

		function buildMonthNav() {
			var monthNavFragment = window.document.createDocumentFragment();
			self.monthNav = createElement("div", "flatpickr-month");

			self.prevMonthNav = createElement("span", "flatpickr-prev-month");
			self.prevMonthNav.innerHTML = self.config.prevArrow;

			self.currentMonthElement = createElement("span", "cur-month");

			var yearInput = createNumberInput("cur-year");
			self.currentYearElement = yearInput.childNodes[0];
			self.currentYearElement.title = self.l10n.scrollTitle;

			if (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();

			if (self.config.maxDate) {
				self.currentYearElement.max = self.config.maxDate.getFullYear();

				self.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
			}

			self.nextMonthNav = createElement("span", "flatpickr-next-month");
			self.nextMonthNav.innerHTML = self.config.nextArrow;

			self.navigationCurrentMonth = createElement("span", "flatpickr-current-month");
			self.navigationCurrentMonth.appendChild(self.currentMonthElement);
			self.navigationCurrentMonth.appendChild(yearInput);

			monthNavFragment.appendChild(self.prevMonthNav);
			monthNavFragment.appendChild(self.navigationCurrentMonth);
			monthNavFragment.appendChild(self.nextMonthNav);
			self.monthNav.appendChild(monthNavFragment);

			updateNavigationCurrentMonth();

			return self.monthNav;
		}

		function buildTime() {
			self.calendarContainer.classList.add("hasTime");
			if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
			self.timeContainer = createElement("div", "flatpickr-time");
			self.timeContainer.tabIndex = -1;
			var separator = createElement("span", "flatpickr-time-separator", ":");

			var hourInput = createNumberInput("flatpickr-hour");
			self.hourElement = hourInput.childNodes[0];

			var minuteInput = createNumberInput("flatpickr-minute");
			self.minuteElement = minuteInput.childNodes[0];

			self.hourElement.tabIndex = self.minuteElement.tabIndex = 0;
			self.hourElement.pattern = self.minuteElement.pattern = "\\d*";

			self.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour);

			self.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);

			self.hourElement.step = self.config.hourIncrement;
			self.minuteElement.step = self.config.minuteIncrement;

			self.hourElement.min = self.config.time_24hr ? 0 : 1;
			self.hourElement.max = self.config.time_24hr ? 23 : 12;

			self.minuteElement.min = 0;
			self.minuteElement.max = 59;

			self.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;

			self.timeContainer.appendChild(hourInput);
			self.timeContainer.appendChild(separator);
			self.timeContainer.appendChild(minuteInput);

			if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

			if (self.config.enableSeconds) {
				self.timeContainer.classList.add("hasSeconds");

				var secondInput = createNumberInput("flatpickr-second");
				self.secondElement = secondInput.childNodes[0];

				self.secondElement.pattern = self.hourElement.pattern;
				self.secondElement.value = self.latestSelectedDateObj ? self.pad(self.latestSelectedDateObj.getSeconds()) : "00";

				self.secondElement.step = self.minuteElement.step;
				self.secondElement.min = self.minuteElement.min;
				self.secondElement.max = self.minuteElement.max;

				self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
				self.timeContainer.appendChild(secondInput);
			}

			if (!self.config.time_24hr) {
				// add self.amPM if appropriate
				self.amPM = createElement("span", "flatpickr-am-pm", ["AM", "PM"][self.hourElement.value > 11 | 0]);
				self.amPM.title = self.l10n.toggleTitle;
				self.amPM.tabIndex = 0;
				self.timeContainer.appendChild(self.amPM);
			}

			return self.timeContainer;
		}

		function buildWeekdays() {
			if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");

			var firstDayOfWeek = self.l10n.firstDayOfWeek;
			var weekdays = self.l10n.weekdays.shorthand.slice();

			if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
				weekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
			}

			self.weekdayContainer.innerHTML = "\n\t\t<span class=flatpickr-weekday>\n\t\t\t" + weekdays.join("</span><span class=flatpickr-weekday>") + "\n\t\t</span>\n\t\t";

			return self.weekdayContainer;
		}

		/* istanbul ignore next */
		function buildWeeks() {
			self.calendarContainer.classList.add("hasWeeks");
			self.weekWrapper = createElement("div", "flatpickr-weekwrapper");
			self.weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
			self.weekNumbers = createElement("div", "flatpickr-weeks");
			self.weekWrapper.appendChild(self.weekNumbers);

			return self.weekWrapper;
		}

		function changeMonth(value, is_offset) {
			self.currentMonth = typeof is_offset === "undefined" || is_offset ? self.currentMonth + value : value;

			handleYearChange();
			updateNavigationCurrentMonth();
			buildDays();

			if (!self.config.noCalendar) self.days.focus();

			triggerEvent("MonthChange");
		}

		function clear(triggerChangeEvent) {
			self.input.value = "";

			if (self.altInput) self.altInput.value = "";

			if (self.mobileInput) self.mobileInput.value = "";

			self.selectedDates = [];
			self.latestSelectedDateObj = null;
			self.dateIsPicked = false;

			self.redraw();

			if (triggerChangeEvent !== false)
				// triggerChangeEvent is true (default) or an Event
				triggerEvent("Change");
		}

		function close() {
			self.isOpen = false;

			if (!self.isMobile) {
				self.calendarContainer.classList.remove("open");
				(self.altInput || self.input).classList.remove("active");
			}

			triggerEvent("Close");
		}

		function destroy(instance) {
			instance = instance || self;
			instance.clear(false);

			window.document.removeEventListener("keydown", onKeyDown);
			window.removeEventListener("resize", instance.debouncedResize);

			window.document.removeEventListener("click", documentClick);
			window.document.removeEventListener("touchstart", documentClick);
			window.document.removeEventListener("blur", documentClick);

			if (instance.timeContainer) instance.timeContainer.removeEventListener("transitionend", positionCalendar);

			if (instance.mobileInput && instance.mobileInput.parentNode) instance.mobileInput.parentNode.removeChild(instance.mobileInput);else if (instance.calendarContainer && instance.calendarContainer.parentNode) instance.calendarContainer.parentNode.removeChild(instance.calendarContainer);

			if (instance.altInput) {
				instance.input.type = "text";
				if (instance.altInput.parentNode) instance.altInput.parentNode.removeChild(instance.altInput);
			}

			instance.input.type = instance.input._type;
			instance.input.classList.remove("flatpickr-input");
			instance.input.removeEventListener("focus", open);
			instance.input.removeAttribute("readonly");

			delete instance.input._flatpickr;
		}

		function isCalendarElem(elem) {
			var e = elem;
			while (e) {
				if (/flatpickr-day|flatpickr-calendar/.test(e.className)) return true;
				e = e.parentNode;
			}

			return false;
		}

		function documentClick(e) {
			var isInput = self.element.contains(e.target) || e.target === self.input || e.target === self.altInput || e.path && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));

			if (self.isOpen && !self.config.inline && !isCalendarElem(e.target) && !isInput) {
				e.preventDefault();
				self.close();

				if (self.config.mode === "range" && self.selectedDates.length === 1) {
					self.clear();
					self.redraw();
				}
			}
		}

		function formatDate(frmt, dateObj) {
			if (self.config.formatDate) return self.config.formatDate(frmt, dateObj);

			var chars = frmt.split("");
			return chars.map(function (c, i) {
				return self.formats[c] && chars[i - 1] !== "\\" ? self.formats[c](dateObj) : c !== "\\" ? c : "";
			}).join("");
		}

		function handleYearChange(newYear) {
			if (self.currentMonth < 0 || self.currentMonth > 11) {
				self.currentYear += self.currentMonth % 11;
				self.currentMonth = (self.currentMonth + 12) % 12;

				triggerEvent("YearChange");
			} else if (newYear && (!self.currentYearElement.min || newYear >= self.currentYearElement.min) && (!self.currentYearElement.max || newYear <= self.currentYearElement.max)) {
				self.currentYear = parseInt(newYear, 10) || self.currentYear;

				if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
					self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
				} else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
					self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
				}

				self.redraw();
				triggerEvent("YearChange");
			}
		}

		function isEnabled(date, timeless) {
			var ltmin = compareDates(date, self.config.minDate, typeof timeless !== "undefined" ? timeless : !self.minDateHasTime) < 0;
			var gtmax = compareDates(date, self.config.maxDate, typeof timeless !== "undefined" ? timeless : !self.maxDateHasTime) > 0;

			if (ltmin || gtmax) return false;

			if (!self.config.enable.length && !self.config.disable.length) return true;

			var dateToCheck = self.parseDate(date, true); // timeless

			var bool = self.config.enable.length > 0,
			    array = bool ? self.config.enable : self.config.disable;

			for (var i = 0, d; i < array.length; i++) {
				d = array[i];

				if (d instanceof Function && d(dateToCheck)) // disabled by function
					return bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime())
					// disabled by date string
					return bool;else if ( // disabled by range
				(typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;
			}

			return !bool;
		}

		function onKeyDown(e) {
			if (self.isOpen) {
				switch (e.which) {
					case 13:
						if (self.timeContainer && self.timeContainer.contains(e.target)) updateValue();else selectDate(e);

						break;

					case 27:
						// escape
						self.clear();
						self.redraw();
						self.close();
						break;

					case 37:
						if (e.target !== self.input & e.target !== self.altInput) changeMonth(-1);
						break;

					case 38:
						e.preventDefault();

						if (self.timeContainer && self.timeContainer.contains(e.target)) updateTime(e);else {
							self.currentYear++;
							self.redraw();
						}

						break;

					case 39:
						if (e.target !== self.input & e.target !== self.altInput) changeMonth(1);
						break;

					case 40:
						e.preventDefault();
						if (self.timeContainer && self.timeContainer.contains(e.target)) updateTime(e);else {
							self.currentYear--;
							self.redraw();
						}

						break;

					default:
						break;
				}
			}
		}

		function onMouseOver(e) {
			if (self.selectedDates.length !== 1 || !e.target.classList.contains("flatpickr-day")) return;

			var hoverDate = e.target.dateObj,
			    initialDate = self.parseDate(self.selectedDates[0], true),
			    rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),
			    rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),
			    containsDisabled = false;

			for (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {
				if (!isEnabled(new Date(t))) {
					containsDisabled = true;
					break;
				}
			}

			for (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {
				var outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime();

				if (outOfRange) {
					self.days.childNodes[i].classList.add("notAllowed");
					self.days.childNodes[i].classList.remove("inRange", "startRange", "endRange");
					continue;
				} else if (containsDisabled && !outOfRange) continue;

				self.days.childNodes[i].classList.remove("startRange", "inRange", "endRange", "notAllowed");

				var minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),
				    maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);

				e.target.classList.add(hoverDate < self.selectedDates[0] ? "startRange" : "endRange");

				if (initialDate > hoverDate && timestamp === initialDate.getTime()) self.days.childNodes[i].classList.add("endRange");else if (initialDate < hoverDate && timestamp === initialDate.getTime()) self.days.childNodes[i].classList.add("startRange");else if (timestamp > minRangeDate && timestamp < maxRangeDate) self.days.childNodes[i].classList.add("inRange");
			}
		}

		function onResize() {
			if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
		}

		function open(e) {
			if (self.isMobile) {
				if (e) {
					e.preventDefault();
					e.target.blur();
				}

				setTimeout(function () {
					self.mobileInput.click();
				}, 0);

				triggerEvent("Open");
				return;
			} else if (self.isOpen || (self.altInput || self.input).disabled || self.config.inline) return;

			self.calendarContainer.classList.add("open");

			if (!self.config.static && !self.config.inline) positionCalendar();

			self.isOpen = true;

			if (!self.config.allowInput) {
				(self.altInput || self.input).blur();
				(self.config.noCalendar ? self.timeContainer : self.selectedDateElem ? self.selectedDateElem : self.days).focus();
			}

			(self.altInput || self.input).classList.add("active");
			triggerEvent("Open");
		}

		function minMaxDateSetter(type) {
			return function (date) {
				var dateObj = self.config["_" + type + "Date"] = self.parseDate(date);
				var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

				if (self.selectedDates) {
					self.selectedDates = self.selectedDates.filter(isEnabled);
					updateValue();
				}

				if (self.days) redraw();

				if (!self.currentYearElement) return;

				if (date && dateObj instanceof Date) {
					self[type + "DateHasTime"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();

					self.currentYearElement[type] = dateObj.getFullYear();
				} else self.currentYearElement.removeAttribute(type);

				self.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();
			};
		}

		function parseConfig() {
			var boolOpts = ["utc", "wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
			self.config = Object.create(Flatpickr.defaultConfig);

			Object.defineProperty(self.config, "minDate", {
				get: function get() {
					return this._minDate;
				},
				set: minMaxDateSetter("min")
			});

			Object.defineProperty(self.config, "maxDate", {
				get: function get() {
					return this._maxDate;
				},
				set: minMaxDateSetter("max")
			});

			var userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));

			_extends(self.config, userConfig);

			for (var i = 0; i < boolOpts.length; i++) {
				self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
			}if (!userConfig.dateFormat && userConfig.enableTime) {
				self.config.dateFormat = self.config.noCalendar ? "H:i" + (self.config.enableSeconds ? ":S" : "") : Flatpickr.defaultConfig.dateFormat + " H:i" + (self.config.enableSeconds ? ":S" : "");
			}

			if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {
				self.config.altFormat = self.config.noCalendar ? "h:i" + (self.config.enableSeconds ? ":S K" : " K") : Flatpickr.defaultConfig.altFormat + (" h:i" + (self.config.enableSeconds ? ":S" : "") + " K");
			}
		}

		function setupLocale() {
			if (_typeof(self.config.locale) !== "object" && typeof Flatpickr.l10ns[self.config.locale] === "undefined") console.warn("flatpickr: invalid locale " + self.config.locale);

			self.l10n = _extends(Object.create(Flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? Flatpickr.l10ns[self.config.locale] || {} : {});
		}

		function positionCalendar(e) {
			if (e && e.target !== self.timeContainer) return;

			var calendarHeight = self.calendarContainer.offsetHeight,
			    calendarWidth = self.calendarContainer.offsetWidth,
			    input = self.altInput || self.input,
			    inputBounds = input.getBoundingClientRect(),
			    distanceFromBottom = window.innerHeight - inputBounds.bottom + input.offsetHeight;

			var top = void 0;

			if (distanceFromBottom < calendarHeight + 60) {
				top = window.pageYOffset - calendarHeight + inputBounds.top - 2;
				self.calendarContainer.classList.remove("arrowTop");
				self.calendarContainer.classList.add("arrowBottom");
			} else {
				top = window.pageYOffset + input.offsetHeight + inputBounds.top + 2;
				self.calendarContainer.classList.remove("arrowBottom");
				self.calendarContainer.classList.add("arrowTop");
			}

			if (!self.config.static && !self.config.inline) {
				self.calendarContainer.style.top = top + "px";

				var left = window.pageXOffset + inputBounds.left;
				var right = window.document.body.offsetWidth - inputBounds.right;

				if (left + calendarWidth <= window.document.body.offsetWidth) {
					self.calendarContainer.style.left = left + "px";
					self.calendarContainer.style.right = "auto";

					self.calendarContainer.classList.remove("rightMost");
				} else {
					self.calendarContainer.style.left = "auto";
					self.calendarContainer.style.right = right + "px";

					self.calendarContainer.classList.add("rightMost");
				}
			}
		}

		function redraw() {
			if (self.config.noCalendar || self.isMobile) return;

			buildWeekdays();
			updateNavigationCurrentMonth();
			buildDays();
		}

		function selectDate(e) {
			e.preventDefault();
			if (self.config.allowInput && e.which === 13 && e.target === (self.altInput || self.input)) return self.setDate((self.altInput || self.input).value), e.target.blur();

			if (!e.target.classList.contains("flatpickr-day") || e.target.classList.contains("disabled") || e.target.classList.contains("notAllowed")) return;

			var selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());

			self.selectedDateElem = e.target;

			if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
				var selectedIndex = isDateSelected(selectedDate);
				if (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);
			} else if (self.config.mode === "range") {
				if (self.selectedDates.length === 2) self.clear();

				self.selectedDates.push(selectedDate);
				self.selectedDates.sort(function (a, b) {
					return a.getTime() - b.getTime();
				});
			}

			setHoursFromInputs();

			if (selectedDate.getMonth() !== self.currentMonth && self.config.mode !== "range") {
				self.currentYear = selectedDate.getFullYear();
				self.currentMonth = selectedDate.getMonth();
				updateNavigationCurrentMonth();
			}

			buildDays();

			if (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);

			updateValue();

			setTimeout(function () {
				return self.dateIsPicked = true;
			}, 50);

			if (self.config.mode === "range" && self.selectedDates.length === 1) onMouseOver(e);

			if (self.config.mode === "single" && !self.config.enableTime) self.close();

			triggerEvent("Change");
		}

		function set(option, value) {
			self.config[option] = value;
			self.redraw();
			jumpToDate();
		}

		function setDate(date, triggerChange) {
			if (!date) return self.clear();

			self.selectedDates = (Array.isArray(date) ? date.map(self.parseDate) : [self.parseDate(date)]).filter(function (d) {
				return d instanceof Date && isEnabled(d);
			});

			if (self.selectedDates.length > 0) {
				self.dateIsPicked = true;
				self.latestSelectedDateObj = self.selectedDates[0];
			} else self.latestSelectedDateObj = null;

			self.redraw();
			jumpToDate();

			setHoursFromDate();
			updateValue();

			if (triggerChange === true) triggerEvent("Change");
		}

		function setupDates() {
			function parseDateRules(arr) {
				for (var i = arr.length; i--;) {
					if (typeof arr[i] === "string" || +arr[i]) arr[i] = self.parseDate(arr[i], true);else if (arr[i] && arr[i].from && arr[i].to) {
						arr[i].from = self.parseDate(arr[i].from);
						arr[i].to = self.parseDate(arr[i].to);
					}
				}

				return arr.filter(function (x) {
					return x;
				}); // remove falsy values
			}

			self.selectedDates = [];
			self.now = new Date();
			var inputDate = self.config.defaultDate || self.input.value;

			if (Array.isArray(inputDate)) self.selectedDates = inputDate.map(self.parseDate);else if (inputDate) {
				switch (self.config.mode) {
					case "single":
						self.selectedDates = [self.parseDate(inputDate)];
						break;

					case "multiple":
						self.selectedDates = inputDate.split("; ").map(self.parseDate);
						break;

					case "range":
						self.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(self.parseDate);
						break;

					default:
						break;
				}
			}

			if (self.config.disable.length) self.config.disable = parseDateRules(self.config.disable);

			if (self.config.enable.length) self.config.enable = parseDateRules(self.config.enable);

			self.selectedDates = self.selectedDates.filter(function (d) {
				return d instanceof Date && d.getTime() && isEnabled(d, false);
			});

			self.selectedDates.sort(function (a, b) {
				return a.getTime() - b.getTime();
			});

			var initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;

			self.currentYear = initialDate.getFullYear();
			self.currentMonth = initialDate.getMonth();

			if (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];

			self.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());

			self.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());

			Object.defineProperty(self, "latestSelectedDateObj", {
				get: function get() {
					return self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1] || null;
				},
				set: function set(date) {
					self._selectedDateObj = date;
				}
			});
		}

		function setupHelperFunctions() {
			self.utils = {
				duration: {
					DAY: 86400000
				},
				getDaysinMonth: function getDaysinMonth(month, yr) {
					month = typeof month === "undefined" ? self.currentMonth : month;

					yr = typeof yr === "undefined" ? self.currentYear : yr;

					if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;

					return self.l10n.daysInMonth[month];
				},
				monthToStr: function monthToStr(monthNumber, shorthand) {
					shorthand = typeof shorthand === "undefined" ? self.config.shorthandCurrentMonth : shorthand;

					return self.l10n.months[(shorthand ? "short" : "long") + "hand"][monthNumber];
				}
			};
		}

		/* istanbul ignore next */
		function setupFormats() {
			self.formats = {
				// weekday name, short, e.g. Thu
				D: function D(date) {
					return self.l10n.weekdays.shorthand[self.formats.w(date)];
				},

				// full month name e.g. January
				F: function F(date) {
					return self.utils.monthToStr(self.formats.n(date) - 1, false);
				},

				// hours with leading zero e.g. 03
				H: function H(date) {
					return Flatpickr.prototype.pad(date.getHours());
				},

				// day (1-30) with ordinal suffix e.g. 1st, 2nd
				J: function J(date) {
					return date.getDate() + self.l10n.ordinal(date.getDate());
				},

				// AM/PM
				K: function K(date) {
					return date.getHours() > 11 ? "PM" : "AM";
				},

				// shorthand month e.g. Jan, Sep, Oct, etc
				M: function M(date) {
					return self.utils.monthToStr(date.getMonth(), true);
				},

				// seconds 00-59
				S: function S(date) {
					return Flatpickr.prototype.pad(date.getSeconds());
				},

				// unix timestamp
				U: function U(date) {
					return date.getTime() / 1000;
				},

				// full year e.g. 2016
				Y: function Y(date) {
					return date.getFullYear();
				},

				// day in month, padded (01-30)
				d: function d(date) {
					return Flatpickr.prototype.pad(self.formats.j(date));
				},

				// hour from 1-12 (am/pm)
				h: function h(date) {
					return date.getHours() % 12 ? date.getHours() % 12 : 12;
				},

				// minutes, padded with leading zero e.g. 09
				i: function i(date) {
					return Flatpickr.prototype.pad(date.getMinutes());
				},

				// day in month (1-30)
				j: function j(date) {
					return date.getDate();
				},

				// weekday name, full, e.g. Thursday
				l: function l(date) {
					return self.l10n.weekdays.longhand[self.formats.w(date)];
				},

				// padded month number (01-12)
				m: function m(date) {
					return Flatpickr.prototype.pad(self.formats.n(date));
				},

				// the month number (1-12)
				n: function n(date) {
					return date.getMonth() + 1;
				},

				// seconds 0-59
				s: function s(date) {
					return date.getSeconds();
				},

				// number of the day of the week
				w: function w(date) {
					return date.getDay();
				},

				// last two digits of year e.g. 16 for 2016
				y: function y(date) {
					return String(self.formats.Y(date)).substring(2);
				}
			};
		}

		function setupInputs() {
			self.input = self.config.wrap ? self.element.querySelector("[data-input]") : self.element;

			if (!self.input) return console.warn("Error: invalid input element specified", self.input);

			self.input._type = self.input.type;
			self.input.type = "text";
			self.input.classList.add("flatpickr-input");

			if (self.config.altInput) {
				// replicate self.element
				self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
				self.altInput.placeholder = self.input.placeholder;
				self.altInput.type = "text";

				self.input.type = "hidden";
				if (self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
			}

			if (!self.config.allowInput) (self.altInput || self.input).setAttribute("readonly", "readonly");
		}

		function setupMobile() {
			var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";

			self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
			self.mobileInput.step = "any";
			self.mobileInput.tabIndex = 1;
			self.mobileInput.type = inputType;
			self.mobileInput.disabled = self.input.disabled;

			self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

			if (self.selectedDates.length) {
				self.mobileInput.defaultValue = self.mobileInput.value = formatDate(self.mobileFormatStr, self.selectedDates[0]);
			}

			if (self.config.minDate) self.mobileInput.min = formatDate("Y-m-d", self.config.minDate);

			if (self.config.maxDate) self.mobileInput.max = formatDate("Y-m-d", self.config.maxDate);

			self.input.type = "hidden";
			if (self.config.altInput) self.altInput.type = "hidden";

			try {
				self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
			} catch (e) {
				//
			}

			self.mobileInput.addEventListener("change", function (e) {
				self.latestSelectedDateObj = self.parseDate(e.target.value);
				self.setDate(self.latestSelectedDateObj);
				triggerEvent("Change");
				triggerEvent("Close");
			});
		}

		function toggle() {
			if (self.isOpen) self.close();else self.open();
		}

		function triggerEvent(event, data) {
			if (self.config["on" + event]) {
				var hooks = Array.isArray(self.config["on" + event]) ? self.config["on" + event] : [self.config["on" + event]];

				for (var i = 0; i < hooks.length; i++) {
					hooks[i](self.selectedDates, self.input.value, self, data);
				}
			}

			if (event === "Change") {
				try {
					self.input.dispatchEvent(new Event("change", { "bubbles": true }));

					// many front-end frameworks bind to the input event
					self.input.dispatchEvent(new Event("input", { "bubbles": true }));
				} catch (e) {
					if (window.document.createEvent !== undefined) return self.input.dispatchEvent(self.changeEvent);

					self.input.fireEvent("onchange");
				}
			}
		}

		function isDateSelected(date) {
			for (var i = 0; i < self.selectedDates.length; i++) {
				if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
			}

			return false;
		}

		function isDateInRange(date) {
			if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
			return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
		}

		function updateNavigationCurrentMonth() {
			if (self.config.noCalendar || self.isMobile || !self.monthNav) return;

			self.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + " ";
			self.currentYearElement.value = self.currentYear;

			if (self.config.minDate) {
				var hidePrevMonthArrow = self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear();

				self.prevMonthNav.style.display = hidePrevMonthArrow ? "none" : "block";
			} else self.prevMonthNav.style.display = "block";

			if (self.config.maxDate) {
				var hideNextMonthArrow = self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear();

				self.nextMonthNav.style.display = hideNextMonthArrow ? "none" : "block";
			} else self.nextMonthNav.style.display = "block";
		}

		function updateValue() {
			if (!self.selectedDates.length) return self.clear();

			if (self.isMobile) {
				self.mobileInput.value = self.selectedDates.length ? formatDate(self.mobileFormatStr, self.latestSelectedDateObj) : "";
			}

			var joinChar = self.config.mode !== "range" ? "; " : self.l10n.rangeSeparator;

			self.input.value = self.selectedDates.map(function (dObj) {
				return formatDate(self.config.dateFormat, dObj);
			}).join(joinChar);

			if (self.config.altInput) {
				self.altInput.value = self.selectedDates.map(function (dObj) {
					return formatDate(self.config.altFormat, dObj);
				}).join(joinChar);
			}

			triggerEvent("ValueUpdate");
		}

		function yearScroll(e) {
			e.preventDefault();

			var delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)),
			    newYear = parseInt(e.target.value, 10) + delta;

			handleYearChange(newYear);
			e.target.value = self.currentYear;
		}

		function createElement(tag, className, content) {
			var e = window.document.createElement(tag);
			className = className || "";
			content = content || "";

			e.className = className;

			if (content) e.textContent = content;

			return e;
		}

		/* istanbul ignore next */
		function debounce(func, wait, immediate) {
			var timeout = void 0;
			return function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				var context = this;
				var later = function later() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};

				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (immediate && !timeout) func.apply(context, args);
			};
		}

		function compareDates(date1, date2, timeless) {
			if (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;

			if (timeless !== false) {
				return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
			}

			return date1.getTime() - date2.getTime();
		}

		function timeWrapper(e) {
			e.preventDefault();
			if (e && ((e.target.value || e.target.textContent).length >= 2 || // typed two digits
			e.type !== "keydown" && e.type !== "input" // scroll event
			)) e.target.blur();

			if (self.amPM && e.target === self.amPM) return e.target.textContent = ["AM", "PM"][e.target.textContent === "AM" | 0];

			var min = Number(e.target.min),
			    max = Number(e.target.max),
			    step = Number(e.target.step),
			    curValue = parseInt(e.target.value, 10),
			    delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));

			var newValue = Number(curValue);

			switch (e.type) {
				case "wheel":
					newValue = curValue + step * delta;
					break;

				case "keydown":
					newValue = curValue + step * (e.which === 38 ? 1 : -1);
					break;
			}

			if (e.type !== "input" || e.target.value.length === 2) {
				if (newValue < min) {
					newValue = max + newValue + (e.target !== self.hourElement) + (e.target === self.hourElement && !self.amPM);
				} else if (newValue > max) {
					newValue = e.target === self.hourElement ? newValue - max - !self.amPM : min;
				}

				if (self.amPM && e.target === self.hourElement && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === "PM" ? "AM" : "PM";

				e.target.value = self.pad(newValue);
			} else e.target.value = newValue;
		}

		init();
		return self;
	}

	/* istanbul ignore next */
	Flatpickr.defaultConfig = {

		mode: "single",

		/* if true, dates will be parsed, formatted, and displayed in UTC.
	 preloading date strings w/ timezones is recommended but not necessary */
		utc: false,

		// wrap: see https://chmln.github.io/flatpickr/#strap
		wrap: false,

		// enables week numbers
		weekNumbers: false,

		// allow manual datetime input
		allowInput: false,

		/*
	 	clicking on input opens the date(time)picker.
	 	disable if you wish to open the calendar manually with .open()
	 */
		clickOpens: true,

		// display time picker in 24 hour mode
		time_24hr: false,

		// enables the time picker functionality
		enableTime: false,

		// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime
		noCalendar: false,

		// more date format chars at https://chmln.github.io/flatpickr/#dateformat
		dateFormat: "Y-m-d",

		// altInput - see https://chmln.github.io/flatpickr/#altinput
		altInput: false,

		// the created altInput element will have this class.
		altInputClass: "flatpickr-input form-control input",

		// same as dateFormat, but for altInput
		altFormat: "F j, Y", // defaults to e.g. June 10, 2016

		// defaultDate - either a datestring or a date object. used for datetimepicker"s initial value
		defaultDate: null,

		// the minimum date that user can pick (inclusive)
		minDate: null,

		// the maximum date that user can pick (inclusive)
		maxDate: null,

		// dateparser that transforms a given string to a date object
		parseDate: null,

		// dateformatter that transforms a given date object to a string, according to passed format
		formatDate: null,

		getWeek: function getWeek(givenDate) {
			var date = new Date(givenDate.getTime());
			date.setHours(0, 0, 0, 0);

			// Thursday in current week decides the year.
			date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
			// January 4 is always in week 1.
			var week1 = new Date(date.getFullYear(), 0, 4);
			// Adjust to Thursday in week 1 and count number of weeks from date to week1.
			return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
		},

		// see https://chmln.github.io/flatpickr/#disable
		enable: [],

		// see https://chmln.github.io/flatpickr/#disable
		disable: [],

		// display the short version of month names - e.g. Sep instead of September
		shorthandCurrentMonth: false,

		// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar
		inline: false,

		// position calendar inside wrapper and next to the input element
		// leave at false unless you know what you"re doing
		static: false,

		// DOM node to append the calendar to in *static* mode
		appendTo: null,

		// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome
		prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
		nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",

		// enables seconds in the time picker
		enableSeconds: false,

		// step size used when scrolling/incrementing the hour element
		hourIncrement: 1,

		// step size used when scrolling/incrementing the minute element
		minuteIncrement: 5,

		// initial value in the hour element
		defaultHour: 12,

		// initial value in the minute element
		defaultMinute: 0,

		// disable native mobile datetime input support
		disableMobile: false,

		// default locale
		locale: "default",

		// onChange callback when user selects a date or time
		onChange: null, // function (dateObj, dateStr) {}

		// called every time calendar is opened
		onOpen: null, // function (dateObj, dateStr) {}

		// called every time calendar is closed
		onClose: null, // function (dateObj, dateStr) {}

		// called after calendar is ready
		onReady: null, // function (dateObj, dateStr) {}

		onValueUpdate: null,

		onDayCreate: null
	};

	/* istanbul ignore next */
	Flatpickr.l10ns = {
		en: {
			weekdays: {
				shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
				longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
			},
			months: {
				shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
			},
			daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
			firstDayOfWeek: 0,
			ordinal: function ordinal(nth) {
				var s = nth % 100;
				if (s > 3 && s < 21) return "th";
				switch (s % 10) {
					case 1:
						return "st";
					case 2:
						return "nd";
					case 3:
						return "rd";
					default:
						return "th";
				}
			},
			rangeSeparator: " to ",
			weekAbbreviation: "Wk",
			scrollTitle: "Scroll to increment",
			toggleTitle: "Click to toggle"
		}
	};

	Flatpickr.l10ns.default = Object.create(Flatpickr.l10ns.en);
	Flatpickr.localize = function (l10n) {
		return _extends(Flatpickr.l10ns.default, l10n || {});
	};
	Flatpickr.setDefaults = function (config) {
		return _extends(Flatpickr.defaultConfig, config || {});
	};

	Flatpickr.prototype = {
		pad: function pad(number) {
			return ("0" + number).slice(-2);
		},
		parseDate: function parseDate(date, timeless) {
			if (!date) return null;

			var dateTimeRegex = /(\d+)/g,
			    timeRegex = /^(\d{1,2})[:\s](\d\d)?[:\s]?(\d\d)?\s?(a|p)?/i,
			    timestamp = /^(\d+)$/g,
			    date_orig = date;

			if (date.toFixed || timestamp.test(date)) // timestamp
				date = new Date(date);else if (typeof date === "string") {
				date = date.trim();

				if (date === "today") {
					date = new Date();
					timeless = true;
				} else if (this.config && this.config.parseDate) date = this.config.parseDate(date);else if (timeRegex.test(date)) {
					// time picker
					var m = date.match(timeRegex),
					    hours = !m[4] ? m[1] // military time, no conversion needed
					: m[1] % 12 + (m[4].toLowerCase() === "p" ? 12 : 0); // am/pm

					date = new Date();
					date.setHours(hours, m[2] || 0, m[3] || 0);
				} else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone
					date = new Date(date);else if (dateTimeRegex.test(date) && /^[0-9]/.test(date)) {
					var d = date.match(dateTimeRegex);
					date = new Date(d[0] + "/" + (d[1] || 1) + "/" + (d[2] || 1) + " " + (d[3] || 0) + ":" + (d[4] || 0) + ":" + (d[5] || 0));
				} else // fallback
					date = new Date(date);
			} else if (date instanceof Date) date = new Date(date.getTime()); // create a copy

			if (!(date instanceof Date)) {
				console.warn("flatpickr: invalid date " + date_orig);
				console.info(this.element);
				return null;
			}

			if (this.config && this.config.utc && !date.fp_isUTC) date = date.fp_toUTC();

			if (timeless === true) date.setHours(0, 0, 0, 0);

			return date;
		}
	};

	function _flatpickr(nodeList, config) {
		var nodes = Array.prototype.slice.call(nodeList); // static list
		var instances = [];
		for (var i = 0; i < nodes.length; i++) {
			try {
				nodes[i]._flatpickr = new Flatpickr(nodes[i], config || {});
				instances.push(nodes[i]._flatpickr);
			} catch (e) {
				console.warn(e, e.stack);
			}
		}

		return instances.length === 1 ? instances[0] : instances;
	}
	if (typeof HTMLElement !== "undefined") {
		// browser env
		HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
			return _flatpickr(this, config);
		};

		HTMLElement.prototype.flatpickr = function (config) {
			return _flatpickr([this], config);
		};
	}

	function flatpickr(selector, config) {
		return _flatpickr(window.document.querySelectorAll(selector), config);
	}

	if (typeof jQuery !== "undefined") {
		jQuery.fn.flatpickr = function (config) {
			return _flatpickr(this, config);
		};
	}

	Date.prototype.fp_incr = function (days) {
		return new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));
	};

	Date.prototype.fp_isUTC = false;
	Date.prototype.fp_toUTC = function () {
		var newDate = new Date(this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds());

		newDate.fp_isUTC = true;
		return newDate;
	};

	// IE9 classList polyfill
	/* istanbul ignore next */
	if (!window.document.documentElement.classList && Object.defineProperty && typeof HTMLElement !== "undefined") {
		Object.defineProperty(HTMLElement.prototype, "classList", {
			get: function get() {
				var self = this;
				function update(fn) {
					return function (value) {
						var classes = self.className.split(/\s+/),
						    index = classes.indexOf(value);

						fn(classes, index, value);
						self.className = classes.join(" ");
					};
				}

				var ret = {
					add: update(function (classes, index, value) {
						if (!~index) classes.push(value);
					}),

					remove: update(function (classes, index) {
						if (~index) classes.splice(index, 1);
					}),

					toggle: update(function (classes, index, value) {
						if (~index) classes.splice(index, 1);else classes.push(value);
					}),

					contains: function contains(value) {
						return !!~self.className.split(/\s+/).indexOf(value);
					},

					item: function item(i) {
						return self.className.split(/\s+/)[i] || null;
					}
				};

				Object.defineProperty(ret, "length", {
					get: function get() {
						return self.className.split(/\s+/).length;
					}
				});

				return ret;
			}
		});
	}

	if (true) module.exports = Flatpickr;


/***/ },
/* 196 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInteger;
	/**
	 * Check if the passed value is an integer
	 *
	 * @name 		isInteger
	 * @param 		{Mixed} 		value 		The value to check
	 * @return 		{Boolean} 					The check result
	 *
	 * @example 	js
	 * isInteger(10) => true
	 * isInteger('hello') => false
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInteger(data) {
	  return !isNaN(data) && function (x) {
	    return (x | 0) === x;
	  }(parseFloat(data));
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapComponent = __webpack_require__(198);

	var _SGoogleMapComponent2 = _interopRequireDefault(_SGoogleMapComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapComponent2.default.define('s-google-map', _SGoogleMapComponent2.default);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _coffeekrakenSGoogleMapComponentBase = __webpack_require__(199);

	var _coffeekrakenSGoogleMapComponentBase2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponentBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SGoogleMapComponent
	 * @extends 	SGoogleMapComponentBase
	 * Provide a nice webcomponent wrapper around the google map api.
	 * @styleguide  	Objects / Google Map
	 * @example 	html
	 * <s-google-map api-key="..." center="{lat: -25.363, lng: 131.044}">
	 * </s-google-map>
	 * @see 	https://www.npmjs.com/package/google-maps
	 * @see 	https://developers.google.com/maps/documentation/javascript/
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SGoogleMapComponent = function (_SGoogleMapComponentB) {
		_inherits(SGoogleMapComponent, _SGoogleMapComponentB);

		function SGoogleMapComponent() {
			_classCallCheck(this, SGoogleMapComponent);

			return _possibleConstructorReturn(this, (SGoogleMapComponent.__proto__ || Object.getPrototypeOf(SGoogleMapComponent)).apply(this, arguments));
		}

		_createClass(SGoogleMapComponent, [{
			key: 'shouldAcceptComponentProp',


			/**
	   * Accept all props
	   * @definition 		SWebComponent.shouldAcceptComponentProp
	   * @protected
	   */
			value: function shouldAcceptComponentProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentMount', this).call(this);

				// create the map container
				this._mapElm = document.createElement('div');
				this._mapElm.className = this._componentNameDash + '__map';
				this._mapElm.setAttribute('s-google-map-map', true);

				// try to get the placeholder
				this._placeholder = this.querySelector(this._componentNameDash + '-placeholder');

				// manage placeholder
				if (this._placeholder) {
					this._handlePlaceholder();
				} else {
					// init directly
					this._internalInit();
				}

				// append the map elm
				this.appendChild(this._mapElm);
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				console.log('ddd', name, newVal);
				switch (name) {
					case 'skin':
						console.log('coco', name, newVal);
						this._map.setOptions({
							styles: SGoogleMapComponent._registeredSkins[newVal]
						});
						break;
				}
			}

			/**
	   * Component will receive props
	   * @definition 		SWebComponent.componentWillReceiveProps
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps, previousProps) {
				if (!this._map) return;
				this._map.setOptions(nextProps);
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Handle the placeholder element
	   */

		}, {
			key: '_handlePlaceholder',
			value: function _handlePlaceholder() {
				// listen to init the map
				this._placeholder.addEventListener(this.props.initOn, this._onPlaceholderInit.bind(this));
			}

			/**
	   * Proxy function of placeholder init listener
	   */

		}, {
			key: '_onPlaceholderInit',
			value: function _onPlaceholderInit() {
				// remove the placeholder
				this._placeholder.parentNode.removeChild(this._placeholder);
				// stop listening for init on placeholder
				this._placeholder.removeEventListener(this.props.initOn, this._onPlaceholderInit);
				// internal init
				this._internalInit();
			}

			/**
	   * Init the map
	   */

		}, {
			key: '_internalInit',
			value: function _internalInit() {
				// init the map
				this._initMap();
			}

			/**
	   * Init the map
	   */

		}, {
			key: '_initMap',
			value: function _initMap() {

				var styles = this.props.styles;
				if (this.props.skin) {
					styles = SGoogleMapComponent._registeredSkins[this.props.skin];
				}

				this._map = new this._google.maps.Map(this._mapElm, _extends({}, this.props, {
					styles: styles
				}));
				// set the component as inited
				// used by the markers to init when the map is ok
				this.setAttribute('inited', true);
			}

			/**
	   * Access the google map instance
	   * @name 	map
	   * @type 	{Google.Map} 	The google map instance
	   */

		}, {
			key: 'map',
			get: function get() {
				return this._map;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: relative;\n\t\t\t\tmin-height: 50px;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__map {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0; left: 0;\n\t\t\t\twidth: 100%; height: 100%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__placeholder {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tcursor: pointer;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\t\t';
			}

			/**
	   * Register a map style to use later through the "style" property
	   * @param 		{String} 		name 		The name of the style to register
	   * @param 		{Object} 		skin 		The skin object
	   */

		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Set the initial zoom of the map
	     * @prop
	     * @type 	{integer}
	     */
					zoom: 4,

					/**
	     * Set when to init the map if the placeholder setting is used
	     * @prop
	     * @type 	{String}
	     */
					initOn: 'click',

					/**
	     * Specify a registered skin to use. The skin has to be registered through the static ```SGoogleMapComponent.registerSkin``` method.
	     * @prop
	     * @type 	{String}
	     */
					skin: null

					/**
	     * @name 	Google Map API
	     * Support all the google api options
	     * @prop
	     * @name 	All others google map options
	     * @type 	{Mixed}
	     */
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SGoogleMapComponent;
	}(_coffeekrakenSGoogleMapComponentBase2.default);

	SGoogleMapComponent._registeredSkins = {};

	SGoogleMapComponent.registerSkin = function (name, skin) {
		// save the new skin
		SGoogleMapComponent._registeredSkins[name] = skin;
	};

	exports.default = SGoogleMapComponent;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapComponentBase = __webpack_require__(200);

	var _SGoogleMapComponentBase2 = _interopRequireDefault(_SGoogleMapComponentBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapComponentBase2.default;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SWebComponent2 = __webpack_require__(201);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _googleMaps = __webpack_require__(226);

	var _googleMaps2 = _interopRequireDefault(_googleMaps);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SGoogleMapComponentBase = function (_SWebComponent) {
		_inherits(SGoogleMapComponentBase, _SWebComponent);

		function SGoogleMapComponentBase() {
			_classCallCheck(this, SGoogleMapComponentBase);

			return _possibleConstructorReturn(this, (SGoogleMapComponentBase.__proto__ || Object.getPrototypeOf(SGoogleMapComponentBase)).apply(this, arguments));
		}

		_createClass(SGoogleMapComponentBase, [{
			key: '_loadGoogleApi',


			/**
	   * Return a promise that load the google api
	   * @return 	{Promise}
	   */
			value: function _loadGoogleApi() {
				// set some static variables on the google loader
				if (this.props.apiKey) {
					_googleMaps2.default.KEY = this.props.apiKey;
				}
				if (this.props.client) {
					_googleMaps2.default.CLIENT = this.props.client;
				}
				if (this.props.version) {
					_googleMaps2.default.VERSION = this.props.version;
				}
				if (this.props.libraries) {
					_googleMaps2.default.LIBRARIES = this.props.libraries;
				}
				if (this.props.language) {
					_googleMaps2.default.LANGUAGE = this.props.language;
				}
				if (this.props.region) {
					_googleMaps2.default.REGION = this.props.region;
				}
				return new Promise(function (resolve, reject) {
					// load the map api
					_googleMaps2.default.load(function (google) {
						// resolve the promise
						resolve(google);
					});
				});
			}

			/**
	   * _google
	   * Get the google api
	   * @type 	{Object}
	   */

		}, {
			key: '_google',
			get: function get() {
				return window.google;
			}
		}], [{
			key: 'mountDependencies',


			/**
	   * Return a list of promises to resolve before init the component
	   * @return 	{Array} 	An array of promises to resolve
	   */
			get: function get() {
				return [function () {
					return this._loadGoogleApi();
				}];
			}

			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   */

		}, {
			key: 'defaultProps',
			get: function get() {
				return {

					/**
	     * Set the api key used to reach the google services
	     * @prop
	     * @type		{String}
	     */
					apiKey: null,

					/**
	     * Set the client api id used to reach google services
	     * @prop
	     * @type 		{String}
	     */
					client: null,

					/**
	     * Set the version of the api to load
	     * @prop
	     * @type		{String}
	     */
					version: null,

					/**
	     * Set the libraries to load
	     * @prop
	     * @type		{Array}
	     */
					libraries: null,

					/**
	     * Set the language to use
	     * @prop
	     * @type  	{String}
	     */
					language: null,

					/**
	     * Store the region to use
	     * @prop
	     * @type 	{String}
	     */
					region: null
				};
			}
		}]);

		return SGoogleMapComponentBase;
	}(_SWebComponent3.default);

	exports.default = SGoogleMapComponentBase;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(202);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(203);

	var _SWebComponentMixin = __webpack_require__(204);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(203);

	var _autoCast = __webpack_require__(205);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(206);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(207);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(208);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(210);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(211);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(218);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(219);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(221);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(224);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 205 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 206 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 207 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(209);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(211);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(214);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(215);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(216);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(212);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(213);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 212 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(212);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(217);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 217 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(220);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(208);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(225);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 225 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {

		if (root === null) {
			throw new Error('Google-maps package can be used only in browser');
		}

		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			module.exports = factory();
		} else {
			root.GoogleMapsLoader = factory();
		}

	})(typeof window !== 'undefined' ? window : null, function() {


		'use strict';


		var googleVersion = '3.18';

		var script = null;

		var google = null;

		var loading = false;

		var callbacks = [];

		var onLoadEvents = [];

		var originalCreateLoaderMethod = null;


		var GoogleMapsLoader = {};


		GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';

		GoogleMapsLoader.KEY = null;

		GoogleMapsLoader.LIBRARIES = [];

		GoogleMapsLoader.CLIENT = null;

		GoogleMapsLoader.CHANNEL = null;

		GoogleMapsLoader.LANGUAGE = null;

		GoogleMapsLoader.REGION = null;

		GoogleMapsLoader.VERSION = googleVersion;

		GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';


		GoogleMapsLoader._googleMockApiObject = {};


		GoogleMapsLoader.load = function(fn) {
			if (google === null) {
				if (loading === true) {
					if (fn) {
						callbacks.push(fn);
					}
				} else {
					loading = true;

					window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
						ready(fn);
					};

					GoogleMapsLoader.createLoader();
				}
			} else if (fn) {
				fn(google);
			}
		};


		GoogleMapsLoader.createLoader = function() {
			script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = GoogleMapsLoader.createUrl();

			document.body.appendChild(script);
		};


		GoogleMapsLoader.isLoaded = function() {
			return google !== null;
		};


		GoogleMapsLoader.createUrl = function() {
			var url = GoogleMapsLoader.URL;

			url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;

			if (GoogleMapsLoader.KEY) {
				url += '&key=' + GoogleMapsLoader.KEY;
			}

			if (GoogleMapsLoader.LIBRARIES.length > 0) {
				url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
			}

			if (GoogleMapsLoader.CLIENT) {
				url += '&client=' + GoogleMapsLoader.CLIENT + '&v=' + GoogleMapsLoader.VERSION;
			}

			if (GoogleMapsLoader.CHANNEL) {
				url += '&channel=' + GoogleMapsLoader.CHANNEL;
			}

			if (GoogleMapsLoader.LANGUAGE) {
				url += '&language=' + GoogleMapsLoader.LANGUAGE;
			}

			if (GoogleMapsLoader.REGION) {
				url += '&region=' + GoogleMapsLoader.REGION;
			}

			return url;
		};


		GoogleMapsLoader.release = function(fn) {
			var release = function() {
				GoogleMapsLoader.KEY = null;
				GoogleMapsLoader.LIBRARIES = [];
				GoogleMapsLoader.CLIENT = null;
				GoogleMapsLoader.CHANNEL = null;
				GoogleMapsLoader.LANGUAGE = null;
				GoogleMapsLoader.REGION = null;
				GoogleMapsLoader.VERSION = googleVersion;

				google = null;
				loading = false;
				callbacks = [];
				onLoadEvents = [];

				if (typeof window.google !== 'undefined') {
					delete window.google;
				}

				if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
					delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
				}

				if (originalCreateLoaderMethod !== null) {
					GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
					originalCreateLoaderMethod = null;
				}

				if (script !== null) {
					script.parentElement.removeChild(script);
					script = null;
				}

				if (fn) {
					fn();
				}
			};

			if (loading) {
				GoogleMapsLoader.load(function() {
					release();
				});
			} else {
				release();
			}
		};


		GoogleMapsLoader.onLoad = function(fn) {
			onLoadEvents.push(fn);
		};


		GoogleMapsLoader.makeMock = function() {
			originalCreateLoaderMethod = GoogleMapsLoader.createLoader;

			GoogleMapsLoader.createLoader = function() {
				window.google = GoogleMapsLoader._googleMockApiObject;
				window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
			};
		};


		var ready = function(fn) {
			var i;

			loading = false;

			if (google === null) {
				google = window.google;
			}

			for (i = 0; i < onLoadEvents.length; i++) {
				onLoadEvents[i](google);
			}

			if (fn) {
				fn(google);
			}

			for (i = 0; i < callbacks.length; i++) {
				callbacks[i](google);
			}

			callbacks = [];
		};


		return GoogleMapsLoader;

	});


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapMarkerComponent = __webpack_require__(228);

	var _SGoogleMapMarkerComponent2 = _interopRequireDefault(_SGoogleMapMarkerComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapMarkerComponent2.default.define('s-google-map-marker', _SGoogleMapMarkerComponent2.default);

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _coffeekrakenSGoogleMapComponentBase = __webpack_require__(199);

	var _coffeekrakenSGoogleMapComponentBase2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponentBase);

	var _whenAttribute = __webpack_require__(229);

	var _whenAttribute2 = _interopRequireDefault(_whenAttribute);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SGoogleMapMarkerComponent
	 * @extends 	SGoogleMapComponentBase
	 * Provide a nice webcomponent wrapper around the google map marker api.
	 *
	 * @styleguide  	Objects / Google Map
	 * @example 	html
	 * <s-google-map api-key="..." center="{lat: -25.363, lng: 131.044}">
	 * 	<s-google-map-marker api-key="..." position="{lat: -25.363, lng: 131.044}">
	 * 	</s-google-map-marker>
	 * </s-google-map>
	 * @see 	https://www.npmjs.com/package/google-maps
	 * @see 	https://developers.google.com/maps/documentation/javascript/
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SGoogleMapMarkerComponent = function (_SGoogleMapComponentB) {
		_inherits(SGoogleMapMarkerComponent, _SGoogleMapComponentB);

		function SGoogleMapMarkerComponent() {
			_classCallCheck(this, SGoogleMapMarkerComponent);

			return _possibleConstructorReturn(this, (SGoogleMapMarkerComponent.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent)).apply(this, arguments));
		}

		_createClass(SGoogleMapMarkerComponent, [{
			key: 'shouldAcceptComponentProp',


			/**
	   * Should accept component props
	   * @definition 		SWebComponent.shouldAcceptComponentProp
	   * @protected
	   */
			value: function shouldAcceptComponentProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentMount', this).call(this);

				// get the map instance to use for this marker.
				// this is grabed from the parent node that need to be a google-map component
				if (!this.map) {
					throw 'The "' + this._componentNameDash + '" component has to be a direct child of a "SGoogleMapComponent"';
				}

				// add the marker to the map
				// load the map api
				if (!this._marker) {
					this._initMarker();
				} else {
					this._marker.setMap(this.map);
				}
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive props
	   * @definition 		SWebComponent.componentWillReceiveProps
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps, previousProps) {
				if (!this._marker) return;
				this._marker.setOptions(nextProps);
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Init the marker
	   */

		}, {
			key: '_initMarker',
			value: function _initMarker() {
				this._marker = new this._google.maps.Marker(this.props);
				this._marker.setMap(this.map);
			}

			/**
	   * Access the google map instance
	   * @type 	{Google.Map}
	   */

		}, {
			key: 'map',
			get: function get() {
				return this.parentNode.map;
			}

			/**
	   * Access the google map marker instance
	   * @type 	{Google.Map.Marker}
	   */

		}, {
			key: 'marker',
			get: function get() {
				return this._marker;
			}
		}], [{
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {};
			}

			/**
	   * Mount dependencies
	   * @definition 		SWebComponent.mountDependencies
	   * @protected
	   */

		}, {
			key: 'mountDependencies',
			get: function get() {
				return [function () {
					return (0, _whenAttribute2.default)(this.parentNode, 'inited');
				}];
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SGoogleMapMarkerComponent;
	}(_coffeekrakenSGoogleMapComponentBase2.default);

	exports.default = SGoogleMapMarkerComponent;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenAttribute;

	var _attributesObservable = __webpack_require__(230);

	var _attributesObservable2 = _interopRequireDefault(_attributesObservable);

	var _autoCast = __webpack_require__(245);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Resolve a promise when the wanted attribute on the passed HTMLElement exist or pass the check function provided
	 *
	 * @name 		whenAttribute
	 * @param 		{HTMLElement} 				elm 				The HTMLElement on which to monitor the property
	 * @param 		{String} 					attribute 			The attribute to monitor
	 * @param 		{Function} 					[checkFn=null] 		An optional function to check the attribute. The promise is resolved when this function return true
	 * @return 		(Promise) 										The promise that will be resolved when the attribute exist on the element (and that it passes the checkFn)
	 *
	 * @example 	js
	 * import whenAttribute from 'sugarcss/js/dom/whenAttribute'
	 * whenAttribute(myCoolHTMLElement, 'value').then((value) => {
	 * 		// the value attribute exist on the element
	 * });
	 * // with a checkFn
	 * whenAttribute(myCoolHTMLElement, 'value', (newVal, oldVal) => {
	 * 		// make sure the value is a number
	 * 		return typeof(newVal) === 'number';
	 * }).then((value) => {
	 * 		// do something with your number value...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenAttribute(elm, attrName) {
		var checkFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

		return new Promise(function (resolve, reject) {

			if (elm.hasAttribute(attrName)) {
				var value = (0, _autoCast2.default)(elm.getAttribute(attrName));
				if (checkFn && checkFn(value, value)) {
					resolve(value);
					return;
				} else if (!checkFn) {
					resolve(value);
					return;
				}
			}

			var obs = (0, _attributesObservable2.default)(elm).subscribe(function (mutation) {
				if (mutation.attributeName === attrName) {
					var _value = (0, _autoCast2.default)(mutation.target.getAttribute(mutation.attributeName));
					if (checkFn && checkFn(_value, mutation.oldValue)) {
						resolve(_value);
						obs.unsubscribe();
					} else if (!checkFn) {
						resolve(_value);
						obs.unsubscribe();
					}
				}
			});
		});
	}

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	/**
	 * List of attributes to observe
	 * @setting
	 * @name 		attributes
	 * @type 		{Array}
	 * @default 	null
	 */
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	/**
	 * Observe attributes on an HTMLElement and get mutations through the observable subscription
	 *
	 * @name 		attributesObservable
	 * @param 		{HTMLElement} 					target 		The element to observe
	 * @param 		{MutationObserverInit} 			settings 	The mutation observer settings
	 * @return 		{Observable} 								The mutation observable
	 *
	 * @example  	js
	 * import attributesObservable from 'sugarcss/js/dom/attributesObservable'
	 * attributesObservable(myCoolHTMLElement).subscribe((mutation) => {
	 * 		// do something with the mutation
	 * });
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/MutationObserver
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */


	exports.default = function (target) {
		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		var observable = new _Observable.Observable(function (observer) {

			// create a new observer
			var mutationObserver = new MutationObserver(function (mutations) {
				var mutedAttrs = {};
				// loop on mutations
				mutations.forEach(function (mutation) {
					// push mutation
					if (!mutedAttrs[mutation.attribute]) {
						observer.next(mutation);
						mutedAttrs[mutation.attribute] = true;
					}
				});
				mutedAttrs = {};
			});
			mutationObserver.observe(target, _extends({
				attributes: true
			}, settings));
			// unsubscribe routine
			return function () {
				mutationObserver.disconnect();
			};
		});

		return observable;
	};

	var _Observable = __webpack_require__(231);

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(232);
	var toSubscriber_1 = __webpack_require__(233);
	var observable_1 = __webpack_require__(244);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 232 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(234);
	var rxSubscriber_1 = __webpack_require__(243);
	var Observer_1 = __webpack_require__(242);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(235);
	var Subscription_1 = __webpack_require__(236);
	var Observer_1 = __webpack_require__(242);
	var rxSubscriber_1 = __webpack_require__(243);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(237);
	var isObject_1 = __webpack_require__(238);
	var isFunction_1 = __webpack_require__(235);
	var tryCatch_1 = __webpack_require__(239);
	var errorObject_1 = __webpack_require__(240);
	var UnsubscriptionError_1 = __webpack_require__(241);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(240);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(232);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(232);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCustomScrollbarComponent = __webpack_require__(247);

	var _SCustomScrollbarComponent2 = _interopRequireDefault(_SCustomScrollbarComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SCustomScrollbarComponent2.default.define('s-custom-scrollbar', _SCustomScrollbarComponent2.default);

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(248);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _simplebar = __webpack_require__(273);

	var _simplebar2 = _interopRequireDefault(_simplebar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SCustomScrollbarComponent
	 * @extends 	SWebComponent
	 * Provide a simple webcomponent to create nice custom scrollbars. It will use the native scrollbar behavior and just hide the native scrollbars. Perfect for integration on mobile devices, etc...
	 * @example 	html
	 * <s-custom-scrollbar style="height:300px;">
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * </s-custom-scrollbar>
	 *
	 * @see 		https://github.com/Grsmto/simplebar
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	/**
	 * @name 			Scrollbar
	 * Provide a way to display a nice custom-scrollbar
	 * @styleguide  	Blocks / Scrollbar
	 * @example 		html
	 * <s-custom-scrollbar style="height:300px;">
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * 	<p>Duis volutpat vehicula aliquam. Praesent aliquet ac orci et vehicula. Fusce pharetra eleifend orci, vulputate consectetur risus vehicula vitae. Pellentesque sed mauris id elit semper interdum. Pellentesque dictum sollicitudin risus tincidunt consectetur. Fusce imperdiet nec purus eu eleifend. Ut feugiat ultricies finibus. In eu enim eget libero aliquet venenatis. Praesent gravida ligula id mauris cursus mollis. Aenean lacinia ullamcorper tincidunt. Sed posuere ultrices tortor, sit amet convallis leo rutrum non.</p>
	 * </s-custom-scrollbar>
	 * @see 			https://github.com/coffeekraken/s-custom-scrollbar-component
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SCustomScrollbarComponent = function (_SWebComponent) {
		_inherits(SCustomScrollbarComponent, _SWebComponent);

		function SCustomScrollbarComponent() {
			_classCallCheck(this, SCustomScrollbarComponent);

			return _possibleConstructorReturn(this, (SCustomScrollbarComponent.__proto__ || Object.getPrototypeOf(SCustomScrollbarComponent)).apply(this, arguments));
		}

		_createClass(SCustomScrollbarComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SCustomScrollbarComponent.prototype.__proto__ || Object.getPrototypeOf(SCustomScrollbarComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SCustomScrollbarComponent.prototype.__proto__ || Object.getPrototypeOf(SCustomScrollbarComponent.prototype), 'componentMount', this).call(this);

				// add the simplebar attribute on the element
				this.setAttribute('data-simplebar', true);

				// init the simplebar
				this._simplebar = new _simplebar2.default(this, {
					forceEnabled: true,
					scrollbarMinSize: 0
				});

				// listen for resize window
				window.addEventListener('resize', this._onWindowResize.bind(this));
			}

			/**
	   * On window resize
	   * @param 		{Event} 	e 	The event
	   */

		}, {
			key: '_onWindowResize',
			value: function _onWindowResize(e) {
				// recalculate the scroll
				this._simplebar.recalculate();
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SCustomScrollbarComponent.prototype.__proto__ || Object.getPrototypeOf(SCustomScrollbarComponent.prototype), 'componentUnmount', this).call(this);

				// listen for resize window
				window.removeEventListener('resize', this._onWindowResize);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SCustomScrollbarComponent.prototype.__proto__ || Object.getPrototypeOf(SCustomScrollbarComponent.prototype), 'render', this).call(this);
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tposition: relative;\n\t\t\t\tz-index: 0;\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t\t-webkit-overflow-scrolling: touch;\n\t\t\t}\n\n\t\t\t.simplebar-scroll-content {\n\t\t\t\toverflow: auto;\n\t\t\t\tposition: relative;\n\t\t\t\tz-index: 0;\n\t\t\t}\n\n\t\t\t.simplebar-track {\n\t\t\t\tz-index: 1;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tright: 0;\n\t\t\t\tbottom: 0;\n\t\t\t\twidth: 4px;\n\t\t\t}\n\n\t\t\t.simplebar-track .simplebar-scrollbar {\n\t\t\t\tposition: absolute;\n\t\t\t\tright: 0px;\n\t\t\t\tborder-radius: 0px;\n\t\t\t\twidth: 100%;\n\t\t\t\ttransition: opacity 0.2s linear;\n\t\t\t\tbackground: #6c6e71;\n\t\t\t\tbackground-clip: padding-box;\n\t\t\t}\n\n\t\t\t.horizontal.simplebar-track {\n\t\t\t\ttop: auto;\n\t\t\t\tleft: 0;\n\t\t\t\twidth: auto;\n\t\t\t\theight: 4px;\n\t\t\t}\n\n\t\t\t.horizontal.simplebar-track .simplebar-scrollbar {\n\t\t\t\tright: auto;\n\t\t\t\ttop: 0px;\n\t\t\t\theight: 100%;\n\t\t\t\tmin-height: 0;\n\t\t\t\twidth: auto;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SCustomScrollbarComponent;
	}(_SWebComponent3.default);

	exports.default = SCustomScrollbarComponent;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(249);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(250);

	var _SWebComponentMixin = __webpack_require__(251);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(250);

	var _autoCast = __webpack_require__(252);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(253);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(254);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(255);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(257);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(258);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(265);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(266);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(268);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 252 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 253 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 254 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(256);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(258);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(261);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(262);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(263);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(259);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(260);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 259 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(259);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 261 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 262 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(264);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 264 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 265 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(267);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 267 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(255);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(272);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 272 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * 
	 *             SimpleBar.js - v2.2.1
	 *             Scrollbars, simpler.
	 *             https://grsmto.github.io/simplebar/
	 *             
	 *             Made by Adrien Grsmto from a fork by Jonathan Nicol
	 *             Under MIT License
	 *         
	 */
	!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.SimpleBar=e():t.SimpleBar=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={exports:{},id:r,loaded:!1};return t[r].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{"default":t}}Object.defineProperty(e,"__esModule",{value:!0});var i=n(32),o=r(i),s=n(29),c=r(s),a=n(30),u=r(a),l=n(33),f=r(l),h=n(34),d=r(h),p=n(72),v=r(p),b=n(70),y=r(b),m=n(71),g=r(m);n(69);var _=function(){function t(e,n){(0,f.default)(this,t),this.el=e,this.track,this.scrollbar,this.flashTimeout,this.contentEl,this.scrollContentEl,this.dragOffset={x:0,y:0},this.isVisible={x:!0,y:!0},this.scrollOffsetAttr={x:"scrollLeft",y:"scrollTop"},this.sizeAttr={x:"offsetWidth",y:"offsetHeight"},this.scrollSizeAttr={x:"scrollWidth",y:"scrollHeight"},this.offsetAttr={x:"left",y:"top"},this.observer,this.currentAxis,this.enabled,this.scrollbarWidth=(0,v.default)(),this.options=(0,u.default)({},t.defaultOptions,n),this.classNames=this.options.classNames,this.flashScrollbar=this.flashScrollbar.bind(this),this.startScroll=this.startScroll.bind(this),this.startDrag=this.startDrag.bind(this),this.drag=this.drag.bind(this),this.endDrag=this.endDrag.bind(this),this.recalculate=(0,y.default)(this.recalculate,100,{leading:!0,trailing:!1}),this.init()}return(0,d.default)(t,[{key:"init",value:function(){return this.el.SimpleBar=this,this.enabled=0!==this.scrollbarWidth&&!this.options.forceEnabled,this.enabled?(this.initDOM(),this.trackX=this.el.querySelector("."+this.classNames.track+".horizontal"),this.trackY=this.el.querySelector("."+this.classNames.track+".vertical"),this.scrollbarX=this.trackX.querySelector("."+this.classNames.scrollbar),this.scrollbarY=this.trackY.querySelector("."+this.classNames.scrollbar),this.recalculate(),this.options.autoHide||(this.showScrollbar("x"),this.showScrollbar("y")),void this.initListeners()):void(this.el.style.overflow="auto")}},{key:"initDOM",value:function(){if(this.options.wrapContent){for(this.scrollContentEl=document.createElement("div"),this.contentEl=document.createElement("div"),this.scrollContentEl.classList.add(this.classNames.scrollContent),this.contentEl.classList.add(this.classNames.content),this.scrollContentEl.style.padding="0 "+this.scrollbarWidth+"px "+this.scrollbarWidth+"px 0",this.scrollContentEl.style.margin="0 -"+this.scrollbarWidth+"px -"+this.scrollbarWidth+"px 0",this.contentEl.style.marginBottom="-"+this.scrollbarWidth+"px";this.el.firstChild;)this.contentEl.appendChild(this.el.firstChild);this.scrollContentEl.appendChild(this.contentEl),this.el.appendChild(this.scrollContentEl)}var t=document.createElement("div"),e=document.createElement("div");t.classList.add(this.classNames.track),e.classList.add(this.classNames.scrollbar),t.appendChild(e),this.trackX=t.cloneNode(!0),this.trackX.classList.add("horizontal"),this.trackY=t.cloneNode(!0),this.trackY.classList.add("vertical"),this.el.insertBefore(this.trackX,this.el.firstChild),this.el.insertBefore(this.trackY,this.el.firstChild)}},{key:"initListeners",value:function(){var t=this;this.options.autoHide&&this.el.addEventListener("mouseenter",this.flashScrollbar),this.scrollbarX.addEventListener("mousedown",function(e){return t.startDrag(e,"x")}),this.scrollbarY.addEventListener("mousedown",function(e){return t.startDrag(e,"y")}),this.scrollContentEl.addEventListener("scroll",this.startScroll),"undefined"!=typeof MutationObserver&&(this.mutationObserver=new MutationObserver(function(e){e.forEach(function(e){(t.isChildNode(e.target)||e.addedNodes.length)&&t.recalculate()})}),this.mutationObserver.observe(this.el,{attributes:!0,childList:!0,characterData:!0,subtree:!0})),this.resizeObserver=new g.default(this.recalculate.bind(this)),this.resizeObserver.observe(this.el)}},{key:"removeListeners",value:function(){var t=this;this.enabled&&(this.options.autoHide&&this.el.removeEventListener("mouseenter",this.flashScrollbar),this.scrollbarX.removeEventListener("mousedown",function(e){return t.startDrag(e,"x")}),this.scrollbarY.removeEventListener("mousedown",function(e){return t.startDrag(e,"y")}),this.scrollContentEl.removeEventListener("scroll",this.startScroll),this.observer&&this.observer.disconnect())}},{key:"startDrag",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"y";t.preventDefault();var n="y"===e?this.scrollbarY:this.scrollbarX,r="y"===e?t.pageY:t.pageX;this.dragOffset[e]=r-n.getBoundingClientRect()[this.offsetAttr[e]],this.currentAxis=e,document.addEventListener("mousemove",this.drag),document.addEventListener("mouseup",this.endDrag)}},{key:"drag",value:function(t){t.preventDefault();var e="y"===this.currentAxis?t.pageY:t.pageX,n="y"===this.currentAxis?this.trackY:this.trackX,r=e-n.getBoundingClientRect()[this.offsetAttr[this.currentAxis]]-this.dragOffset[this.currentAxis],i=r/n[this.sizeAttr[this.currentAxis]],o=i*this.contentEl[this.scrollSizeAttr[this.currentAxis]];this.scrollContentEl[this.scrollOffsetAttr[this.currentAxis]]=o}},{key:"endDrag",value:function(){document.removeEventListener("mousemove",this.drag),document.removeEventListener("mouseup",this.endDrag)}},{key:"resizeScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y",e=void 0,n=void 0;"x"===t?(e=this.trackX,n=this.scrollbarX):(e=this.trackY,n=this.scrollbarY);var r=this.contentEl[this.scrollSizeAttr[t]],i=this.scrollContentEl[this.scrollOffsetAttr[t]],o=e[this.sizeAttr[t]],s=o/r,c=i/(r-o),a=Math.max(Math.floor(s*(o-2))-2,this.options.scrollbarMinSize),u=(o-4-a)*c+2;this.isVisible[t]=o<r,this.isVisible[t]?(e.style.visibility="visible","x"===t?(n.style.left=u+"px",n.style.width=a+"px"):(n.style.top=u+"px",n.style.height=a+"px")):e.style.visibility="hidden"}},{key:"startScroll",value:function(){this.flashScrollbar()}},{key:"flashScrollbar",value:function(){this.resizeScrollbar("x"),this.resizeScrollbar("y"),this.showScrollbar("x"),this.showScrollbar("y")}},{key:"showScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";this.isVisible[t]&&("x"===t?this.scrollbarX.classList.add("visible"):this.scrollbarY.classList.add("visible"),this.options.autoHide&&("number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout),this.flashTimeout=window.setTimeout(this.hideScrollbar.bind(this),1e3)))}},{key:"hideScrollbar",value:function(){this.scrollbarX.classList.remove("visible"),this.scrollbarY.classList.remove("visible"),"number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout)}},{key:"recalculate",value:function(){this.enabled&&(this.resizeScrollbar("x"),this.resizeScrollbar("y"))}},{key:"getScrollElement",value:function(){return this.scrollContentEl}},{key:"getContentElement",value:function(){return this.contentEl}},{key:"unMount",value:function(){this.removeListeners(),this.el.SimpleBar=null}},{key:"isChildNode",value:function(t){return null!==t&&(t===this.el||this.isChildNode(t.parentNode))}}],[{key:"initHtmlApi",value:function(){if("undefined"!=typeof MutationObserver){var e=new MutationObserver(function(e){e.forEach(function(e){(0,c.default)(e.addedNodes).forEach(function(e){if(1===e.nodeType){if(e.SimpleBar)return;e.hasAttribute("data-simplebar")?new t(e,t.getElOptions(e)):(0,c.default)(e.querySelectorAll("[data-simplebar]")).forEach(function(e){new t(e,t.getElOptions(e))})}}),(0,c.default)(e.removedNodes).forEach(function(t){1===t.nodeType&&(t.hasAttribute("data-simplebar")?t.SimpleBar&&t.SimpleBar.unMount():(0,c.default)(t.querySelectorAll("[data-simplebar]")).forEach(function(t){t.SimpleBar&&t.SimpleBar.unMount()}))})})});e.observe(document,{childList:!0,subtree:!0})}"complete"===document.readyState||"loading"!==document.readyState&&!document.documentElement.doScroll?window.setTimeout(this.initDOMLoadedElements.bind(this)):(document.addEventListener("DOMContentLoaded",this.initDOMLoadedElements.bind(this)),window.addEventListener("load",this.initDOMLoadedElements.bind(this)))}},{key:"getElOptions",value:function(e){var n=(0,o.default)(t.htmlAttributes).reduce(function(n,r){var i=t.htmlAttributes[r];return e.hasAttribute(i)&&(n[r]=JSON.parse(e.getAttribute(i))),n},{});return n}},{key:"removeObserver",value:function(){this.observer&&this.observer.disconnect()}},{key:"initDOMLoadedElements",value:function(){document.removeEventListener("DOMContentLoaded",this.initDOMLoadedElements),window.removeEventListener("load",this.initDOMLoadedElements),(0,c.default)(document.querySelectorAll("[data-simplebar]")).forEach(function(e){e.SimpleBar||new t(e,t.getElOptions(e))})}},{key:"defaultOptions",get:function(){return{wrapContent:!0,autoHide:!0,forceEnabled:!1,classNames:{content:"simplebar-content",scrollContent:"simplebar-scroll-content",scrollbar:"simplebar-scrollbar",track:"simplebar-track"},scrollbarMinSize:10}}},{key:"htmlAttributes",get:function(){return{autoHide:"data-simplebar-autohide",forceEnabled:"data-simplebar-force-enabled",scrollbarMinSize:"data-simplebar-scrollbar-min-size"}}}]),t}();e.default=_,_.initHtmlApi(),t.exports=e.default},function(t,e){var n=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=n)},function(t,e,n){var r=n(25)("wks"),i=n(28),o=n(5).Symbol,s="function"==typeof o,c=t.exports=function(t){return r[t]||(r[t]=s&&o[t]||(s?o:i)("Symbol."+t))};c.store=r},function(t,e,n){t.exports=!n(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e,n){var r=n(5),i=n(1),o=n(20),s=n(10),c="prototype",a=function(t,e,n){var u,l,f,h=t&a.F,d=t&a.G,p=t&a.S,v=t&a.P,b=t&a.B,y=t&a.W,m=d?i:i[e]||(i[e]={}),g=m[c],_=d?r:p?r[e]:(r[e]||{})[c];d&&(n=e);for(u in n)l=!h&&_&&void 0!==_[u],l&&u in m||(f=l?_[u]:n[u],m[u]=d&&"function"!=typeof _[u]?n[u]:b&&l?o(f,r):y&&_[u]==f?function(t){var e=function(e,n,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(e);case 2:return new t(e,n)}return new t(e,n,r)}return t.apply(this,arguments)};return e[c]=t[c],e}(f):v&&"function"==typeof f?o(Function.call,f):f,v&&((m.virtual||(m.virtual={}))[u]=f,t&a.R&&g&&!g[u]&&s(g,u,f)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e,n){var r=n(7),i=n(44),o=n(62),s=Object.defineProperty;e.f=n(3)?Object.defineProperty:function(t,e,n){if(r(t),e=o(e,!0),r(n),i)try{return s(t,e,n)}catch(c){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(t[e]=n.value),t}},function(t,e,n){var r=n(13);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,e){t.exports=function(t){try{return!!t()}catch(e){return!0}}},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var r=n(6),i=n(16);t.exports=n(3)?function(t,e,n){return r.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(12);t.exports=function(t){return Object(r(t))}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e){t.exports={}},function(t,e,n){var r=n(56),i=n(22);t.exports=Object.keys||function(t){return r(t,i)}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e,n){var r=n(25)("keys"),i=n(28);t.exports=function(t){return r[t]||(r[t]=i(t))}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e,n){var r=n(39);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,i){return t.call(e,n,r,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(13),i=n(5).document,o=r(i)&&r(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,e,n){var r=n(19);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,e,n){var r=n(6).f,i=n(9),o=n(2)("toStringTag");t.exports=function(t,e,n){t&&!i(t=n?t:t.prototype,o)&&r(t,o,{configurable:!0,value:e})}},function(t,e,n){var r=n(5),i="__core-js_shared__",o=r[i]||(r[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,e,n){var r=n(23),i=n(12);t.exports=function(t){return r(i(t))}},function(t,e,n){var r=n(18),i=Math.min;t.exports=function(t){return t>0?i(r(t),9007199254740991):0}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+r).toString(36))}},function(t,e,n){t.exports={"default":n(35),__esModule:!0}},function(t,e,n){t.exports={"default":n(36),__esModule:!0}},function(t,e,n){t.exports={"default":n(37),__esModule:!0}},function(t,e,n){t.exports={"default":n(38),__esModule:!0}},function(t,e){"use strict";e.__esModule=!0,e.default=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{"default":t}}e.__esModule=!0;var i=n(31),o=r(i);e.default=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),(0,o.default)(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}()},function(t,e,n){n(68),n(64),t.exports=n(1).Array.from},function(t,e,n){n(65),t.exports=n(1).Object.assign},function(t,e,n){n(66);var r=n(1).Object;t.exports=function(t,e,n){return r.defineProperty(t,e,n)}},function(t,e,n){n(67),t.exports=n(1).Object.keys},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){var r=n(26),i=n(27),o=n(61);t.exports=function(t){return function(e,n,s){var c,a=r(e),u=i(a.length),l=o(s,u);if(t&&n!=n){for(;u>l;)if(c=a[l++],c!=c)return!0}else for(;u>l;l++)if((t||l in a)&&a[l]===n)return t||l||0;return!t&&-1}}},function(t,e,n){var r=n(19),i=n(2)("toStringTag"),o="Arguments"==r(function(){return arguments}()),s=function(t,e){try{return t[e]}catch(n){}};t.exports=function(t){var e,n,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=s(e=Object(t),i))?n:o?r(e):"Object"==(c=r(e))&&"function"==typeof e.callee?"Arguments":c}},function(t,e,n){"use strict";var r=n(6),i=n(16);t.exports=function(t,e,n){e in t?r.f(t,e,i(0,n)):t[e]=n}},function(t,e,n){t.exports=n(5).document&&document.documentElement},function(t,e,n){t.exports=!n(3)&&!n(8)(function(){return 7!=Object.defineProperty(n(21)("div"),"a",{get:function(){return 7}}).a})},function(t,e,n){var r=n(14),i=n(2)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||o[i]===t)}},function(t,e,n){var r=n(7);t.exports=function(t,e,n,i){try{return i?e(r(n)[0],n[1]):e(n)}catch(o){var s=t.return;throw void 0!==s&&r(s.call(t)),o}}},function(t,e,n){"use strict";var r=n(52),i=n(16),o=n(24),s={};n(10)(s,n(2)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=r(s,{next:i(1,n)}),o(t,e+" Iterator")}},function(t,e,n){"use strict";var r=n(50),i=n(4),o=n(59),s=n(10),c=n(9),a=n(14),u=n(47),l=n(24),f=n(55),h=n(2)("iterator"),d=!([].keys&&"next"in[].keys()),p="@@iterator",v="keys",b="values",y=function(){return this};t.exports=function(t,e,n,m,g,_,x){u(n,e,m);var w,E,O,S=function(t){if(!d&&t in j)return j[t];switch(t){case v:return function(){return new n(this,t)};case b:return function(){return new n(this,t)}}return function(){return new n(this,t)}},A=e+" Iterator",M=g==b,k=!1,j=t.prototype,C=j[h]||j[p]||g&&j[g],L=C||S(g),T=g?M?S("entries"):L:void 0,D="Array"==e?j.entries||C:C;if(D&&(O=f(D.call(new t)),O!==Object.prototype&&(l(O,A,!0),r||c(O,h)||s(O,h,y))),M&&C&&C.name!==b&&(k=!0,L=function(){return C.call(this)}),r&&!x||!d&&!k&&j[h]||s(j,h,L),a[e]=L,a[A]=y,g)if(w={values:M?L:S(b),keys:_?L:S(v),entries:T},x)for(E in w)E in j||o(j,E,w[E]);else i(i.P+i.F*(d||k),e,w);return w}},function(t,e,n){var r=n(2)("iterator"),i=!1;try{var o=[7][r]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(s){}t.exports=function(t,e){if(!e&&!i)return!1;var n=!1;try{var o=[7],s=o[r]();s.next=function(){return{done:n=!0}},o[r]=function(){return s},t(o)}catch(c){}return n}},function(t,e){t.exports=!0},function(t,e,n){"use strict";var r=n(15),i=n(54),o=n(57),s=n(11),c=n(23),a=Object.assign;t.exports=!a||n(8)(function(){var t={},e={},n=Symbol(),r="abcdefghijklmnopqrst";return t[n]=7,r.split("").forEach(function(t){e[t]=t}),7!=a({},t)[n]||Object.keys(a({},e)).join("")!=r})?function(t,e){for(var n=s(t),a=arguments.length,u=1,l=i.f,f=o.f;a>u;)for(var h,d=c(arguments[u++]),p=l?r(d).concat(l(d)):r(d),v=p.length,b=0;v>b;)f.call(d,h=p[b++])&&(n[h]=d[h]);return n}:a},function(t,e,n){var r=n(7),i=n(53),o=n(22),s=n(17)("IE_PROTO"),c=function(){},a="prototype",u=function(){var t,e=n(21)("iframe"),r=o.length,i="<",s=">";for(e.style.display="none",n(43).appendChild(e),e.src="javascript:",t=e.contentWindow.document,t.open(),t.write(i+"script"+s+"document.F=Object"+i+"/script"+s),t.close(),u=t.F;r--;)delete u[a][o[r]];return u()};t.exports=Object.create||function(t,e){var n;return null!==t?(c[a]=r(t),n=new c,c[a]=null,n[s]=t):n=u(),void 0===e?n:i(n,e)}},function(t,e,n){var r=n(6),i=n(7),o=n(15);t.exports=n(3)?Object.defineProperties:function(t,e){i(t);for(var n,s=o(e),c=s.length,a=0;c>a;)r.f(t,n=s[a++],e[n]);return t}},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,n){var r=n(9),i=n(11),o=n(17)("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),r(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null}},function(t,e,n){var r=n(9),i=n(26),o=n(40)(!1),s=n(17)("IE_PROTO");t.exports=function(t,e){var n,c=i(t),a=0,u=[];for(n in c)n!=s&&r(c,n)&&u.push(n);for(;e.length>a;)r(c,n=e[a++])&&(~o(u,n)||u.push(n));return u}},function(t,e){e.f={}.propertyIsEnumerable},function(t,e,n){var r=n(4),i=n(1),o=n(8);t.exports=function(t,e){var n=(i.Object||{})[t]||Object[t],s={};s[t]=e(n),r(r.S+r.F*o(function(){n(1)}),"Object",s)}},function(t,e,n){t.exports=n(10)},function(t,e,n){var r=n(18),i=n(12);t.exports=function(t){return function(e,n){var o,s,c=String(i(e)),a=r(n),u=c.length;return a<0||a>=u?t?"":void 0:(o=c.charCodeAt(a),o<55296||o>56319||a+1===u||(s=c.charCodeAt(a+1))<56320||s>57343?t?c.charAt(a):o:t?c.slice(a,a+2):(o-55296<<10)+(s-56320)+65536)}}},function(t,e,n){var r=n(18),i=Math.max,o=Math.min;t.exports=function(t,e){return t=r(t),t<0?i(t+e,0):o(t,e)}},function(t,e,n){var r=n(13);t.exports=function(t,e){if(!r(t))return t;var n,i;if(e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;if("function"==typeof(n=t.valueOf)&&!r(i=n.call(t)))return i;if(!e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,e,n){var r=n(41),i=n(2)("iterator"),o=n(14);t.exports=n(1).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[r(t)]}},function(t,e,n){"use strict";var r=n(20),i=n(4),o=n(11),s=n(46),c=n(45),a=n(27),u=n(42),l=n(63);i(i.S+i.F*!n(49)(function(t){Array.from(t)}),"Array",{from:function(t){var e,n,i,f,h=o(t),d="function"==typeof this?this:Array,p=arguments.length,v=p>1?arguments[1]:void 0,b=void 0!==v,y=0,m=l(h);if(b&&(v=r(v,p>2?arguments[2]:void 0,2)),void 0==m||d==Array&&c(m))for(e=a(h.length),n=new d(e);e>y;y++)u(n,y,b?v(h[y],y):h[y]);else for(f=m.call(h),n=new d;!(i=f.next()).done;y++)u(n,y,b?s(f,v,[i.value,y],!0):i.value);return n.length=y,n}})},function(t,e,n){var r=n(4);r(r.S+r.F,"Object",{assign:n(51)})},function(t,e,n){var r=n(4);r(r.S+r.F*!n(3),"Object",{defineProperty:n(6).f})},function(t,e,n){var r=n(11),i=n(15);n(58)("keys",function(){return function(t){return i(r(t))}})},function(t,e,n){"use strict";var r=n(60)(!0);n(48)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e){},function(t,e){(function(e){function n(t,e,n){function i(e){var n=v,r=b;return v=b=void 0,O=e,m=t.apply(r,n)}function o(t){return O=t,g=setTimeout(l,e),S?i(t):m}function a(t){var n=t-E,r=t-O,i=e-n;return A?x(i,y-r):i}function u(t){var n=t-E,r=t-O;return void 0===E||n>=e||n<0||A&&r>=y}function l(){var t=w();return u(t)?f(t):void(g=setTimeout(l,a(t)))}function f(t){return g=void 0,M&&v?i(t):(v=b=void 0,m)}function h(){void 0!==g&&clearTimeout(g),O=0,v=E=b=g=void 0}function d(){return void 0===g?m:f(w())}function p(){var t=w(),n=u(t);if(v=arguments,b=this,E=t,n){if(void 0===g)return o(E);if(A)return g=setTimeout(l,e),i(E)}return void 0===g&&(g=setTimeout(l,e)),m}var v,b,y,m,g,E,O=0,S=!1,A=!1,M=!0;if("function"!=typeof t)throw new TypeError(c);return e=s(e)||0,r(n)&&(S=!!n.leading,A="maxWait"in n,y=A?_(s(n.maxWait)||0,e):y,M="trailing"in n?!!n.trailing:M),p.cancel=h,p.flush=d,p}function r(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function i(t){return!!t&&"object"==typeof t}function o(t){return"symbol"==typeof t||i(t)&&g.call(t)==u}function s(t){if("number"==typeof t)return t;if(o(t))return a;if(r(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=r(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(l,"");var n=h.test(t);return n||d.test(t)?p(t.slice(2),n?2:8):f.test(t)?a:+t}var c="Expected a function",a=NaN,u="[object Symbol]",l=/^\s+|\s+$/g,f=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,p=parseInt,v="object"==typeof e&&e&&e.Object===Object&&e,b="object"==typeof self&&self&&self.Object===Object&&self,y=v||b||Function("return this")(),m=Object.prototype,g=m.toString,_=Math.max,x=Math.min,w=function(){return y.Date.now()};t.exports=n}).call(e,function(){return this}())},function(t,e,n){(function(e){!function(e,n){t.exports=n()}(this,function(){"use strict";function t(t){return parseFloat(t)||0}function n(e){var n=Array.prototype.slice.call(arguments,1);return n.reduce(function(n,r){var i=e["border-"+r+"-width"];return n+t(i)},0)}function r(e){for(var n=["top","right","bottom","left"],r={},i=0,o=n;i<o.length;i+=1){var s=o[i],c=e["padding-"+s];r[s]=t(c)}return r}function i(t){var e=t.getBBox();return u(0,0,e.width,e.height)}function o(e){var i=e.clientWidth,o=e.clientHeight;if(!i&&!o)return w;var c=getComputedStyle(e),a=r(c),l=a.left+a.right,f=a.top+a.bottom,h=t(c.width),d=t(c.height);if("border-box"===c.boxSizing&&(Math.round(h+l)!==i&&(h-=n(c,"left","right")+l),Math.round(d+f)!==o&&(d-=n(c,"top","bottom")+f)),!s(e)){var p=Math.round(h+l)-i,v=Math.round(d+f)-o;1!==Math.abs(p)&&(h-=p),1!==Math.abs(v)&&(d-=v)}return u(a.left,a.top,h,d)}function s(t){return t===document.documentElement}function c(t){return h?E(t)?i(t):o(t):w}function a(t){var e=t.x,n=t.y,r=t.width,i=t.height,o="function"==typeof DOMRectReadOnly?DOMRectReadOnly:Object,s=Object.create(o.prototype);return x(s,{x:e,y:n,width:r,height:i,top:n,right:e+r,bottom:i+n,left:e}),s}function u(t,e,n,r){return{x:t,y:e,width:n,height:r}}var l=function(){return"undefined"!=typeof e&&e.Math===Math?e:"undefined"!=typeof self&&self.Math===Math?self:"undefined"!=typeof window&&window.Math===Math?window:Function("return this")()}(),f=function(){function t(t,e){var n=-1;return t.some(function(t,r){return t[0]===e&&(n=r,!0)}),n}return"function"==typeof l.Map?l.Map:function(){function e(){this.__entries__=[]}var n={size:{}};return n.size.get=function(){return this.__entries__.length},e.prototype.get=function(e){var n=t(this.__entries__,e),r=this.__entries__[n];return r&&r[1]},e.prototype.set=function(e,n){var r=t(this.__entries__,e);~r?this.__entries__[r][1]=n:this.__entries__.push([e,n])},e.prototype.delete=function(e){var n=this.__entries__,r=t(n,e);~r&&n.splice(r,1)},e.prototype.has=function(e){return!!~t(this.__entries__,e)},e.prototype.clear=function(){this.__entries__.splice(0)},e.prototype.forEach=function(t,e){var n=this;void 0===e&&(e=null);for(var r=0,i=n.__entries__;r<i.length;r+=1){var o=i[r];t.call(e,o[1],o[0])}},Object.defineProperties(e.prototype,n),e}()}(),h=l.window===l&&"undefined"!=typeof document,d=function(){return"function"==typeof requestAnimationFrame?requestAnimationFrame:function(t){return setTimeout(function(){return t(Date.now())},1e3/60)}}(),p=2,v=function(){var t=Date;return"object"==typeof performance&&"function"==typeof performance.now&&(t=performance),function(){return t.now()}}(),b=function(t,e,n){function r(){s=!1,t(),c&&o()}function i(){n?d(r):r()}function o(){var t=v();if(s){if(t-a<p)return;c=!0}else s=!0,c=!1,setTimeout(i,e);a=t}void 0===n&&(n=!1);var s=!1,c=!1,a=0;return o},y=20,m=80,g="function"==typeof MutationObserver&&"object"==typeof navigator&&!("Netscape"===navigator.appName&&navigator.userAgent.match(/Trident\/.*rv:11/)),_=function(){this.isCycleContinuous_=!g,this.listenersEnabled_=!1,this.mutationsObserver_=null,this.observers_=[],this.refresh=b(this.refresh.bind(this),y,!0),this.continuousUpdateHandler_=b(this.refresh,m)};_.prototype.connect=function(t){this.isConnected(t)||this.observers_.push(t),this.listenersEnabled_||this.addListeners_()},_.prototype.disconnect=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.listenersEnabled_&&this.removeListeners_()},_.prototype.isConnected=function(t){return!!~this.observers_.indexOf(t)},_.prototype.refresh=function(){var t=this.updateObservers_();t?this.refresh():this.isCycleContinuous_&&this.listenersEnabled_&&this.continuousUpdateHandler_()},_.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),t.length>0},_.prototype.addListeners_=function(){h&&!this.listenersEnabled_&&(window.addEventListener("resize",this.refresh),document.addEventListener("transitionend",this.refresh),g&&(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})),this.listenersEnabled_=!0,this.isCycleContinuous_&&this.refresh())},_.prototype.removeListeners_=function(){h&&this.listenersEnabled_&&(window.removeEventListener("resize",this.refresh),document.removeEventListener("transitionend",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationsObserver_=null,this.listenersEnabled_=!1)};var x=function(t,e){for(var n=0,r=Object.keys(e);n<r.length;n+=1){var i=r[n];Object.defineProperty(t,i,{value:e[i],enumerbale:!1,writable:!1,configurable:!0})}return t},w=u(0,0,0,0),E=function(){return"function"==typeof SVGGraphicsElement?function(t){return t instanceof SVGGraphicsElement}:function(t){return t instanceof SVGElement&&"function"==typeof t.getBBox}}(),O=function(t){this.target=t,this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=u(0,0,0,0)};O.prototype.isActive=function(){var t=c(this.target);return this.contentRect_=t,t.width!==this.broadcastWidth||t.height!==this.broadcastHeight},O.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t};var S=function(t,e){var n=a(e);x(this,{target:t,contentRect:n})},A=function(t,e,n){if("function"!=typeof t)throw new TypeError("The callback provided as parameter 1 is not a function.");this.activeTargets_=[],this.observationTargets_=new f,this.callback_=t,this.controller_=e,this.callbackCtx_=n};A.prototype.observe=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("Element"in l&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observationTargets_;e.has(t)||(e.set(t,new O(t)),this.controller_.isConnected(this)||this.controller_.connect(this),this.controller_.refresh())}},A.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("Element"in l&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observationTargets_;e.has(t)&&(e.delete(t),e.size||this.controller_.disconnect(this))}},A.prototype.disconnect=function(){this.clearActive(),this.observationTargets_.clear(),this.controller_.disconnect(this)},A.prototype.gatherActive=function(){this.clearActive();var t=this.activeTargets_;this.observationTargets_.forEach(function(e){e.isActive()&&t.push(e)})},A.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeTargets_.map(function(t){return new S(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},A.prototype.clearActive=function(){this.activeTargets_.splice(0)},A.prototype.hasActive=function(){return this.activeTargets_.length>0};var M=new _,k="function"==typeof WeakMap?new WeakMap:new f,j=function(t){if(!(this instanceof j))throw new TypeError("Cannot call a class as a function");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var e=new A(t,M,this);k.set(this,e)};["observe","unobserve","disconnect"].forEach(function(t){j.prototype[t]=function(){var e;return(e=k.get(this))[t].apply(e,arguments)}});var C=function(){return"function"==typeof l.ResizeObserver?l.ResizeObserver:j}();return C})}).call(e,function(){return this}())},function(t,e,n){var r,i,o;/*! scrollbarWidth.js v0.1.0 | felixexter | MIT | https://github.com/felixexter/scrollbarWidth */
	!function(n,s){i=[],r=s,o="function"==typeof r?r.apply(e,i):r,!(void 0!==o&&(t.exports=o))}(this,function(){"use strict";function t(){var t,e=document.body,n=document.createElement("div"),r=n.style;return r.position="absolute",r.top=r.left="-9999px",r.width=r.height="100px",r.overflow="scroll",e.appendChild(n),t=n.offsetWidth-n.clientWidth,e.removeChild(n),t}return t})}])});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SRippleComponent = __webpack_require__(275);

	var _SRippleComponent2 = _interopRequireDefault(_SRippleComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SRippleComponent2.default.define('s-ripple', _SRippleComponent2.default);

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(276);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _coffeekrakenSParticlesSystemComponent = __webpack_require__(301);

	var _coffeekrakenSParticlesSystemComponent2 = _interopRequireDefault(_coffeekrakenSParticlesSystemComponent);

	var _style = __webpack_require__(361);

	var _style2 = _interopRequireDefault(_style);

	var _offset = __webpack_require__(365);

	var _offset2 = _interopRequireDefault(_offset);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SRippleComponent = function (_SWebComponent) {
		_inherits(SRippleComponent, _SWebComponent);

		function SRippleComponent() {
			_classCallCheck(this, SRippleComponent);

			return _possibleConstructorReturn(this, (SRippleComponent.__proto__ || Object.getPrototypeOf(SRippleComponent)).apply(this, arguments));
		}

		_createClass(SRippleComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   */
			value: function componentWillMount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentWillMount', this).call(this);
				this._particlesSystem = null;
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentMount', this).call(this);
				// set initial styles
				this._setInitialStyles();
				// listen for click on parent
				this.parentNode.addEventListener('click', this._onParentClick.bind(this));
				this._parentNode = this.parentNode;
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentUnmount', this).call(this);
				// do not listen for click anymore
				this._parentNode.removeEventListener('click', this._onParentClick);
			}

			/**
	   * When click on parent, trigger a ripple
	   */

		}, {
			key: '_onParentClick',
			value: function _onParentClick(e) {

				// calculate position of the emitter
				var emitterX = void 0,
				    emitterY = void 0;
				if (this.props.centered) {
					emitterX = this.offsetWith * .5;
					emitterY = this.offsetHeight * .5;
				} else {
					var elmOffset = (0, _offset2.default)(this);
					emitterX = e.pageX - elmOffset.left;
					emitterY = e.pageY - elmOffset.top;
				}

				// add a particle system
				if (!this._particlesSystem) {
					this._particlesSystem = document.createElement('s-particles-system').setProps({
						particleClass: this._componentNameDash + '__particle',
						loop: false
					});
					this.appendChild(this._particlesSystem);
				}

				// amit a particle
				this._emitRipples(emitterX, emitterY);
			}

			/**
	   * Emit ripples
	   */

		}, {
			key: '_emitRipples',
			value: function _emitRipples(emitterX, emitterY) {
				var _this2 = this;

				var current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;


				var emX = emitterX,
				    emY = emitterY;

				// handle spread
				if (this.props.spread) {
					emX += -this.props.spread + Math.round(Math.random() * (this.props.spread * 2));
					emY += -this.props.spread + Math.round(Math.random() * (this.props.spread * 2));
				}

				// set emitter position
				this._particlesSystem.setProps({
					emitterX: emX,
					emitterY: emY
				});

				// emit a particle
				this._particlesSystem.emitParticle();
				// check if need more that 1
				if (this.props.count > 1 && current < this.props.count) {
					setTimeout(function () {
						_this2._emitRipples(emitterX, emitterY, current + 1);
					}, this.props.delay);
				}
			}

			/**
	   * Set initial styles
	   */

		}, {
			key: '_setInitialStyles',
			value: function _setInitialStyles() {
				if (this.parentNode.style.position !== 'relative' || this.parentNode.style.position !== 'absolute') {
					(0, _style2.default)(this.parentNode, {
						position: 'relative'
					});
				}
				if (this.props.contains) {
					(0, _style2.default)(this, {
						overflow: 'hidden'
					});
				} else {
					(0, _style2.default)(this, {
						overflow: null
					});
				}
			}

			/**
	   * Should component update
	   */

		}, {
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate(nextProps) {
				return false;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tpointer-events : none;\n\t\t\t\tposition : absolute;\n\t\t\t\ttop : 0;\n\t\t\t\tleft : 0;\n\t\t\t\twidth : 100%;\n\t\t\t\theight : 100%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__particle {\n\t\t\t\ttop:50%; left:50%;\n\t\t\t\t-webkit-transform: translateX(-50%) translateY(-50%);\n\t\t\t\ttransform: translateX(-50%) translateY(-50%);\n\t\t\t\tposition:absolute;\n\t\t\t\twidth:150%;\n\t\t\t\tborder-radius: 50%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__particle:after {\n\t\t\t\tcontent:"";\n\t\t\t\tdisplay:block;\n\t\t\t\twidth:100%;\n\t\t\t\theight:0;\n\t\t\t\tpadding-top:100%;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   */
			get: function get() {
				return {
					/**
	     * Set if need to stay contained in the parent (overflow hidden)
	     * @prop
	     * @type 		{Boolean}
	     */
					contains: true,

					/**
	     * Set if want the ripple to be centered into his parent and not be placed where the user has clicked
	     * @prop
	     * @type 		{Boolean}
	     */
					centered: false,

					/**
	     * Set the delay between each ripples if the props.count is more that 1
	     * @prop
	     * @type 		{Number}
	     */
					delay: 130,

					/**
	     * Set the number of ripples wanted on each click
	     * @prop
	     * @type 		{Integer}
	     */
					count: 1,

					/**
	     * Set the random distance that each ripples will takes relative to the emitter position
	     * @prop
	     * @type 		{Number}
	     */
					spread: 0
				};
			}
		}]);

		return SRippleComponent;
	}(_SWebComponent3.default);

	exports.default = SRippleComponent;

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(277);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(278);

	var _SWebComponentMixin = __webpack_require__(279);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(278);

	var _autoCast = __webpack_require__(280);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(281);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(282);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(283);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(285);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(286);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(293);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(294);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(296);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(297);
	__webpack_require__(298);
	__webpack_require__(299);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 280 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 281 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 282 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(284);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(286);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(289);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(290);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(291);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(287);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(288);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 287 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(287);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 289 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 290 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(292);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 292 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 293 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(295);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 295 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(283);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(300);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 300 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SParticlesSystemComponent = __webpack_require__(302);

	var _SParticlesSystemComponent2 = _interopRequireDefault(_SParticlesSystemComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SParticlesSystemComponent2.default.define('s-particles-system', _SParticlesSystemComponent2.default);

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(303);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _coffeekrakenSParticleComponent = __webpack_require__(328);

	var _coffeekrakenSParticleComponent2 = _interopRequireDefault(_coffeekrakenSParticleComponent);

	var _getAnimationProperties = __webpack_require__(358);

	var _getAnimationProperties2 = _interopRequireDefault(_getAnimationProperties);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SParticlesSystemComponent = function (_SWebComponent) {
		_inherits(SParticlesSystemComponent, _SWebComponent);

		function SParticlesSystemComponent() {
			_classCallCheck(this, SParticlesSystemComponent);

			return _possibleConstructorReturn(this, (SParticlesSystemComponent.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent)).apply(this, arguments));
		}

		_createClass(SParticlesSystemComponent, [{
			key: 'componentMount',


			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   */
			value: function componentMount() {
				var _this2 = this;

				_get(SParticlesSystemComponent.prototype.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent.prototype), 'componentMount', this).call(this);

				// check if need to create a timer or not
				if (this.props.amount && this.props.duration) {
					this._timer = new STimer(this.props.duration / this.props.amount, {
						loop: this.props.loop
					});
					// on tick
					this._timer.onTick(function () {
						// emit a particle
						_this2.emitParticle();
					});
					if (this.props.onComplete) {
						this._timer.onComplete(this.props.onComplete);
					}
					if (this.props.active) {
						// start the timer
						this._timer.start();
					}
				}
			}

			/**
	   * Unmount component
	   * @definition 		SWebComponent.componentUnmount
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SParticlesSystemComponent.prototype.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent.prototype), 'componentUnmount', this).call(this);
				if (this._timer) {
					this._timer.destroy();
				}
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'active':
						if (!newVal) this.stop();else this.start();
						break;
				}
			}

			/**
	   * Emit a particle
	   * @return 		{HTMLElement} 		The emited particle
	   */

		}, {
			key: 'emitParticle',
			value: function emitParticle() {
				var _this3 = this;

				// append a new particle
				var particle = document.createElement('s-particle');

				// set particle position
				particle.style.top = this.props.emitterY + Math.random() * this.props.spread + 'px';
				particle.style.left = this.props.emitterX + Math.random() * this.props.spread + 'px';

				// append class if needed
				if (this.props.particleClass) {
					if (this.props.particleClass instanceof Array) {
						if (this.props.particleClassSelection === 'random') {
							particle.classList.add(this.props.particleClass[Math.round(Math.random() * (this.props.particleClass.length - 1))]);
						}
					} else {
						particle.classList.add(this.props.particleClass);
					}
				}

				// add the particle element if specified
				if (this.props.particleElm) {
					var particles = [].concat(this.props.particleElm);
					particle.appendChild(particles[Math.round(Math.random() * particles.length - 1)]);
				}

				this.mutate(function () {
					// append the new particle into the system
					_this3.appendChild(particle);
				});

				// return the emited particle
				return particle;
			}

			/**
	   * Stop the system
	   */

		}, {
			key: 'stop',
			value: function stop() {
				this._timer.stop();
			}

			/**
	   * Start the system
	   */

		}, {
			key: 'start',
			value: function start() {
				this._timer.start();
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   */
			get: function get() {
				return {
					/**
	     * Emitter x position
	     * @prop
	     * @type	{Number}
	     */
					emitterX: 0,
					/**
	     * Emitter y position
	     * @prop
	     * @type	{Number}
	     */
					emitterY: 0,
					/**
	     * Max distance where the particle will take birth from the emiter position
	     * @prop
	     * @type	{Number}
	     */
					spread: 0,
					/**
	     * Amount of particles to emit during the props.duration property
	     * @prop
	     * @type	{Integer}
	     */
					amount: 0,
					/**
	     * Duration of the particles emission
	     * @prop
	     * @type	{Number}
	     */
					duration: null,
					/**
	     * Class to apply to each particles
	     * @prop
	     * @type	{String}
	     */
					particleClass: null,
					/**
	     * Specify the method to pick a particle class if the props.particleClass is an array. Only random is supported for now
	     * @prop
	     * @type 	{String|Array<String>}
	     */
					particleClassSelection: 'random',
					/**
	     * DOM element to add into particle. If is an array, will pick a particle randomly
	     * @prop
	     * @type	{HTMLElement|Array<HTMLElement>}
	     */
					particleElm: null,
					/**
	     * Callback when the emission is completed
	     * @prop
	     * @type  	{Function}
	     */
					onComplete: null,
					/**
	     * Specify if the system if active or not
	     * @prop
	     * @type	{Boolean}
	     */
					active: true,
					/**
	     * Specify if the system hs to start again at the end automatically
	     * @prop
	     * @type 	{Boolean}
	     */
					loop: false
				};
			}
		}]);

		return SParticlesSystemComponent;
	}(_SWebComponent3.default);

	exports.default = SParticlesSystemComponent;

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(304);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(305);

	var _SWebComponentMixin = __webpack_require__(306);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(305);

	var _autoCast = __webpack_require__(307);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(308);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(309);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(310);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(312);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(313);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(320);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(321);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(323);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(324);
	__webpack_require__(325);
	__webpack_require__(326);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 307 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 308 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 309 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(311);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(313);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(316);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(317);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(318);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(314);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(315);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 314 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(314);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 316 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 317 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(319);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 319 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 320 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(322);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 322 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(310);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(327);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 327 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SParticleComponent = __webpack_require__(329);

	var _SParticleComponent2 = _interopRequireDefault(_SParticleComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SParticleComponent2.default.define('s-particle', _SParticleComponent2.default);

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(330);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _getAnimationProperties = __webpack_require__(355);

	var _getAnimationProperties2 = _interopRequireDefault(_getAnimationProperties);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SParticleComponent = function (_SWebComponent) {
		_inherits(SParticleComponent, _SWebComponent);

		function SParticleComponent() {
			_classCallCheck(this, SParticleComponent);

			return _possibleConstructorReturn(this, (SParticleComponent.__proto__ || Object.getPrototypeOf(SParticleComponent)).apply(this, arguments));
		}

		_createClass(SParticleComponent, [{
			key: 'componentMount',


			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   */
			value: function componentMount() {
				var _this2 = this;

				_get(SParticleComponent.prototype.__proto__ || Object.getPrototypeOf(SParticleComponent.prototype), 'componentMount', this).call(this);

				var lifetime = this.props.lifetime;
				if (!lifetime) {
					// get the animation properties
					var animation = (0, _getAnimationProperties2.default)(this);
					lifetime = animation.totalDuration;
				}

				// wait till the animation is finished to remove the particle from DOM
				setTimeout(function () {
					if (_this2.parentNode) {
						_this2.parentNode.removeChild(_this2);
					}
				}, lifetime);
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   */
			get: function get() {
				return {
					/**
	     * Specify the particle lifetime. It not specified, will be auto-detected from his animation.
	     */
					lifetime: null
				};
			}
		}]);

		return SParticleComponent;
	}(_SWebComponent3.default);

	exports.default = SParticleComponent;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(331);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(332);

	var _SWebComponentMixin = __webpack_require__(333);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(332);

	var _autoCast = __webpack_require__(334);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(335);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(336);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(337);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(339);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(340);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(347);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(348);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(350);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(351);
	__webpack_require__(352);
	__webpack_require__(353);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 334 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 335 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 336 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(338);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(340);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(343);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(344);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(345);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(341);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(342);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 341 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(341);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 343 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 344 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(346);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 346 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 347 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(349);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 349 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(337);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(354);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 354 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = getAnimationProperties;

	var _getStyleProperty = __webpack_require__(356);

	var _getStyleProperty2 = _interopRequireDefault(_getStyleProperty);

	var _toMs = __webpack_require__(357);

	var _toMs2 = _interopRequireDefault(_toMs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get the css animation properties from an HTMLElement in an object format
	 *
	 * @name 		getAnimationProperties
	 * @param 		{HTMLElement} 					elm  		The element to get the properties from
	 * @return 		{Object} 									The animation properties
	 *
	 * @example  	js
	 * import getAnimationProperties from 'sugarcss/js/dom/getAnimationProperties'
	 * const props = getAnimationProperties(myCoolHTMLElement);
	 * // output format
	 * // {
	 * // 	name : ['animation1'],
	 * // 	duration : [200],
	 * // 	delay : [0],
	 * // 	timingFunction : ['linear'],
	 * // 	iterationCount : [1],
	 * // 	direction : ['forward'],
	 * // 	totalDuration : 200
	 * // }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	function splitIfNeeded(what, separator) {
		if (what.indexOf(separator) !== -1) {
			return what.split(separator).map(function (item) {
				return item.trim();
			});
		}
		return what;
	}
	function getAnimationProperties(elm) {
		// get the animation properties
		var name = (0, _getStyleProperty2.default)(elm, 'animation-name') || '';
		var duration = (0, _getStyleProperty2.default)(elm, 'animation-duration') || '0s';
		var timingFunction = (0, _getStyleProperty2.default)(elm, 'animation-timing-function') || 'linear';
		var delay = (0, _getStyleProperty2.default)(elm, 'animation-delay') || '0s';
		var iterationCount = (0, _getStyleProperty2.default)(elm, 'animation-iteration-count') || 1;
		var direction = (0, _getStyleProperty2.default)(elm, 'animation-direction') || 'normal';

		// return the animation object
		var props = {
			name: name.split(','),
			duration: duration.split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			delay: ('' + delay).split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			timingFunction: timingFunction.split(','),
			iterationCount: ('' + iterationCount).split(','),
			direction: direction.split(',')
		};
		var totalDuration = 0;
		var i = 0;
		var delays = [0].concat(props.delay);
		[0].concat(props.duration).forEach(function (val) {
			if (val + delays[i] > totalDuration) {
				totalDuration = val + delays[i];
			}
		});
		props.totalDuration = totalDuration;
		return props;
	}

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getStyleProperty;

	var _camelize = __webpack_require__(335);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _autoCast = __webpack_require__(334);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get a style property on the passed element through the computed style.
	 * This function try to store the actual style to not trigger more that 1 redraw
	 * each js execution loop.
	 *
	 * @name 		getStyleProperty
	 * @param 		{HTMLElement} 					elm  		The element to get style from
	 * @param 		{String} 						property 	The css property to get
	 * @return 		{Mixed} 									The style value
	 *
	 * @example  	js
	 * import getStyleProperty from 'sugarcss/js/dom/getStyleProperty'
	 * const opacity = getStyleProperty(myCoolHTMLElement, 'opacity');
	 *
	 * @see 		https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function getStyleProperty(elm, property) {

	  // caching mecanisme
	  setTimeout(function () {
	    elm._sComputedStyle = null;
	  });

	  var computed = elm._sComputedStyle || window.getComputedStyle(elm);
	  elm._sComputedStyle = computed;

	  var prefixes = ['', 'webkit-', 'moz-', 'ms-', 'o-', 'khtml-'];
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var value = computed[(0, _camelize2.default)('' + prefix + property)];
	    if (value && value.trim() !== '') return (0, _autoCast2.default)(value);
	  }
	  return null;
	}

/***/ },
/* 357 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = toMs;
	function toMs(string) {
		// parse the string to int to get the lenght of the suffix
		// if (string.substr(0,1) === '.') string = '0${string}';
		var value = parseFloat(string);
		var valueLength = ('' + value).length;
		var suffix = string.substr(valueLength);
		// switch on suffix
		switch (suffix) {
			case 'ms':
				// milisecond
				return value;
				break;
			case 's': // seconds
			default:
				return value * 1000;
				break;
		}
	}

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = getAnimationProperties;

	var _getStyleProperty = __webpack_require__(359);

	var _getStyleProperty2 = _interopRequireDefault(_getStyleProperty);

	var _toMs = __webpack_require__(360);

	var _toMs2 = _interopRequireDefault(_toMs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get the css animation properties from an HTMLElement in an object format
	 *
	 * @name 		getAnimationProperties
	 * @param 		{HTMLElement} 					elm  		The element to get the properties from
	 * @return 		{Object} 									The animation properties
	 *
	 * @example  	js
	 * import getAnimationProperties from 'sugarcss/js/dom/getAnimationProperties'
	 * const props = getAnimationProperties(myCoolHTMLElement);
	 * // output format
	 * // {
	 * // 	name : ['animation1'],
	 * // 	duration : [200],
	 * // 	delay : [0],
	 * // 	timingFunction : ['linear'],
	 * // 	iterationCount : [1],
	 * // 	direction : ['forward'],
	 * // 	totalDuration : 200
	 * // }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	function splitIfNeeded(what, separator) {
		if (what.indexOf(separator) !== -1) {
			return what.split(separator).map(function (item) {
				return item.trim();
			});
		}
		return what;
	}
	function getAnimationProperties(elm) {
		// get the animation properties
		var name = (0, _getStyleProperty2.default)(elm, 'animation-name') || '';
		var duration = (0, _getStyleProperty2.default)(elm, 'animation-duration') || '0s';
		var timingFunction = (0, _getStyleProperty2.default)(elm, 'animation-timing-function') || 'linear';
		var delay = (0, _getStyleProperty2.default)(elm, 'animation-delay') || '0s';
		var iterationCount = (0, _getStyleProperty2.default)(elm, 'animation-iteration-count') || 1;
		var direction = (0, _getStyleProperty2.default)(elm, 'animation-direction') || 'normal';

		// return the animation object
		var props = {
			name: name.split(','),
			duration: duration.split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			delay: ('' + delay).split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			timingFunction: timingFunction.split(','),
			iterationCount: ('' + iterationCount).split(','),
			direction: direction.split(',')
		};
		var totalDuration = 0;
		var i = 0;
		var delays = [0].concat(props.delay);
		[0].concat(props.duration).forEach(function (val) {
			if (val + delays[i] > totalDuration) {
				totalDuration = val + delays[i];
			}
		});
		props.totalDuration = totalDuration;
		return props;
	}

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getStyleProperty;

	var _camelize = __webpack_require__(308);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _autoCast = __webpack_require__(307);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get a style property on the passed element through the computed style.
	 * This function try to store the actual style to not trigger more that 1 redraw
	 * each js execution loop.
	 *
	 * @name 		getStyleProperty
	 * @param 		{HTMLElement} 					elm  		The element to get style from
	 * @param 		{String} 						property 	The css property to get
	 * @return 		{Mixed} 									The style value
	 *
	 * @example  	js
	 * import getStyleProperty from 'sugarcss/js/dom/getStyleProperty'
	 * const opacity = getStyleProperty(myCoolHTMLElement, 'opacity');
	 *
	 * @see 		https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function getStyleProperty(elm, property) {

	  // caching mecanisme
	  setTimeout(function () {
	    elm._sComputedStyle = null;
	  });

	  var computed = elm._sComputedStyle || window.getComputedStyle(elm);
	  elm._sComputedStyle = computed;

	  var prefixes = ['', 'webkit-', 'moz-', 'ms-', 'o-', 'khtml-'];
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var value = computed[(0, _camelize2.default)('' + prefix + property)];
	    if (value && value.trim() !== '') return (0, _autoCast2.default)(value);
	  }
	  return null;
	}

/***/ },
/* 360 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = toMs;
	function toMs(string) {
		// parse the string to int to get the lenght of the suffix
		// if (string.substr(0,1) === '.') string = '0${string}';
		var value = parseFloat(string);
		var valueLength = ('' + value).length;
		var suffix = string.substr(valueLength);
		// switch on suffix
		switch (suffix) {
			case 'ms':
				// milisecond
				return value;
				break;
			case 's': // seconds
			default:
				return value * 1000;
				break;
		}
	}

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = style;

	var _uncamelize = __webpack_require__(362);

	var _uncamelize2 = _interopRequireDefault(_uncamelize);

	var _styleString2Object = __webpack_require__(363);

	var _styleString2Object2 = _interopRequireDefault(_styleString2Object);

	var _styleObject2String = __webpack_require__(364);

	var _styleObject2String2 = _interopRequireDefault(_styleObject2String);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Set or remove a css style property on an HTMLElement
	 *
	 * @name 		style
	 * @param 		{HTMLElement} 			elm 			The element to process
	 * @param 		{Object} 				styleObj 		An object of style to apply
	 * @return 		(Object) 								The element applied style
	 *
	 * @example 	js
	 * import style from 'sugarcss/js/dom/style'
	 * style(myCoolHTMLElement, {
	 * 		paddingLeft : 20,
	 * 		display : null
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	window.sugar._styles = new Map();

	function style(elm, styleObj) {

	  // convert style string to object
	  var styleAttr = elm.getAttribute('style');

	  if (styleAttr) {
	    styleObj = _extends({}, (0, _styleString2Object2.default)(styleAttr), styleObj);
	  }

	  // apply the style to the element
	  // elm.setAttribute('style', __styleObject2String(current.styleObj));
	  elm.style.cssText = (0, _styleObject2String2.default)(styleObj);

	  // return the style
	  return elm.style;
	}

/***/ },
/* 362 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = uncamelize;
	/**
	 * Uncamelize a string
	 */
	function uncamelize(text) {
		var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';

		// Replace all capital letters by separator followed by lowercase one
		var res = '';
		res = text.replace(/[A-Z]/g, function (letter) {
			return separator + letter.toLowerCase();
		});

		// Remove first separator (to avoid _hello_world name)
		return res.replace("/^" + separator + "/", '').trim();
	}

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = styleString2Object;

	var _camelize = __webpack_require__(281);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _autoCast = __webpack_require__(280);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Transform a style string to an object representation
	 *
	 * @name 		styleString2Object
	 * @param 		{String} 				style 			The style string
	 * @return 		(Object) 								The string object representation
	 *
	 * @example 	js
	 * import styleString2Object from 'sugarcss/js/dom/styleString2Object'
	 * const styleString = styleString2Object('padding-left:20px; display:block;');
	 * // output => {
	 * //		paddingLeft : '20px',
	 * // 		display : 'block'
	 * // }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function styleString2Object(style) {
	  if (!style || style === '') return {};
	  var obj = {};
	  var split = style.replace(/\s/g, '').split(';');
	  split.forEach(function (statement) {
	    // split statement by key value pairs
	    var spl = statement.split(':'),
	        key = (0, _camelize2.default)(spl[0]),
	        value = spl[1];
	    // add element into object
	    obj[key] = (0, _autoCast2.default)(value);
	  });
	  // return the style object
	  return obj;
	}

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = styleObject2String;

	var _uncamelize = __webpack_require__(362);

	var _uncamelize2 = _interopRequireDefault(_uncamelize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Transform a style object to inline string separated by ;
	 *
	 * @name 		styleObject2String
	 * @param 		{Object} 				styleObj 		An object of style to apply
	 * @return 		(String) 								The string style representation
	 *
	 * @example 	js
	 * import styleObject2String from 'sugarcss/js/dom/styleObject2String'
	 * const styleString = styleObject2String({
	 * 		paddingLeft : '20px',
	 * 		display : 'block'
	 * });
	 * // output => padding-left:20px; display:block;
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function styleObject2String(styleObj) {
	  // process the style object
	  var propertiesArray = [];
	  for (var key in styleObj) {
	    var value = styleObj[key];
	    // if the value is ''
	    // mean that we need to get rid of
	    if (value === undefined || value === '') {
	      delete styleObj[key];
	    } else {
	      propertiesArray.push((0, _uncamelize2.default)(key) + ':' + value + ';');
	    }
	  }
	  // return the css text
	  return propertiesArray.join(' ');
	}

/***/ },
/* 365 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = offset;
	// import __getTranslateProperties from './getTranslateProperties'

	/**
	 * Get the offset top and left of the passed element from the document top left point
	 *
	 * @name 		offset
	 * @param 		{HTMLElement} 					elm  		The element to get the offset from
	 * @return 		{Object} 									The offset top and left object
	 *
	 * @example  	js
	 * import offset from 'sugarcss/js/dom/offset'
	 * const offsetElm = offset(myCoolElement);
	 * // output : { top : 200, left : 300 }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function offset(elm) {
		var body = void 0,
		    box = void 0,
		    clientLeft = void 0,
		    clientTop = void 0,
		    docEl = void 0,
		    left = void 0,
		    scrollLeft = void 0,
		    scrollTop = void 0,
		    top = void 0,
		    translates = void 0,
		    transX = void 0,
		    transY = void 0;
		box = elm.getBoundingClientRect();
		body = document.body;
		docEl = document.documentElement;
		scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
		scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
		clientTop = docEl.clientTop || body.clientTop || 0;
		clientLeft = docEl.clientLeft || body.clientLeft || 0;
		// translates = __getTranslateProperties(elm);
		// transX = translates.x;
		// transY = translates.y;
		top = box.top + scrollTop - clientTop;
		left = box.left + scrollLeft - clientLeft;
		return {
			top: Math.round(top),
			left: Math.round(left)
		};
	}

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SEqualizeComponent = __webpack_require__(367);

	var _SEqualizeComponent2 = _interopRequireDefault(_SEqualizeComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SEqualizeComponent2.default.define('s-equalize', _SEqualizeComponent2.default);

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(368);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _dispatchEvent = __webpack_require__(375);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _offset = __webpack_require__(393);

	var _offset2 = _interopRequireDefault(_offset);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 	SEqualizeComponent
	 * @extends 	SWebComponent
	 * Simply made some equal height columns.
	 *
	 * @example 	html
	 * <div style="overflow:hidden">
	 * 	<div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 1</h4>
	 *  	<p>Integer congue a nibh sed elementum. Mauris ligula sem, scelerisque.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * <div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 2</h4>
	 *  	<p>Donec scelerisque eu felis sit amet sodales. Nam sit amet lacus purus. Aliquam rutrum facilisis velit non egestas. Maecenas condimentum condimentum eleifend. Ut sed massa tempus, pellentesque orci id, facilisis dolor. Integer ac ligula convallis, egestas sem ut, luctus purus.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * </div>
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	/**
	 * @name 			Equalize
	 * Simply made some equal height columns.
	 * @styleguide  	Layout / Equalize
	 * @example 		html
	 * <div style="overflow:hidden">
	 * <div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 1</h4>
	 *  	<p>Integer congue a nibh sed elementum. Mauris ligula sem, scelerisque.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * <div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 2</h4>
	 *  	<p>Donec scelerisque eu felis sit amet sodales. Nam sit amet lacus purus. Aliquam rutrum facilisis velit non egestas. Maecenas condimentum condimentum eleifend. Ut sed massa tempus, pellentesque orci id, facilisis dolor. Integer ac ligula convallis, egestas sem ut, luctus purus.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * </div>
	 * @see 			https://github.com/Coffeekraken/s-google-map-component/tree/release/{version}
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SEqualizeComponent = function (_SWebComponent) {
		_inherits(SEqualizeComponent, _SWebComponent);

		function SEqualizeComponent() {
			_classCallCheck(this, SEqualizeComponent);

			return _possibleConstructorReturn(this, (SEqualizeComponent.__proto__ || Object.getPrototypeOf(SEqualizeComponent)).apply(this, arguments));
		}

		_createClass(SEqualizeComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				var _this2 = this;

				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'componentMount', this).call(this);

				if (!SEqualizeComponent._groups[this.props.group]) {
					SEqualizeComponent._groups[this.props.group] = {
						refreshLinesInProgress: false,
						elements: [],
						lines: []
					};
				}
				SEqualizeComponent._groups[this.props.group].elements = document.querySelectorAll(this._componentNameDash + '[group="' + this.props.group + '"]');

				// init lines
				this.lines = [];

				// refresh lines first time
				this.refreshLines();

				// equalize
				this.equalize();

				// listen for resizing window
				var resizeWindowTimeout = void 0;
				window.addEventListener('resize', function (e) {
					clearTimeout(resizeWindowTimeout);
					resizeWindowTimeout = setTimeout(function () {
						_this2.equalize();
					}, _this2.props.resizeTimeout);
				});
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Return the equalizer HTMLElement if exist
	   * @return 	{HTMLElement} 		The equalizer HTMLElement
	   */

		}, {
			key: 'refreshLines',


			/**
	   * Refresh the lines values
	   */
			value: function refreshLines() {
				var _this3 = this;

				if (SEqualizeComponent._groups[this.props.group].refreshLinesInProgress) return;
				SEqualizeComponent._groups[this.props.group].refreshLinesInProgress = true;
				setTimeout(function () {
					SEqualizeComponent._groups[_this3.props.group].refreshLinesInProgress = false;
				}, 100);
				// loop on all the columns
				var offsetTop = void 0;
				this.lines = [];
				var line = {
					inProgress: false,
					height: 0,
					elements: []
				};
				[].forEach.call(SEqualizeComponent._groups[this.props.group].elements, function (elm) {

					// reset the equalizer or element min-height
					// to get the real height of the element
					if (elm.equalizerElm) {
						elm.equalizerElm.style.minHeight = 0;
					} else {
						elm.style.minHeight = 0;
					}

					var elmHeight = elm.offsetHeight;
					var elmOffset = (0, _offset2.default)(elm);

					// check if is on new line
					if (offsetTop !== elmOffset.top && line.height > 0) {
						// add the new line to lines stack
						_this3.lines.push(line);
						// reset the line
						line = {
							inProgress: false,
							height: 0,
							elements: []
						};
					}
					// add the element in the line
					line.elements.push(elm);
					// check if the element is higher that the highest of the line
					if (elmHeight > line.height) {
						line.height = elmHeight;
					}
					// save the new offset
					offsetTop = elmOffset.top;
				});

				// add the last line
				this.lines.push(line);

				// save the lins in static stack
				SEqualizeComponent._groups[this.props.group].lines = this.lines;
			}

			/**
	   * Get the line object from an HTMLElement
	   * @param 		{HTMLElement} 		elm 		The element to get the line from
	   * @return 		{Object} 		The line object
	   */

		}, {
			key: 'getLineFromElm',
			value: function getLineFromElm(elm) {
				// loop on lines
				for (var key in SEqualizeComponent._groups[this.props.group].lines) {
					var line = SEqualizeComponent._groups[this.props.group].lines[key];
					if (line.elements.indexOf(elm) !== -1) return line;
				}
				return null;
			}

			/**
	   * Equalize the passed line
	   * @param 		{Object} 		line 		The line object to equalize the elements from
	   */

		}, {
			key: 'equalizeLine',
			value: function equalizeLine(line) {

				// do nothing if the line is already in progress
				if (line.inProgress) return;
				// flag the line as inProgress
				line.inProgress = true;

				// refresh lines
				// don't worry, it will not do the work
				// every time it is called but only 1 by group every 100ms
				this.refreshLines();

				setTimeout(function () {
					// loop on each columns
					[].forEach.call(line.elements, function (element) {
						element.classList.add('clear-transmations');
						// reset the equalizer or element min-height
						// to get the real height of the element
						if (element.equalizerElm) {
							element.equalizerElm.style.minHeight = 0;
						} else {
							element.style.minHeight = 0;
						}
					});
					// loop on each columns
					[].forEach.call(line.elements, function (element) {
						// check if an equalizer exist to use it
						// @TODO : find a way to not query each time in the column for the equalizer
						// reset the equalizer or element min-height
						// to get the real height of the element
						if (element.equalizerElm) {
							element.equalizerElm.style.display = 'block';
							element.equalizerElm.style.minHeight = line.height - element.offsetHeight + 'px';
						} else {
							element.style.minHeight = line.height + 'px';
						}
					});
					[].forEach.call(line.elements, function (element) {
						element.classList.remove('clear-transmations');
					});
					// reset the line progress status
					line.inProgress = false;
				});
			}

			/**
	   * Equalize from an element or a line object
	   * @param 		{HTMLElement|Object} 		[elmOrLine=null] 		An HTMLElement that belong to a line or directly a line object
	   */

		}, {
			key: 'equalize',
			value: function equalize() {
				var _this4 = this;

				var elmOrLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

				// if we have an element passed
				if (elmOrLine && elmOrLine.tagName) {
					// equalize from an element
					var line = this.getLineFromElm(elmOrLine);
					if (!line) return;
					this.equalizeLine(line);
				} else if (elmOrLine && elmOrLine.elements) {
					// equalize a line directly
					this.equalizeLine(elmOrLine);
				} else {
					// equalize the whole set
					SEqualizeComponent._groups[this.props.group].lines.forEach(function (line) {
						// equalize line
						_this4.equalizeLine(line);
					});
				}
				setTimeout(function () {
					(0, _dispatchEvent2.default)(_this4, 'update:height');
				});
			}
		}, {
			key: 'equalizerElm',
			get: function get() {
				if (this._equalizerElmCache) return this._equalizerElmCache;
				this._equalizerElmCache = this.querySelector(this._componentNameDash + '-equalizer');
				return this._equalizerElmCache;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay : block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Specify the group name that the equalize element belong to
	     * @prop
	     * @type 	{String}
	     */
					group: null,

					/**
	     * Specify the timeout to wait before resize again after a window resizeTimeout
	     * @prop
	     * @type 	{Number}
	     */
					resizeTimeout: 200
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */


			/**
	   * Store the groups
	   * @type	{Object}
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return ['group'];
			}
		}]);

		return SEqualizeComponent;
	}(_SWebComponent3.default);

	SEqualizeComponent._groups = {};
	exports.default = SEqualizeComponent;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(369);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(370);

	var _SWebComponentMixin = __webpack_require__(371);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(370);

	var _autoCast = __webpack_require__(372);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(373);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(374);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(375);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(377);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(378);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(385);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(386);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(388);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(389);
	__webpack_require__(390);
	__webpack_require__(391);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 372 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 373 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 374 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(376);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(378);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(381);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(382);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(383);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(379);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(380);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 379 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(379);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 381 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 382 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(384);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 384 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 385 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(387);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 387 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(375);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(392);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 392 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 393 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = offset;
	// import __getTranslateProperties from './getTranslateProperties'

	/**
	 * Get the offset top and left of the passed element from the document top left point
	 *
	 * @name 		offset
	 * @param 		{HTMLElement} 					elm  		The element to get the offset from
	 * @return 		{Object} 									The offset top and left object
	 *
	 * @example  	js
	 * import offset from 'sugarcss/js/dom/offset'
	 * const offsetElm = offset(myCoolElement);
	 * // output : { top : 200, left : 300 }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function offset(elm) {
		var body = void 0,
		    box = void 0,
		    clientLeft = void 0,
		    clientTop = void 0,
		    docEl = void 0,
		    left = void 0,
		    scrollLeft = void 0,
		    scrollTop = void 0,
		    top = void 0,
		    translates = void 0,
		    transX = void 0,
		    transY = void 0;
		box = elm.getBoundingClientRect();
		body = document.body;
		docEl = document.documentElement;
		scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
		scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
		clientTop = docEl.clientTop || body.clientTop || 0;
		clientLeft = docEl.clientLeft || body.clientLeft || 0;
		// translates = __getTranslateProperties(elm);
		// transX = translates.x;
		// transY = translates.y;
		top = box.top + scrollTop - clientTop;
		left = box.left + scrollLeft - clientLeft;
		return {
			top: Math.round(top),
			left: Math.round(left)
		};
	}

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SShareComponent = __webpack_require__(395);

	var _SShareComponent2 = _interopRequireDefault(_SShareComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SShareComponent2.default.define('s-share', _SShareComponent2.default, 'a');

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SAnchorWebComponent2 = __webpack_require__(396);

	var _SAnchorWebComponent3 = _interopRequireDefault(_SAnchorWebComponent2);

	var _sharerNpm = __webpack_require__(421);

	var _sharerNpm2 = _interopRequireDefault(_sharerNpm);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 	SShareComponent
	 * @extends 	SAnchorWebComponent
	 * Easily create some share buttons to target facebook, twitter, linkedin, google+, etc...
	 *
	 * @example 	html
	 * <a is="s-share" href="#" platform="facebook" title="Share on facebook">
	 * 	Share on facebook
	 * </a>
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	/**
	 * @name 			Share
	 * Easily create some share buttons to target facebook, twitter, linkedin, google+, etc...
	 * @styleguide  	Objects / Share
	 *
	 * @example 		html
	 * <a is="s-share" href="#" platform="facebook" title="Share on facebook">
	 * 	Share on facebook
	 * </a>
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SShareComponent = function (_SAnchorWebComponent) {
		_inherits(SShareComponent, _SAnchorWebComponent);

		function SShareComponent() {
			_classCallCheck(this, SShareComponent);

			return _possibleConstructorReturn(this, (SShareComponent.__proto__ || Object.getPrototypeOf(SShareComponent)).apply(this, arguments));
		}

		_createClass(SShareComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentMount', this).call(this);

				// list all attributes available for each platforms
				this._platformAttrs = {
					twitter: ['title', 'url', 'hashtags', 'via'],
					facebook: ['url'],
					linkedin: ['url'],
					googleplus: ['url'],
					email: ['title', 'url', 'to', 'subject'],
					whatsapp: ['title', 'url'],
					telegram: ['title', 'url'],
					viber: ['title', 'url'],
					pinterest: ['url', 'image', 'description'],
					tumblr: ['url', 'title', 'caption', 'tags'],
					hackernews: ['url', 'title'],
					reddit: ['url'],
					vk: ['url', 'title', 'image', 'caption'],
					buffer: ['url', 'title', 'via', 'picture'],
					xing: ['url', 'title'],
					line: ['url', 'title'],
					instapaper: ['url', 'title', 'description'],
					pocket: ['url'],
					digg: ['url'],
					stumbleupon: ['title', 'url'],
					flipboard: ['title', 'url'],
					weibo: ['url', 'title', 'image', 'apikey', 'relateui'],
					renren: ['url'],
					myspace: ['url', 'title', 'description'],
					blogger: ['url', 'title', 'description'],
					baidu: ['url', 'title'],
					okru: ['url', 'title']
				};

				// listen for click on the element
				this.addEventListener('click', this._onClick.bind(this));
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Get default share attributes
	   * @param 		{String} 		attr 		The attribute name to process
	   * @return 		{String} 					The default attribute
	   */

		}, {
			key: '_getDefaultShareAttriute',
			value: function _getDefaultShareAttriute(attr) {
				switch (attr) {
					case 'title':
					case 'subject':
					case 'caption':
						return document.title;
						break;
					case 'description':
						var descElm = document.querySelector('meta[name="description"]');
						if (descElm && descElm.content) return descElm.content;
						break;
					case 'url':
						var href = this.getAttribute('href');
						return href && href !== '#' ? href : document.location.href;
						break;
				}
				return null;
			}

			/**
	   * Handle click
	   * @param 		{Event} 		e 		The click event
	   */

		}, {
			key: '_onClick',
			value: function _onClick(e) {
				var _this2 = this;

				e.preventDefault();
				// loop on platform attributes
				if (!this._platformAttrs[this.props.platform]) return;
				this.setAttribute('data-sharer', this.props.platform);
				this._platformAttrs[this.props.platform].forEach(function (attr) {
					if (_this2.hasAttribute('data-' + attr)) return;
					var val = _this2.props[attr];
					if (!val) {
						val = _this2._getDefaultShareAttriute(attr);
					}
					if (val) {
						_this2.setAttribute('data-' + attr, val);
					}
				});

				// create a new sharer
				var sharer = new _sharerNpm2.default(this);
				sharer.share();
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay : block;\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * On which platform to share the content
	     * @prop
	     * @type 		{String}
	     */
					platform: null,

					/**
	     * Set the title to share
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					title: null,

					/**
	     * Set the url to share
	     * @prop
	     * @type 		{String}
	     * @default 	document.location.href
	     */
					url: null,

					/**
	     * Set a username to tweet through without @
	     * @prop
	     * @type 		{String}
	     */
					via: null,

					/**
	     * Set some hashtags to add to tweet comma separated without #
	     * @prop
	     * @type 		{String}
	     */
					hashtags: null,

					/**
	     * Set an email address to share to
	     * @prop
	     * @type 		{String}
	     */
					to: null,

					/**
	     * Set the email subject
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					subject: null,

					/**
	     * Set the absolute image url to share through (pinterest,vk,weibo)
	     * @prop
	     * @type 		{String}
	     */
					image: null,

					/**
	     * Set the description to share (pinterest,instapaper,myspace,blogger,)
	     * @prop
	     * @type 		{String}
	     * @default 	meta[description]
	     */
					description: null,

					/**
	     * Set the caption to share (tumblr,vk)
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					caption: null,

					/**
	     * Set the tags to share comma separated (tumblr)
	     * @prop
	     * @type 		{String}
	     */
					tags: null
				};
			}

			/**
	   * Required props
	   * @definition 		SWebComponent.requiredProps
	   * @protected
	   */

		}, {
			key: 'requiredProps',
			get: function get() {
				return ['platform'];
			}
		}]);

		return SShareComponent;
	}(_SAnchorWebComponent3.default);

	exports.default = SShareComponent;

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(397);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SAnchorWebComponent = function (_native) {
	  _inherits(SAnchorWebComponent, _native);

	  function SAnchorWebComponent() {
	    _classCallCheck(this, SAnchorWebComponent);

	    return _possibleConstructorReturn(this, (SAnchorWebComponent.__proto__ || Object.getPrototypeOf(SAnchorWebComponent)).apply(this, arguments));
	  }

	  return SAnchorWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLAnchorElement));

	exports.default = SAnchorWebComponent;

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(398);

	var _SWebComponentMixin = __webpack_require__(399);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(398);

	var _autoCast = __webpack_require__(400);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(401);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(402);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(403);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(405);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(406);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(413);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(414);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(416);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(417);
	__webpack_require__(418);
	__webpack_require__(419);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 400 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 401 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 402 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(404);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(406);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(409);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(410);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(411);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(407);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(408);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 407 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(407);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 409 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 410 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(412);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 412 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 413 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(415);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 415 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(403);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(420);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 420 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 421 */
/***/ function(module, exports) {

	/**
	 * @preserve
	 * Sharer.js
	 *
	 * @description Create your own social share buttons
	 * @version 0.2.12
	 * @author Ellison Leao <ellisonleao@gmail.com>
	 * @license GPLv3
	 *
	 */

	/**
	 * @constructor
	 */
	var Sharer = function(elem) {
	    this.elem = elem;
	};

	Sharer.prototype = {
	    /**
	     *  @function getValue
	     *  @description Helper to get the attribute of a DOM element
	     *  @param {String} attr DOM element attribute
	     *  @returns {String|Empty} returns the attr value or empty string
	     */
	    getValue: function(attr) {
	        var val = this.elem.getAttribute('data-' + attr);
	        return (val === undefined || val === null) ? false : val;
	    },

	    /**
	     * @event share
	     * @description Main share event. Will pop a window or redirect to a link
	     * based on the data-sharer attribute.
	     */
	    share: function() {
	        var sharer = this.getValue('sharer').toLowerCase(),
	            sharers = {
	                facebook: {
	                    shareUrl: 'https://www.facebook.com/sharer/sharer.php',
	                    params: {u: this.getValue('url')}
	                },
	                googleplus: {
	                    shareUrl: 'https://plus.google.com/share',
	                    params: {url: this.getValue('url')}
	                },
	                linkedin: {
	                    shareUrl: 'https://www.linkedin.com/shareArticle',
	                    params: {
	                        url: this.getValue('url'),
	                        mini: true
	                    }
	                },
	                twitter: {
	                    shareUrl: 'https://twitter.com/intent/tweet/',
	                    params: {
	                        text: this.getValue('title'),
	                        url: this.getValue('url'),
	                        hashtags: this.getValue('hashtags'),
	                        via: this.getValue('via')
	                    }
	                },
	                email: {
	                    shareUrl: 'mailto:' + this.getValue('to'),
	                    params: {
	                        subject: this.getValue('subject'),
	                        body: this.getValue('title') + '\n' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                whatsapp: {
	                    shareUrl: 'whatsapp://send',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                telegram: {
	                    shareUrl: 'tg://msg_url',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                viber: {
	                    shareUrl: 'viber://forward',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                line: {
	                    shareUrl: 'http://line.me/R/msg/text/?' + encodeURIComponent(this.getValue('title') + ' ' + this.getValue('url')),
	                    isLink: true
	                },
	                pinterest: {
	                    shareUrl: 'https://www.pinterest.com/pin/create/button/',
	                    params: {url: this.getValue('url')}
	                },
	                tumblr: {
	                    shareUrl: 'http://tumblr.com/widgets/share/tool',
	                    params: {
	                        canonicalUrl: this.getValue('url'),
	                        content: this.getValue('url'),
	                        posttype: 'link',
	                        title: this.getValue('title'),
	                        caption: this.getValue('caption'),
	                        tags: this.getValue('tags')
	                    }
	                },
	                hackernews: {
	                    shareUrl: 'https://news.ycombinator.com/submitlink',
	                    params: {
	                        u: this.getValue('url'),
	                        t: this.getValue('title')
	                    }
	                },
	                reddit: {
	                    shareUrl: 'https://www.reddit.com/submit',
	                    params: {'url': this.getValue('url')}
	                },
	                vk: {
	                    shareUrl: 'http://vk.com/share.php',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        description: this.getValue('caption'),
	                        image: this.getValue('image')
	                    }
	                },
	                xing: {
	                    shareUrl: 'https://www.xing.com/app/user',
	                    params: {
	                        'op': 'share',
	                        'url': this.getValue('url'),
	                        'title': this.getValue('title')
	                    }
	                },
	                buffer: {
	                    shareUrl: 'https://buffer.com/add',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        via: this.getValue('via'),
	                        picture: this.getValue('picture')
	                    }
	                },
	                instapaper: {
	                    shareUrl: 'http://www.instapaper.com/edit',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        description: this.getValue('description')
	                    }
	                },
	                pocket: {
	                    shareUrl: 'https://getpocket.com/save',
	                    params: {
	                        url: this.getValue('url')
	                    }
	                },
	                digg: {
	                    shareUrl: 'http://www.digg.com/submit',
	                    params: {
	                        url: this.getValue('url')
	                    }
	                },
	                stumbleupon: {
	                    shareUrl: 'http://www.stumbleupon.com/submit',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title')
	                    }
	                },
	                flipboard: {
	                    shareUrl: 'https://share.flipboard.com/bookmarklet/popout',
	                    params: {
	                        v: 2,
	                        title: this.getValue('title'),
	                        url: this.getValue('url'),
	                        t: Date.now()
	                    }
	                },
	                weibo: {
	                    shareUrl: 'http://service.weibo.com/share/share.php',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        language: 'zh_cn'
	                    }
	                },
	                renren: {
	                    shareUrl: 'http://share.renren.com/share/buttonshare',
	                    params: {
	                        link: this.getValue('url')
	                    }
	                },
	                myspace: {
	                    shareUrl: 'https://myspace.com/post',
	                    params: {
	                        u: this.getValue('url'),
	                        t: this.getValue('title'),
	                        c: this.getValue('description')
	                    }
	                },
	                blogger: {
	                    shareUrl: 'https://www.blogger.com/blog-this.g',
	                    params: {
	                        u: this.getValue('url'),
	                        n: this.getValue('title'),
	                        t: this.getValue('description')
	                    }
	                },
	                baidu: {
	                    shareUrl: 'http://cang.baidu.com/do/add',
	                    params: {
	                        it: this.getValue('title'),
	                        iu: this.getValue('url')
	                    }
	                },
	                hatenabookmark: {
	                    shareUrl: 'http://b.hatena.ne.jp/entry/' + this.getValue('url'),
	                }
	            },
	            s = sharers[sharer];

	        // custom popups sizes
	        if (s) {
	            s.width = this.getValue('width');
	            s.height = this.getValue('height');
	        }
	        return s !== undefined ? this.urlSharer(s) : false;
	    },
	    /**
	     * @event urlSharer
	     * @param {Object} sharer
	     */
	    urlSharer: function(sharer) {
	        var p = sharer.params || {},
	            keys = Object.keys(p),
	            i,
	            str = keys.length > 0 ? '?' : '';
	        for (i = 0; i < keys.length; i++) {
	            if (str !== '?') {
	                str += '&';
	            }
	            if (p[keys[i]]) {
	                str += keys[i] + '=' + encodeURIComponent(p[keys[i]]);
	            }
	        }
	        sharer.shareUrl += str;

	        if (!sharer.isLink) {
	            var popWidth = sharer.width || 600,
	                popHeight = sharer.height || 480,
	                left = window.innerWidth / 2 - popWidth / 2 + window.screenX,
	                top = window.innerHeight / 2 - popHeight / 2 + window.screenY,
	                popParams = 'scrollbars=no, width=' + popWidth + ', height=' + popHeight + ', top=' + top + ', left=' + left,
	                newWindow = window.open(sharer.shareUrl, '', popParams);

	            if (window.focus) {
	                newWindow.focus();
	            }
	        } else {
	            window.location.href = sharer.shareUrl;
	        }
	    }
	};

	module.exports = Sharer;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _BodymovinComponent = __webpack_require__(423);

	var _BodymovinComponent2 = _interopRequireDefault(_BodymovinComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _BodymovinComponent2.default.define('s-bodymovin', _BodymovinComponent2.default);

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(424);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _bodymovin = __webpack_require__(449);

	var _bodymovin2 = _interopRequireDefault(_bodymovin);

	var _whenProperty = __webpack_require__(450);

	var _whenProperty2 = _interopRequireDefault(_whenProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SBodymivinComponent
	 * @extends 	SWebComponent
	 * Simple webcomponent wrapper around the freaking cool bodymovin library.
	 * Features:
	 * - All bodymovin capabilities
	 * - Use it as an image tag ```<s-bodymovin src="..."></s-bodymovin>```
	 * - Support a reactive mode that play the animation when a special class is detected
	 * - Cool "yoyo" mode that will play the animation backward when complete
	 *
	 * @example 	html
	 * <s-bodymovin src="my-cool-animation.json" yoyo></s-bodymovin>
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SBodymovinComponent = function (_SWebComponent) {
		_inherits(SBodymovinComponent, _SWebComponent);

		function SBodymovinComponent() {
			_classCallCheck(this, SBodymovinComponent);

			return _possibleConstructorReturn(this, (SBodymovinComponent.__proto__ || Object.getPrototypeOf(SBodymovinComponent)).apply(this, arguments));
		}

		_createClass(SBodymovinComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SBodymovinComponent.prototype.__proto__ || Object.getPrototypeOf(SBodymovinComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				var _this2 = this;

				_get(SBodymovinComponent.prototype.__proto__ || Object.getPrototypeOf(SBodymovinComponent.prototype), 'componentMount', this).call(this);

				// init bodymovin
				this.bodymovin = _bodymovin2.default.loadAnimation(_extends({}, this.props, {
					container: this,
					loop: !this.props.yoyo ? this.props.loop : false,
					path: this.props.path || this.props.src
				}));
				this.bodymovin.setDirection(this.props.direction);
				this.bodymovin.setSpeed(this.props.speed);

				// add the loading class
				this.classList.add(this.props.loadingClass);

				// when is ready
				(0, _whenProperty2.default)(this.bodymovin, 'isLoaded', function (value) {
					return value === true;
				}).then(function (property) {
					setTimeout(function () {
						_this2._onAnimationReady();
					});
				});

				// bodymovin proxy
				this._exposeBodymovinFn(['play', 'stop', 'pause', 'setSpeed', 'goToAndPlay', 'goToAndStop', 'setDirection', 'playSegments']);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'speed':
						this.bodymovin.setSpeed(newVal);
						break;
					case 'direction':
						this.bodymovin.setDirection(newVal);
						break;
					case 'class':
						newVal = typeof newVal !== 'string' ? '' : newVal;
						oldVal = typeof oldVal !== 'string' ? '' : oldVal;
						// check reactiveClass<
						if (this.props.reactive) {
							var classes = newVal.split(' ');
							var oldClasses = oldVal.split(' ');
							if (classes.indexOf(this.props.reactiveClass) === -1 && oldClasses.indexOf(this.props.reactiveClass) !== -1) {
								if (this.props.reactiveBackward) {
									// play back
									this.bodymovin.setDirection(-1);
									this.bodymovin.goToAndPlay(this.bodymovin.totalFrames, true);
								} else {
									// goto frame 0 without playing
									this.bodymovin.goToAndStop(0, true);
								}
							} else if (classes.indexOf(this.props.reactiveClass) !== -1 && oldClasses.indexOf(this.props.reactiveClass) === -1) {
								// play forward if needed
								this.bodymovin.setDirection(1);
								this.bodymovin.goToAndPlay(0, true);
							}
						}
						break;
				}
			}

			/**
	   * Actual real init method that will be fired when the bodymovin animation is ready
	   */

		}, {
			key: '_onAnimationReady',
			value: function _onAnimationReady() {
				var _this3 = this;

				console.log('body', this.bodymovin);

				// remove the loading class
				this.classList.remove(this.props.loadingClass);

				// reactiveClass
				if (this.props.reactive && this.classList.contains(this.props.reactiveClass)) {
					this.bodymovin.goToAndStop(this.bodymovin.totalFrames, true);
				}

				// check the play on prop
				if (this.props.playOn) {
					this.addEventListener(this.props.playOn, function (e) {
						_this3.bodymovin.goToAndPlay(0, true);
					});
				}

				// handle yoyo
				if (this.props.yoyo) {
					this.bodymovin.addEventListener('complete', function (e) {
						if (_this3.bodymovin.currentFrame <= 0) {
							_this3.bodymovin.setSpeed(_this3.props.speed);
							_this3.bodymovin.setDirection(1);
						} else {
							setTimeout(function () {
								_this3.bodymovin.setSpeed(_this3.props.yoyoSpeed);
								_this3.bodymovin.setDirection(-1);
							}, _this3.props.yoyoTimeout);
						}
						if (_this3.props.loop || _this3.bodymovin.currentFrame > 0) {
							_this3.bodymovin.play();
						}
					});
				}

				// this.props.queuePoints = {
				// 	0 : 'one',
				// 	35 : 'two',
				// 	52 : 'three'
				// }
				//
				// if (this.props.queuePoints) {
				//
				// 	this.bodymovin.addEventListener('enterFrame', (e) => {
				// 		console.log('enterframe', e);
				// 		if (this.__bodymovinPlayTimeout) return
				// 		if (this.props.queuePoints[Math.round(e.currentTime)]) {
				// 			console.log('seg');
				// 			this.bodymovin.pause();
				// 		}
				//
				// 	});
				// }
			}

			/**
	   * Expose some bodymovin functions on the component iutlself
	   */

		}, {
			key: '_exposeBodymovinFn',
			value: function _exposeBodymovinFn(fns) {
				var _this4 = this;

				// loop on each functions to expose
				fns.forEach(function (fn) {
					_this4[fn] = function () {
						this.bodymovin[fn].apply(this.bodymovin, arguments);
					};
				});
			}

			/**
	   * Heres the list of bodymovin methods that are exposed on the component itself:
	   * - play()
	   * - pause()
	   * - stop()
	   * - setSpeed(speed)
	   * - setDirection(direction)
	   * - goToAndPlay(timeOrFrame, isFrame)
	   * - goToAndStop(timeOrFeame, isFrame)
	   * - playSegments(segments)
	   */

		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay : inline-block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {

					/**
	     * Bodymovin animation data object
	     * @prop
	     * @type 	{object}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					animationData: null,

					/**
	     * Bodymovin json animation relative path
	     * @prop
	     * @type 	{String}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					path: null,

					/**
	     * Alias to the "path" prop
	     * @prop
	     * @type 	{String}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					src: null,

					/**
	     * Set if the animation has to loop or not
	     * @prop
	     * @type 	{Boolean}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					loop: false,

					/**
	     * Set if the animation has to autoplay or not
	     * @prop
	     * @type 	{Boolean}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					autoplay: false,

					/**
	     * Specify the direction of the animation
	     * @prop
	     * @type 	{Integer}
	     * @see		https://github.com/bodymovin/bodymovin
	     */
					direction: 1,

					/**
	     * Set the playback speed
	     * @prop
	     * @type 	{Number}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					speed: 1,

					/**
	     * Set a name to the animation to get it later through the bodymovin api
	     * @prop
	     * @type 	{String}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					name: null,

					/**
	     * Set the renderer to use
	     * @prop
	     * @type 	{String}
	     * @see 	https://github.com/bodymovin/bodymovin
	     */
					renderer: 'svg',

					/**
	     * Specify when to play the animation
	     * @prop
	     * @type 	{String}
	     */
					playOn: null,

					/**
	     * Specify if we want the animation to react to a class change
	     * @prop
	     * @type 	{Boolean}
	     */
					reactive: false,

					/**
	     * Specify the class that the bodymovin will react to
	     * @prop
	     * @type	{String}
	     */
					reactiveClass: 'active',

					/**
	     * Specify if the animation has to take place when the reactive class is removed.
	     * If false, the animation will simply jump to start when the class is removed.
	     * @prop
	     * @type 	{Boolean}
	     */
					reactiveBackward: false,

					/**
	     * Specify if the animation has to play backward when arrived to the end. Like a yoyo
	     * @prop
	     * @type 	{Boolean}
	     */
					yoyo: false,

					/**
	     * Specify the speed for the yoyo backward animation
	     * @prop
	     * @type 	{Number}
	     */
					yoyoSpeed: 1,

					/**
	     * Specify how many time to wait before playing the animation back to his starting point
	     * @prop
	     * @type 	{Number}
	     */
					yoyoTimeout: 0,

					/**
	     * Specify the laoding class to set on the element before the animation is ready to play
	     * @prop
	     * @type 	{String}
	     */
					loadingClass: 'loading',

					/**
	     * Listen for classes changes
	     * @protected
	     */
					class: null

				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SBodymovinComponent;
	}(_SWebComponent3.default);

	exports.default = SBodymovinComponent;

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(425);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(426);

	var _SWebComponentMixin = __webpack_require__(427);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(426);

	var _autoCast = __webpack_require__(428);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(429);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(430);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(431);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(433);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(434);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(441);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(442);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(444);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(445);
	__webpack_require__(446);
	__webpack_require__(447);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 428 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 429 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 430 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(432);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(434);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(437);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(438);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(439);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(435);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(436);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 435 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(435);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 437 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 438 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(440);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 440 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 441 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(443);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 443 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(431);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(448);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 448 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if(true) { !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } else if(typeof module === "object" && module.exports) { module.exports = factory(); } else { root.bodymovin = factory(); } }(window, function() {var svgNS = "http://www.w3.org/2000/svg";
	var subframeEnabled = true;
	var expressionsPlugin;
	var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	var cachedColors = {};
	var bm_rounder = Math.round;
	var bm_rnd;
	var bm_pow = Math.pow;
	var bm_sqrt = Math.sqrt;
	var bm_abs = Math.abs;
	var bm_floor = Math.floor;
	var bm_max = Math.max;
	var bm_min = Math.min;
	var blitter = 10;

	var BMMath = {};
	(function(){
	    var propertyNames = Object.getOwnPropertyNames(Math);
	    var i, len = propertyNames.length;
	    for(i=0;i<len;i+=1){
	        BMMath[propertyNames[i]] = Math[propertyNames[i]];
	    }
	}());

	function ProjectInterface(){return {}};

	BMMath.random = Math.random;
	BMMath.abs = function(val){
	    var tOfVal = typeof val;
	    if(tOfVal === 'object' && val.length){
	        var absArr = Array.apply(null,{length:val.length});
	        var i, len = val.length;
	        for(i=0;i<len;i+=1){
	            absArr[i] = Math.abs(val[i]);
	        }
	        return absArr;
	    }
	    return Math.abs(val);

	}
	var defaultCurveSegments = 150;
	var degToRads = Math.PI/180;
	var roundCorner = 0.5519;

	function roundValues(flag){
	    if(flag){
	        bm_rnd = Math.round;
	    }else{
	        bm_rnd = function(val){
	            return val;
	        };
	    }
	}
	roundValues(false);

	function roundTo2Decimals(val){
	    return Math.round(val*10000)/10000;
	}

	function roundTo3Decimals(val){
	    return Math.round(val*100)/100;
	}

	function styleDiv(element){
	    element.style.position = 'absolute';
	    element.style.top = 0;
	    element.style.left = 0;
	    element.style.display = 'block';
	    element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';
	    element.style.backfaceVisibility  = element.style.webkitBackfaceVisibility = 'visible';
	    element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = "preserve-3d";
	}

	function styleUnselectableDiv(element){
	    element.style.userSelect = 'none';
	    element.style.MozUserSelect = 'none';
	    element.style.webkitUserSelect = 'none';
	    element.style.oUserSelect = 'none';

	}

	function BMEnterFrameEvent(n,c,t,d){
	    this.type = n;
	    this.currentTime = c;
	    this.totalTime = t;
	    this.direction = d < 0 ? -1:1;
	}

	function BMCompleteEvent(n,d){
	    this.type = n;
	    this.direction = d < 0 ? -1:1;
	}

	function BMCompleteLoopEvent(n,c,t,d){
	    this.type = n;
	    this.currentLoop = c;
	    this.totalLoops = t;
	    this.direction = d < 0 ? -1:1;
	}

	function BMSegmentStartEvent(n,f,t){
	    this.type = n;
	    this.firstFrame = f;
	    this.totalFrames = t;
	}

	function BMDestroyEvent(n,t){
	    this.type = n;
	    this.target = t;
	}

	function _addEventListener(eventName, callback){

	    if (!this._cbs[eventName]){
	        this._cbs[eventName] = [];
	    }
	    this._cbs[eventName].push(callback);

	}

	function _removeEventListener(eventName,callback){

	    if (!callback){
	        this._cbs[eventName] = null;
	    }else if(this._cbs[eventName]){
	        var i = 0, len = this._cbs[eventName].length;
	        while(i<len){
	            if(this._cbs[eventName][i] === callback){
	                this._cbs[eventName].splice(i,1);
	                i -=1;
	                len -= 1;
	            }
	            i += 1;
	        }
	        if(!this._cbs[eventName].length){
	            this._cbs[eventName] = null;
	        }
	    }

	}

	function _triggerEvent(eventName, args){
	    if (this._cbs[eventName]) {
	        var len = this._cbs[eventName].length;
	        for (var i = 0; i < len; i++){
	            this._cbs[eventName][i](args);
	        }
	    }
	}

	function randomString(length, chars){
	    if(chars === undefined){
	        chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
	    }
	    var i;
	    var result = '';
	    for (i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];
	    return result;
	}

	function HSVtoRGB(h, s, v) {
	    var r, g, b, i, f, p, q, t;
	    if (arguments.length === 1) {
	        s = h.s, v = h.v, h = h.h;
	    }
	    i = Math.floor(h * 6);
	    f = h * 6 - i;
	    p = v * (1 - s);
	    q = v * (1 - f * s);
	    t = v * (1 - (1 - f) * s);
	    switch (i % 6) {
	        case 0: r = v, g = t, b = p; break;
	        case 1: r = q, g = v, b = p; break;
	        case 2: r = p, g = v, b = t; break;
	        case 3: r = p, g = q, b = v; break;
	        case 4: r = t, g = p, b = v; break;
	        case 5: r = v, g = p, b = q; break;
	    }
	    return [ r,
	        g,
	         b ];
	}

	function RGBtoHSV(r, g, b) {
	    if (arguments.length === 1) {
	        g = r.g, b = r.b, r = r.r;
	    }
	    var max = Math.max(r, g, b), min = Math.min(r, g, b),
	        d = max - min,
	        h,
	        s = (max === 0 ? 0 : d / max),
	        v = max / 255;

	    switch (max) {
	        case min: h = 0; break;
	        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
	        case g: h = (b - r) + d * 2; h /= 6 * d; break;
	        case b: h = (r - g) + d * 4; h /= 6 * d; break;
	    }

	    return [
	         h,
	         s,
	         v
	    ];
	}

	function addSaturationToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[1] += offset;
	    if (hsv[1] > 1) {
	        hsv[1] = 1;
	    }
	    else if (hsv[1] <= 0) {
	        hsv[1] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function addBrightnessToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[2] += offset;
	    if (hsv[2] > 1) {
	        hsv[2] = 1;
	    }
	    else if (hsv[2] < 0) {
	        hsv[2] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function addHueToRGB(color,offset) {
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[0] += offset/360;
	    if (hsv[0] > 1) {
	        hsv[0] -= 1;
	    }
	    else if (hsv[0] < 0) {
	        hsv[0] += 1;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function componentToHex(c) {
	    var hex = c.toString(16);
	    return hex.length == 1 ? '0' + hex : hex;
	}

	var rgbToHex = (function(){
	    var colorMap = [];
	    var i;
	    var hex;
	    for(i=0;i<256;i+=1){
	        hex = i.toString(16);
	        colorMap[i] = hex.length == 1 ? '0' + hex : hex;
	    }

	    return function(r, g, b) {
	        if(r<0){
	            r = 0;
	        }
	        if(g<0){
	            g = 0;
	        }
	        if(b<0){
	            b = 0;
	        }
	        return '#' + colorMap[r] + colorMap[g] + colorMap[b];
	    };
	}());

	function fillToRgba(hex,alpha){
	    if(!cachedColors[hex]){
	        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	        cachedColors[hex] = parseInt(result[1], 16)+','+parseInt(result[2], 16)+','+parseInt(result[3], 16);
	    }
	    return 'rgba('+cachedColors[hex]+','+alpha+')';
	}

	var fillColorToString = (function(){

	    var colorMap = [];
	    return function(colorArr,alpha){
	        if(alpha !== undefined){
	            colorArr[3] = alpha;
	        }
	        if(!colorMap[colorArr[0]]){
	            colorMap[colorArr[0]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]]){
	            colorMap[colorArr[0]][colorArr[1]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]][colorArr[2]]){
	            colorMap[colorArr[0]][colorArr[1]][colorArr[2]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]]){
	            colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]] = 'rgba(' + colorArr.join(',')+')';
	        }
	        return colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]];
	    };
	}());

	function RenderedFrame(tr,o) {
	    this.tr = tr;
	    this.o = o;
	}

	function LetterProps(o,sw,sc,fc,m,p){
	    this.o = o;
	    this.sw = sw;
	    this.sc = sc;
	    this.fc = fc;
	    this.m = m;
	    this.props = p;
	}

	function iterateDynamicProperties(num){
	    var i, len = this.dynamicProperties;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue(num);
	    }
	}

	function reversePath(paths){
	    var newI = [], newO = [], newV = [];
	    var i, len, newPaths = {};
	    var init = 0;
	    if (paths.c) {
	        newI[0] = paths.o[0];
	        newO[0] = paths.i[0];
	        newV[0] = paths.v[0];
	        init = 1;
	    }
	    len = paths.i.length;
	    var cnt = len - 1;

	    for (i = init; i < len; i += 1) {
	        newI.push(paths.o[cnt]);
	        newO.push(paths.i[cnt]);
	        newV.push(paths.v[cnt]);
	        cnt -= 1;
	    }

	    newPaths.i = newI;
	    newPaths.o = newO;
	    newPaths.v = newV;

	    return newPaths;
	}
	/*!
	 Transformation Matrix v2.0
	 (c) Epistemex 2014-2015
	 www.epistemex.com
	 By Ken Fyrstenberg
	 Contributions by leeoniya.
	 License: MIT, header required.
	 */

	/**
	 * 2D transformation matrix object initialized with identity matrix.
	 *
	 * The matrix can synchronize a canvas context by supplying the context
	 * as an argument, or later apply current absolute transform to an
	 * existing context.
	 *
	 * All values are handled as floating point values.
	 *
	 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
	 * @prop {number} a - scale x
	 * @prop {number} b - shear y
	 * @prop {number} c - shear x
	 * @prop {number} d - scale y
	 * @prop {number} e - translate x
	 * @prop {number} f - translate y
	 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
	 * @constructor
	 */

	var Matrix = (function(){

	    function reset(){
	        this.props[0] = 1;
	        this.props[1] = 0;
	        this.props[2] = 0;
	        this.props[3] = 0;
	        this.props[4] = 0;
	        this.props[5] = 1;
	        this.props[6] = 0;
	        this.props[7] = 0;
	        this.props[8] = 0;
	        this.props[9] = 0;
	        this.props[10] = 1;
	        this.props[11] = 0;
	        this.props[12] = 0;
	        this.props[13] = 0;
	        this.props[14] = 0;
	        this.props[15] = 1;
	        return this;
	    }

	    function rotate(angle) {
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateX(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(1, 0, 0, 0
	            , 0, mCos, -mSin, 0
	            , 0, mSin,  mCos, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateY(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos,  0,  mSin, 0
	            , 0, 1, 0, 0
	            , -mSin,  0,  mCos, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateZ(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	    }

	    function shear(sx,sy){
	        return this._t(1, sy, sx, 1, 0, 0);
	    }

	    function skew(ax, ay){
	        return this.shear(Math.tan(ax), Math.tan(ay));
	    }

	    function skewFromAxis(ax, angle){
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, mSin,  0, 0
	            , -mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1)
	            ._t(1, 0,  0, 0
	            , Math.tan(ax),  1, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1)
	            ._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	        //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, Math.tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
	    }

	    function scale(sx, sy, sz) {
	        sz = isNaN(sz) ? 1 : sz;
	        if(sx == 1 && sy == 1 && sz == 1){
	            return this;
	        }
	        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
	    }

	    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
	        this.props[0] = a;
	        this.props[1] = b;
	        this.props[2] = c;
	        this.props[3] = d;
	        this.props[4] = e;
	        this.props[5] = f;
	        this.props[6] = g;
	        this.props[7] = h;
	        this.props[8] = i;
	        this.props[9] = j;
	        this.props[10] = k;
	        this.props[11] = l;
	        this.props[12] = m;
	        this.props[13] = n;
	        this.props[14] = o;
	        this.props[15] = p;
	        return this;
	    }

	    function translate(tx, ty, tz) {
	        tz = tz || 0;
	        if(tx !== 0 || ty !== 0 || tz !== 0){
	            return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);
	        }
	        return this;
	    }

	    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {

	        if(a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0){
	            if(m2 !== 0 || n2 !== 0 || o2 !== 0){

	                this.props[12] = this.props[12] * a2 + this.props[13] * e2 + this.props[14] * i2 + this.props[15] * m2 ;
	                this.props[13] = this.props[12] * b2 + this.props[13] * f2 + this.props[14] * j2 + this.props[15] * n2 ;
	                this.props[14] = this.props[12] * c2 + this.props[13] * g2 + this.props[14] * k2 + this.props[15] * o2 ;
	                this.props[15] = this.props[12] * d2 + this.props[13] * h2 + this.props[14] * l2 + this.props[15] * p2 ;
	            }
	            return this;
	        }

	        var a1 = this.props[0];
	        var b1 = this.props[1];
	        var c1 = this.props[2];
	        var d1 = this.props[3];
	        var e1 = this.props[4];
	        var f1 = this.props[5];
	        var g1 = this.props[6];
	        var h1 = this.props[7];
	        var i1 = this.props[8];
	        var j1 = this.props[9];
	        var k1 = this.props[10];
	        var l1 = this.props[11];
	        var m1 = this.props[12];
	        var n1 = this.props[13];
	        var o1 = this.props[14];
	        var p1 = this.props[15];

	        /* matrix order (canvas compatible):
	         * ace
	         * bdf
	         * 001
	         */
	        this.props[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
	        this.props[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2 ;
	        this.props[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2 ;
	        this.props[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2 ;

	        this.props[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2 ;
	        this.props[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2 ;
	        this.props[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2 ;
	        this.props[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2 ;

	        this.props[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2 ;
	        this.props[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2 ;
	        this.props[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2 ;
	        this.props[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2 ;

	        this.props[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2 ;
	        this.props[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2 ;
	        this.props[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2 ;
	        this.props[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2 ;

	        return this;
	    }

	    function clone(matr){
	        var i;
	        for(i=0;i<16;i+=1){
	            matr.props[i] = this.props[i];
	        }
	    }

	    function cloneFromProps(props){
	        var i;
	        for(i=0;i<16;i+=1){
	            this.props[i] = props[i];
	        }
	    }

	    function applyToPoint(x, y, z) {

	        return {
	            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
	            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
	            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
	        };
	        /*return {
	         x: x * me.a + y * me.c + me.e,
	         y: x * me.b + y * me.d + me.f
	         };*/
	    }
	    function applyToX(x, y, z) {
	        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
	    }
	    function applyToY(x, y, z) {
	        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
	    }
	    function applyToZ(x, y, z) {
	        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
	    }

	    function inversePoints(pts){
	        //var determinant = this.a * this.d - this.b * this.c;
	        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
	        var a = this.props[5]/determinant;
	        var b = - this.props[1]/determinant;
	        var c = - this.props[4]/determinant;
	        var d = this.props[0]/determinant;
	        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12])/determinant;
	        var f = - (this.props[0] * this.props[13] - this.props[1] * this.props[12])/determinant;
	        var i, len = pts.length, retPts = [];
	        for(i=0;i<len;i+=1){
	            retPts[i] = [pts[i][0] * a + pts[i][1] * c + e, pts[i][0] * b + pts[i][1] * d + f, 0]
	        }
	        return retPts;
	    }

	    function applyToPointArray(x,y,z,dimensions){
	        if(dimensions && dimensions === 2) {
	            var arr = point_pool.newPoint();
	            arr[0] = x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12]; 
	            arr[1] = x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13]; 
	            return arr;    
	        }
	        return [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
	    }
	    function applyToPointStringified(x, y) {
	        return (bm_rnd(x * this.props[0] + y * this.props[4] + this.props[12]))+','+(bm_rnd(x * this.props[1] + y * this.props[5] + this.props[13]));
	    }

	    function toArray() {
	        return [this.props[0],this.props[1],this.props[2],this.props[3],this.props[4],this.props[5],this.props[6],this.props[7],this.props[8],this.props[9],this.props[10],this.props[11],this.props[12],this.props[13],this.props[14],this.props[15]];
	    }

	    function toCSS() {
	        if(isSafari){
	            return "matrix3d(" + roundTo2Decimals(this.props[0]) + ',' + roundTo2Decimals(this.props[1]) + ',' + roundTo2Decimals(this.props[2]) + ',' + roundTo2Decimals(this.props[3]) + ',' + roundTo2Decimals(this.props[4]) + ',' + roundTo2Decimals(this.props[5]) + ',' + roundTo2Decimals(this.props[6]) + ',' + roundTo2Decimals(this.props[7]) + ',' + roundTo2Decimals(this.props[8]) + ',' + roundTo2Decimals(this.props[9]) + ',' + roundTo2Decimals(this.props[10]) + ',' + roundTo2Decimals(this.props[11]) + ',' + roundTo2Decimals(this.props[12]) + ',' + roundTo2Decimals(this.props[13]) + ',' + roundTo2Decimals(this.props[14]) + ',' + roundTo2Decimals(this.props[15]) + ')';
	        } else {
	            this.cssParts[1] = this.props.join(',');
	            return this.cssParts.join('');
	        }
	    }

	    function to2dCSS() {
	        return "matrix(" + this.props[0] + ',' + this.props[1] + ',' + this.props[4] + ',' + this.props[5] + ',' + this.props[12] + ',' + this.props[13] + ")";
	    }

	    function toString() {
	        return "" + this.toArray();
	    }

	    return function(){
	        this.reset = reset;
	        this.rotate = rotate;
	        this.rotateX = rotateX;
	        this.rotateY = rotateY;
	        this.rotateZ = rotateZ;
	        this.skew = skew;
	        this.skewFromAxis = skewFromAxis;
	        this.shear = shear;
	        this.scale = scale;
	        this.setTransform = setTransform;
	        this.translate = translate;
	        this.transform = transform;
	        this.applyToPoint = applyToPoint;
	        this.applyToX = applyToX;
	        this.applyToY = applyToY;
	        this.applyToZ = applyToZ;
	        this.applyToPointArray = applyToPointArray;
	        this.applyToPointStringified = applyToPointStringified;
	        this.toArray = toArray;
	        this.toCSS = toCSS;
	        this.to2dCSS = to2dCSS;
	        this.toString = toString;
	        this.clone = clone;
	        this.cloneFromProps = cloneFromProps;
	        this.inversePoints = inversePoints;
	        this._t = this.transform;

	        this.props = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];

	        this.cssParts = ['matrix3d(','',')'];
	    }
	}());

	function Matrix() {


	}

	/*
	 Copyright 2014 David Bau.

	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:

	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	 */

	(function (pool, math) {
	//
	// The following constants are related to IEEE 754 limits.
	//
	    var global = this,
	        width = 256,        // each RC4 output is 0 <= x < 256
	        chunks = 6,         // at least six RC4 outputs for each double
	        digits = 52,        // there are 52 significant digits in a double
	        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
	        startdenom = math.pow(width, chunks),
	        significance = math.pow(2, digits),
	        overflow = significance * 2,
	        mask = width - 1,
	        nodecrypto;         // node.js crypto module, initialized at the bottom.

	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	    function seedrandom(seed, options, callback) {
	        var key = [];
	        options = (options == true) ? { entropy: true } : (options || {});

	        // Flatten the seed string or build one from local entropy if needed.
	        var shortseed = mixkey(flatten(
	            options.entropy ? [seed, tostring(pool)] :
	                (seed == null) ? autoseed() : seed, 3), key);

	        // Use the seed to initialize an ARC4 generator.
	        var arc4 = new ARC4(key);

	        // This function returns a random double in [0, 1) that contains
	        // randomness in every bit of the mantissa of the IEEE 754 value.
	        var prng = function() {
	            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
	                d = startdenom,                 //   and denominator d = 2 ^ 48.
	                x = 0;                          //   and no 'extra last byte'.
	            while (n < significance) {          // Fill up all significant digits by
	                n = (n + x) * width;              //   shifting numerator and
	                d *= width;                       //   denominator and generating a
	                x = arc4.g(1);                    //   new least-significant-byte.
	            }
	            while (n >= overflow) {             // To avoid rounding up, before adding
	                n /= 2;                           //   last byte, shift everything
	                d /= 2;                           //   right using integer math until
	                x >>>= 1;                         //   we have exactly the desired bits.
	            }
	            return (n + x) / d;                 // Form the number within [0, 1).
	        };

	        prng.int32 = function() { return arc4.g(4) | 0; }
	        prng.quick = function() { return arc4.g(4) / 0x100000000; }
	        prng.double = prng;

	        // Mix the randomness into accumulated entropy.
	        mixkey(tostring(arc4.S), pool);

	        // Calling convention: what to return as a function of prng, seed, is_math.
	        return (options.pass || callback ||
	        function(prng, seed, is_math_call, state) {
	            if (state) {
	                // Load the arc4 state from the given state if it has an S array.
	                if (state.S) { copy(state, arc4); }
	                // Only provide the .state method if requested via options.state.
	                prng.state = function() { return copy(arc4, {}); }
	            }

	            // If called as a method of Math (Math.seedrandom()), mutate
	            // Math.random because that is how seedrandom.js has worked since v1.0.
	            if (is_math_call) { math[rngname] = prng; return seed; }

	            // Otherwise, it is a newer calling convention, so return the
	            // prng directly.
	            else return prng;
	        })(
	            prng,
	            shortseed,
	            'global' in options ? options.global : (this == math),
	            options.state);
	    }
	    math['seed' + rngname] = seedrandom;

	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	    function ARC4(key) {
	        var t, keylen = key.length,
	            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	        // The empty key [] is treated as [0].
	        if (!keylen) { key = [keylen++]; }

	        // Set up S using the standard key scheduling algorithm.
	        while (i < width) {
	            s[i] = i++;
	        }
	        for (i = 0; i < width; i++) {
	            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
	            s[j] = t;
	        }

	        // The "g" method returns the next (count) outputs as one number.
	        (me.g = function(count) {
	            // Using instance members instead of closure state nearly doubles speed.
	            var t, r = 0,
	                i = me.i, j = me.j, s = me.S;
	            while (count--) {
	                t = s[i = mask & (i + 1)];
	                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
	            }
	            me.i = i; me.j = j;
	            return r;
	            // For robust unpredictability, the function call below automatically
	            // discards an initial batch of values.  This is called RC4-drop[256].
	            // See http://google.com/search?q=rsa+fluhrer+response&btnI
	        })(width);
	    }

	//
	// copy()
	// Copies internal state of ARC4 to or from a plain object.
	//
	    function copy(f, t) {
	        t.i = f.i;
	        t.j = f.j;
	        t.S = f.S.slice();
	        return t;
	    };

	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	    function flatten(obj, depth) {
	        var result = [], typ = (typeof obj), prop;
	        if (depth && typ == 'object') {
	            for (prop in obj) {
	                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	            }
	        }
	        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
	    }

	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	    function mixkey(seed, key) {
	        var stringseed = seed + '', smear, j = 0;
	        while (j < stringseed.length) {
	            key[mask & j] =
	                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	        }
	        return tostring(key);
	    }

	//
	// autoseed()
	// Returns an object for autoseeding, using window.crypto and Node crypto
	// module if available.
	//
	    function autoseed() {
	        try {
	            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
	            var out = new Uint8Array(width);
	            (global.crypto || global.msCrypto).getRandomValues(out);
	            return tostring(out);
	        } catch (e) {
	            var browser = global.navigator,
	                plugins = browser && browser.plugins;
	            return [+new Date, global, plugins, global.screen, tostring(pool)];
	        }
	    }

	//
	// tostring()
	// Converts an array of charcodes to a string
	//
	    function tostring(a) {
	        return String.fromCharCode.apply(0, a);
	    }

	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to interfere with deterministic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	    mixkey(math.random(), pool);

	//
	// Nodejs and AMD support: export the implementation as a module using
	// either convention.
	//

	// End anonymous scope, and pass initial values.
	})(
	    [],     // pool: entropy pool starts empty
	    BMMath    // math: package containing random, pow, and seedrandom
	);
	var BezierFactory = (function(){
	    /**
	     * BezierEasing - use bezier curve for transition easing function
	     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	     *
	     * Credits: is based on Firefox's nsSMILKeySpline.cpp
	     * Usage:
	     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
	     * spline.get(x) => returns the easing value | x must be in [0, 1] range
	     *
	     */

	        var ob = {};
	    ob.getBezierEasing = getBezierEasing;
	    var beziers = {};

	    function getBezierEasing(a,b,c,d,nm){
	        var str = nm || ('bez_' + a+'_'+b+'_'+c+'_'+d).replace(/\./g, 'p');
	        if(beziers[str]){
	            return beziers[str];
	        }
	        var bezEasing = new BezierEasing([a,b,c,d]);
	        beziers[str] = bezEasing;
	        return bezEasing;
	    }

	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	    var NEWTON_ITERATIONS = 4;
	    var NEWTON_MIN_SLOPE = 0.001;
	    var SUBDIVISION_PRECISION = 0.0000001;
	    var SUBDIVISION_MAX_ITERATIONS = 10;

	    var kSplineTableSize = 11;
	    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	    var float32ArraySupported = typeof Float32Array === "function";

	    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	    function C (aA1)      { return 3.0 * aA1; }

	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	    function calcBezier (aT, aA1, aA2) {
	        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
	    }

	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	    function getSlope (aT, aA1, aA2) {
	        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	    }

	    function binarySubdivide (aX, aA, aB, mX1, mX2) {
	        var currentX, currentT, i = 0;
	        do {
	            currentT = aA + (aB - aA) / 2.0;
	            currentX = calcBezier(currentT, mX1, mX2) - aX;
	            if (currentX > 0.0) {
	                aB = currentT;
	            } else {
	                aA = currentT;
	            }
	        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	        return currentT;
	    }

	    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
	        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	            var currentSlope = getSlope(aGuessT, mX1, mX2);
	            if (currentSlope === 0.0) return aGuessT;
	            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	            aGuessT -= currentX / currentSlope;
	        }
	        return aGuessT;
	    }

	    /**
	     * points is an array of [ mX1, mY1, mX2, mY2 ]
	     */
	    function BezierEasing (points) {
	        this._p = points;
	        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	        this._precomputed = false;

	        this.get = this.get.bind(this);
	    }

	    BezierEasing.prototype = {

	        get: function (x) {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            if (!this._precomputed) this._precompute();
	            if (mX1 === mY1 && mX2 === mY2) return x; // linear
	            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	            if (x === 0) return 0;
	            if (x === 1) return 1;
	            return calcBezier(this._getTForX(x), mY1, mY2);
	        },

	        // Private part

	        _precompute: function () {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            this._precomputed = true;
	            if (mX1 !== mY1 || mX2 !== mY2)
	                this._calcSampleValues();
	        },

	        _calcSampleValues: function () {
	            var mX1 = this._p[0],
	                mX2 = this._p[2];
	            for (var i = 0; i < kSplineTableSize; ++i) {
	                this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	            }
	        },

	        /**
	         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
	         */
	        _getTForX: function (aX) {
	            var mX1 = this._p[0],
	                mX2 = this._p[2],
	                mSampleValues = this._mSampleValues;

	            var intervalStart = 0.0;
	            var currentSample = 1;
	            var lastSample = kSplineTableSize - 1;

	            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
	                intervalStart += kSampleStepSize;
	            }
	            --currentSample;

	            // Interpolate to provide an initial guess for t
	            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
	            var guessForT = intervalStart + dist * kSampleStepSize;

	            var initialSlope = getSlope(guessForT, mX1, mX2);
	            if (initialSlope >= NEWTON_MIN_SLOPE) {
	                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	            } else if (initialSlope === 0.0) {
	                return guessForT;
	            } else {
	                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	            }
	        }
	    };

	    return ob;

	}())


	function matrixManagerFunction(){

	    var mat = new Matrix();

	    var returnMatrix2D = function(rX, scaleX, scaleY, tX, tY){
	        return mat.reset().translate(tX,tY).rotate(rX).scale(scaleX,scaleY).toCSS();
	    };

	    var getMatrix = function(animData){
	        return returnMatrix2D(animData.tr.r[2],animData.tr.s[0],animData.tr.s[1],animData.tr.p[0],animData.tr.p[1]);
	    };

	    return {
	        getMatrix : getMatrix
	    };

	}
	var MatrixManager = matrixManagerFunction;
	(function () {
	    var lastTime = 0;
	    var vendors = ['ms', 'moz', 'webkit', 'o'];
	    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
	        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	    }
	    if(!window.requestAnimationFrame)
	        window.requestAnimationFrame = function (callback, element) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	            var id = window.setTimeout(function () {
	                    callback(currTime + timeToCall);
	                },
	                timeToCall);
	            lastTime = currTime + timeToCall;
	            return id;
	        };
	    if(!window.cancelAnimationFrame)
	        window.cancelAnimationFrame = function (id) {
	            clearTimeout(id);
	        };
	}());
	function createElement(parent,child,params){
	    if(child){
	        child.prototype = Object.create(parent.prototype);
	        child.prototype.constructor = child;
	        child.prototype._parent = parent.prototype;
	    }else{
	        var instance = Object.create(parent.prototype,params);
	        var getType = {};
	        if(instance && getType.toString.call(instance.init) === '[object Function]'){
	            instance.init();
	        }
	        return instance;
	    }
	}

	function extendPrototype(source,destination){
	    for (var attr in source.prototype) {
	        if (source.prototype.hasOwnProperty(attr)) destination.prototype[attr] = source.prototype[attr];
	    }
	}
	function bezFunction(){

	    var easingFunctions = [];
	    var math = Math;

	    function pointOnLine2D(x1,y1, x2,y2, x3,y3){
	        var det1 = (x1*y2) + (y1*x3) + (x2*y3) - (x3*y2) - (y3*x1) - (x2*y1);
	        return det1 > -0.0001 && det1 < 0.0001;
	    }

	    function pointOnLine3D(x1,y1,z1, x2,y2,z2, x3,y3,z3){
	        return pointOnLine2D(x1,y1, x2,y2, x3,y3) && pointOnLine2D(x1,z1, x2,z2, x3,z3);
	    }

	    /*function getEasingCurve(aa,bb,cc,dd,encodedFuncName) {
	        if(!encodedFuncName){
	            encodedFuncName = ('bez_' + aa+'_'+bb+'_'+cc+'_'+dd).replace(/\./g, 'p');
	        }
	        if(easingFunctions[encodedFuncName]){
	            return easingFunctions[encodedFuncName];
	        }
	        var A0, B0, C0;
	        var A1, B1, C1;
	        easingFunctions[encodedFuncName] = function(tt) {
	            var x = tt;
	            var i = 0, z;
	            while (++i < 20) {
	                C0 = 3 * aa;
	                B0 = 3 * (cc - aa) - C0;
	                A0 = 1 - C0 - B0;
	                z = (x * (C0 + x * (B0 + x * A0))) - tt;
	                if (bm_abs(z) < 1e-3) break;
	                x -= z / (C0 + x * (2 * B0 + 3 * A0 * x));
	            }
	            C1 = 3 * bb;
	            B1 = 3 * (dd - bb) - C1;
	            A1 = 1 - C1 - B1;
	            var polyB = x * (C1 + x * (B1 + x * A1));
	            //return c * polyB + b;
	            return polyB;
	        };
	        return easingFunctions[encodedFuncName];
	    }*/
	    var getBezierLength = (function(){

	        function Segment(l,p){
	            this.l = l;
	            this.p = p;
	        }

	        return function(pt1,pt2,pt3,pt4){
	            var curveSegments = defaultCurveSegments;
	            var k;
	            var i, len;
	            var ptCoord,perc,addedLength = 0;
	            var ptDistance;
	            var point = [],lastPoint = [];
	            var lengthData = {
	                addedLength: 0,
	                segments: []
	            };
	            len = pt3.length;
	            for(k=0;k<curveSegments;k+=1){
	                perc = k/(curveSegments-1);
	                ptDistance = 0;
	                for(i=0;i<len;i+=1){
	                    ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bm_pow(perc,2)*pt4[i]+bm_pow(perc,3)*pt2[i];
	                    point[i] = ptCoord;
	                    if(lastPoint[i] !== null){
	                        ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                    }
	                    lastPoint[i] = point[i];
	                }
	                if(ptDistance){
	                    ptDistance = bm_sqrt(ptDistance);
	                    addedLength += ptDistance;
	                }
	                lengthData.segments.push(new Segment(addedLength,perc));
	            }
	            lengthData.addedLength = addedLength;
	            return lengthData;
	        };
	    }());

	    function BezierData(length){
	        this.segmentLength = 0;
	        this.points = new Array(length);
	    }

	    function PointData(partial,point){
	        this.partialLength = partial;
	        this.point = point;
	    }

	    var buildBezierData = (function(){

	        var storedData = {};

	        return function (keyData){
	            var pt1 = keyData.s;
	            var pt2 = keyData.e;
	            var pt3 = keyData.to;
	            var pt4 = keyData.ti;
	            var bezierName = (pt1.join('_')+'_'+pt2.join('_')+'_'+pt3.join('_')+'_'+pt4.join('_')).replace(/\./g, 'p');
	            if(storedData[bezierName]){
	                keyData.bezierData = storedData[bezierName];
	                return;
	            }
	        var curveSegments = defaultCurveSegments;
	        var k, i, len;
	            var ptCoord,perc,addedLength = 0;
	            var ptDistance;
	            var point,lastPoint = null;
	            if(pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){
	                curveSegments = 2;
	            }
	            var bezierData = new BezierData(curveSegments);
	            len = pt3.length;
	            for(k=0;k<curveSegments;k+=1){
	            point = new Array(len);
	                perc = k/(curveSegments-1);
	                ptDistance = 0;
	                for(i=0;i<len;i+=1){
	                ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*(pt1[i] + pt3[i])+3*(1-perc)*bm_pow(perc,2)*(pt2[i] + pt4[i])+bm_pow(perc,3)*pt2[i];
	                point[i] = ptCoord;
	                    if(lastPoint !== null){
	                    ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                    }
	                }
	            ptDistance = bm_sqrt(ptDistance);
	                addedLength += ptDistance;
	                bezierData.points[k] = new PointData(ptDistance,point);
	                lastPoint = point;
	            }
	            bezierData.segmentLength = addedLength;
	            keyData.bezierData = bezierData;
	            storedData[bezierName] = bezierData;

	        }
	    }());

	    function getDistancePerc(perc,bezierData){
	        var segments = bezierData.segments;
	        var len = segments.length;
	        var initPos = bm_floor((len-1)*perc);
	        var lengthPos = perc*bezierData.addedLength;
	        var lPerc = 0;
	        if(lengthPos == segments[initPos].l){
	            return segments[initPos].p;
	        }else{
	            var dir = segments[initPos].l > lengthPos ? -1 : 1;
	            var flag = true;
	            while(flag){
	                if(segments[initPos].l <= lengthPos && segments[initPos+1].l > lengthPos){
	                    lPerc = (lengthPos - segments[initPos].l)/(segments[initPos+1].l-segments[initPos].l);
	                    flag = false;
	                }else{
	                    initPos += dir;
	                }
	                if(initPos < 0 || initPos >= len - 1){
	                    flag = false;
	                }
	            }
	            return segments[initPos].p + (segments[initPos+1].p - segments[initPos].p)*lPerc;
	        }
	    }

	    function SegmentPoints(){
	        this.pt1 = new Array(2);
	        this.pt2 = new Array(2);
	        this.pt3 = new Array(2);
	        this.pt4 = new Array(2);
	    }

	    function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc, bezierData){

	        var pts = new SegmentPoints();
	        startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;
	        var t0 = getDistancePerc(startPerc,bezierData);
	        endPerc = endPerc > 1 ? 1 : endPerc;
	        var t1 = getDistancePerc(endPerc,bezierData);
	        var i, len = pt1.length;
	        var u0 = 1 - t0;
	        var u1 = 1 - t1;
	        //Math.round(num * 100) / 100
	        for(i=0;i<len;i+=1){
	            pts.pt1[i] =  Math.round((u0*u0*u0* pt1[i] + (t0*u0*u0 + u0*t0*u0 + u0*u0*t0) * pt3[i] + (t0*t0*u0 + u0*t0*t0 + t0*u0*t0)* pt4[i] + t0*t0*t0* pt2[i])* 1000) / 1000;
	            pts.pt3[i] = Math.round((u0*u0*u1*pt1[i] + (t0*u0*u1 + u0*t0*u1 + u0*u0*t1)* pt3[i] + (t0*t0*u1 + u0*t0*t1 + t0*u0*t1)* pt4[i] + t0*t0*t1* pt2[i])* 1000) / 1000;
	            pts.pt4[i] = Math.round((u0*u1*u1* pt1[i] + (t0*u1*u1 + u0*t1*u1 + u0*u1*t1)* pt3[i] + (t0*t1*u1 + u0*t1*t1 + t0*u1*t1)* pt4[i] + t0*t1*t1* pt2[i])* 1000) / 1000;
	            pts.pt2[i] = Math.round((u1*u1*u1* pt1[i] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[i] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[i] + t1*t1*t1* pt2[i])* 1000) / 1000;
	        }
	        return pts;
	    }

	    return {
	        //getEasingCurve : getEasingCurve,
	        getBezierLength : getBezierLength,
	        getNewSegment : getNewSegment,
	        buildBezierData : buildBezierData,
	        pointOnLine2D : pointOnLine2D,
	        pointOnLine3D : pointOnLine3D
	    };
	}

	var bez = bezFunction();
	function dataFunctionManager(){

	    //var tCanvasHelper = document.createElement('canvas').getContext('2d');

	    function completeLayers(layers, comps, fontManager){
	        var layerData;
	        var animArray, lastFrame;
	        var i, len = layers.length;
	        var j, jLen, k, kLen;
	        for(i=0;i<len;i+=1){
	            layerData = layers[i];
	            if(!('ks' in layerData) || layerData.completed){
	                continue;
	            }
	            layerData.completed = true;
	            if(layerData.tt){
	                layers[i-1].td = layerData.tt;
	            }
	            animArray = [];
	            lastFrame = -1;
	            if(layerData.hasMask){
	                var maskProps = layerData.masksProperties;
	                jLen = maskProps.length;
	                for(j=0;j<jLen;j+=1){
	                    if(maskProps[j].pt.k.i){
	                        convertPathsToAbsoluteValues(maskProps[j].pt.k);
	                    }else{
	                        kLen = maskProps[j].pt.k.length;
	                        for(k=0;k<kLen;k+=1){
	                            if(maskProps[j].pt.k[k].s){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
	                            }
	                            if(maskProps[j].pt.k[k].e){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
	                            }
	                        }
	                    }
	                }
	            }
	            if(layerData.ty===0){
	                layerData.layers = findCompLayers(layerData.refId, comps);
	                completeLayers(layerData.layers,comps, fontManager);
	            }else if(layerData.ty === 4){
	                completeShapes(layerData.shapes);
	            }else if(layerData.ty == 5){
	                completeText(layerData, fontManager);
	            }
	        }
	    }

	    function findCompLayers(id,comps){
	        var i = 0, len = comps.length;
	        while(i<len){
	            if(comps[i].id === id){
	                return comps[i].layers;
	            }
	            i += 1;
	        }
	    }

	    function completeShapes(arr){
	        var i, len = arr.length;
	        var j, jLen;
	        var hasPaths = false;
	        for(i=len-1;i>=0;i-=1){
	            if(arr[i].ty == 'sh'){
	                if(arr[i].ks.k.i){
	                    convertPathsToAbsoluteValues(arr[i].ks.k);
	                }else{
	                    jLen = arr[i].ks.k.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(arr[i].ks.k[j].s){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
	                        }
	                        if(arr[i].ks.k[j].e){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
	                        }
	                    }
	                }
	                hasPaths = true;
	            }else if(arr[i].ty == 'gr'){
	                completeShapes(arr[i].it);
	            }
	        }
	        /*if(hasPaths){
	            //mx: distance
	            //ss: sensitivity
	            //dc: decay
	            arr.splice(arr.length-1,0,{
	                "ty": "ms",
	                "mx":20,
	                "ss":10,
	                 "dc":0.001,
	                "maxDist":200
	            });
	        }*/
	    }

	    function convertPathsToAbsoluteValues(path){
	        var i, len = path.i.length;
	        for(i=0;i<len;i+=1){
	            path.i[i][0] += path.v[i][0];
	            path.i[i][1] += path.v[i][1];
	            path.o[i][0] += path.v[i][0];
	            path.o[i][1] += path.v[i][1];
	        }
	    }

	    function checkVersion(minimum,animVersionString){
	        var animVersion = animVersionString ? animVersionString.split('.') : [100,100,100];
	        if(minimum[0]>animVersion[0]){
	            return true;
	        } else if(animVersion[0] > minimum[0]){
	            return false;
	        }
	        if(minimum[1]>animVersion[1]){
	            return true;
	        } else if(animVersion[1] > minimum[1]){
	            return false;
	        }
	        if(minimum[2]>animVersion[2]){
	            return true;
	        } else if(animVersion[2] > minimum[2]){
	            return false;
	        }
	    }

	    var checkText = (function(){
	        var minimumVersion = [4,4,14];

	        function updateTextLayer(textLayer){
	            var documentData = textLayer.t.d;
	            textLayer.t.d = {
	                k: [
	                    {
	                        s:documentData,
	                        t:0
	                    }
	                ]
	            }
	        }

	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 5){
	                    updateTextLayer(layers[i]);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }())

	    var checkColors = (function(){
	        var minimumVersion = [4,1,9];

	        function iterateShapes(shapes){
	            var i, len = shapes.length;
	            var j, jLen;
	            for(i=0;i<len;i+=1){
	                if(shapes[i].ty === 'gr'){
	                    iterateShapes(shapes[i].it);
	                }else if(shapes[i].ty === 'fl' || shapes[i].ty === 'st'){
	                    if(shapes[i].c.k && shapes[i].c.k[0].i){
	                        jLen = shapes[i].c.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(shapes[i].c.k[j].s){
	                                shapes[i].c.k[j].s[0] /= 255;
	                                shapes[i].c.k[j].s[1] /= 255;
	                                shapes[i].c.k[j].s[2] /= 255;
	                                shapes[i].c.k[j].s[3] /= 255;
	                            }
	                            if(shapes[i].c.k[j].e){
	                                shapes[i].c.k[j].e[0] /= 255;
	                                shapes[i].c.k[j].e[1] /= 255;
	                                shapes[i].c.k[j].e[2] /= 255;
	                                shapes[i].c.k[j].e[3] /= 255;
	                            }
	                        }
	                    } else {
	                        shapes[i].c.k[0] /= 255;
	                        shapes[i].c.k[1] /= 255;
	                        shapes[i].c.k[2] /= 255;
	                        shapes[i].c.k[3] /= 255;
	                    }
	                }
	            }
	        }

	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 4){
	                    iterateShapes(layers[i].shapes);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }());

	    var checkShapes = (function(){
	        var minimumVersion = [4,4,18];



	        function completeShapes(arr){
	            var i, len = arr.length;
	            var j, jLen;
	            var hasPaths = false;
	            for(i=len-1;i>=0;i-=1){
	                if(arr[i].ty == 'sh'){
	                    if(arr[i].ks.k.i){
	                        arr[i].ks.k.c = arr[i].closed;
	                    }else{
	                        jLen = arr[i].ks.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(arr[i].ks.k[j].s){
	                                arr[i].ks.k[j].s[0].c = arr[i].closed;
	                            }
	                            if(arr[i].ks.k[j].e){
	                                arr[i].ks.k[j].e[0].c = arr[i].closed;
	                            }
	                        }
	                    }
	                    hasPaths = true;
	                }else if(arr[i].ty == 'gr'){
	                    completeShapes(arr[i].it);
	                }
	            }
	        }

	        function iterateLayers(layers){
	            var layerData;
	            var i, len = layers.length;
	            var j, jLen, k, kLen;
	            for(i=0;i<len;i+=1){
	                layerData = layers[i];
	                if(layerData.hasMask){
	                    var maskProps = layerData.masksProperties;
	                    jLen = maskProps.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(maskProps[j].pt.k.i){
	                            maskProps[j].pt.k.c = maskProps[j].cl;
	                        }else{
	                            kLen = maskProps[j].pt.k.length;
	                            for(k=0;k<kLen;k+=1){
	                                if(maskProps[j].pt.k[k].s){
	                                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
	                                }
	                                if(maskProps[j].pt.k[k].e){
	                                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
	                                }
	                            }
	                        }
	                    }
	                }
	                if(layerData.ty === 4){
	                    completeShapes(layerData.shapes);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }());

	    /*function blitPaths(path){
	        var i, len = path.i.length;
	        for(i=0;i<len;i+=1){
	            path.i[i][0] /= blitter;
	            path.i[i][1] /= blitter;
	            path.o[i][0] /= blitter;
	            path.o[i][1] /= blitter;
	            path.v[i][0] /= blitter;
	            path.v[i][1] /= blitter;
	        }
	    }

	    function blitShapes(arr){
	        var i, len = arr.length;
	        var j, jLen;
	        var hasPaths = false;
	        for(i=len-1;i>=0;i-=1){
	            if(arr[i].ty == 'sh'){
	                if(arr[i].ks.k.i){
	                    blitPaths(arr[i].ks.k);
	                }else{
	                    jLen = arr[i].ks.k.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(arr[i].ks.k[j].s){
	                            blitPaths(arr[i].ks.k[j].s[0]);
	                        }
	                        if(arr[i].ks.k[j].e){
	                            blitPaths(arr[i].ks.k[j].e[0]);
	                        }
	                    }
	                }
	                hasPaths = true;
	            }else if(arr[i].ty == 'gr'){
	                blitShapes(arr[i].it);
	            }else if(arr[i].ty == 'rc'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].s);
	            }else if(arr[i].ty == 'st'){
	                blitProperty(arr[i].w);
	            }else if(arr[i].ty == 'tr'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].sk);
	                blitProperty(arr[i].a);
	            }else if(arr[i].ty == 'el'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].s);
	            }else if(arr[i].ty == 'rd'){
	                blitProperty(arr[i].r);
	            }else{

	                //console.log(arr[i].ty );
	            }
	        }
	    }

	    function blitText(data, fontManager){

	    }

	    function blitValue(val){
	        if(typeof(val) === 'number'){
	            val /= blitter;
	        } else {
	            var i = val.length-1;
	            while(i>=0){
	                val[i] /= blitter;
	                i-=1;
	            }
	        }
	        return val;
	    }

	    function blitProperty(data){
	        if(!data.k.length){
	            data.k = blitValue(data.k);
	        }else if(typeof(data.k[0]) === 'number'){
	            data.k = blitValue(data.k);
	        } else {
	            var i, len = data.k.length;
	            for(i=0;i<len;i+=1){
	                if(data.k[i].s){
	                    //console.log('pre S: ', data.k[i].s);
	                    data.k[i].s = blitValue(data.k[i].s);
	                    //console.log('post S: ', data.k[i].s);
	                }
	                if(data.k[i].e){
	                    //console.log('pre E: ', data.k[i].e);
	                    data.k[i].e = blitValue(data.k[i].e);
	                    //console.log('post E: ', data.k[i].e);
	                }
	            }
	        }
	    }

	    function blitLayers(layers,comps, fontManager){
	        var layerData;
	        var animArray, lastFrame;
	        var i, len = layers.length;
	        var j, jLen, k, kLen;
	        for(i=0;i<len;i+=1){
	            layerData = layers[i];
	            if(!('ks' in layerData)){
	                continue;
	            }
	            blitProperty(layerData.ks.a);
	            blitProperty(layerData.ks.p);
	            layerData.completed = true;
	            if(layerData.tt){
	                layers[i-1].td = layerData.tt;
	            }
	            animArray = [];
	            lastFrame = -1;
	            if(layerData.hasMask){
	                var maskProps = layerData.masksProperties;
	                jLen = maskProps.length;
	                for(j=0;j<jLen;j+=1){
	                    if(maskProps[j].pt.k.i){
	                        blitPaths(maskProps[j].pt.k);
	                    }else{
	                        kLen = maskProps[j].pt.k.length;
	                        for(k=0;k<kLen;k+=1){
	                            if(maskProps[j].pt.k[k].s){
	                                blitPaths(maskProps[j].pt.k[k].s[0]);
	                            }
	                            if(maskProps[j].pt.k[k].e){
	                                blitPaths(maskProps[j].pt.k[k].e[0]);
	                            }
	                        }
	                    }
	                }
	            }
	            if(layerData.ty===0){
	                layerData.w = Math.round(layerData.w/blitter);
	                layerData.h = Math.round(layerData.h/blitter);
	                blitLayers(layerData.layers,comps, fontManager);
	            }else if(layerData.ty === 4){
	                blitShapes(layerData.shapes);
	            }else if(layerData.ty == 5){
	                blitText(layerData, fontManager);
	            }else if(layerData.ty == 1){
	                layerData.sh /= blitter;
	                layerData.sw /= blitter;
	            } else {
	            }
	        }
	    }

	    function blitAnimation(animationData,comps, fontManager){
	        blitLayers(animationData.layers,comps, fontManager);
	    }*/

	    function completeData(animationData, fontManager){
	        if(animationData.__complete){
	            return;
	        }
	        checkColors(animationData);
	        checkText(animationData);
	        checkShapes(animationData);
	        completeLayers(animationData.layers, animationData.assets, fontManager);
	        animationData.__complete = true;
	        //blitAnimation(animationData, animationData.assets, fontManager);
	    }

	    function completeText(data, fontManager){
	        var letters;
	        var keys = data.t.d.k;
	        var k, kLen = keys.length;
	        for(k=0;k<kLen;k+=1){
	            var documentData = data.t.d.k[k].s;
	            letters = [];
	            var i, len;
	            var newLineFlag, index = 0, val;
	            var anchorGrouping = data.t.m.g;
	            var currentSize = 0, currentPos = 0, currentLine = 0, lineWidths = [];
	            var lineWidth = 0;
	            var maxLineWidth = 0;
	            var j, jLen;
	            var fontData = fontManager.getFontByName(documentData.f);
	            var charData, cLength = 0;
	            var styles = fontData.fStyle.split(' ');

	            var fWeight = 'normal', fStyle = 'normal';
	            len = styles.length;
	            for(i=0;i<len;i+=1){
	                if (styles[i].toLowerCase() === 'italic') {
	                    fStyle = 'italic';
	                }else if (styles[i].toLowerCase() === 'bold') {
	                    fWeight = '700';
	                } else if (styles[i].toLowerCase() === 'black') {
	                    fWeight = '900';
	                } else if (styles[i].toLowerCase() === 'medium') {
	                    fWeight = '500';
	                } else if (styles[i].toLowerCase() === 'regular' || styles[i].toLowerCase() === 'normal') {
	                    fWeight = '400';
	                } else if (styles[i].toLowerCase() === 'light' || styles[i].toLowerCase() === 'thin') {
	                    fWeight = '200';
	                }
	            }
	            documentData.fWeight = fWeight;
	            documentData.fStyle = fStyle;
	            len = documentData.t.length;
	            if(documentData.sz){
	                var boxWidth = documentData.sz[0];
	                var lastSpaceIndex = -1;
	                for(i=0;i<len;i+=1){
	                    newLineFlag = false;
	                    if(documentData.t.charAt(i) === ' '){
	                        lastSpaceIndex = i;
	                    }else if(documentData.t.charCodeAt(i) === 13){
	                        lineWidth = 0;
	                        newLineFlag = true;
	                    }
	                    if(fontManager.chars){
	                        charData = fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, fontData.fFamily);
	                        cLength = newLineFlag ? 0 : charData.w*documentData.s/100;
	                    }else{
	                        //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
	                        cLength = fontManager.measureText(documentData.t.charAt(i), documentData.f, documentData.s);
	                    }
	                    if(lineWidth + cLength > boxWidth){
	                        if(lastSpaceIndex === -1){
	                            //i -= 1;
	                            documentData.t = documentData.t.substr(0,i) + "\r" + documentData.t.substr(i);
	                            len += 1;
	                        } else {
	                            i = lastSpaceIndex;
	                            documentData.t = documentData.t.substr(0,i) + "\r" + documentData.t.substr(i+1);
	                        }
	                        lastSpaceIndex = -1;
	                        lineWidth = 0;
	                    }else {
	                        lineWidth += cLength;
	                    }
	                }
	                len = documentData.t.length;
	            }
	            lineWidth = 0;
	            cLength = 0;
	            for (i = 0;i < len ;i += 1) {
	                newLineFlag = false;
	                if(documentData.t.charAt(i) === ' '){
	                    val = '\u00A0';
	                }else if(documentData.t.charCodeAt(i) === 13){
	                    lineWidths.push(lineWidth);
	                    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	                    lineWidth = 0;
	                    val = '';
	                    newLineFlag = true;
	                    currentLine += 1;
	                }else{
	                    val = documentData.t.charAt(i);
	                }
	                if(fontManager.chars){
	                    charData = fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
	                    cLength = newLineFlag ? 0 : charData.w*documentData.s/100;
	                }else{
	                    //var charWidth = fontManager.measureText(val, documentData.f, documentData.s);
	                    //tCanvasHelper.font = documentData.s + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
	                    cLength = fontManager.measureText(val, documentData.f, documentData.s);
	                }

	                //
	                lineWidth += cLength;
	                letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag, anIndexes:[], val: val, line: currentLine});
	                if(anchorGrouping == 2){
	                    currentSize += cLength;
	                    if(val == '' || val == '\u00A0' || i == len - 1){
	                        if(val == '' || val == '\u00A0'){
	                            currentSize -= cLength;
	                        }
	                        while(currentPos<=i){
	                            letters[currentPos].an = currentSize;
	                            letters[currentPos].ind = index;
	                            letters[currentPos].extra = cLength;
	                            currentPos += 1;
	                        }
	                        index += 1;
	                        currentSize = 0;
	                    }
	                }else if(anchorGrouping == 3){
	                    currentSize += cLength;
	                    if(val == '' || i == len - 1){
	                        if(val == ''){
	                            currentSize -= cLength;
	                        }
	                        while(currentPos<=i){
	                            letters[currentPos].an = currentSize;
	                            letters[currentPos].ind = index;
	                            letters[currentPos].extra = cLength;
	                            currentPos += 1;
	                        }
	                        currentSize = 0;
	                        index += 1;
	                    }
	                }else{
	                    letters[index].ind = index;
	                    letters[index].extra = 0;
	                    index += 1;
	                }
	            }
	            documentData.l = letters;
	            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	            lineWidths.push(lineWidth);
	            if(documentData.sz){
	                documentData.boxWidth = documentData.sz[0];
	                documentData.justifyOffset = 0;
	            }else{
	                documentData.boxWidth = maxLineWidth;
	                switch(documentData.j){
	                    case 1:
	                        documentData.justifyOffset = - documentData.boxWidth;
	                        break;
	                    case 2:
	                        documentData.justifyOffset = - documentData.boxWidth/2;
	                        break;
	                    default:
	                        documentData.justifyOffset = 0;
	                }
	            }
	            documentData.lineWidths = lineWidths;

	            var animators = data.t.a;
	            jLen = animators.length;
	            var based, ind, indexes = [];
	            for(j=0;j<jLen;j+=1){
	                if(animators[j].a.sc){
	                    documentData.strokeColorAnim = true;
	                }
	                if(animators[j].a.sw){
	                    documentData.strokeWidthAnim = true;
	                }
	                if(animators[j].a.fc || animators[j].a.fh || animators[j].a.fs || animators[j].a.fb){
	                    documentData.fillColorAnim = true;
	                }
	                ind = 0;
	                based = animators[j].s.b;
	                for(i=0;i<len;i+=1){
	                    letters[i].anIndexes[j] = ind;
	                    if((based == 1 && letters[i].val != '') || (based == 2 && letters[i].val != '' && letters[i].val != '\u00A0') || (based == 3 && (letters[i].n || letters[i].val == '\u00A0' || i == len - 1)) || (based == 4 && (letters[i].n || i == len - 1))){
	                        if(animators[j].s.rn === 1){
	                            indexes.push(ind);
	                        }
	                        ind += 1;
	                    }
	                }
	                data.t.a[j].s.totalChars = ind;
	                var currentInd = -1, newInd;
	                if(animators[j].s.rn === 1){
	                    for(i = 0; i < len; i += 1){
	                        if(currentInd != letters[i].anIndexes[j]){
	                            currentInd = letters[i].anIndexes[j];
	                            newInd = indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];
	                        }
	                        letters[i].anIndexes[j] = newInd;
	                    }
	                }
	            }
	            if(jLen === 0 && !('m' in data.t.p)){
	                data.singleShape = true;
	            }
	            documentData.yOffset = documentData.lh || documentData.s*1.2;
	            documentData.ascent = fontData.ascent*documentData.s/100;
	        }

	    }

	    var moduleOb = {};
	    moduleOb.completeData = completeData;

	    return moduleOb;
	}

	var dataManager = dataFunctionManager();
	var FontManager = (function(){

	    var maxWaitingTime = 5000;

	    function setUpNode(font, family){
	        var parentNode = document.createElement('span');
	        parentNode.style.fontFamily    = family;
	        var node = document.createElement('span');
	        // Characters that vary significantly among different fonts
	        node.innerHTML = 'giItT1WQy@!-/#';
	        // Visible - so we can measure it - but not on the screen
	        parentNode.style.position      = 'absolute';
	        parentNode.style.left          = '-10000px';
	        parentNode.style.top           = '-10000px';
	        // Large font size makes even subtle changes obvious
	        parentNode.style.fontSize      = '300px';
	        // Reset any font properties
	        parentNode.style.fontVariant   = 'normal';
	        parentNode.style.fontStyle     = 'normal';
	        parentNode.style.fontWeight    = 'normal';
	        parentNode.style.letterSpacing = '0';
	        parentNode.appendChild(node);
	        document.body.appendChild(parentNode);

	        // Remember width with no applied web font
	        var width = node.offsetWidth;
	        node.style.fontFamily = font + ', '+family;
	        return {node:node, w:width, parent:parentNode};
	    }

	    function checkLoadedFonts() {
	        var i, len = this.fonts.length;
	        var node, w;
	        var loadedCount = len;
	        for(i=0;i<len; i+= 1){
	            if(this.fonts[i].loaded){
	                loadedCount -= 1;
	                continue;
	            }
	            if(this.fonts[i].fOrigin === 't'){
	                if(window.Typekit && window.Typekit.load && this.typekitLoaded === 0){
	                    this.typekitLoaded = 1;
	                    try{window.Typekit.load({
	                        async: true,
	                        active: function() {
	                            this.typekitLoaded = 2;
	                        }.bind(this)
	                    });}catch(e){}
	                }
	                if(this.typekitLoaded === 2) {
	                    this.fonts[i].loaded = true;
	                }
	            } else if(this.fonts[i].fOrigin === 'n'){
	                this.fonts[i].loaded = true;
	            } else{
	                node = this.fonts[i].monoCase.node;
	                w = this.fonts[i].monoCase.w;
	                if(node.offsetWidth !== w){
	                    loadedCount -= 1;
	                    this.fonts[i].loaded = true;
	                }else{
	                    node = this.fonts[i].sansCase.node;
	                    w = this.fonts[i].sansCase.w;
	                    if(node.offsetWidth !== w){
	                        loadedCount -= 1;
	                        this.fonts[i].loaded = true;
	                    }
	                }
	                if(this.fonts[i].loaded){
	                    this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
	                    this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
	                }
	            }
	        }

	        if(loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime){
	            setTimeout(checkLoadedFonts.bind(this),20);
	        }else{
	            setTimeout(function(){this.loaded = true;}.bind(this),0);

	        }
	    };

	    function createHelper(def, fontData){
	        var tHelper = document.createElementNS(svgNS,'text');
	        tHelper.style.fontSize = '100px';
	        tHelper.style.fontFamily = fontData.fFamily;
	        tHelper.textContent = '1';
	        if(fontData.fClass){
	            tHelper.style.fontFamily = 'inherit';
	            tHelper.className = fontData.fClass;
	        } else {
	            tHelper.style.fontFamily = fontData.fFamily;
	        }
	        def.appendChild(tHelper);
	        var tCanvasHelper = document.createElement('canvas').getContext('2d');
	        tCanvasHelper.font = '100px '+ fontData.fFamily;
	        return tCanvasHelper;
	        return tHelper;
	    }

	    function addFonts(fontData, defs){
	        if(!fontData){
	            this.loaded = true;
	            return;
	        }
	        if(this.chars){
	            this.loaded = true;
	            this.fonts = fontData.list;
	            return;
	        }

	        var fontArr = fontData.list;
	        var i, len = fontArr.length;
	        for(i=0; i<len; i+= 1){
	            fontArr[i].loaded = false;
	            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily,'monospace');
	            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily,'sans-serif');
	            if(!fontArr[i].fPath) {
	                fontArr[i].loaded = true;
	            }else if(fontArr[i].fOrigin === 'p'){
	                var s = document.createElement('style');
	                s.type = "text/css";
	                s.innerHTML = "@font-face {" + "font-family: "+fontArr[i].fFamily+"; font-style: normal; src: url('"+fontArr[i].fPath+"');}";
	                defs.appendChild(s);
	            } else if(fontArr[i].fOrigin === 'g'){
	                //<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
	                var l = document.createElement('link');
	                l.type = "text/css";
	                l.rel = "stylesheet";
	                l.href = fontArr[i].fPath;
	                defs.appendChild(l);
	            } else if(fontArr[i].fOrigin === 't'){
	                //<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
	                var sc = document.createElement('script');
	                sc.setAttribute('src',fontArr[i].fPath);
	                defs.appendChild(sc);
	            }
	            fontArr[i].helper = createHelper(defs,fontArr[i]);
	            this.fonts.push(fontArr[i]);
	        }
	        checkLoadedFonts.bind(this)();
	    }

	    function addChars(chars){
	        if(!chars){
	            return;
	        }
	        if(!this.chars){
	            this.chars = [];
	        }
	        var i, len = chars.length;
	        var j, jLen = this.chars.length, found;
	        for(i=0;i<len;i+=1){
	            j = 0;
	            found = false;
	            while(j<jLen){
	                if(this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch){
	                    found = true;
	                }
	                j += 1;
	            }
	            if(!found){
	                this.chars.push(chars[i]);
	                jLen += 1;
	            }
	        }
	    }

	    function getCharData(char, style, font){
	        var i = 0, len = this.chars.length;
	        while( i < len) {
	            if(this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font){
	                return this.chars[i];
	            }
	            i+= 1;
	        }
	    }

	    function measureText(char, fontName, size){
	        var fontData = this.getFontByName(fontName);
	        var tHelper = fontData.helper;
	        //tHelper.textContent = char;
	        return tHelper.measureText(char).width*size/100;
	        //return tHelper.getComputedTextLength()*size/100;
	    }

	    function getFontByName(name){
	        var i = 0, len = this.fonts.length;
	        while(i<len){
	            if(this.fonts[i].fName === name) {
	                return this.fonts[i];
	            }
	            i += 1;
	        }
	        return 'sans-serif';
	    }

	    var Font = function(){
	        this.fonts = [];
	        this.chars = null;
	        this.typekitLoaded = 0;
	        this.loaded = false;
	        this.initTime = Date.now();
	    };
	    Font.prototype.addChars = addChars;
	    Font.prototype.addFonts = addFonts;
	    Font.prototype.getCharData = getCharData;
	    Font.prototype.getFontByName = getFontByName;
	    Font.prototype.measureText = measureText;

	    return Font;

	}());
	var PropertyFactory = (function(){

	    var initFrame = -999999;

	    function getValue(){
	        if(this.elem.globalData.frameId === this.frameId){
	            return;
	        }
	        this.mdf = false;
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        if(!(frameNum === this.lastFrame || (this.lastFrame !== initFrame && ((this.lastFrame >= this.keyframes[this.keyframes.length- 1].t-this.offsetTime && frameNum >= this.keyframes[this.keyframes.length- 1].t-this.offsetTime) || (this.lastFrame < this.keyframes[0].t-this.offsetTime && frameNum < this.keyframes[0].t-this.offsetTime))))){
	            var i = this.lastFrame < frameNum ? this._lastIndex : 0;
	            var len = this.keyframes.length- 1,flag = true;
	            var keyData, nextKeyData;

	            while(flag){
	                keyData = this.keyframes[i];
	                nextKeyData = this.keyframes[i+1];
	                if(i == len-1 && frameNum >= nextKeyData.t - this.offsetTime){
	                    if(keyData.h){
	                        keyData = nextKeyData;
	                    }
	                    break;
	                }
	                if((nextKeyData.t - this.offsetTime) > frameNum){
	                    break;
	                }
	                if(i < len - 1){
	                    i += 1;
	                }else{
	                    flag = false;
	                }
	            }

	            this._lastIndex = i;

	            var k, kLen,perc,jLen, j, fnc;
	            if(keyData.to){

	                if(!keyData.bezierData){
	                    bez.buildBezierData(keyData);
	                }
	                var bezierData = keyData.bezierData;
	                if(frameNum >= nextKeyData.t-this.offsetTime || frameNum < keyData.t-this.offsetTime){
	                    var ind = frameNum >= nextKeyData.t-this.offsetTime ? bezierData.points.length - 1 : 0;
	                    kLen = bezierData.points[ind].point.length;
	                    for(k = 0; k < kLen; k += 1){
	                        this.pv[k] = bezierData.points[ind].point[k];
	                        this.v[k] = this.mult ? this.pv[k]*this.mult : this.pv[k];
	                        if(this.lastPValue[k] !== this.pv[k]) {
	                            this.mdf = true;
	                            this.lastPValue[k] = this.pv[k];
	                        }
	                    }
	                    this._lastBezierData = null;
	                }else{
	                    if(keyData.__fnct){
	                        fnc = keyData.__fnct;
	                    }else{
	                        fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y,keyData.n).get;
	                        keyData.__fnct = fnc;
	                    }
	                    perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
	                    var distanceInLine = bezierData.segmentLength*perc;

	                    var segmentPerc;
	                    var addedLength =  (this.lastFrame < frameNum && this._lastBezierData === bezierData) ? this._lastAddedLength : 0;
	                    j =  (this.lastFrame < frameNum && this._lastBezierData === bezierData) ? this._lastPoint : 0;
	                    flag = true;
	                    jLen = bezierData.points.length;
	                    while(flag){
	                        addedLength +=bezierData.points[j].partialLength;
	                        if(distanceInLine === 0 || perc === 0 || j == bezierData.points.length - 1){
	                            kLen = bezierData.points[j].point.length;
	                            for(k=0;k<kLen;k+=1){
	                                this.pv[k] = bezierData.points[j].point[k];
	                                this.v[k] = this.mult ? this.pv[k]*this.mult : this.pv[k];
	                                if(this.lastPValue[k] !== this.pv[k]) {
	                                    this.mdf = true;
	                                    this.lastPValue[k] = this.pv[k];
	                                }
	                            }
	                            break;
	                        }else if(distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j+1].partialLength){
	                            segmentPerc = (distanceInLine-addedLength)/(bezierData.points[j+1].partialLength);
	                            kLen = bezierData.points[j].point.length;
	                            for(k=0;k<kLen;k+=1){
	                                this.pv[k] = bezierData.points[j].point[k] + (bezierData.points[j+1].point[k] - bezierData.points[j].point[k])*segmentPerc;
	                                this.v[k] = this.mult ? this.pv[k] * this.mult : this.pv[k];
	                                if(this.lastPValue[k] !== this.pv[k]) {
	                                    this.mdf = true;
	                                    this.lastPValue[k] = this.pv[k];
	                                }
	                            }
	                            break;
	                        }
	                        if(j < jLen - 1){
	                            j += 1;
	                        }else{
	                            flag = false;
	                        }
	                    }
	                    this._lastPoint = j;
	                    this._lastAddedLength = addedLength - bezierData.points[j].partialLength;
	                    this._lastBezierData = bezierData;
	                }
	            }else{
	                var outX,outY,inX,inY, keyValue;
	                len = keyData.s.length;
	                for(i=0;i<len;i+=1){
	                    if(keyData.h !== 1){
	                        if(frameNum >= nextKeyData.t-this.offsetTime){
	                            perc = 1;
	                        }else if(frameNum < keyData.t-this.offsetTime){
	                            perc = 0;
	                        }else{
	                            if(keyData.o.x instanceof Array){
	                                if(!keyData.__fnct){
	                                    keyData.__fnct = [];
	                                }
	                                if (!keyData.__fnct[i]) {
	                                    outX = keyData.o.x[i] || keyData.o.x[0];
	                                    outY = keyData.o.y[i] || keyData.o.y[0];
	                                    inX = keyData.i.x[i] || keyData.i.x[0];
	                                    inY = keyData.i.y[i] || keyData.i.y[0];
	                                    fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                                    keyData.__fnct[i] = fnc;
	                                } else {
	                                    fnc = keyData.__fnct[i];
	                                }
	                            } else {
	                                if (!keyData.__fnct) {
	                                    outX = keyData.o.x;
	                                    outY = keyData.o.y;
	                                    inX = keyData.i.x;
	                                    inY = keyData.i.y;
	                                    fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                                    keyData.__fnct = fnc;
	                                } else{
	                                    fnc = keyData.__fnct;
	                                }
	                            }
	                            perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
	                        }
	                    }
	                    if(this.sh && keyData.h !== 1){
	                        var initP = keyData.s[i];
	                        var endP = keyData.e[i];
	                        if(initP-endP < -180){
	                            initP += 360;
	                        } else if(initP-endP > 180){
	                            initP -= 360;
	                        }
	                        keyValue = initP+(endP-initP)*perc;
	                    } else {
	                        keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i]+(keyData.e[i]-keyData.s[i])*perc;
	                    }
	                    if(len === 1){
	                        this.v = this.mult ? keyValue*this.mult : keyValue;
	                        this.pv = keyValue;
	                        if(this.lastPValue != this.pv){
	                            this.mdf = true;
	                            this.lastPValue = this.pv;
	                        }
	                    }else{
	                        this.v[i] = this.mult ? keyValue*this.mult : keyValue;
	                        this.pv[i] = keyValue;
	                        if(this.lastPValue[i] !== this.pv[i]){
	                            this.mdf = true;
	                            this.lastPValue[i] = this.pv[i];
	                        }
	                    }
	                }
	            }
	        }
	        this.lastFrame = frameNum;
	        this.frameId = this.elem.globalData.frameId;
	    }

	    function getNoValue(){}

	    function ValueProperty(elem,data, mult){
	        this.mult = mult;
	        this.v = mult ? data.k * mult : data.k;
	        this.pv = data.k;
	        this.mdf = false;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.vel = 0;
	        this.getValue = getNoValue;
	    }

	    function MultiDimensionalProperty(elem,data, mult){
	        this.mult = mult;
	        this.data = data;
	        this.mdf = false;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.frameId = -1;
	        this.v = Array.apply(null, {length:data.k.length});
	        this.pv = Array.apply(null, {length:data.k.length});
	        this.lastValue = Array.apply(null, {length:data.k.length});
	        var arr = Array.apply(null, {length:data.k.length});
	        this.vel = arr.map(function () { return 0 });
	        var i, len = data.k.length;
	        for(i = 0;i<len;i+=1){
	            this.v[i] = mult ? data.k[i] * mult : data.k[i];
	            this.pv[i] = data.k[i];
	        }
	        this.getValue = getNoValue;
	    }

	    function KeyframedValueProperty(elem, data, mult){
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.lastValue = -99999;
	        this.lastPValue = -99999;
	        this.frameId = -1;
	        this._lastIndex = 0;
	        this.k = true;
	        this.kf = true;
	        this.data = data;
	        this.mult = mult;
	        this.elem = elem;
	        this.comp = elem.comp;
	        this.lastFrame = initFrame;
	        this.v = mult ? data.k[0].s[0]*mult : data.k[0].s[0];
	        this.pv = data.k[0].s[0];
	        this.getValue = getValue;
	    }

	    function KeyframedMultidimensionalProperty(elem, data, mult){
	        var i, len = data.k.length;
	        var s, e,to,ti;
	        for(i=0;i<len-1;i+=1){
	            if(data.k[i].to && data.k[i].s && data.k[i].e ){
	                s = data.k[i].s;
	                e = data.k[i].e;
	                to = data.k[i].to;
	                ti = data.k[i].ti;
	                if((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0] + to[0],s[1] + to[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0] + ti[0],e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0] + to[0],s[1] + to[1],s[2] + to[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0] + ti[0],e[1] + ti[1],e[2] + ti[2]))){
	                    data.k[i].to = null;
	                    data.k[i].ti = null;
	                }
	            }
	        }
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.k = true;
	        this.kf = true;
	        this.mult = mult;
	        this.elem = elem;
	        this.comp = elem.comp;
	        this.getValue = getValue;
	        this.frameId = -1;
	        this._lastIndex = 0;
	        this.v = Array.apply(null, {length:data.k[0].s.length});
	        this.pv = Array.apply(null, {length:data.k[0].s.length});
	        this.lastValue = Array.apply(null, {length:data.k[0].s.length});
	        this.lastPValue = Array.apply(null, {length:data.k[0].s.length});
	        this.lastFrame = initFrame;
	    }

	    var TransformProperty = (function() {
	        function positionGetter() {
	            return ExpressionValue(this.p);
	        }
	        function xPositionGetter() {
	            return ExpressionValue(this.px);
	        }
	        function yPositionGetter() {
	            return ExpressionValue(this.py);
	        }
	        function zPositionGetter() {
	            return ExpressionValue(this.pz);
	        }
	        function anchorGetter() {
	            return ExpressionValue(this.a);
	        }
	        function orientationGetter() {
	            return ExpressionValue(this.or);
	        }
	        function rotationGetter() {
	            return ExpressionValue(this.r, 1/degToRads);
	        }
	        function scaleGetter() {
	            return ExpressionValue(this.s, 100);
	        }
	        function opacityGetter() {
	            return ExpressionValue(this.o, 100);
	        }
	        function skewGetter() {
	            return ExpressionValue(this.sk);
	        }
	        function skewAxisGetter() {
	            return ExpressionValue(this.sa);
	        }
	        function applyToMatrix(mat) {
	            var i, len = this.dynamicProperties.length;
	            for(i = 0; i < len; i += 1) {
	                this.dynamicProperties[i].getValue();
	                if (this.dynamicProperties[i].mdf) {
	                    this.mdf = true;
	                }
	            }
	            if (this.a) {
	                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	            }
	            if (this.s) {
	                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	            }
	            if (this.r) {
	                mat.rotate(-this.r.v);
	            } else {
	                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	            }
	            if (this.data.p.s) {
	                if (this.data.p.z) {
	                    mat.translate(this.px.v, this.py.v, -this.pz.v);
	                } else {
	                    mat.translate(this.px.v, this.py.v, 0);
	                }
	            } else {
	                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
	            }
	        }
	        function processKeys(){
	            if (this.elem.globalData.frameId === this.frameId) {
	                return;
	            }

	            this.mdf = false;
	            var i, len = this.dynamicProperties.length;

	            for(i = 0; i < len; i += 1) {
	                this.dynamicProperties[i].getValue();
	                if (this.dynamicProperties[i].mdf) {
	                    this.mdf = true;
	                }
	            }
	            if (this.mdf) {
	                this.v.reset();
	                if (this.a) {
	                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	                }
	                if(this.s) {
	                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	                }
	                if (this.sk) {
	                    this.v.skewFromAxis(-this.sk.v, this.sa.v);
	                }
	                if (this.r) {
	                    this.v.rotate(-this.r.v);
	                } else {
	                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	                }
	                if (this.autoOriented && this.p.keyframes && this.p.getValueAtTime) {
	                    var v1,v2;
	                    if (this.p.lastFrame+this.p.offsetTime <= this.p.keyframes[0].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / this.elem.globalData.frameRate,0);
	                        v2 = this.p.getValueAtTime(this.p.keyframes[0].t / this.elem.globalData.frameRate, 0);
	                    } else if(this.p.lastFrame+this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / this.elem.globalData.frameRate), 0);
	                        v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.01) / this.elem.globalData.frameRate, 0);
	                    } else {
	                        v1 = this.p.pv;
	                        v2 = this.p.getValueAtTime((this.p.lastFrame+this.p.offsetTime - 0.01) / this.elem.globalData.frameRate, this.p.offsetTime);
	                    }
	                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
	                }
	                if(this.data.p.s){
	                    if(this.data.p.z) {
	                        this.v.translate(this.px.v, this.py.v, -this.pz.v);
	                    } else {
	                        this.v.translate(this.px.v, this.py.v, 0);
	                    }
	                }else{
	                    this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	            }
	            //console.log(this.v.to2dCSS())
	            this.frameId = this.elem.globalData.frameId;
	        }

	        function setInverted(){
	            this.inverted = true;
	            this.iv = new Matrix();
	            if(!this.k){
	                if(this.data.p.s){
	                    this.iv.translate(this.px.v,this.py.v,-this.pz.v);
	                }else{
	                    this.iv.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	                if(this.r){
	                    this.iv.rotate(-this.r.v);
	                }else{
	                    this.iv.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	                }
	                if(this.s){
	                    this.iv.scale(this.s.v[0],this.s.v[1],1);
	                }
	                if(this.a){
	                    this.iv.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);
	                }
	            }
	        }

	        function autoOrient(){
	            //
	            //var prevP = this.getValueAtTime();
	        }

	        return function TransformProperty(elem,data,arr){
	            this.elem = elem;
	            this.frameId = -1;
	            this.type = 'transform';
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.data = data;
	            this.getValue = processKeys;
	            this.applyToMatrix = applyToMatrix;
	            this.setInverted = setInverted;
	            this.autoOrient = autoOrient;
	            this.v = new Matrix();
	            if(data.p.s){
	                this.px = PropertyFactory.getProp(elem,data.p.x,0,0,this.dynamicProperties);
	                this.py = PropertyFactory.getProp(elem,data.p.y,0,0,this.dynamicProperties);
	                if(data.p.z){
	                    this.pz = PropertyFactory.getProp(elem,data.p.z,0,0,this.dynamicProperties);
	                }
	            }else{
	                this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            }
	            if(data.r) {
	                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this.dynamicProperties);
	            } else if(data.rx) {
	                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this.dynamicProperties);
	                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this.dynamicProperties);
	                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this.dynamicProperties);
	                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this.dynamicProperties);
	            }
	            if(data.sk){
	                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this.dynamicProperties);
	                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this.dynamicProperties);
	            }
	            if(data.a) {
	                this.a = PropertyFactory.getProp(elem,data.a,1,0,this.dynamicProperties);
	            }
	            if(data.s) {
	                this.s = PropertyFactory.getProp(elem,data.s,1,0.01,this.dynamicProperties);
	            }
	            if(data.o){
	                this.o = PropertyFactory.getProp(elem,data.o,0,0.01,arr);
	            } else {
	                this.o = {mdf:false,v:1};
	            }
	            if(this.dynamicProperties.length){
	                arr.push(this);
	            }else{
	                if(this.a){
	                    this.v.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);
	                }
	                if(this.s){
	                    this.v.scale(this.s.v[0],this.s.v[1],this.s.v[2]);
	                }
	                if(this.sk){
	                    this.v.skewFromAxis(-this.sk.v,this.sa.v);
	                }
	                if(this.r){
	                    this.v.rotate(-this.r.v);
	                }else{
	                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	                }
	                if(this.data.p.s){
	                    if(data.p.z) {
	                        this.v.translate(this.px.v, this.py.v, -this.pz.v);
	                    } else {
	                        this.v.translate(this.px.v, this.py.v, 0);
	                    }
	                }else{
	                    this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	            }
	            Object.defineProperty(this, "position", { get: positionGetter});
	            Object.defineProperty(this, "xPosition", { get: xPositionGetter});
	            Object.defineProperty(this, "yPosition", { get: yPositionGetter});
	            Object.defineProperty(this, "orientation", { get: orientationGetter});
	            Object.defineProperty(this, "anchorPoint", { get: anchorGetter});
	            Object.defineProperty(this, "rotation", { get: rotationGetter});
	            Object.defineProperty(this, "scale", { get: scaleGetter});
	            Object.defineProperty(this, "opacity", { get: opacityGetter});
	            Object.defineProperty(this, "skew", { get: skewGetter});
	            Object.defineProperty(this, "skewAxis", { get: skewAxisGetter});
	        }
	    }());

	    function getProp(elem,data,type, mult, arr) {
	        var p;
	        if(type === 2){
	            p = new TransformProperty(elem, data, arr);
	        } else if(data.a === 0){
	            if(type === 0) {
	                p = new ValueProperty(elem,data,mult);
	            } else {
	                p = new MultiDimensionalProperty(elem,data, mult);
	            }
	        } else if(data.a === 1){
	            if(type === 0) {
	                p = new KeyframedValueProperty(elem,data,mult);
	            } else {
	                p = new KeyframedMultidimensionalProperty(elem,data, mult);
	            }
	        } else if(!data.k.length){
	            p = new ValueProperty(elem,data, mult);
	        }else if(typeof(data.k[0]) === 'number'){
	            p = new MultiDimensionalProperty(elem,data, mult);
	        }else{
	            switch(type){
	                case 0:
	                    p = new KeyframedValueProperty(elem,data,mult);
	                    break;
	                case 1:
	                    p = new KeyframedMultidimensionalProperty(elem,data,mult);
	                    break;
	            }
	        }
	        if(p.k){
	            arr.push(p);
	        }
	        return p;
	    }

	    var getGradientProp = (function(){

	        function getValue(forceRender){
	            this.prop.getValue();
	            this.cmdf = false;
	            this.omdf = false;
	            if(this.prop.mdf || forceRender){
	                var i, len = this.data.p*4;
	                var mult, val;
	                for(i=0;i<len;i+=1){
	                    mult = i%4 === 0 ? 100 : 255;
	                    val = Math.round(this.prop.v[i]*mult);
	                    if(this.c[i] !== val){
	                        this.c[i] = val;
	                        this.cmdf = true;
	                    }
	                }
	                if(this.o.length){
	                    len = this.prop.v.length;
	                    for(i=this.data.p*4;i<len;i+=1){
	                        mult = i%2 === 0 ? 100 : 1;
	                        val = i%2 === 0 ?  Math.round(this.prop.v[i]*100):this.prop.v[i];
	                        if(this.o[i-this.data.p*4] !== val){
	                            this.o[i-this.data.p*4] = val;
	                            this.omdf = true;
	                        }
	                    }
	                }
	            }

	        }

	        function gradientProp(elem,data,arr){
	            this.prop = getProp(elem,data.k,1,null,[]);
	            this.data = data;
	            this.k = this.prop.k;
	            this.c = Array.apply(null,{length:data.p*4});
	            var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p*4) : data.k.k.length - data.p*4;
	            this.o = Array.apply(null,{length:cLength});
	            this.cmdf = false;
	            this.omdf = false;
	            this.getValue = getValue;
	            if(this.prop.k){
	                arr.push(this);
	            }
	            this.getValue(true);
	        }

	        return function getGradientProp(elem,data,arr){
	            return new gradientProp(elem,data,arr);
	        }
	    }());




	    var DashProperty = (function(){

	        function processKeys(forceRender){
	            var i = 0, len = this.dataProps.length;

	            if(this.elem.globalData.frameId === this.frameId && !forceRender){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            while(i<len){
	                if(this.dataProps[i].p.mdf){
	                    this.mdf = true;
	                    break;
	                }
	                i+=1;
	            }
	            if(this.mdf || forceRender){
	                if(this.renderer === 'svg') {
	                    this.dasharray = '';
	                }
	                for(i=0;i<len;i+=1){
	                    if(this.dataProps[i].n != 'o'){
	                        if(this.renderer === 'svg') {
	                            this.dasharray += ' ' + this.dataProps[i].p.v;
	                        }else{
	                            this.dasharray[i] = this.dataProps[i].p.v;
	                        }
	                    }else{
	                        this.dashoffset = this.dataProps[i].p.v;
	                    }
	                }
	            }
	        }

	        return function(elem, data,renderer, dynamicProperties){
	            this.elem = elem;
	            this.frameId = -1;
	            this.dataProps = new Array(data.length);
	            this.renderer = renderer;
	            this.mdf = false;
	            this.k = false;
	            if(this.renderer === 'svg'){
	                this.dasharray = '';
	            }else{

	                this.dasharray = new Array(data.length - 1);
	            }
	            this.dashoffset = 0;
	            var i, len = data.length, prop;
	            for(i=0;i<len;i+=1){
	                prop = PropertyFactory.getProp(elem,data[i].v,0, 0, dynamicProperties);
	                this.k = prop.k ? true : this.k;
	                this.dataProps[i] = {n:data[i].n,p:prop};
	            }
	            this.getValue = processKeys;
	            if(this.k){
	                dynamicProperties.push(this);
	            }else{
	                this.getValue(true);
	            }

	        }
	    }());

	    function getDashProp(elem, data,renderer, dynamicProperties) {
	        return new DashProperty(elem, data,renderer, dynamicProperties);
	    };

	    var TextSelectorProp = (function(){
	        var max = Math.max;
	        var min = Math.min;
	        var floor = Math.floor;
	        function updateRange(){
	            if(this.dynamicProperties.length){
	                var i, len = this.dynamicProperties.length;
	                for(i=0;i<len;i+=1){
	                    this.dynamicProperties[i].getValue();
	                    if(this.dynamicProperties[i].mdf){
	                        this.mdf = true;
	                    }
	                }
	            }
	            var totalChars = this.data.totalChars;
	            var divisor = this.data.r === 2 ? 1 : 100/totalChars;
	            var o = this.o.v/divisor;
	            var s = this.s.v/divisor + o;
	            var e = (this.e.v/divisor) + o;
	            if(s>e){
	                var _s = s;
	                s = e;
	                e = _s;
	            }
	            this.finalS = s;
	            this.finalE = e;
	        }

	        function getMult(ind){
	            //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
	            var easer = BezierFactory.getBezierEasing(this.ne.v/100,0,1-this.xe.v/100,1).get;
	            var mult = 0;
	            var s = this.finalS;
	            var e = this.finalE;
	            var type = this.data.sh;
	            if(type == 2){
	                if(e === s){
	                    mult = ind >= e ? 1 : 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }
	                mult = easer(mult);
	            }else if(type == 3){
	                if(e === s){
	                    mult = ind >= e ? 0 : 1;
	                }else{
	                    mult = 1 - max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }

	                mult = easer(mult);
	            }else if(type == 4){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                    if(mult<.5){
	                        mult *= 2;
	                    }else{
	                        mult = 1 - 2*(mult-0.5);
	                    }
	                }
	                mult = easer(mult);
	            }else if(type == 5){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    var tot = e - s;
	                    /*ind += 0.5;
	                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    var x = -tot/2+ind;
	                    var a = tot/2;
	                    mult = Math.sqrt(1 - (x*x)/(a*a));
	                }
	                mult = easer(mult);
	            }else if(type == 6){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind)/(e-s)))))/2;
	                    /*
	                     ind = Math.min(Math.max(s,ind),e-1);
	                     mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind-s)/(e-1-s)))))/2;
	                     mult = Math.max(mult,(1/(e-1-s))/(e-1-s));*/
	                }
	                mult = easer(mult);
	            }else {
	                if(ind >= floor(s)){
	                    if(ind-s < 0){
	                        mult = 1 - (s - ind);
	                    }else{
	                        mult = max(0,min(e-ind,1));
	                    }
	                }
	                mult = easer(mult);
	            }
	            return mult*this.a.v;
	        }

	        return function TextSelectorProp(elem,data, arr){
	            this.mdf = false;
	            this.k = false;
	            this.data = data;
	            this.dynamicProperties = [];
	            this.getValue = updateRange;
	            this.getMult = getMult;
	            this.comp = elem.comp;
	            this.finalS = 0;
	            this.finalE = 0;
	            this.s = PropertyFactory.getProp(elem,data.s || {k:0},0,0,this.dynamicProperties);
	            if('e' in data){
	                this.e = PropertyFactory.getProp(elem,data.e,0,0,this.dynamicProperties);
	            }else{
	                this.e = {v:data.r === 2 ? data.totalChars : 100};
	            }
	            this.o = PropertyFactory.getProp(elem,data.o || {k:0},0,0,this.dynamicProperties);
	            this.xe = PropertyFactory.getProp(elem,data.xe || {k:0},0,0,this.dynamicProperties);
	            this.ne = PropertyFactory.getProp(elem,data.ne || {k:0},0,0,this.dynamicProperties);
	            this.a = PropertyFactory.getProp(elem,data.a,0,0.01,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                arr.push(this);
	            }else{
	                this.getValue();
	            }
	        }
	    }());

	    function getTextSelectorProp(elem, data,arr) {
	        return new TextSelectorProp(elem, data, arr);
	    };

	    var ob = {};
	    ob.getProp = getProp;
	    ob.getDashProp = getDashProp;
	    ob.getTextSelectorProp = getTextSelectorProp;
	    ob.getGradientProp = getGradientProp;
	    return ob;
	}());
	function ShapePath(){
		this.c = false;
		this._length = 0;
		this._maxLength = 8;
		this.v = Array.apply(null,{length:this._maxLength});
		this.o = Array.apply(null,{length:this._maxLength});
		this.i = Array.apply(null,{length:this._maxLength});
	};

	ShapePath.prototype.setPathData = function(closed, len) {
		this.c = closed;
		while(len > this._maxLength){
			this.doubleArrayLength();
		}
		var i = 0;
		while(i < len){
			this.v[i] = point_pool.newPoint();
			this.o[i] = point_pool.newPoint();
			this.i[i] = point_pool.newPoint();
			i += 1;
		}
		this._length = len;
	};

	ShapePath.prototype.doubleArrayLength = function() {
		this.v = this.v.concat(Array.apply(null,{length:this._maxLength}))
		this.i = this.i.concat(Array.apply(null,{length:this._maxLength}))
		this.o = this.o.concat(Array.apply(null,{length:this._maxLength}))
		this._maxLength *= 2;
	};

	ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
		var arr;
		this._length = Math.max(this._length, pos + 1);
		if(this._length >= this._maxLength) {
			this.doubleArrayLength();
		}
		switch(type){
			case 'v':
				arr = this.v;
				break;
			case 'i':
				arr = this.i;
				break;
			case 'o':
				arr = this.o;
				break;
		}
		if(!arr[pos] || (arr[pos] && !replace)){
			arr[pos] = point_pool.newPoint();
		}
		arr[pos][0] = x;
		arr[pos][1] = y;
	};

	ShapePath.prototype.setTripleAt = function(vX,vY,oX,oY,iX,iY,pos, replace) {
		this.setXYAt(vX,vY,'v',pos, replace);
		this.setXYAt(oX,oY,'o',pos, replace);
		this.setXYAt(iX,iY,'i',pos, replace);
	};
	var ShapePropertyFactory = (function(){

	    var initFrame = -999999;

	    function interpolateShape() {
	        if(this.elem.globalData.frameId === this.frameId){
	            return;
	        }
	        this.mdf = false;
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        if(!((this.lastFrame !== initFrame && ((this.lastFrame < this.keyframes[0].t-this.offsetTime && frameNum < this.keyframes[0].t-this.offsetTime) || (this.lastFrame > this.keyframes[this.keyframes.length - 1].t-this.offsetTime && frameNum > this.keyframes[this.keyframes.length - 1].t-this.offsetTime))))){
	            var keyPropS,keyPropE,isHold;
	            if(frameNum < this.keyframes[0].t-this.offsetTime){
	                keyPropS = this.keyframes[0].s[0];
	                isHold = true;
	                this._lastIndex = 0;
	            }else if(frameNum >= this.keyframes[this.keyframes.length - 1].t-this.offsetTime){
	                if(this.keyframes[this.keyframes.length - 2].h === 1){
	                    keyPropS = this.keyframes[this.keyframes.length - 1].s[0];
	                }else{
	                    keyPropS = this.keyframes[this.keyframes.length - 2].e[0];
	                }
	                isHold = true;
	            }else{
	                var i = this.lastFrame < initFrame ? this._lastIndex : 0;
	                var len = this.keyframes.length- 1,flag = true,keyData,nextKeyData, j, jLen, k, kLen;
	                while(flag){
	                    keyData = this.keyframes[i];
	                    nextKeyData = this.keyframes[i+1];
	                    if((nextKeyData.t - this.offsetTime) > frameNum){
	                        break;
	                    }
	                    if(i < len - 1){
	                        i += 1;
	                    }else{
	                        flag = false;
	                    }
	                }
	                isHold = keyData.h === 1;
	                this._lastIndex = i;

	                var perc;
	                if(!isHold){
	                    if(frameNum >= nextKeyData.t-this.offsetTime){
	                        perc = 1;
	                    }else if(frameNum < keyData.t-this.offsetTime){
	                        perc = 0;
	                    }else{
	                        var fnc;
	                        if(keyData.__fnct){
	                            fnc = keyData.__fnct;
	                        }else{
	                            fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;
	                            keyData.__fnct = fnc;
	                        }
	                        perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
	                    }
	                    keyPropE = keyData.e[0];
	                }
	                keyPropS = keyData.s[0];
	            }
	            jLen = this.v._length;
	            kLen = keyPropS.i[0].length;
	            var hasModified = false;
	            var vertexValue;
	            for(j=0;j<jLen;j+=1){
	                for(k=0;k<kLen;k+=1){
	                    if(isHold){
	                        vertexValue = keyPropS.i[j][k];
	                        if(this.v.i[j][k] !== vertexValue){
	                            this.v.i[j][k] = vertexValue;
	                            this.pv.i[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                        vertexValue = keyPropS.o[j][k];
	                        if(this.v.o[j][k] !== vertexValue){
	                            this.v.o[j][k] = vertexValue;
	                            this.pv.o[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                        vertexValue = keyPropS.v[j][k];
	                        if(this.v.v[j][k] !== vertexValue){
	                            this.v.v[j][k] = vertexValue;
	                            this.pv.v[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                    }else{
	                        vertexValue = keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;
	                        if(this.v.i[j][k] !== vertexValue){
	                            this.v.i[j][k] = vertexValue;
	                            this.pv.i[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                        vertexValue = keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;
	                        if(this.v.o[j][k] !== vertexValue){
	                            this.v.o[j][k] = vertexValue;
	                            this.pv.o[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                        vertexValue = keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;
	                        if(this.v.v[j][k] !== vertexValue){
	                            this.v.v[j][k] = vertexValue;
	                            this.pv.v[j][k] = vertexValue;
	                            hasModified = true;
	                        }
	                    }
	                }
	            }
	            this.mdf = hasModified;
	            this.v.c = keyPropS.c;
	            this.paths = this.localShapeCollection;
	        }

	        this.lastFrame = frameNum;
	        this.frameId = this.elem.globalData.frameId;
	    }

	    function getShapeValue(){
	        return this.v;
	    }

	    function resetShape(){
	        this.paths = this.localShapeCollection;
	        if(!this.k){
	            this.mdf = false;
	        }
	    }

	    function ShapeProperty(elem, data, type){
	        this.comp = elem.comp;
	        this.k = false;
	        this.mdf = false;
	        this.v = shape_pool.newShape();
	        var pathData = type === 3 ? data.pt.k : data.ks.k;
	        this.v.v = pathData.v;
	        this.v.i = pathData.i;
	        this.v.o = pathData.o;
	        this.v.c = pathData.c;
	        this.v._length = this.v.v.length;
	        this.getValue = getShapeValue;
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.reset = resetShape;
	    }

	    function KeyframedShapeProperty(elem,data,type){
	        this.comp = elem.comp;
	        this.elem = elem;
	        this.offsetTime = elem.data.st;
	        this._lastIndex = 0;
	        this.getValue = interpolateShape;
	        this.keyframes = type === 3 ? data.pt.k : data.ks.k;
	        this.k = true;
	        var i, len = this.keyframes[0].s[0].i.length;
	        var jLen = this.keyframes[0].s[0].i[0].length;
	        this.v = shape_pool.newShape();
	        this.v.setPathData(this.keyframes[0].s[0].c, len);
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.lastFrame = initFrame;
	        this.reset = resetShape;
	    }

	    var EllShapeProperty = (function(){

	        var cPoint = roundCorner;

	        function convertEllToPath(){
	            var p0 = this.p.v[0], p1 = this.p.v[1], s0 = this.s.v[0]/2, s1 = this.s.v[1]/2;
	            if(this.d !== 3){
	                this.v.v[0][0] = p0;
	                this.v.v[0][1] = p1-s1;
	                this.v.v[1][0] = p0 + s0;
	                this.v.v[1][1] = p1;
	                this.v.v[2][0] = p0;
	                this.v.v[2][1] = p1+s1;
	                this.v.v[3][0] = p0 - s0;
	                this.v.v[3][1] = p1;
	                this.v.i[0][0] = p0 - s0*cPoint;
	                this.v.i[0][1] = p1 - s1;
	                this.v.i[1][0] = p0 + s0;
	                this.v.i[1][1] = p1 - s1*cPoint;
	                this.v.i[2][0] = p0 + s0*cPoint;
	                this.v.i[2][1] = p1 + s1;
	                this.v.i[3][0] = p0 - s0;
	                this.v.i[3][1] = p1 + s1*cPoint;
	                this.v.o[0][0] = p0 + s0*cPoint;
	                this.v.o[0][1] = p1 - s1;
	                this.v.o[1][0] = p0 + s0;
	                this.v.o[1][1] = p1 + s1*cPoint;
	                this.v.o[2][0] = p0 - s0*cPoint;
	                this.v.o[2][1] = p1 + s1;
	                this.v.o[3][0] = p0 - s0;
	                this.v.o[3][1] = p1 - s1*cPoint;
	            }else{
	                this.v.v[0][0] = p0;
	                this.v.v[0][1] = p1-s1;
	                this.v.v[1][0] = p0 - s0;
	                this.v.v[1][1] = p1;
	                this.v.v[2][0] = p0;
	                this.v.v[2][1] = p1+s1;
	                this.v.v[3][0] = p0 + s0;
	                this.v.v[3][1] = p1;
	                this.v.i[0][0] = p0 + s0*cPoint;
	                this.v.i[0][1] = p1 - s1;
	                this.v.i[1][0] = p0 - s0;
	                this.v.i[1][1] = p1 - s1*cPoint;
	                this.v.i[2][0] = p0 - s0*cPoint;
	                this.v.i[2][1] = p1 + s1;
	                this.v.i[3][0] = p0 + s0;
	                this.v.i[3][1] = p1 + s1*cPoint;
	                this.v.o[0][0] = p0 - s0*cPoint;
	                this.v.o[0][1] = p1 - s1;
	                this.v.o[1][0] = p0 - s0;
	                this.v.o[1][1] = p1 + s1*cPoint;
	                this.v.o[2][0] = p0 + s0*cPoint;
	                this.v.o[2][1] = p1 + s1;
	                this.v.o[3][0] = p0 + s0;
	                this.v.o[3][1] = p1 - s1*cPoint;
	            }
	        }

	        function processKeys(frameNum){
	            var i, len = this.dynamicProperties.length;
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue(frameNum);
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertEllToPath();
	            }
	        }

	        return function EllShapeProperty(elem,data) {
	            /*this.v = {
	                v: Array.apply(null,{length:4}),
	                i: Array.apply(null,{length:4}),
	                o: Array.apply(null,{length:4}),
	                c: true
	            };*/
	            this.v = shape_pool.newShape();
	            this.v.setPathData(true, 4);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.paths = this.localShapeCollection;
	            this.localShapeCollection.addShape(this.v);
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.convertEllToPath = convertEllToPath;
	            this.reset = resetShape;
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertEllToPath();
	            }
	        }
	    }());

	    var StarShapeProperty = (function() {

	        function convertPolygonToPath(){
	            var numPts = Math.floor(this.pt.v);
	            var angle = Math.PI*2/numPts;
	            /*this.v.v.length = numPts;
	            this.v.i.length = numPts;
	            this.v.o.length = numPts;*/
	            var rad = this.or.v;
	            var roundness = this.os.v;
	            var perimSegment = 2*Math.PI*rad/(numPts*4);
	            var i, currentAng = -Math.PI/ 2;
	            var dir = this.data.d === 3 ? -1 : 1;
	            currentAng += this.r.v;
	            this.v._length = 0;
	            for(i=0;i<numPts;i+=1){
	                var x = rad * Math.cos(currentAng);
	                var y = rad * Math.sin(currentAng);
	                var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                x +=  + this.p.v[0];
	                y +=  + this.p.v[1];
	                this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);
	                /*this.v.v[i] = [x,y];
	                this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];*/
	                currentAng += angle*dir;
	            }
	            this.paths.length = 0;
	            this.paths[0] = this.v;
	        }

	        function convertStarToPath() {
	            var numPts = Math.floor(this.pt.v)*2;
	            var angle = Math.PI*2/numPts;
	            /*this.v.v.length = numPts;
	            this.v.i.length = numPts;
	            this.v.o.length = numPts;*/
	            var longFlag = true;
	            var longRad = this.or.v;
	            var shortRad = this.ir.v;
	            var longRound = this.os.v;
	            var shortRound = this.is.v;
	            var longPerimSegment = 2*Math.PI*longRad/(numPts*2);
	            var shortPerimSegment = 2*Math.PI*shortRad/(numPts*2);
	            var i, rad,roundness,perimSegment, currentAng = -Math.PI/ 2;
	            currentAng += this.r.v;
	            var dir = this.data.d === 3 ? -1 : 1;
	            this.v._length = 0;
	            for(i=0;i<numPts;i+=1){
	                rad = longFlag ? longRad : shortRad;
	                roundness = longFlag ? longRound : shortRound;
	                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
	                var x = rad * Math.cos(currentAng);
	                var y = rad * Math.sin(currentAng);
	                var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                x +=  + this.p.v[0];
	                y +=  + this.p.v[1];
	                this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);

	                /*this.v.v[i] = [x,y];
	                this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
	                this.v._length = numPts;*/
	                longFlag = !longFlag;
	                currentAng += angle*dir;
	            }
	        }

	        function processKeys() {
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            var i, len = this.dynamicProperties.length;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue();
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertToPath();
	            }
	        }

	        return function StarShapeProperty(elem,data) {
	            /*this.v = {
	                v: [],
	                i: [],
	                o: [],
	                c: true
	            };*/
	            this.v = shape_pool.newShape();
	            this.v.setPathData(true, 0);
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.data = data;
	            this.frameId = -1;
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.reset = resetShape;
	            if(data.sy === 1){
	                this.ir = PropertyFactory.getProp(elem,data.ir,0,0,this.dynamicProperties);
	                this.is = PropertyFactory.getProp(elem,data.is,0,0.01,this.dynamicProperties);
	                this.convertToPath = convertStarToPath;
	            } else {
	                this.convertToPath = convertPolygonToPath;
	            }
	            this.pt = PropertyFactory.getProp(elem,data.pt,0,0,this.dynamicProperties);
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.r = PropertyFactory.getProp(elem,data.r,0,degToRads,this.dynamicProperties);
	            this.or = PropertyFactory.getProp(elem,data.or,0,0,this.dynamicProperties);
	            this.os = PropertyFactory.getProp(elem,data.os,0,0.01,this.dynamicProperties);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertToPath();
	            }
	        }
	    }());

	    var RectShapeProperty = (function() {
	        function processKeys(frameNum){
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            var i, len = this.dynamicProperties.length;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue(frameNum);
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertRectToPath();
	            }

	        }

	        function convertRectToPath(){
	            var p0 = this.p.v[0], p1 = this.p.v[1], v0 = this.s.v[0]/2, v1 = this.s.v[1]/2;
	            var round = bm_min(v0,v1,this.r.v);
	            var cPoint = round*(1-roundCorner);
	            this.v._length = 0;

	            if(this.d === 2 || this.d === 1) {
	                this.v.setTripleAt(p0+v0, p1-v1+round,p0+v0, p1-v1+round,p0+v0,p1-v1+cPoint,0, true);
	                this.v.setTripleAt(p0+v0, p1+v1-round,p0+v0, p1+v1-cPoint,p0+v0, p1+v1-round,1, true);
	                if(round!== 0){
	                    this.v.setTripleAt(p0+v0-round, p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2, true);
	                    this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3, true);
	                    this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4, true);
	                    this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5, true);
	                    this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6, true);
	                    this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7, true);
	                } else {
	                    this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);
	                    this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);
	                }
	            }else{
	                this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0, true);
	                if(round!== 0){
	                    this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1, true);
	                    this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2, true);
	                    this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3, true);
	                    this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4, true);
	                    this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5, true);
	                    this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6, true);
	                    this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7, true);
	                } else {
	                    this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1, true);
	                    this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2, true);
	                    this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3, true);

	                }
	            }
	        }

	        return function RectShapeProperty(elem,data) {
	            this.v = shape_pool.newShape();
	            this.v.c = true;
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.convertRectToPath = convertRectToPath;
	            this.reset = resetShape;
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this.dynamicProperties);
	            this.r = PropertyFactory.getProp(elem,data.r,0,0,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertRectToPath();
	            }
	        }
	    }());

	    function getShapeProp(elem,data,type, arr){
	        var prop;
	        if(type === 3 || type === 4){
	            var dataProp = type === 3 ? data.pt : data.ks;
	            var keys = dataProp.k;
	            if(dataProp.a === 1 || keys.length){
	                prop = new KeyframedShapeProperty(elem, data, type);
	            }else{
	                prop = new ShapeProperty(elem, data, type);
	            }
	        }else if(type === 5){
	            prop = new RectShapeProperty(elem, data);
	        }else if(type === 6){
	            prop = new EllShapeProperty(elem, data);
	        }else if(type === 7){
	            prop = new StarShapeProperty(elem, data);
	        }
	        if(prop.k){
	            arr.push(prop);
	        }
	        return prop;
	    }

	    var ob = {};
	    ob.getShapeProp = getShapeProp;
	    return ob;
	}());
	var ShapeModifiers = (function(){
	    var ob = {};
	    var modifiers = {};
	    ob.registerModifier = registerModifier;
	    ob.getModifier = getModifier;

	    function registerModifier(nm,factory){
	        if(!modifiers[nm]){
	            modifiers[nm] = factory;
	        }
	    }

	    function getModifier(nm,elem, data, dynamicProperties){
	        return new modifiers[nm](elem, data, dynamicProperties);
	    }

	    return ob;
	}());

	function ShapeModifier(){}
	ShapeModifier.prototype.initModifierProperties = function(){};
	ShapeModifier.prototype.addShapeToModifier = function(){};
	ShapeModifier.prototype.addShape = function(data){
	    if(!this.closed){
	        this.shapes.push({shape:data.sh, data: data, localShapeCollection:shapeCollection_pool.newShapeCollection()});
	        this.addShapeToModifier(data.sh);
	    }
	}
	ShapeModifier.prototype.init = function(elem,data,dynamicProperties){
	    this.elem = elem;
	    this.frameId = -1;
	    this.shapes = [];
	    this.dynamicProperties = [];
	    this.mdf = false;
	    this.closed = false;
	    this.k = false;
	    this.isTrimming = false;
	    this.comp = elem.comp;
	    this.initModifierProperties(elem,data);
	    if(this.dynamicProperties.length){
	        this.k = true;
	        dynamicProperties.push(this);
	    }else{
	        this.getValue(true);
	    }
	}
	function TrimModifier(){};
	extendPrototype(ShapeModifier,TrimModifier);
	TrimModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    this.frameId = this.elem.globalData.frameId;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	    if(this.mdf || forceRender){
	        var o = (this.o.v%360)/360;
	        if(o < 0){
	            o += 1;
	        }
	        var s = this.s.v + o;
	        var e = this.e.v + o;
	        if(s == e){

	        }
	        if(s>e){
	            var _s = s;
	            s = e;
	            e = _s;
	        }
	        this.sValue = s;
	        this.eValue = e;
	        this.oValue = o;
	    }
	}
	TrimModifier.prototype.initModifierProperties = function(elem,data){
	    this.sValue = 0;
	    this.eValue = 0;
	    this.oValue = 0;
	    this.getValue = this.processKeys;
	    this.s = PropertyFactory.getProp(elem,data.s,0,0.01,this.dynamicProperties);
	    this.e = PropertyFactory.getProp(elem,data.e,0,0.01,this.dynamicProperties);
	    this.o = PropertyFactory.getProp(elem,data.o,0,0,this.dynamicProperties);
	    this.m = data.m;
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	};

	TrimModifier.prototype.getSegmentsLength = function(shapeData){
	    var closed = shapeData.c;
	    var pathV = shapeData.v;
	    var pathO = shapeData.o;
	    var pathI = shapeData.i;
	    var i, len = shapeData._length;
	    var lengths = [];
	    var totalLength = 0;
	    for(i=0;i<len-1;i+=1){
	        lengths[i] = bez.getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);
	        totalLength += lengths[i].addedLength;
	    }
	    if(closed){
	        lengths[i] = bez.getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);
	        totalLength += lengths[i].addedLength;
	    }
	    return {lengths:lengths,totalLength:totalLength};
	}

	TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
	    var segments = []
	    if(e <= 1){
	        segments.push({
	            s: s,
	            e: e
	        })
	    }else if(s >= 1){
	        segments.push({
	            s: s - 1,
	            e: e - 1
	        })
	    }else{
	        segments.push({
	            s: s,
	            e: 1
	        })
	        segments.push({
	            s: 0,
	            e: e - 1
	        })
	    }
	    var shapeSegments = [];
	    var i, len = segments.length, segmentOb;
	    for(i = 0; i < len; i += 1) {
	        segmentOb = segments[i];
	        if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) {
	            
	        } else {
	            var shapeS, shapeE;
	            if(segmentOb.s * totalModifierLength <= addedLength) {
	                shapeS = 0;
	            } else {
	                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
	            }
	            if(segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
	                shapeE = 1;
	            } else {
	                shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
	            }
	            shapeSegments.push([shapeS, shapeE]);
	        }
	    }
	    if(!shapeSegments.length){
	        shapeSegments.push([0,0]);
	    }
	    return shapeSegments;
	}

	TrimModifier.prototype.processShapes = function(firstFrame){
	    var shapePaths;
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var s = this.sValue;
	    var e = this.eValue;
	    var pathsData,pathData, totalShapeLength, totalModifierLength = 0;

	    if(e === s){
	        for(i=0;i<len;i+=1){
	            this.shapes[i].localShapeCollection.releaseShapes();
	            this.shapes[i].shape.mdf = true;
	            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
	        }
	    } else if(!((e === 1 && s === 0) || (e===0 && s === 1))){
	        var segments = [], shapeData, localShapeCollection;
	        for(i=0;i<len;i+=1){
	            shapeData = this.shapes[i];
	            if(!shapeData.shape.mdf && !this.mdf && !firstFrame && this.m !== 2){
	                shapeData.shape.paths = shapeData.localShapeCollection;
	            } else {
	                shapePaths = shapeData.shape.paths;
	                jLen = shapePaths._length;
	                totalShapeLength = 0;
	                if(!shapeData.shape.mdf && shapeData.pathsData){
	                    totalShapeLength = shapeData.totalShapeLength;
	                } else {
	                    pathsData = [];
	                    for(j=0;j<jLen;j+=1){
	                        pathData = this.getSegmentsLength(shapePaths.shapes[j]);
	                        pathsData.push(pathData);
	                        totalShapeLength += pathData.totalLength;
	                    }
	                    shapeData.totalShapeLength = totalShapeLength;
	                    shapeData.pathsData = pathsData;
	                }

	                totalModifierLength += totalShapeLength;
	                shapeData.shape.mdf = true;
	            }
	        }
	        var shapeS = s, shapeE = e, addedLength = 0;
	        var j, jLen;
	        for(i = len - 1; i >= 0; i -= 1){
	            shapeData = this.shapes[i];
	            if (shapeData.shape.mdf) {
	                localShapeCollection = shapeData.localShapeCollection;
	                localShapeCollection.releaseShapes();
	                if(this.m === 2 && len > 1) {
	                    var edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
	                    addedLength += shapeData.totalShapeLength;
	                } else {
	                    edges = [[shapeS, shapeE]]
	                }
	                jLen = edges.length;
	                for (j = 0; j < jLen; j += 1) {
	                    shapeS = edges[j][0];
	                    shapeE = edges[j][1];
	                    segments.length = 0;
	                    if(shapeE <= 1){
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength * shapeE
	                        })
	                    }else if(shapeS >= 1){
	                        segments.push({
	                            s:shapeData.totalShapeLength * (shapeS - 1),
	                            e:shapeData.totalShapeLength * (shapeE - 1)
	                        })
	                    }else{
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength
	                        })
	                        segments.push({
	                            s:0,
	                            e:shapeData.totalShapeLength*(shapeE - 1)
	                        })
	                    }
	                    var newShapesData = this.addShapes(shapeData,segments[0]);
	                    if (segments[0].s !== segments[0].e) {
	                        var lastPos;
	                        if(segments.length > 1){
	                            if(shapeData.shape.v.c){
	                                var lastShape = newShapesData.pop();
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData,segments[1], lastShape);
	                            } else {
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData,segments[1]);
	                            }
	                        } 
	                        this.addPaths(newShapesData, localShapeCollection);
	                    }
	                    
	                }
	                shapeData.shape.paths = localShapeCollection;
	            }
	        }
	    }
	    if(!this.dynamicProperties.length){
	        this.mdf = false;
	    }
	}

	TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
	    var i, len = newPaths.length;
	    for(i = 0; i < len; i += 1) {
	        localShapeCollection.addShape(newPaths[i])
	    }
	}

	TrimModifier.prototype.addSegment = function(pt1,pt2,pt3,pt4,shapePath,pos, newShape) {
	    /*console.log(pt1, 'vertex: v, at: ', pos);
	    console.log(pt2, 'vertex: o, at: ', pos);
	    console.log(pt3, 'vertex: i, at: ', pos + 1);
	    console.log(pt4, 'vertex: v, at: ', pos + 1);
	    console.log('newShape: ', newShape);*/
	    shapePath.setXYAt(pt2[0],pt2[1],'o',pos);
	    shapePath.setXYAt(pt3[0],pt3[1],'i',pos + 1);
	    if(newShape){
	        shapePath.setXYAt(pt1[0],pt1[1],'v',pos);
	    }
	    shapePath.setXYAt(pt4[0],pt4[1],'v',pos + 1);
	}

	TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath){
	    var pathsData = shapeData.pathsData;
	    var shapePaths = shapeData.shape.paths.shapes;
	    var i, len = shapeData.shape.paths._length, j, jLen;
	    var addedLength = 0;
	    var currentLengthData,segmentCount;
	    var lengths;
	    var segment;
	    var shapes = [];
	    var initPos;
	    var newShape = true;
	    if(!shapePath){
	        shapePath = shape_pool.newShape();
	        segmentCount = 0;
	        initPos = 0;
	    } else {
	        segmentCount = shapePath._length;
	        initPos = shapePath._length;
	    }
	    shapes.push(shapePath);
	    for(i=0;i<len;i+=1){
	        lengths = pathsData[i].lengths;
	        shapePath.c = shapePaths[i].c;
	        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
	        for(j=1;j<jLen;j+=1){
	            currentLengthData = lengths[j-1];
	            if(addedLength + currentLengthData.addedLength < shapeSegment.s){
	                addedLength += currentLengthData.addedLength;
	                shapePath.c = false;
	            } else if(addedLength > shapeSegment.e){
	                shapePath.c = false;
	                break;
	            } else {
	                if(shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength){
	                    this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[j],shapePaths[i].v[j],shapePath,segmentCount,newShape);
	                    newShape = false;
	                } else {
	                    segment = bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[j],shapePaths[i].o[j-1],shapePaths[i].i[j], (shapeSegment.s - addedLength)/currentLengthData.addedLength,(shapeSegment.e - addedLength)/currentLengthData.addedLength, lengths[j-1]);
	                    this.addSegment(segment.pt1,segment.pt3,segment.pt4,segment.pt2,shapePath,segmentCount,newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	                addedLength += currentLengthData.addedLength;
	                segmentCount += 1;
	            }
	        }
	        if(shapePaths[i].c){
	            currentLengthData = lengths[j-1];
	            if(addedLength <= shapeSegment.e){
	                var segmentLength = lengths[j-1].addedLength;
	                if(shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength){
	                    this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[0],shapePaths[i].v[0],shapePath,segmentCount,newShape);
	                    newShape = false;
	                }else{
	                    segment = bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[0],shapePaths[i].o[j-1],shapePaths[i].i[0], (shapeSegment.s - addedLength)/segmentLength,(shapeSegment.e - addedLength)/segmentLength, lengths[j-1]);
	                    this.addSegment(segment.pt1,segment.pt3,segment.pt4,segment.pt2,shapePath,segmentCount,newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	            } else {
	                shapePath.c = false;
	            }
	            addedLength += currentLengthData.addedLength;
	            segmentCount += 1;
	        }
	        if(shapePath._length){
	            shapePath.setXYAt(shapePath.v[initPos][0],shapePath.v[initPos][1],'i',initPos);
	            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0],shapePath.v[shapePath._length - 1][1],'o',shapePath._length - 1);
	        }
	        if(addedLength > shapeSegment.e){
	            break;
	        }
	        if(i<len-1){
	            shapePath = shape_pool.newShape();
	            newShape = true;
	            shapes.push(shapePath);
	            segmentCount = 0;
	        }
	    }
	    return shapes;

	}


	ShapeModifiers.registerModifier('tm',TrimModifier);
	function RoundCornersModifier(){};
	extendPrototype(ShapeModifier,RoundCornersModifier);
	RoundCornersModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    this.frameId = this.elem.globalData.frameId;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	}
	RoundCornersModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.rd = PropertyFactory.getProp(elem,data.r,0,null,this.dynamicProperties);
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	};

	RoundCornersModifier.prototype.processPath = function(path, round){
	    var cloned_path = shape_pool.newShape();
	    cloned_path.c = path.c;
	    var i, len = path._length;
	    var currentV,currentI,currentO,closerV, newV,newO,newI,distance,newPosPerc,index = 0;
	    var vX,vY,oX,oY,iX,iY;
	    for(i=0;i<len;i+=1){
	        currentV = path.v[i];
	        currentO = path.o[i];
	        currentI = path.i[i];
	        if(currentV[0]===currentO[0] && currentV[1]===currentO[1] && currentV[0]===currentI[0] && currentV[1]===currentI[1]){
	            if((i===0 || i === len - 1) && !path.c){
	                cloned_path.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);
	                /*cloned_path.v[index] = currentV;
	                cloned_path.o[index] = currentO;
	                cloned_path.i[index] = currentI;*/
	                index += 1;
	            } else {
	                if(i===0){
	                    closerV = path.v[len-1];
	                } else {
	                    closerV = path.v[i-1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = iX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = iY = currentV[1]-(currentV[1]-closerV[1])*newPosPerc;
	                oX = vX-(vX-currentV[0])*roundCorner;
	                oY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
	                /*newV = [currentV[0]+(closerV[0]-currentV[0])*newPosPerc,currentV[1]-(currentV[1]-closerV[1])*newPosPerc];
	                newI = newV;
	                newO = [newV[0]-(newV[0]-currentV[0])*roundCorner,newV[1]-(newV[1]-currentV[1])*roundCorner];
	                cloned_path.v[index] = newV;
	                cloned_path.i[index] = newI;
	                cloned_path.o[index] = newO;*/
	                index += 1;

	                if(i === len - 1){
	                    closerV = path.v[0];
	                } else {
	                    closerV = path.v[i+1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = oX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = oY = currentV[1]+(closerV[1]-currentV[1])*newPosPerc;
	                iX = vX-(vX-currentV[0])*roundCorner;
	                iY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);

	                /*newV = [currentV[0]+(closerV[0]-currentV[0])*newPosPerc,currentV[1]+(closerV[1]-currentV[1])*newPosPerc];
	                newI = [newV[0]-(newV[0]-currentV[0])*roundCorner,newV[1]-(newV[1]-currentV[1])*roundCorner];
	                newO = newV;
	                cloned_path.v[index] = newV;
	                cloned_path.i[index] = newI;
	                cloned_path.o[index] = newO;*/
	                index += 1;
	            }
	        } else {
	            /*cloned_path.v[index] = path.v[i];
	            cloned_path.o[index] = path.o[i];
	            cloned_path.i[index] = path.i[i];*/
	            cloned_path.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);
	            index += 1;
	        }
	    }
	    return cloned_path;
	}

	RoundCornersModifier.prototype.processShapes = function(firstFrame){
	    var shapePaths;
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var rd = this.rd.v;

	    if(rd !== 0){
	        var shapeData, newPaths, localShapeCollection;
	        for(i=0;i<len;i+=1){
	            shapeData = this.shapes[i];
	            newPaths = shapeData.shape.paths;
	            localShapeCollection = shapeData.localShapeCollection;
	            if(!(!shapeData.shape.mdf && !this.mdf && !firstFrame)){
	                localShapeCollection.releaseShapes();
	                shapeData.shape.mdf = true;
	                shapePaths = shapeData.shape.paths.shapes;
	                jLen = shapeData.shape.paths._length;
	                for(j=0;j<jLen;j+=1){
	                    localShapeCollection.addShape(this.processPath(shapePaths[j],rd));
	                }
	            }
	            shapeData.shape.paths = shapeData.localShapeCollection;
	        }

	    }
	    if(!this.dynamicProperties.length){
	        this.mdf = false;
	    }
	}


	ShapeModifiers.registerModifier('rd',RoundCornersModifier);
	function RepeaterModifier(){};
	extendPrototype(ShapeModifier,RepeaterModifier);
	RepeaterModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    this.frameId = this.elem.globalData.frameId;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	};
	RepeaterModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.c = PropertyFactory.getProp(elem,data.c,0,null,this.dynamicProperties);
	    this.o = PropertyFactory.getProp(elem,data.o,0,null,this.dynamicProperties);
	    this.tr = PropertyFactory.getProp(elem,data.tr,2,null,this.dynamicProperties);
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	    this.pMatrix = new Matrix();
	    this.rMatrix = new Matrix();
	    this.sMatrix = new Matrix();
	    this.tMatrix = new Matrix();
	    this.matrix = new Matrix();
	};

	RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv){
	    var dir = inv ? -1 : 1;
	    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
	    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
	    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
	    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    rMatrix.rotate(-transform.r.v * dir * perc);
	    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    sMatrix.scale(inv ? 1/scaleX : scaleX, inv ? 1/scaleY : scaleY);
	    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	}

	RepeaterModifier.prototype.processShapes = function(firstFrame){
	    if(!this.dynamicProperties.length){
	        this.mdf = false;
	    }
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var shapeData, localShapeCollection, currentPath;
	    var copies = Math.ceil(this.c.v);
	    var offset = this.o.v;
	    var offsetModulo = offset%1;
	    var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
	    var k, pathData, shapeCollection, shapeCollectionList;
	    var tMat = this.tr.v.props;
	    var pProps = this.pMatrix.props;
	    var rProps = this.rMatrix.props;
	    var sProps = this.sMatrix.props;
	    var iteration = 0;
	    var l, lLen, tProps,transformers, maxLvl;
	    for(i=0;i<len;i+=1){
	        shapeData = this.shapes[i];
	        localShapeCollection = shapeData.localShapeCollection;
	        if(!(!shapeData.shape.mdf && !this.mdf && !firstFrame)){
	            localShapeCollection.releaseShapes();
	            shapeData.shape.mdf = true;
	            shapeCollection = shapeData.shape.paths;
	            shapeCollectionList = shapeCollection.shapes;
	            jLen = shapeCollection._length;
	            iteration = 0;
	            this.pMatrix.reset();
	            this.rMatrix.reset();
	            this.sMatrix.reset();
	            this.tMatrix.reset();
	            this.matrix.reset();

	            if(offset > 0) {
	                while(iteration<roundOffset){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                    iteration += 1;
	                }
	                if(offsetModulo){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
	                    iteration += offsetModulo;
	                }
	            } else if(roundOffset < 0) {
	                while(iteration>roundOffset){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
	                    iteration -= 1;
	                }
	                if(offsetModulo){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, - offsetModulo, true);
	                    iteration -= offsetModulo;
	                }
	            }
	            for(j=0;j<jLen;j+=1){
	                currentPath = shapeCollectionList[j];
	                for(k=0;k<copies;k+=1) {
	                    if(k !== 0) {
	                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                    }
	                    if(shapeData.data.transformers) {
	                        shapeData.data.lvl = 0;
	                        maxLvl = 0;
	                        lLen = shapeData.data.elements.length;
	                        for(l = 0; l < lLen; l += 1) {
	                            maxLvl = Math.max(maxLvl, shapeData.data.elements[l].st.lvl);
	                        } 
	                        transformers = shapeData.data.transformers;
	                        lLen = transformers.length;
	                        for(l = lLen - 1; l >= maxLvl; l -= 1) {
	                            tProps = transformers[l].mProps.v.props;
	                            this.matrix.transform(tProps[0],tProps[1],tProps[2],tProps[3],tProps[4],tProps[5],tProps[6],tProps[7],tProps[8],tProps[9],tProps[10],tProps[11],tProps[12],tProps[13],tProps[14],tProps[15]);
	                        }
	                    }
	                    if(iteration !== 0){
	                        this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);
	                        this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);
	                        this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);
	                    }
	                    localShapeCollection.addShape(this.processPath(currentPath, this.matrix));
	                    this.matrix.reset();
	                    iteration += 1;
	                }
	            }
	        }
	        shapeData.shape.paths = localShapeCollection;
	    }
	};

	RepeaterModifier.prototype.processPath = function(path, transform) {
	    var clonedPath = shape_pool.clone(path, transform);
	    return clonedPath;
	};


	ShapeModifiers.registerModifier('rp',RepeaterModifier);
	function ShapeCollection(){
		this._length = 0;
		this._maxLength = 4;
		this.shapes = Array.apply(null,{length:this._maxLength});
	};

	ShapeCollection.prototype.addShape = function(shapeData){
		if(this._length === this._maxLength){
			this.shapes = this.shapes.concat(Array.apply(null,{length:this._maxLength}));
			this._maxLength *= 2;
		}
		this.shapes[this._length] = shapeData;
		this._length += 1;
	};

	ShapeCollection.prototype.releaseShapes = function(){
		var i;
		for(i = 0; i < this._length; i += 1) {
			shape_pool.release(this.shapes[i]);
		}
		this._length = 0;
	};
	var ImagePreloader = (function(){

	    function imageLoaded(){
	        this.loadedAssets += 1;
	        if(this.loadedAssets === this.totalImages){
	        }
	    }

	    function getAssetsPath(assetData){
	        var path = '';
	        if(this.assetsPath){
	            var imagePath = assetData.p;
	            if(imagePath.indexOf('images/') !== -1){
	                imagePath = imagePath.split('/')[1];
	            }
	            path = this.assetsPath + imagePath;
	        } else {
	            path = this.path;
	            path += assetData.u ? assetData.u : '';
	            path += assetData.p;
	        }
	        return path;
	    }

	    function loadImage(path){
	        var img = document.createElement('img');
	        img.addEventListener('load', imageLoaded.bind(this), false);
	        img.addEventListener('error', imageLoaded.bind(this), false);
	        img.src = path;
	    }
	    function loadAssets(assets){
	        this.totalAssets = assets.length;
	        var i;
	        for(i=0;i<this.totalAssets;i+=1){
	            if(!assets[i].layers){
	                loadImage.bind(this)(getAssetsPath.bind(this)(assets[i]));
	                this.totalImages += 1;
	            }
	        }
	    }

	    function setPath(path){
	        this.path = path || '';
	    }

	    function setAssetsPath(path){
	        this.assetsPath = path || '';
	    }

	    return function ImagePreloader(){
	        this.loadAssets = loadAssets;
	        this.setAssetsPath = setAssetsPath;
	        this.setPath = setPath;
	        this.assetsPath = '';
	        this.path = '';
	        this.totalAssets = 0;
	        this.totalImages = 0;
	        this.loadedAssets = 0;
	    }
	}());
	var featureSupport = (function(){
		var ob = {
			maskType: true
		}
		if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
		   ob.maskType = false;
		}
		return ob;
	}());
	var filtersFactory = (function(){
		var ob = {};
		ob.createFilter = createFilter;
		ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

		function createFilter(filId){
	        	var fil = document.createElementNS(svgNS,'filter');
	        	fil.setAttribute('id',filId);
	                fil.setAttribute('filterUnits','objectBoundingBox');
	                fil.setAttribute('x','0%');
	                fil.setAttribute('y','0%');
	                fil.setAttribute('width','100%');
	                fil.setAttribute('height','100%');
	                return fil;
		}

		function createAlphaToLuminanceFilter(){
	                var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	                feColorMatrix.setAttribute('type','matrix');
	                feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	                feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 0 1');
	                return feColorMatrix;
		}

		return ob;
	}())
	var pooling = (function(){

		function double(arr){
			return arr.concat(Array.apply(null,{length:arr.length}))
		}

		return {
			double: double
		}
	}());
	var point_pool = (function(){
		var ob = {
			newPoint: newPoint,
			release: release
			/*,getLength:function(){return _length}
			,getCont:function(){return cont}*/
		}

		var _length = 0;
		var _maxLength = 8;
		var pool = Array.apply(null,{length:_maxLength});

		//var cont = 0;

		function newPoint(){
			//window.bm_newPoint = window.bm_newPoint ? window.bm_newPoint + 1 : 1;
			var point;
			if(_length){
				_length -= 1;
				point = pool[_length];
				//window.bm_reuse = window.bm_reuse ? window.bm_reuse + 1 : 1;
			} else {
				point = [0.1,0.1];
				//cont++;
				//console.log('new');
				//window.bm_new = window.bm_new ? window.bm_new + 1 : 1;
				//point._tst = cont++;
			}
			return point;
		}

		function release(point) {
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = point;
			_length += 1;
			//window.bm_release = window.bm_release ? window.bm_release + 1 : 1;
			//console.log('release');
		}


		return ob;
	}());
	var shape_pool = (function(){
		var ob = {
			clone: clone,
			newShape: newShape,
			release: release,
			releaseArray: releaseArray
		}

		var _length = 0;
		var _maxLength = 4;
		var pool = Array.apply(null,{length:_maxLength});

		function newShape(){
			var shapePath;
			if(_length){
				_length -= 1;
				shapePath = pool[_length];
			} else {
				shapePath = new ShapePath();
			}
			return shapePath;
		}

		function release(shapePath) {
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			var len = shapePath._length, i;
			for(i = 0; i < len; i += 1) {
				point_pool.release(shapePath.v[i]);
				point_pool.release(shapePath.i[i]);
				point_pool.release(shapePath.o[i]);
			}
			shapePath._length = 0;
			shapePath.c = false;
			pool[_length] = shapePath;
			_length += 1;
		}

		function releaseArray(shapePathsCollection, length) {
			while(length--) {
				release(shapePathsCollection[length]);
			}
		}

		function clone(shape, transform) {
			var i, len = shape._length;
			var cloned = newShape();
			cloned._length = shape._length;
			cloned.c = shape.c;

			var pt;
			
			for(i = 0; i < len; i += 1) {
				if(transform){
					pt = transform.applyToPointArray(shape.v[i][0],shape.v[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'v',i);
					point_pool.release(pt);
					pt = transform.applyToPointArray(shape.o[i][0],shape.o[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'o',i);
					point_pool.release(pt);
					pt = transform.applyToPointArray(shape.i[i][0],shape.i[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'i',i);
					point_pool.release(pt);
				}else{
					cloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1], i);
				}
			}
			return cloned
		}


		return ob;
	}());
	var shapeCollection_pool = (function(){
		var ob = {
			newShapeCollection: newShapeCollection,
			release: release,
			clone: clone
		}

		var _length = 0;
		var _maxLength = 4;
		var pool = Array.apply(null,{length:_maxLength});

		var cont = 0;

		function newShapeCollection(){
			var shapeCollection;
			if(_length){
				_length -= 1;
				shapeCollection = pool[_length];
			} else {
				shapeCollection = new ShapeCollection();
			}
			return shapeCollection;
		}

		function release(shapeCollection) {
			var i, len = shapeCollection._length;
			for(i = 0; i < len; i += 1) {
				shape_pool.release(shapeCollection.shapes[i]);
			}
			shapeCollection._length = 0;

			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = shapeCollection;
			_length += 1;
		}

		function clone(shapeCollection, originCollection) {
			release(shapeCollection);
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = shapeCollection;
			_length += 1;
		}


		return ob;
	}());
	function BaseRenderer(){}
	BaseRenderer.prototype.checkLayers = function(num){
	    var i, len = this.layers.length, data;
	    this.completeLayers = true;
	    for (i = len - 1; i >= 0; i--) {
	        if (!this.elements[i]) {
	            data = this.layers[i];
	            if(data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st))
	            {
	                this.buildItem(i);
	            }
	        }
	        this.completeLayers = this.elements[i] ? this.completeLayers:false;
	    }
	    this.checkPendingElements();
	};

	BaseRenderer.prototype.createItem = function(layer){
	    switch(layer.ty){
	        case 2:
	            return this.createImage(layer);
	        case 0:
	            return this.createComp(layer);
	        case 1:
	            return this.createSolid(layer);
	        case 4:
	            return this.createShape(layer);
	        case 5:
	            return this.createText(layer);
	        case 99:
	            return null;
	    }
	    return this.createBase(layer);
	};
	BaseRenderer.prototype.buildAllItems = function(){
	    var i, len = this.layers.length;
	    for(i=0;i<len;i+=1){
	        this.buildItem(i);
	    }
	    this.checkPendingElements();
	};

	BaseRenderer.prototype.includeLayers = function(newLayers){
	    this.completeLayers = false;
	    var i, len = newLayers.length;
	    var j, jLen = this.layers.length;
	    for(i=0;i<len;i+=1){
	        j = 0;
	        while(j<jLen){
	            if(this.layers[j].id == newLayers[i].id){
	                this.layers[j] = newLayers[i];
	                break;
	            }
	            j += 1;
	        }
	    }
	};

	BaseRenderer.prototype.setProjectInterface = function(pInterface){
	    this.globalData.projectInterface = pInterface;
	};

	BaseRenderer.prototype.initItems = function(){
	    if(!this.globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	};
	BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy){
	    hierarchy = hierarchy || [];
	    var elements = this.elements;
	    var layers = this.layers;
	    var i=0, len = layers.length;
	    while(i<len){
	        if(layers[i].ind == parentName){
	            if(!elements[i] || elements[i] === true){
	                this.buildItem(i);
	                this.addPendingElement(element);
	            } else if(layers[i].parent !== undefined){
	                hierarchy.push(elements[i]);
	                elements[i]._isParent = true;
	                this.buildElementParenting(element,layers[i].parent, hierarchy);
	            } else {
	                hierarchy.push(elements[i]);
	                elements[i]._isParent = true;
	                element.setHierarchy(hierarchy);
	            }


	        }
	        i += 1;
	    }
	};

	BaseRenderer.prototype.addPendingElement = function(element){
	    this.pendingElements.push(element);
	};
	function SVGRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.renderConfig = {
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	        progressiveLoad: (config && config.progressiveLoad) || false
	    };
	    this.elements = [];
	    this.pendingElements = [];
	    this.destroyed = false;

	}

	extendPrototype(BaseRenderer,SVGRenderer);

	SVGRenderer.prototype.createBase = function (data) {
	    return new SVGBaseElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createShape = function (data) {
	    return new IShapeElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createText = function (data) {
	    return new SVGTextElement(data, this.layerElement,this.globalData,this);

	};

	SVGRenderer.prototype.createImage = function (data) {
	    return new IImageElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createComp = function (data) {
	    return new ICompElement(data, this.layerElement,this.globalData,this);

	};

	SVGRenderer.prototype.createSolid = function (data) {
	    return new ISolidElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.configAnimation = function(animData){
	    this.layerElement = document.createElementNS(svgNS,'svg');
	    this.layerElement.setAttribute('xmlns','http://www.w3.org/2000/svg');
	    this.layerElement.setAttribute('width',animData.w);
	    this.layerElement.setAttribute('height',animData.h);
	    this.layerElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);
	    this.layerElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);
	    this.layerElement.style.width = '100%';
	    this.layerElement.style.height = '100%';
	    //this.layerElement.style.transform = 'translate3d(0,0,0)';
	    //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
	    this.animationItem.wrapper.appendChild(this.layerElement);
	    //Mask animation
	    var defs = document.createElementNS(svgNS, 'defs');
	    this.globalData.defs = defs;
	    this.layerElement.appendChild(defs);
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.globalData.frameId = 0;
	    this.globalData.nm = animData.nm;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.data = animData;
	    this.globalData.frameRate = animData.fr;
	    var maskElement = document.createElementNS(svgNS, 'clipPath');
	    var rect = document.createElementNS(svgNS,'rect');
	    rect.setAttribute('width',animData.w);
	    rect.setAttribute('height',animData.h);
	    rect.setAttribute('x',0);
	    rect.setAttribute('y',0);
	    var maskId = 'animationMask_'+randomString(10);
	    maskElement.setAttribute('id', maskId);
	    maskElement.appendChild(rect);
	    var maskedElement = document.createElementNS(svgNS,'g');
	    maskedElement.setAttribute("clip-path", "url(#"+maskId+")");
	    this.layerElement.appendChild(maskedElement);
	    defs.appendChild(maskElement);
	    this.layerElement = maskedElement;
	    this.layers = animData.layers;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,defs);
	    this.elements = Array.apply(null,{length:animData.layers.length});
	};


	SVGRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.layerElement = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};

	SVGRenderer.prototype.updateContainerSize = function () {
	};

	SVGRenderer.prototype.buildItem  = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    elements[pos] = true;
	    var element = this.createItem(this.layers[pos]);

	    elements[pos] = element;
	    if(expressionsPlugin){
	        if(this.layers[pos].ty === 0){
	            this.globalData.projectInterface.registerComposition(element);
	        }
	        element.initExpressions();
	    }
	    this.appendElementInPos(element,pos);
	    if(this.layers[pos].tt){
	        if(!this.elements[pos - 1] || this.elements[pos - 1] === true){
	            this.buildItem(pos - 1);
	            this.addPendingElement(element);
	        } else {
	            element.setMatte(elements[pos - 1].layerId);
	        }
	    }
	};

	SVGRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	        if(element.data.tt){
	            var i = 0, len = this.elements.length;
	            while(i<len){
	                if(this.elements[i] === element){
	                    element.setMatte(this.elements[i - 1].layerId);
	                    break;
	                }
	                i += 1;
	            }
	        }
	    }
	};

	SVGRenderer.prototype.renderFrame = function(num){
	    if(this.renderedFrame == num || this.destroyed){
	        return;
	    }
	    if(num === null){
	        num = this.renderedFrame;
	    }else{
	        this.renderedFrame = num;
	    }
	    //clearPoints();
	    /*console.log('-------');
	    console.log('FRAME ',num);*/
	    this.globalData.frameNum = num;
	    this.globalData.frameId += 1;
	    this.globalData.projectInterface.currentFrame = num;
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }
	    for (i = len - 1; i >= 0; i--) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    for (i = len - 1; i >= 0; i--) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	};

	SVGRenderer.prototype.appendElementInPos = function(element, pos){
	    var newElement = element.getBaseElement();
	    if(!newElement){
	        return;
	    }
	    var i = 0;
	    var nextElement;
	    while(i<pos){
	        if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement()){
	            nextElement = this.elements[i].getBaseElement();
	        }
	        i += 1;
	    }
	    if(nextElement){
	        this.layerElement.insertBefore(newElement, nextElement);
	    } else {
	        this.layerElement.appendChild(newElement);
	    }
	};

	SVGRenderer.prototype.hide = function(){
	    this.layerElement.style.display = 'none';
	};

	SVGRenderer.prototype.show = function(){
	    this.layerElement.style.display = 'block';
	};

	SVGRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElementNS(svgNS,'g');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
	            comp.initExpressions();
	            //comp.compInterface = CompExpressionInterface(comp);
	            //Expressions.addLayersInterface(comp.elements, this.globalData.projectInterface);
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};

	function MaskElement(data,element,globalData) {
	    this.dynamicProperties = [];
	    this.data = data;
	    this.element = element;
	    this.globalData = globalData;
	    this.paths = [];
	    this.storedData = [];
	    this.masksProperties = this.data.masksProperties;
	    this.viewData = new Array(this.masksProperties.length);
	    this.maskElement = null;
	    this.firstFrame = true;
	    var defs = this.globalData.defs;
	    var i, len = this.masksProperties.length;


	    var path, properties = this.masksProperties;
	    var count = 0;
	    var currentMasks = [];
	    var j, jLen;
	    var layerId = randomString(10);
	    var rect, expansor, feMorph,x;
	    var maskType = 'clipPath', maskRef = 'clip-path';
	    for (i = 0; i < len; i++) {

	        if((properties[i].mode !== 'a' && properties[i].mode !== 'n')|| properties[i].inv || properties[i].o.k !== 100){
	            maskType = 'mask';
	            maskRef = 'mask';
	        }

	        if((properties[i].mode == 's' || properties[i].mode == 'i') && count == 0){
	            rect = document.createElementNS(svgNS, 'rect');
	            rect.setAttribute('fill', '#ffffff');
	            rect.setAttribute('width', this.element.comp.data.w);
	            rect.setAttribute('height', this.element.comp.data.h);
	            currentMasks.push(rect);
	        } else {
	            rect = null;
	        }

	        path = document.createElementNS(svgNS, 'path');
	        if(properties[i].mode == 'n') {
	            this.viewData[i] = {
	                op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.dynamicProperties),
	                prop: ShapePropertyFactory.getShapeProp(this.element,properties[i],3,this.dynamicProperties,null),
	                elem: path
	            };
	            defs.appendChild(path);
	            continue;
	        }
	        count += 1;

	        if(properties[i].mode == 's'){
	            path.setAttribute('fill', '#000000');
	        }else{
	            path.setAttribute('fill', '#ffffff');
	        }
	        path.setAttribute('clip-rule','nonzero');

	        if(properties[i].x.k !== 0){
	            maskType = 'mask';
	            maskRef = 'mask';
	            x = PropertyFactory.getProp(this.element,properties[i].x,0,null,this.dynamicProperties);
	            var filterID = 'fi_'+randomString(10);
	            expansor = document.createElementNS(svgNS,'filter');
	            expansor.setAttribute('id',filterID);
	            feMorph = document.createElementNS(svgNS,'feMorphology');
	            feMorph.setAttribute('operator','dilate');
	            feMorph.setAttribute('in','SourceGraphic');
	            feMorph.setAttribute('radius','0');
	            expansor.appendChild(feMorph);
	            defs.appendChild(expansor);
	            if(properties[i].mode == 's'){
	                path.setAttribute('stroke', '#000000');
	            }else{
	                path.setAttribute('stroke', '#ffffff');
	            }
	        }else{
	            feMorph = null;
	            x = null;
	        }


	        this.storedData[i] = {
	             elem: path,
	             x: x,
	             expan: feMorph,
	            lastPath: '',
	            lastOperator:'',
	            filterId:filterID,
	            lastRadius:0
	        };
	        if(properties[i].mode == 'i'){
	            jLen = currentMasks.length;
	            var g = document.createElementNS(svgNS,'g');
	            for(j=0;j<jLen;j+=1){
	                g.appendChild(currentMasks[j]);
	            }
	            var mask = document.createElementNS(svgNS,'mask');
	            mask.setAttribute('mask-type','alpha');
	            mask.setAttribute('id',layerId+'_'+count);
	            mask.appendChild(path);
	            defs.appendChild(mask);
	            g.setAttribute('mask','url(#'+layerId+'_'+count+')');

	            currentMasks.length = 0;
	            currentMasks.push(g);
	        }else{
	            currentMasks.push(path);
	        }
	        if(properties[i].inv && !this.solidPath){
	            this.solidPath = this.createLayerSolidPath();
	        }
	        this.viewData[i] = {
	            elem: path,
	            lastPath: '',
	            op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.dynamicProperties),
	            prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3,this.dynamicProperties,null)
	        };
	        if(rect){
	            this.viewData[i].invRect = rect;
	        }
	        if(!this.viewData[i].prop.k){
	            this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	    }

	    this.maskElement = document.createElementNS(svgNS, maskType);

	    len = currentMasks.length;
	    for(i=0;i<len;i+=1){
	        this.maskElement.appendChild(currentMasks[i]);
	    }

	    this.maskElement.setAttribute('id', layerId);
	    if(count > 0){
	        this.element.maskedElement.setAttribute(maskRef, "url(#" + layerId + ")");
	    }

	    defs.appendChild(this.maskElement);
	};

	MaskElement.prototype.getMaskProperty = function(pos){
	    return this.viewData[pos].prop;
	};

	MaskElement.prototype.prepareFrame = function(){
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();

	    }
	};

	MaskElement.prototype.renderFrame = function (finalMat) {
	    var i, len = this.masksProperties.length;
	    for (i = 0; i < len; i++) {
	        if(this.viewData[i].prop.mdf || this.firstFrame){
	            this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	        if(this.viewData[i].op.mdf || this.firstFrame){
	            this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);
	        }
	        if(this.masksProperties[i].mode !== 'n'){
	            if(this.viewData[i].invRect && (this.element.finalTransform.mProp.mdf || this.firstFrame)){
	                this.viewData[i].invRect.setAttribute('x', -finalMat.props[12]);
	                this.viewData[i].invRect.setAttribute('y', -finalMat.props[13]);
	            }
	            if(this.storedData[i].x && (this.storedData[i].x.mdf || this.firstFrame)){
	                var feMorph = this.storedData[i].expan;
	                if(this.storedData[i].x.v < 0){
	                    if(this.storedData[i].lastOperator !== 'erode'){
	                        this.storedData[i].lastOperator = 'erode';
	                        this.storedData[i].elem.setAttribute('filter','url(#'+this.storedData[i].filterId+')');
	                    }
	                    feMorph.setAttribute('radius',-this.storedData[i].x.v);
	                }else{
	                    if(this.storedData[i].lastOperator !== 'dilate'){
	                        this.storedData[i].lastOperator = 'dilate';
	                        this.storedData[i].elem.setAttribute('filter',null);
	                    }
	                    this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v*2);

	                }
	            }
	        }
	    }
	    this.firstFrame = false;
	};

	MaskElement.prototype.getMaskelement = function () {
	    return this.maskElement;
	};

	MaskElement.prototype.createLayerSolidPath = function(){
	    var path = 'M0,0 ';
	    path += ' h' + this.globalData.compSize.w ;
	    path += ' v' + this.globalData.compSize.h ;
	    path += ' h-' + this.globalData.compSize.w ;
	    path += ' v-' + this.globalData.compSize.h + ' ';
	    return path;
	};

	MaskElement.prototype.drawPath = function(pathData,pathNodes,viewData){
	    var pathString = " M"+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    var i, len;
	    len = pathNodes._length;
	    for(i=1;i<len;i+=1){
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
	        pathString += " C"+bm_rnd(pathNodes.o[i-1][0])+','+bm_rnd(pathNodes.o[i-1][1]) + " "+bm_rnd(pathNodes.i[i][0])+','+bm_rnd(pathNodes.i[i][1]) + " "+bm_rnd(pathNodes.v[i][0])+','+bm_rnd(pathNodes.v[i][1]);
	    }
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    if(pathNodes.c && len > 1){
	        pathString += " C"+bm_rnd(pathNodes.o[i-1][0])+','+bm_rnd(pathNodes.o[i-1][1]) + " "+bm_rnd(pathNodes.i[0][0])+','+bm_rnd(pathNodes.i[0][1]) + " "+bm_rnd(pathNodes.v[0][0])+','+bm_rnd(pathNodes.v[0][1]);
	    }
	    //pathNodes.__renderedString = pathString;


	    if(viewData.lastPath !== pathString){
	        if(viewData.elem){
	            if(!pathNodes.c){
	                viewData.elem.setAttribute('d','');
	            }else if(pathData.inv){
	                viewData.elem.setAttribute('d',this.solidPath + pathString);
	            }else{
	                viewData.elem.setAttribute('d',pathString);
	            }
	        }
	        viewData.lastPath = pathString;
	    }
	};

	MaskElement.prototype.getMask = function(nm){
	    var i = 0, len = this.masksProperties.length;
	    while(i<len){
	        if(this.masksProperties[i].nm === nm){
	            return {
	                maskPath: this.viewData[i].prop.pv
	            }
	        }
	        i += 1;
	    }
	};

	MaskElement.prototype.destroy = function(){
	    this.element = null;
	    this.globalData = null;
	    this.maskElement = null;
	    this.data = null;
	    this.paths = null;
	    this.masksProperties = null;
	};
	function BaseElement(){
	};
	BaseElement.prototype.checkMasks = function(){
	    if(!this.data.hasMask){
	        return false;
	    }
	    var i = 0, len = this.data.masksProperties.length;
	    while(i<len) {
	        if((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
	            return true;
	        }
	        i += 1;
	    }
	    return false;
	}

	BaseElement.prototype.checkParenting = function(){
	    if(this.data.parent !== undefined){
	        this.comp.buildElementParenting(this, this.data.parent);
	    }
	}

	BaseElement.prototype.prepareFrame = function(num){
	    if(this.data.ip - this.data.st <= num && this.data.op - this.data.st > num)
	    {
	        if(this.isVisible !== true){
	            this.elemMdf = true;
	            this.globalData.mdf = true;
	            this.isVisible = true;
	            this.firstFrame = true;
	            if(this.data.hasMask){
	                this.maskManager.firstFrame = true;
	            }
	        }
	    }else{
	        if(this.isVisible !== false){
	            this.elemMdf = true;
	            this.globalData.mdf = true;
	            this.isVisible = false;
	        }
	    }
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        if(this.isVisible || (this._isParent && this.dynamicProperties[i].type === 'transform')){
	            this.dynamicProperties[i].getValue();
	            if(this.dynamicProperties[i].mdf){
	                this.elemMdf = true;
	                this.globalData.mdf = true;
	            }
	        }
	    }
	    if(this.data.hasMask && this.isVisible){
	        this.maskManager.prepareFrame(num*this.data.sr);
	    }
	    
	    /* TODO check this
	    if(this.data.sy){
	        if(this.data.sy[0].renderedData[num]){
	            if(this.data.sy[0].renderedData[num].c){
	                this.feFlood.setAttribute('flood-color','rgb('+Math.round(this.data.sy[0].renderedData[num].c[0])+','+Math.round(this.data.sy[0].renderedData[num].c[1])+','+Math.round(this.data.sy[0].renderedData[num].c[2])+')');
	            }
	            if(this.data.sy[0].renderedData[num].s){
	                this.feMorph.setAttribute('radius',this.data.sy[0].renderedData[num].s);
	            }
	        }
	    }
	    */


	    this.currentFrameNum = num*this.data.sr;
	    return this.isVisible;
	};

	BaseElement.prototype.globalToLocal = function(pt){
	    var transforms = [];
	    transforms.push(this.finalTransform);
	    var flag = true;
	    var comp = this.comp;
	    while(flag){
	        if(comp.finalTransform){
	            if(comp.data.hasMask){
	                transforms.splice(0,0,comp.finalTransform);
	            }
	            comp = comp.comp;
	        } else {
	            flag = false;
	        }
	    }
	    var i, len = transforms.length,ptNew;
	    for(i=0;i<len;i+=1){
	        ptNew = transforms[i].mat.applyToPointArray(0,0,0);
	        //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
	        pt = [pt[0] - ptNew[0],pt[1] - ptNew[1],0];
	    }
	    return pt;
	};

	BaseElement.prototype.initExpressions = function(){
	    this.layerInterface = LayerExpressionInterface(this);
	    //layers[i].layerInterface = LayerExpressionInterface(layers[i]);
	    //layers[i].layerInterface = LayerExpressionInterface(layers[i]);
	    if(this.data.hasMask){
	        this.layerInterface.registerMaskInterface(this.maskManager);
	    }
	    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);
	    this.layerInterface.registerEffectsInterface(effectsInterface);

	    if(this.data.ty === 0 || this.data.xt){
	        this.compInterface = CompExpressionInterface(this);
	    } else if(this.data.ty === 4){
	        this.layerInterface.shapeInterface = ShapeExpressionInterface.createShapeInterface(this.shapesData,this.viewData,this.layerInterface);
	    } else if(this.data.ty === 5){
	        this.layerInterface.textInterface = TextExpressionInterface(this);
	    }
	}

	BaseElement.prototype.setBlendMode = function(){
	    var blendModeValue = '';
	    switch(this.data.bm){
	        case 1:
	            blendModeValue = 'multiply';
	            break;
	        case 2:
	            blendModeValue = 'screen';
	            break;
	        case 3:
	            blendModeValue = 'overlay';
	            break;
	        case 4:
	            blendModeValue = 'darken';
	            break;
	        case 5:
	            blendModeValue = 'lighten';
	            break;
	        case 6:
	            blendModeValue = 'color-dodge';
	            break;
	        case 7:
	            blendModeValue = 'color-burn';
	            break;
	        case 8:
	            blendModeValue = 'hard-light';
	            break;
	        case 9:
	            blendModeValue = 'soft-light';
	            break;
	        case 10:
	            blendModeValue = 'difference';
	            break;
	        case 11:
	            blendModeValue = 'exclusion';
	            break;
	        case 12:
	            blendModeValue = 'hue';
	            break;
	        case 13:
	            blendModeValue = 'saturation';
	            break;
	        case 14:
	            blendModeValue = 'color';
	            break;
	        case 15:
	            blendModeValue = 'luminosity';
	            break;
	    }
	    var elem = this.baseElement || this.layerElement;

	    elem.style['mix-blend-mode'] = blendModeValue;
	}

	BaseElement.prototype.init = function(){
	    if(!this.data.sr){
	        this.data.sr = 1;
	    }
	    this.dynamicProperties = [];
	    if(this.data.ef){
	        this.effects = new EffectsManager(this.data,this,this.dynamicProperties);
	        //this.effect = this.effectsManager.bind(this.effectsManager);
	    }
	    //this.elemInterface = buildLayerExpressionInterface(this);
	    this.hidden = false;
	    this.firstFrame = true;
	    this.isVisible = false;
	    this._isParent = false;
	    this.currentFrameNum = -99999;
	    this.lastNum = -99999;
	    if(this.data.ks){
	        this.finalTransform = {
	            mProp: PropertyFactory.getProp(this,this.data.ks,2,null,this.dynamicProperties),
	            matMdf: false,
	            opMdf: false,
	            mat: new Matrix(),
	            opacity: 1
	        };
	        if(this.data.ao){
	            this.finalTransform.mProp.autoOriented = true;
	        }
	        this.finalTransform.op = this.finalTransform.mProp.o;
	        this.transform = this.finalTransform.mProp;
	        if(this.data.ty !== 11){
	            this.createElements();
	        }
	        if(this.data.hasMask){
	            this.addMasks(this.data);
	        }
	    }
	    this.elemMdf = false;
	};
	BaseElement.prototype.getType = function(){
	    return this.type;
	};

	BaseElement.prototype.resetHierarchy = function(){
	    if(!this.hierarchy){
	        this.hierarchy = [];
	    }else{
	        this.hierarchy.length = 0;
	    }
	};

	BaseElement.prototype.getHierarchy = function(){
	    if(!this.hierarchy){
	        this.hierarchy = [];
	    }
	    return this.hierarchy;
	};

	BaseElement.prototype.setHierarchy = function(hierarchy){
	    this.hierarchy = hierarchy;
	};

	BaseElement.prototype.getLayerSize = function(){
	    if(this.data.ty === 5){
	        return {w:this.data.textData.width,h:this.data.textData.height};
	    }else{
	        return {w:this.data.width,h:this.data.height};
	    }
	};

	BaseElement.prototype.hide = function(){

	};

	BaseElement.prototype.mHelper = new Matrix();
	function SVGBaseElement(data,parentContainer,globalData,comp, placeholder){
	    this.globalData = globalData;
	    this.comp = comp;
	    this.data = data;
	    this.matteElement = null;
	    this.transformedElement = null;
	    this.parentContainer = parentContainer;
	    this.layerId = placeholder ? placeholder.layerId : 'ly_'+randomString(10);
	    this.placeholder = placeholder;
	    this.init();
	};

	createElement(BaseElement, SVGBaseElement);

	SVGBaseElement.prototype.createElements = function(){
	    this.layerElement = document.createElementNS(svgNS,'g');
	    this.transformedElement = this.layerElement;
	    if(this.data.hasMask){
	        this.maskedElement = this.layerElement;
	    }
	    var layerElementParent = null;
	    if(this.data.td){
	        if(this.data.td == 3 || this.data.td == 1){
	            var masker = document.createElementNS(svgNS,'mask');
	            masker.setAttribute('id',this.layerId);
	            masker.setAttribute('mask-type',this.data.td == 3 ? 'luminance':'alpha');
	            masker.appendChild(this.layerElement);
	            layerElementParent = masker;
	            this.globalData.defs.appendChild(masker);
	            ////// This is only for IE and Edge when mask if of type alpha
	            if(!featureSupport.maskType && this.data.td == 1){
	                masker.setAttribute('mask-type','luminance');
	                var filId = randomString(10);
	                var fil = filtersFactory.createFilter(filId);
	                this.globalData.defs.appendChild(fil);
	                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                var gg = document.createElementNS(svgNS,'g');
	                gg.appendChild(this.layerElement);
	                layerElementParent = gg;
	                masker.appendChild(gg);
	                gg.setAttribute('filter','url(#'+filId+')');
	            }
	        }else if(this.data.td == 2){
	            var maskGroup = document.createElementNS(svgNS,'mask');
	            maskGroup.setAttribute('id',this.layerId);
	            maskGroup.setAttribute('mask-type','alpha');
	            var maskGrouper = document.createElementNS(svgNS,'g');
	            maskGroup.appendChild(maskGrouper);
	            var filId = randomString(10);
	            var fil = filtersFactory.createFilter(filId);
	            ////

	            var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	            feColorMatrix.setAttribute('type','matrix');
	            feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	            feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
	            fil.appendChild(feColorMatrix);

	            ////
	            /*var feCTr = document.createElementNS(svgNS,'feComponentTransfer');
	            feCTr.setAttribute('in','SourceGraphic');
	            fil.appendChild(feCTr);
	            var feFunc = document.createElementNS(svgNS,'feFuncA');
	            feFunc.setAttribute('type','table');
	            feFunc.setAttribute('tableValues','1.0 0.0');
	            feCTr.appendChild(feFunc);*/
	            this.globalData.defs.appendChild(fil);
	            var alphaRect = document.createElementNS(svgNS,'rect');
	            alphaRect.setAttribute('width',this.comp.data.w);
	            alphaRect.setAttribute('height',this.comp.data.h);
	            alphaRect.setAttribute('x','0');
	            alphaRect.setAttribute('y','0');
	            alphaRect.setAttribute('fill','#ffffff');
	            alphaRect.setAttribute('opacity','0');
	            maskGrouper.setAttribute('filter','url(#'+filId+')');
	            maskGrouper.appendChild(alphaRect);
	            maskGrouper.appendChild(this.layerElement);
	            layerElementParent = maskGrouper;
	            if(!featureSupport.maskType){
	                maskGroup.setAttribute('mask-type','luminance');
	                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                var gg = document.createElementNS(svgNS,'g');
	                maskGrouper.appendChild(alphaRect);
	                gg.appendChild(this.layerElement);
	                layerElementParent = gg;
	                maskGrouper.appendChild(gg);
	            }
	            this.globalData.defs.appendChild(maskGroup);
	        }
	    }else if(this.data.hasMask || this.data.tt){
	        if(this.data.tt){
	            this.matteElement = document.createElementNS(svgNS,'g');
	            this.matteElement.appendChild(this.layerElement);
	            layerElementParent = this.matteElement;
	            this.baseElement = this.matteElement;
	        }else{
	            this.baseElement = this.layerElement;
	        }
	    }else{
	        this.baseElement = this.layerElement;
	    }
	    if((this.data.ln || this.data.cl) && (this.data.ty === 4 || this.data.ty === 0)){
	        if(this.data.ln){
	            this.layerElement.setAttribute('id',this.data.ln);
	        }
	        if(this.data.cl){
	            this.layerElement.setAttribute('class',this.data.cl);
	        }
	    }
	    if(this.data.ty === 0){
	            var cp = document.createElementNS(svgNS, 'clipPath');
	            var pt = document.createElementNS(svgNS,'path');
	            pt.setAttribute('d','M0,0 L'+this.data.w+',0'+' L'+this.data.w+','+this.data.h+' L0,'+this.data.h+'z');
	            var clipId = 'cp_'+randomString(8);
	            cp.setAttribute('id',clipId);
	            cp.appendChild(pt);
	            this.globalData.defs.appendChild(cp);
	        if(this.checkMasks()){
	            var cpGroup = document.createElementNS(svgNS,'g');
	            cpGroup.setAttribute('clip-path','url(#'+clipId+')');
	            cpGroup.appendChild(this.layerElement);
	            this.transformedElement = cpGroup;
	            if(layerElementParent){
	                layerElementParent.appendChild(this.transformedElement);
	            } else {
	                this.baseElement = this.transformedElement;
	            }
	        } else {
	            this.layerElement.setAttribute('clip-path','url(#'+clipId+')');
	        }
	        
	    }
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    if(this.layerElement !== this.parentContainer){
	        this.placeholder = null;
	    }
	    /* Todo performance killer
	    if(this.data.sy){
	        var filterID = 'st_'+randomString(10);
	        var c = this.data.sy[0].c.k;
	        var r = this.data.sy[0].s.k;
	        var expansor = document.createElementNS(svgNS,'filter');
	        expansor.setAttribute('id',filterID);
	        var feFlood = document.createElementNS(svgNS,'feFlood');
	        this.feFlood = feFlood;
	        if(!c[0].e){
	            feFlood.setAttribute('flood-color','rgb('+c[0]+','+c[1]+','+c[2]+')');
	        }
	        feFlood.setAttribute('result','base');
	        expansor.appendChild(feFlood);
	        var feMorph = document.createElementNS(svgNS,'feMorphology');
	        feMorph.setAttribute('operator','dilate');
	        feMorph.setAttribute('in','SourceGraphic');
	        feMorph.setAttribute('result','bigger');
	        this.feMorph = feMorph;
	        if(!r.length){
	            feMorph.setAttribute('radius',this.data.sy[0].s.k);
	        }
	        expansor.appendChild(feMorph);
	        var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	        feColorMatrix.setAttribute('result','mask');
	        feColorMatrix.setAttribute('in','bigger');
	        feColorMatrix.setAttribute('type','matrix');
	        feColorMatrix.setAttribute('values','0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0');
	        expansor.appendChild(feColorMatrix);
	        var feComposite = document.createElementNS(svgNS,'feComposite');
	        feComposite.setAttribute('result','drop');
	        feComposite.setAttribute('in','base');
	        feComposite.setAttribute('in2','mask');
	        feComposite.setAttribute('operator','in');
	        expansor.appendChild(feComposite);
	        var feBlend = document.createElementNS(svgNS,'feBlend');
	        feBlend.setAttribute('in','SourceGraphic');
	        feBlend.setAttribute('in2','drop');
	        feBlend.setAttribute('mode','normal');
	        expansor.appendChild(feBlend);
	        this.globalData.defs.appendChild(expansor);
	        var cont = document.createElementNS(svgNS,'g');
	        if(this.layerElement === this.parentContainer){
	            this.layerElement = cont;
	        }else{
	            cont.appendChild(this.layerElement);
	        }
	        cont.setAttribute('filter','url(#'+filterID+')');
	        if(this.data.td){
	            cont.setAttribute('data-td',this.data.td);
	        }
	        if(this.data.td == 3){
	            this.globalData.defs.appendChild(cont);
	        }else if(this.data.td == 2){
	            maskGrouper.appendChild(cont);
	        }else if(this.data.td == 1){
	            masker.appendChild(cont);
	        }else{
	            if(this.data.hasMask && this.data.tt){
	                this.matteElement.appendChild(cont);
	            }else{
	                this.appendNodeToParent(cont);
	            }
	        }
	    }*/
	    if(this.data.ef){
	        this.effectsManager = new SVGEffects(this);
	    }
	    this.checkParenting();
	};


	SVGBaseElement.prototype.setBlendMode = BaseElement.prototype.setBlendMode;

	SVGBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3 || this.data.hd || !this.isVisible){
	        return false;
	    }

	    this.lastNum = this.currentFrameNum;
	    this.finalTransform.opMdf = this.firstFrame || this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.firstFrame || this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i = 0, len = this.hierarchy.length;
	        if(!this.finalTransform.matMdf) {
	            while(i < len) {
	                if(this.hierarchy[i].finalTransform.mProp.mdf) {
	                    this.finalTransform.matMdf = true;
	                    break;
	                }
	                i += 1;
	            }
	        }
	        
	        if(this.finalTransform.matMdf) {
	            mat = this.finalTransform.mProp.v.props;
	            finalMat.cloneFromProps(mat);
	            for(i=0;i<len;i+=1){
	                mat = this.hierarchy[i].finalTransform.mProp.v.props;
	                finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	            }
	        }
	        
	    }else if(this.isVisible){
	        finalMat = this.finalTransform.mProp.v;
	    }
	    if(this.finalTransform.matMdf && this.layerElement){
	        this.transformedElement.setAttribute('transform',finalMat.to2dCSS());
	    }
	    if(this.finalTransform.opMdf && this.layerElement){
	        this.transformedElement.setAttribute('opacity',this.finalTransform.op.v);
	    }

	    if(this.data.hasMask){
	        this.maskManager.renderFrame(finalMat);
	    }
	    if(this.effectsManager){
	        this.effectsManager.renderFrame(this.firstFrame);
	    }
	    return this.isVisible;
	};

	SVGBaseElement.prototype.destroy = function(){
	    this.layerElement = null;
	    this.parentContainer = null;
	    if(this.matteElement) {
	        this.matteElement = null;
	    }
	    if(this.maskManager) {
	        this.maskManager.destroy();
	    }
	};

	SVGBaseElement.prototype.getBaseElement = function(){
	    return this.baseElement;
	};
	SVGBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new MaskElement(data,this,this.globalData);
	};

	SVGBaseElement.prototype.setMatte = function(id){
	    if(!this.matteElement){
	        return;
	    }
	    this.matteElement.setAttribute("mask", "url(#" + id + ")");
	};

	SVGBaseElement.prototype.setMatte = function(id){
	    if(!this.matteElement){
	        return;
	    }
	    this.matteElement.setAttribute("mask", "url(#" + id + ")");
	};

	SVGBaseElement.prototype.hide = function(){

	};

	function ITextElement(data, animationItem,parentContainer,globalData){
	}
	ITextElement.prototype.init = function(){
	    this._parent.init.call(this);

	    this.lettersChangedFlag = false;
	    this.currentTextDocumentData = {};
	    var data = this.data;
	    this.viewData = {
	        m:{
	            a: PropertyFactory.getProp(this,data.t.m.a,1,0,this.dynamicProperties)
	        }
	    };
	    var textData = this.data.t;
	    if(textData.a.length){
	        this.viewData.a = Array.apply(null,{length:textData.a.length});
	        var i, len = textData.a.length, animatorData, animatorProps;
	        for(i=0;i<len;i+=1){
	            animatorProps = textData.a[i];
	            animatorData = {
	                a: {},
	                s: {}
	            };
	            if('r' in animatorProps.a) {
	                animatorData.a.r = PropertyFactory.getProp(this,animatorProps.a.r,0,degToRads,this.dynamicProperties);
	            }
	            if('rx' in animatorProps.a) {
	                animatorData.a.rx = PropertyFactory.getProp(this,animatorProps.a.rx,0,degToRads,this.dynamicProperties);
	            }
	            if('ry' in animatorProps.a) {
	                animatorData.a.ry = PropertyFactory.getProp(this,animatorProps.a.ry,0,degToRads,this.dynamicProperties);
	            }
	            if('sk' in animatorProps.a) {
	                animatorData.a.sk = PropertyFactory.getProp(this,animatorProps.a.sk,0,degToRads,this.dynamicProperties);
	            }
	            if('sa' in animatorProps.a) {
	                animatorData.a.sa = PropertyFactory.getProp(this,animatorProps.a.sa,0,degToRads,this.dynamicProperties);
	            }
	            if('s' in animatorProps.a) {
	                animatorData.a.s = PropertyFactory.getProp(this,animatorProps.a.s,1,0.01,this.dynamicProperties);
	            }
	            if('a' in animatorProps.a) {
	                animatorData.a.a = PropertyFactory.getProp(this,animatorProps.a.a,1,0,this.dynamicProperties);
	            }
	            if('o' in animatorProps.a) {
	                animatorData.a.o = PropertyFactory.getProp(this,animatorProps.a.o,0,0.01,this.dynamicProperties);
	            }
	            if('p' in animatorProps.a) {
	                animatorData.a.p = PropertyFactory.getProp(this,animatorProps.a.p,1,0,this.dynamicProperties);
	            }
	            if('sw' in animatorProps.a) {
	                animatorData.a.sw = PropertyFactory.getProp(this,animatorProps.a.sw,0,0,this.dynamicProperties);
	            }
	            if('sc' in animatorProps.a) {
	                animatorData.a.sc = PropertyFactory.getProp(this,animatorProps.a.sc,1,0,this.dynamicProperties);
	            }
	            if('fc' in animatorProps.a) {
	                animatorData.a.fc = PropertyFactory.getProp(this,animatorProps.a.fc,1,0,this.dynamicProperties);
	            }
	            if('fh' in animatorProps.a) {
	                animatorData.a.fh = PropertyFactory.getProp(this,animatorProps.a.fh,0,0,this.dynamicProperties);
	            }
	            if('fs' in animatorProps.a) {
	                animatorData.a.fs = PropertyFactory.getProp(this,animatorProps.a.fs,0,0.01,this.dynamicProperties);
	            }
	            if('fb' in animatorProps.a) {
	                animatorData.a.fb = PropertyFactory.getProp(this,animatorProps.a.fb,0,0.01,this.dynamicProperties);
	            }
	            if('t' in animatorProps.a) {
	                animatorData.a.t = PropertyFactory.getProp(this,animatorProps.a.t,0,0,this.dynamicProperties);
	            }
	            animatorData.s = PropertyFactory.getTextSelectorProp(this,animatorProps.s,this.dynamicProperties);
	            animatorData.s.t = animatorProps.s.t;
	            this.viewData.a[i] = animatorData;
	        }
	    }else{
	        this.viewData.a = [];
	    }
	    if(textData.p && 'm' in textData.p){
	        this.viewData.p = {
	            f: PropertyFactory.getProp(this,textData.p.f,0,0,this.dynamicProperties),
	            l: PropertyFactory.getProp(this,textData.p.l,0,0,this.dynamicProperties),
	            r: textData.p.r,
	            m: this.maskManager.getMaskProperty(textData.p.m)
	        };
	        this.maskPath = true;
	    } else {
	        this.maskPath = false;
	    }
	};
	ITextElement.prototype.prepareFrame = function(num) {
	    var i = 0, len = this.data.t.d.k.length;
	    var textDocumentData = this.data.t.d.k[i].s;
	    i += 1;
	    while(i<len){
	        if(this.data.t.d.k[i].t > num){
	            break;
	        }
	        textDocumentData = this.data.t.d.k[i].s;
	        i += 1;
	    }
	    this.lettersChangedFlag = false;
	    if(textDocumentData !== this.currentTextDocumentData){
	        this.currentTextDocumentData = textDocumentData;
	        this.lettersChangedFlag = true;
	        this.buildNewText();
	    }
	    this._parent.prepareFrame.call(this, num);
	}

	ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
	    var j,jLen = shapes.length;
	    var k, kLen, pathNodes;
	    var shapeStr = '';
	    for(j=0;j<jLen;j+=1){
	        kLen = shapes[j].ks.k.i.length;
	        pathNodes = shapes[j].ks.k;
	        for(k=1;k<kLen;k+=1){
	            if(k==1){
	                shapeStr += " M"+matrixHelper.applyToPointStringified(pathNodes.v[0][0],pathNodes.v[0][1]);
	            }
	            shapeStr += " C"+matrixHelper.applyToPointStringified(pathNodes.o[k-1][0],pathNodes.o[k-1][1]) + " "+matrixHelper.applyToPointStringified(pathNodes.i[k][0],pathNodes.i[k][1]) + " "+matrixHelper.applyToPointStringified(pathNodes.v[k][0],pathNodes.v[k][1]);
	        }
	        shapeStr += " C"+matrixHelper.applyToPointStringified(pathNodes.o[k-1][0],pathNodes.o[k-1][1]) + " "+matrixHelper.applyToPointStringified(pathNodes.i[0][0],pathNodes.i[0][1]) + " "+matrixHelper.applyToPointStringified(pathNodes.v[0][0],pathNodes.v[0][1]);
	        shapeStr += 'z';
	    }
	    return shapeStr;
	};

	ITextElement.prototype.getMeasures = function(){

	    var matrixHelper = this.mHelper;
	    var renderType = this.renderType;
	    var data = this.data;
	    var xPos,yPos;
	    var i, len;
	    var documentData = this.currentTextDocumentData;
	    var letters = documentData.l;
	    if(this.maskPath) {
	        var mask = this.viewData.p.m;
	        if(!this.viewData.p.n || this.viewData.p.mdf){
	            var paths = mask.v;
	            if(this.viewData.p.r){
	                paths = reversePath(paths);
	            }
	            var pathInfo = {
	                tLength: 0,
	                segments: []
	            };
	            len = paths.v.length - 1;
	            var pathData;
	            var totalLength = 0;
	            for (i = 0; i < len; i += 1) {
	                pathData = {
	                    s: paths.v[i],
	                    e: paths.v[i + 1],
	                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	                    ti: [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]
	                };
	                bez.buildBezierData(pathData);
	                pathInfo.tLength += pathData.bezierData.segmentLength;
	                pathInfo.segments.push(pathData);
	                totalLength += pathData.bezierData.segmentLength;
	            }
	            i = len;
	            if (mask.v.c) {
	                pathData = {
	                    s: paths.v[i],
	                    e: paths.v[0],
	                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	                    ti: [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]
	                };
	                bez.buildBezierData(pathData);
	                pathInfo.tLength += pathData.bezierData.segmentLength;
	                pathInfo.segments.push(pathData);
	                totalLength += pathData.bezierData.segmentLength;
	            }
	            this.viewData.p.pi = pathInfo;
	        }
	        var pathInfo = this.viewData.p.pi;

	        var currentLength = this.viewData.p.f.v, segmentInd = 0, pointInd = 1, currentPoint, prevPoint, points;
	        var segmentLength = 0, flag = true;
	        var segments = pathInfo.segments;
	        if (currentLength < 0 && mask.v.c) {
	            if (pathInfo.tLength < Math.abs(currentLength)) {
	                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
	            }
	            segmentInd = segments.length - 1;
	            points = segments[segmentInd].bezierData.points;
	            pointInd = points.length - 1;
	            while (currentLength < 0) {
	                currentLength += points[pointInd].partialLength;
	                pointInd -= 1;
	                if (pointInd < 0) {
	                    segmentInd -= 1;
	                    points = segments[segmentInd].bezierData.points;
	                    pointInd = points.length - 1;
	                }
	            }

	        }
	        points = segments[segmentInd].bezierData.points;
	        prevPoint = points[pointInd - 1];
	        currentPoint = points[pointInd];
	        var partialLength = currentPoint.partialLength;
	        var perc, tanAngle;
	    }


	    len = letters.length;
	    xPos = 0;
	    yPos = 0;
	    var yOff = documentData.s*1.2*.714;
	    var firstLine = true;
	    var renderedData = this.viewData, animatorProps, animatorSelector;
	    var j, jLen;
	    var lettersValue = Array.apply(null,{length:len}), letterValue;

	    jLen = renderedData.a.length;
	    var lastLetter;

	    var mult, ind = -1, offf, xPathPos, yPathPos;
	    var initPathPos = currentLength,initSegmentInd = segmentInd, initPointInd = pointInd, currentLine = -1;
	    var elemOpacity;
	    var sc,sw,fc,k;
	    var lineLength = 0;
	    var letterSw,letterSc,letterFc,letterM,letterP,letterO;
	    for( i = 0; i < len; i += 1) {
	        matrixHelper.reset();
	        elemOpacity = 1;
	        if(letters[i].n) {
	            xPos = 0;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            currentLength = initPathPos ;
	            firstLine = false;
	            lineLength = 0;
	            if(this.maskPath) {
	                segmentInd = initSegmentInd;
	                pointInd = initPointInd;
	                points = segments[segmentInd].bezierData.points;
	                prevPoint = points[pointInd - 1];
	                currentPoint = points[pointInd];
	                partialLength = currentPoint.partialLength;
	                segmentLength = 0;
	            }
	            lettersValue[i] = this.emptyProp;
	        }else{
	            if(this.maskPath) {
	                if(currentLine !== letters[i].line){
	                    switch(documentData.j){
	                        case 1:
	                            currentLength += totalLength - documentData.lineWidths[letters[i].line];
	                            break;
	                        case 2:
	                            currentLength += (totalLength - documentData.lineWidths[letters[i].line])/2;
	                            break;
	                    }
	                    currentLine = letters[i].line;
	                }
	                if (ind !== letters[i].ind) {
	                    if (letters[ind]) {
	                        currentLength += letters[ind].extra;
	                    }
	                    currentLength += letters[i].an / 2;
	                    ind = letters[i].ind;
	                }
	                currentLength += renderedData.m.a.v[0] * letters[i].an / 200;
	                var animatorOffset = 0;
	                for (j = 0; j < jLen; j += 1) {
	                    animatorProps = renderedData.a[j].a;
	                    if ('p' in animatorProps) {
	                        animatorSelector = renderedData.a[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);
	                        if(mult.length){
	                            animatorOffset += animatorProps.p.v[0] * mult[0];
	                        } else{
	                            animatorOffset += animatorProps.p.v[0] * mult;
	                        }

	                    }
	                }
	                flag = true;
	                while (flag) {
	                    if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
	                        perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
	                        xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
	                        yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
	                        matrixHelper.translate(0, -(renderedData.m.a.v[1] * yOff / 100) + yPos);
	                        flag = false;
	                    } else if (points) {
	                        segmentLength += currentPoint.partialLength;
	                        pointInd += 1;
	                        if (pointInd >= points.length) {
	                            pointInd = 0;
	                            segmentInd += 1;
	                            if (!segments[segmentInd]) {
	                                if (mask.v.c) {
	                                    pointInd = 0;
	                                    segmentInd = 0;
	                                    points = segments[segmentInd].bezierData.points;
	                                } else {
	                                    segmentLength -= currentPoint.partialLength;
	                                    points = null;
	                                }
	                            } else {
	                                points = segments[segmentInd].bezierData.points;
	                            }
	                        }
	                        if (points) {
	                            prevPoint = currentPoint;
	                            currentPoint = points[pointInd];
	                            partialLength = currentPoint.partialLength;
	                        }
	                    }
	                }
	                offf = letters[i].an / 2 - letters[i].add;
	                matrixHelper.translate(-offf, 0, 0);
	            } else {
	                offf = letters[i].an/2 - letters[i].add;
	                matrixHelper.translate(-offf,0,0);

	                // Grouping alignment
	                matrixHelper.translate(-renderedData.m.a.v[0]*letters[i].an/200, -renderedData.m.a.v[1]*yOff/100, 0);
	            }

	            lineLength += letters[i].l/2;
	            for(j=0;j<jLen;j+=1){
	                animatorProps = renderedData.a[j].a;
	                if ('t' in animatorProps) {
	                    animatorSelector = renderedData.a[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);
	                    if(this.maskPath) {
	                        if(mult.length) {
	                            currentLength += animatorProps.t*mult[0];
	                        } else {
	                            currentLength += animatorProps.t*mult;
	                        }
	                    }else{
	                        if(mult.length) {
	                            xPos += animatorProps.t.v*mult[0];
	                        } else {
	                            xPos += animatorProps.t.v*mult;
	                        }
	                    }
	                }
	            }
	            lineLength += letters[i].l/2;
	            if(documentData.strokeWidthAnim) {
	                sw = documentData.sw || 0;
	            }
	            if(documentData.strokeColorAnim) {
	                if(documentData.sc){
	                    sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
	                }else{
	                    sc = [0,0,0];
	                }
	            }
	            if(documentData.fillColorAnim) {
	                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = renderedData.a[j].a;
	                if ('a' in animatorProps) {
	                    animatorSelector = renderedData.a[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);

	                    if(mult.length){
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult[0], -animatorProps.a.v[1]*mult[1], animatorProps.a.v[2]*mult[2]);
	                    } else {
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult, -animatorProps.a.v[1]*mult, animatorProps.a.v[2]*mult);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = renderedData.a[j].a;
	                if ('s' in animatorProps) {
	                    animatorSelector = renderedData.a[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);
	                    if(mult.length){
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult[0]),1+((animatorProps.s.v[1]-1)*mult[1]),1);
	                    } else {
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult),1+((animatorProps.s.v[1]-1)*mult),1);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1) {
	                animatorProps = renderedData.a[j].a;
	                animatorSelector = renderedData.a[j].s;
	                mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);
	                if ('sk' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
	                    } else {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
	                    }
	                }
	                if ('r' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
	                    } else {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult);
	                    }
	                }
	                if ('ry' in animatorProps) {

	                    if(mult.length) {
	                        matrixHelper.rotateY(animatorProps.ry.v*mult[1]);
	                    }else{
	                        matrixHelper.rotateY(animatorProps.ry.v*mult);
	                    }
	                }
	                if ('rx' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult[0]);
	                    } else {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult);
	                    }
	                }
	                if ('o' in animatorProps) {
	                    if(mult.length) {
	                        elemOpacity += ((animatorProps.o.v)*mult[0] - elemOpacity)*mult[0];
	                    } else {
	                        elemOpacity += ((animatorProps.o.v)*mult - elemOpacity)*mult;
	                    }
	                }
	                if (documentData.strokeWidthAnim && 'sw' in animatorProps) {
	                    if(mult.length) {
	                        sw += animatorProps.sw.v*mult[0];
	                    } else {
	                        sw += animatorProps.sw.v*mult;
	                    }
	                }
	                if (documentData.strokeColorAnim && 'sc' in animatorProps) {
	                    for(k=0;k<3;k+=1){
	                        if(mult.length) {
	                            sc[k] = Math.round(255*(sc[k] + (animatorProps.sc.v[k] - sc[k])*mult[0]));
	                        } else {
	                            sc[k] = Math.round(255*(sc[k] + (animatorProps.sc.v[k] - sc[k])*mult));
	                        }
	                    }
	                }
	                if (documentData.fillColorAnim) {
	                    if('fc' in animatorProps){
	                        for(k=0;k<3;k+=1){
	                            if(mult.length) {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult[0];
	                            } else {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult;
	                                //console.log('mult',mult);
	                                //console.log(Math.round(fc[k] + (animatorProps.fc.v[k] - fc[k])*mult));
	                            }
	                        }
	                    }
	                    if('fh' in animatorProps){
	                        if(mult.length) {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult[0]);
	                        } else {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult);
	                        }
	                    }
	                    if('fs' in animatorProps){
	                        if(mult.length) {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);
	                        } else {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult);
	                        }
	                    }
	                    if('fb' in animatorProps){
	                        if(mult.length) {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);
	                        } else {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult);
	                        }
	                    }
	                }
	            }

	            for(j=0;j<jLen;j+=1){
	                animatorProps = renderedData.a[j].a;

	                if ('p' in animatorProps) {
	                    animatorSelector = renderedData.a[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],data.t.a[j].s.totalChars);
	                    if(this.maskPath) {
	                        if(mult.length) {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
	                        } else {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        }
	                    }else{

	                        if(mult.length) {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
	                        } else {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        }
	                    }
	                }
	            }
	            if(documentData.strokeWidthAnim){
	                letterSw = sw < 0 ? 0 : sw;
	            }
	            if(documentData.strokeColorAnim){
	                letterSc = 'rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';
	            }
	            if(documentData.fillColorAnim){
	                letterFc = 'rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';
	            }

	            if(this.maskPath) {
	                if (data.t.p.p) {
	                    tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
	                    var rot = Math.atan(tanAngle) * 180 / Math.PI;
	                    if (currentPoint.point[0] < prevPoint.point[0]) {
	                        rot += 180;
	                    }
	                    matrixHelper.rotate(-rot * Math.PI / 180);
	                }
	                matrixHelper.translate(xPathPos, yPathPos, 0);
	                matrixHelper.translate(renderedData.m.a.v[0]*letters[i].an/200, renderedData.m.a.v[1]*yOff/100,0);
	                currentLength -= renderedData.m.a.v[0]*letters[i].an/200;
	                if(letters[i+1] && ind !== letters[i+1].ind){
	                    currentLength += letters[i].an / 2;
	                    currentLength += documentData.tr/1000*documentData.s;
	                }
	            }else{

	                matrixHelper.translate(xPos,yPos,0);

	                if(documentData.ps){
	                    //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
	                    matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	                }
	                switch(documentData.j){
	                    case 1:
	                        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]),0,0);
	                        break;
	                    case 2:
	                        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line])/2,0,0);
	                        break;
	                }
	                matrixHelper.translate(offf,0,0);
	                matrixHelper.translate(renderedData.m.a.v[0]*letters[i].an/200,renderedData.m.a.v[1]*yOff/100,0);
	                xPos += letters[i].l + documentData.tr/1000*documentData.s;
	            }
	            if(renderType === 'html'){
	                letterM = matrixHelper.toCSS();
	            }else if(renderType === 'svg'){
	                letterM = matrixHelper.to2dCSS();
	            }else{
	                letterP = [matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];
	            }
	            letterO = elemOpacity;

	            lastLetter = this.renderedLetters[i];
	            if(lastLetter && (lastLetter.o !== letterO || lastLetter.sw !== letterSw || lastLetter.sc !== letterSc || lastLetter.fc !== letterFc)){
	                this.lettersChangedFlag = true;
	                letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);
	            }else{
	                if((renderType === 'svg' || renderType === 'html') && (!lastLetter || lastLetter.m !== letterM)){
	                    this.lettersChangedFlag = true;
	                    letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM);
	                }else if(renderType === 'canvas' && (!lastLetter || (lastLetter.props[0] !== letterP[0] || lastLetter.props[1] !== letterP[1] || lastLetter.props[4] !== letterP[4] || lastLetter.props[5] !== letterP[5] || lastLetter.props[12] !== letterP[12] || lastLetter.props[13] !== letterP[13]))){
	                    this.lettersChangedFlag = true;
	                    letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,null,letterP);
	                } else {
	                    letterValue = lastLetter;
	                }
	            }
	            this.renderedLetters[i] = letterValue;
	        }
	    }
	};

	ITextElement.prototype.emptyProp = new LetterProps();

	function SVGTextElement(data,parentContainer,globalData,comp, placeholder){
	    this.textSpans = [];
	    this.renderType = 'svg';
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, SVGTextElement);

	SVGTextElement.prototype.init = ITextElement.prototype.init;
	SVGTextElement.prototype.createPathShape = ITextElement.prototype.createPathShape;
	SVGTextElement.prototype.getMeasures = ITextElement.prototype.getMeasures;
	SVGTextElement.prototype.prepareFrame = ITextElement.prototype.prepareFrame;

	SVGTextElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);


	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }
	};

	SVGTextElement.prototype.buildNewText = function(){
	    var i, len;

	    var documentData = this.currentTextDocumentData;
	    this.renderedLetters = Array.apply(null,{length:this.currentTextDocumentData.l ? this.currentTextDocumentData.l.length : 0});
	    if(documentData.fc) {
	        this.layerElement.setAttribute('fill', 'rgb(' + Math.round(documentData.fc[0]*255) + ',' + Math.round(documentData.fc[1]*255) + ',' + Math.round(documentData.fc[2]*255) + ')');
	    }else{
	        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
	    }
	    if(documentData.sc){
	        this.layerElement.setAttribute('stroke', 'rgb(' + Math.round(documentData.sc[0]*255) + ',' + Math.round(documentData.sc[1]*255) + ',' + Math.round(documentData.sc[2]*255) + ')');
	        this.layerElement.setAttribute('stroke-width', documentData.sw);
	    }
	    this.layerElement.setAttribute('font-size', documentData.s);
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(fontData.fClass){
	        this.layerElement.setAttribute('class',fontData.fClass);
	    } else {
	        this.layerElement.setAttribute('font-family', fontData.fFamily);
	        var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	        this.layerElement.setAttribute('font-style', fStyle);
	        this.layerElement.setAttribute('font-weight', fWeight);
	    }



	    var letters = documentData.l || [];
	    len = letters.length;
	    if(!len){
	        return;
	    }
	    var tSpan;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '', singleShape = this.data.singleShape;
	    if (singleShape) {
	        var xPos = 0, yPos = 0, lineWidths = documentData.lineWidths, boxWidth = documentData.boxWidth, firstLine = true;
	    }
	    var cnt = 0;
	    for (i = 0;i < len ;i += 1) {
	        if(this.globalData.fontManager.chars){
	            if(!singleShape || i === 0){
	                tSpan = this.textSpans[cnt] ? this.textSpans[cnt] : document.createElementNS(svgNS,'path');
	            }
	        }else{
	            tSpan = this.textSpans[cnt] ? this.textSpans[cnt] : document.createElementNS(svgNS,'text');
	        }
	        tSpan.style.display = 'inherit';
	        tSpan.setAttribute('stroke-linecap', 'butt');
	        tSpan.setAttribute('stroke-linejoin','round');
	        tSpan.setAttribute('stroke-miterlimit','4');
	        //tSpan.setAttribute('visibility', 'hidden');
	        if(singleShape && letters[i].n) {
	            xPos = 0;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            firstLine = false;
	        }
	        matrixHelper.reset();
	        if(this.globalData.fontManager.chars) {
	            matrixHelper.scale(documentData.s / 100, documentData.s / 100);
	        }
	        if (singleShape) {
	            if(documentData.ps){
	                matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	            }
	            switch(documentData.j){
	                case 1:
	                    matrixHelper.translate(documentData.justifyOffset + (boxWidth - lineWidths[letters[i].line]),0,0);
	                    break;
	                case 2:
	                    matrixHelper.translate(documentData.justifyOffset + (boxWidth - lineWidths[letters[i].line])/2,0,0);
	                    break;
	            }
	            matrixHelper.translate(xPos, yPos, 0);
	        }
	        if(this.globalData.fontManager.chars){
	            var charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	            var shapeData;
	            if(charData){
	                shapeData = charData.data;
	            } else {
	                shapeData = null;
	            }
	            if(shapeData && shapeData.shapes){
	                shapes = shapeData.shapes[0].it;
	                if(!singleShape){
	                    shapeStr = '';
	                }
	                shapeStr += this.createPathShape(matrixHelper,shapes);
	                if(!singleShape){

	                    tSpan.setAttribute('d',shapeStr);
	                }
	            }
	            if(!singleShape){
	                this.layerElement.appendChild(tSpan);
	            }
	        }else{
	            tSpan.textContent = letters[i].val;
	            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            this.layerElement.appendChild(tSpan);
	            if(singleShape){
	                tSpan.setAttribute('transform',matrixHelper.to2dCSS());
	            }
	        }
	        if(singleShape) {
	            xPos += letters[i].l;
	            xPos += documentData.tr/1000*documentData.s;
	        }
	        //
	        this.textSpans[cnt] = tSpan;
	        cnt += 1;
	    }
	    if(!singleShape){
	        while(cnt < this.textSpans.length){
	            this.textSpans[cnt].style.display = 'none';
	            cnt += 1;
	        }
	    }
	    if(singleShape && this.globalData.fontManager.chars){
	        tSpan.setAttribute('d',shapeStr);
	        this.layerElement.appendChild(tSpan);
	    }
	}

	SVGTextElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.layerElement.style.display = 'none';
	        this.hidden = true;
	    }
	};

	SVGTextElement.prototype.renderFrame = function(parentMatrix){

	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.hidden = false;
	        this.layerElement.style.display = 'block';
	    }

	    if(this.data.singleShape){
	        return;
	    }
	    this.getMeasures();
	    if(!this.lettersChangedFlag){
	        return;
	    }
	    var  i,len;
	    var renderedLetters = this.renderedLetters;

	    var letters = this.currentTextDocumentData.l;

	    len = letters.length;
	    var renderedLetter;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            continue;
	        }
	        renderedLetter = renderedLetters[i];
	        this.textSpans[i].setAttribute('transform',renderedLetter.m);
	        this.textSpans[i].setAttribute('opacity',renderedLetter.o);
	        if(renderedLetter.sw){
	            this.textSpans[i].setAttribute('stroke-width',renderedLetter.sw);
	        }
	        if(renderedLetter.sc){
	            this.textSpans[i].setAttribute('stroke',renderedLetter.sc);
	        }
	        if(renderedLetter.fc){
	            this.textSpans[i].setAttribute('fill',renderedLetter.fc);
	        }
	    }
	    if(this.firstFrame) {
	        this.firstFrame = false;
	    }
	}


	SVGTextElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	};
	function SVGTintFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f2');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	    if(filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k){
	        var feMerge = document.createElementNS(svgNS,'feMerge');
	        filter.appendChild(feMerge);
	        var feMergeNode;
	        feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	        feMergeNode.setAttribute('in','SourceGraphic');
	        feMerge.appendChild(feMergeNode);
	        feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	        feMergeNode.setAttribute('in','f2');
	        feMerge.appendChild(feMergeNode);
	    }
	}

	SVGTintFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var colorBlack = this.filterManager.effectElements[0].p.v;
	        var colorWhite = this.filterManager.effectElements[1].p.v;
	        var opacity = this.filterManager.effectElements[2].p.v/100;
	        this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGFillFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	}
	SVGFillFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var color = this.filterManager.effectElements[2].p.v;
	        var opacity = this.filterManager.effectElements[6].p.v;
	        this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');
	    }
	};
	function SVGStrokeEffect(elem, filterManager){
	    this.initialized = false;
	    this.filterManager = filterManager;
	    this.elem = elem;
	    this.paths = [];
	}

	SVGStrokeEffect.prototype.initialize = function(){

	    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	    var path,groupPath, i, len;
	    if(this.filterManager.effectElements[1].p.v === 1){
	        len = this.elem.maskManager.masksProperties.length;
	        i = 0;
	    } else {
	        i = this.filterManager.effectElements[0].p.v - 1;
	        len = i + 1;
	    }
	    groupPath = document.createElementNS(svgNS,'g'); 
	    groupPath.setAttribute('fill','none');
	    groupPath.setAttribute('stroke-linecap','round');
	    groupPath.setAttribute('stroke-dashoffset',1);
	    for(i;i<len;i+=1){
	        path = document.createElementNS(svgNS,'path');
	        groupPath.appendChild(path);
	        this.paths.push({p:path,m:i});
	    }
	    if(this.filterManager.effectElements[10].p.v === 3){
	        var mask = document.createElementNS(svgNS,'mask');
	        var id = 'stms_' + randomString(10);
	        mask.setAttribute('id',id);
	        mask.setAttribute('mask-type','alpha');
	        mask.appendChild(groupPath);
	        this.elem.globalData.defs.appendChild(mask);
	        var g = document.createElementNS(svgNS,'g');
	        g.setAttribute('mask','url(#'+id+')');
	        if(elemChildren[0]){
	            g.appendChild(elemChildren[0]);
	        }
	        this.elem.layerElement.appendChild(g);
	        this.masker = mask;
	        groupPath.setAttribute('stroke','#fff');
	    } else if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(this.filterManager.effectElements[10].p.v === 2){
	            var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	            while(elemChildren.length){
	                this.elem.layerElement.removeChild(elemChildren[0]);
	            }
	        }
	        this.elem.layerElement.appendChild(groupPath);
	        this.elem.layerElement.removeAttribute('mask');
	        groupPath.setAttribute('stroke','#fff');
	    }
	    this.initialized = true;
	    this.pathMasker = groupPath;
	}

	SVGStrokeEffect.prototype.renderFrame = function(forceRender){
	    if(!this.initialized){
	        this.initialize();
	    }
	    var i, len = this.paths.length;
	    var mask, path;
	    for(i=0;i<len;i+=1){
	        mask = this.elem.maskManager.viewData[this.paths[i].m];
	        path = this.paths[i].p;
	        if(forceRender || this.filterManager.mdf || mask.prop.mdf){
	            path.setAttribute('d',mask.lastPath);
	        }
	        if(forceRender || this.filterManager.effectElements[9].p.mdf || this.filterManager.effectElements[4].p.mdf || this.filterManager.effectElements[7].p.mdf || this.filterManager.effectElements[8].p.mdf || mask.prop.mdf){
	            var dasharrayValue;
	            if(this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100){
	                var s = Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var e = Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var l = path.getTotalLength();
	                dasharrayValue = '0 0 0 ' + l*s + ' ';
	                var lineLength = l*(e-s);
	                var segment = 1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	                var units = Math.floor(lineLength/segment);
	                var j;
	                for(j=0;j<units;j+=1){
	                    dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100 + ' ';
	                }
	                dasharrayValue += '0 ' + l*10 + ' 0 0';
	            } else {
	                dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	            }
	            path.setAttribute('stroke-dasharray',dasharrayValue);
	        }
	    }
	    if(forceRender || this.filterManager.effectElements[4].p.mdf){
	        this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);
	    }
	    
	    if(forceRender || this.filterManager.effectElements[6].p.mdf){
	        this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);
	    }
	    if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(forceRender || this.filterManager.effectElements[3].p.mdf){
	            var color = this.filterManager.effectElements[3].p.v;
	            this.pathMasker.setAttribute('stroke','rgb('+bm_floor(color[0]*255)+','+bm_floor(color[1]*255)+','+bm_floor(color[2]*255)+')');
	        }
	    }
	};
	function SVGTritoneFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    var feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	    filter.appendChild(feComponentTransfer);
	    this.matrixFilter = feComponentTransfer;
	    var feFuncR = document.createElementNS(svgNS,'feFuncR');
	    feFuncR.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncR);
	    this.feFuncR = feFuncR;
	    var feFuncG = document.createElementNS(svgNS,'feFuncG');
	    feFuncG.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncG);
	    this.feFuncG = feFuncG;
	    var feFuncB = document.createElementNS(svgNS,'feFuncB');
	    feFuncB.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncB);
	    this.feFuncB = feFuncB;
	}

	SVGTritoneFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var color1 = this.filterManager.effectElements[0].p.v;
	        var color2 = this.filterManager.effectElements[1].p.v;
	        var color3 = this.filterManager.effectElements[2].p.v;
	        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0]
	        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1]
	        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2]
	        this.feFuncR.setAttribute('tableValues', tableR);
	        this.feFuncG.setAttribute('tableValues', tableG);
	        this.feFuncB.setAttribute('tableValues', tableB);
	        //var opacity = this.filterManager.effectElements[2].p.v/100;
	        //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGProLevelsFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var effectElements = this.filterManager.effectElements;
	    var feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    var feFuncR, feFuncG, feFuncB;
	    
	    if(effectElements[9].p.k || effectElements[9].p.v !== 0 || effectElements[10].p.k || effectElements[10].p.v !== 1 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 0 || effectElements[13].p.k || effectElements[13].p.v !== 1){
	        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
	    }
	    if(effectElements[16].p.k || effectElements[16].p.v !== 0 || effectElements[17].p.k || effectElements[17].p.v !== 1 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 0 || effectElements[20].p.k || effectElements[20].p.v !== 1){
	        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
	    }
	    if(effectElements[23].p.k || effectElements[23].p.v !== 0 || effectElements[24].p.k || effectElements[24].p.v !== 1 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 0 || effectElements[27].p.k || effectElements[27].p.v !== 1){
	        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	    if(effectElements[30].p.k || effectElements[30].p.v !== 0 || effectElements[31].p.k || effectElements[31].p.v !== 1 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 0 || effectElements[34].p.k || effectElements[34].p.v !== 1){
	        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
	    }
	    
	    if(this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA){
	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    }

	    if(effectElements[2].p.k || effectElements[2].p.v !== 0 || effectElements[3].p.k || effectElements[3].p.v !== 1 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 0 || effectElements[6].p.k || effectElements[6].p.v !== 1){

	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
	        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
	        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	}

	SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
	    var feFunc = document.createElementNS(svgNS,type);
	    feFunc.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFunc);
	    return feFunc;
	};

	SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
	    var cnt = 0;
	    var segments = 256;
	    var perc;
	    var min = Math.min(inputBlack, inputWhite);
	    var max = Math.max(inputBlack, inputWhite);
	    var table = Array.call(null,{length:segments});
	    var colorValue;
	    var pos = 0;
	    var outputDelta = outputWhite - outputBlack; 
	    var inputDelta = inputWhite - inputBlack; 
	    while(cnt <= 256) {
	        perc = cnt/256;
	        if(perc <= min){
	            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
	        } else if(perc >= max){
	            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
	        } else {
	            colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
	        }
	        table[pos++] = colorValue;
	        cnt += 256/(segments-1);
	    }
	    return table.join(' ');
	};

	SVGProLevelsFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var val, cnt, perc, bezier;
	        var effectElements = this.filterManager.effectElements;
	        if(this.feFuncRComposed && (forceRender || effectElements[2].p.mdf || effectElements[3].p.mdf || effectElements[4].p.mdf || effectElements[5].p.mdf || effectElements[6].p.mdf)){
	            val = this.getTableValue(effectElements[2].p.v,effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v);
	            this.feFuncRComposed.setAttribute('tableValues',val);
	            this.feFuncGComposed.setAttribute('tableValues',val);
	            this.feFuncBComposed.setAttribute('tableValues',val);
	        }

	        if(this.feFuncR && (forceRender || effectElements[9].p.mdf || effectElements[10].p.mdf || effectElements[11].p.mdf || effectElements[12].p.mdf || effectElements[13].p.mdf)){
	            val = this.getTableValue(effectElements[9].p.v,effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v);
	            this.feFuncR.setAttribute('tableValues',val);
	        }

	        if(this.feFuncG && (forceRender || effectElements[16].p.mdf || effectElements[17].p.mdf || effectElements[18].p.mdf || effectElements[19].p.mdf || effectElements[20].p.mdf)){
	            val = this.getTableValue(effectElements[16].p.v,effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v);
	            this.feFuncG.setAttribute('tableValues',val);
	        }

	        if(this.feFuncB && (forceRender || effectElements[23].p.mdf || effectElements[24].p.mdf || effectElements[25].p.mdf || effectElements[26].p.mdf || effectElements[27].p.mdf)){
	            val = this.getTableValue(effectElements[23].p.v,effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v);
	            this.feFuncB.setAttribute('tableValues',val);
	        }

	        if(this.feFuncA && (forceRender || effectElements[30].p.mdf || effectElements[31].p.mdf || effectElements[32].p.mdf || effectElements[33].p.mdf || effectElements[34].p.mdf)){
	            val = this.getTableValue(effectElements[30].p.v,effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v);
	            this.feFuncA.setAttribute('tableValues',val);
	        }
	        
	    }
	};
	function SVGDropShadowEffect(filter, filterManager){
	    /*<feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <!-- stdDeviation is how much to blur -->
	  <feOffset dx="2" dy="2" result="offsetblur"/> <!-- how much to offset -->
	  <feMerge> 
	    <feMergeNode/> <!-- this contains the offset blurred image -->
	    <feMergeNode in="SourceGraphic"/> <!-- this contains the element that the filter is applied to -->
	  </feMerge>*/
	  /*<feFlood flood-color="#3D4574" flood-opacity="0.5" result="offsetColor"/>*/
	    filter.setAttribute('x','-100%');
	    filter.setAttribute('y','-100%');
	    filter.setAttribute('width','400%');
	    filter.setAttribute('height','400%');
	    this.filterManager = filterManager;

	    var feGaussianBlur = document.createElementNS(svgNS,'feGaussianBlur');
	    feGaussianBlur.setAttribute('in','SourceAlpha');
	    feGaussianBlur.setAttribute('result','drop_shadow_1');
	    feGaussianBlur.setAttribute('stdDeviation','0');
	    this.feGaussianBlur = feGaussianBlur;
	    filter.appendChild(feGaussianBlur);

	    var feOffset = document.createElementNS(svgNS,'feOffset');
	    feOffset.setAttribute('dx','25');
	    feOffset.setAttribute('dy','0');
	    feOffset.setAttribute('in','drop_shadow_1');
	    feOffset.setAttribute('result','drop_shadow_2');
	    this.feOffset = feOffset;
	    filter.appendChild(feOffset);
	    var feFlood = document.createElementNS(svgNS,'feFlood');
	    feFlood.setAttribute('flood-color','#00ff00');
	    feFlood.setAttribute('flood-opacity','1');
	    feFlood.setAttribute('result','drop_shadow_3');
	    this.feFlood = feFlood;
	    filter.appendChild(feFlood);

	    var feComposite = document.createElementNS(svgNS,'feComposite');
	    feComposite.setAttribute('in','drop_shadow_3');
	    feComposite.setAttribute('in2','drop_shadow_2');
	    feComposite.setAttribute('operator','in');
	    feComposite.setAttribute('result','drop_shadow_4');
	    filter.appendChild(feComposite);


	    var feMerge = document.createElementNS(svgNS,'feMerge');
	    filter.appendChild(feMerge);
	    var feMergeNode;
	    feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	    feMerge.appendChild(feMergeNode);
	    feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	    feMergeNode.setAttribute('in','SourceGraphic');
	    this.feMergeNode = feMergeNode;
	    this.feMerge = feMerge;
	    this.originalNodeAdded = false;
	    feMerge.appendChild(feMergeNode);
	}

	SVGDropShadowEffect.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        if(forceRender || this.filterManager.effectElements[4].p.mdf){
	            this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
	        }
	        if(forceRender || this.filterManager.effectElements[0].p.mdf){
	            var col = this.filterManager.effectElements[0].p.v;
	            this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));
	        }
	        if(forceRender || this.filterManager.effectElements[1].p.mdf){
	            this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);
	        }
	        if(forceRender || this.filterManager.effectElements[2].p.mdf || this.filterManager.effectElements[3].p.mdf){
	            var distance = this.filterManager.effectElements[3].p.v
	            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads
	            var x = distance * Math.cos(angle)
	            var y = distance * Math.sin(angle)
	            this.feOffset.setAttribute('dx', x);
	            this.feOffset.setAttribute('dy', y);
	        }
	        /*if(forceRender || this.filterManager.effectElements[5].p.mdf){
	            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
	                this.feMerge.removeChild(this.feMergeNode);
	                this.originalNodeAdded = false;
	            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
	                this.feMerge.appendChild(this.feMergeNode);
	                this.originalNodeAdded = true;
	            }
	        }*/
	    }
	};
	function SVGEffects(elem){
	    var i, len = elem.data.ef.length;
	    var filId = randomString(10);
	    var fil = filtersFactory.createFilter(filId);
	    var count = 0;
	    this.filters = [];
	    var filterManager;
	    for(i=0;i<len;i+=1){
	        if(elem.data.ef[i].ty === 20){
	            count += 1;
	            filterManager = new SVGTintFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 21){
	            count += 1;
	            filterManager = new SVGFillFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 22){
	            filterManager = new SVGStrokeEffect(elem, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 23){
	            count += 1;
	            filterManager = new SVGTritoneFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 24){
	            count += 1;
	            filterManager = new SVGProLevelsFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 25){
	            count += 1;
	            filterManager = new SVGDropShadowEffect(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }
	    }
	    if(count){
	        elem.globalData.defs.appendChild(fil);
	        elem.layerElement.setAttribute('filter','url(#'+filId+')');
	    }
	}

	SVGEffects.prototype.renderFrame = function(firstFrame){
	    var i, len = this.filters.length;
	    for(i=0;i<len;i+=1){
	        this.filters[i].renderFrame(firstFrame);
	    }
	};
	function ICompElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.layers = data.layers;
	    this.supports3d = true;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = this.layers ? Array.apply(null,{length:this.layers.length}) : [];
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.xt){
	        this.layerElement = document.createElementNS(svgNS,'g');
	        this.buildAllItems();
	    } else if(!globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	}
	createElement(SVGBaseElement, ICompElement);

	ICompElement.prototype.hide = function(){
	    if(!this.hidden){
	        var i,len = this.elements.length;
	        for( i = 0; i < len; i+=1 ){
	            if(this.elements[i]){
	                this.elements[i].hide();
	            }
	        }
	        this.hidden = true;
	    }
	};

	ICompElement.prototype.prepareFrame = function(num){
	    this._parent.prepareFrame.call(this,num);
	    if(this.isVisible===false && !this.data.xt){
	        return;
	    }

	    if(this.tm){
	        var timeRemapped = this.tm.v;
	        if(timeRemapped === this.data.op){
	            timeRemapped = this.data.op - 1;
	        }
	        this.renderedFrame = timeRemapped;
	    } else {
	        this.renderedFrame = num/this.data.sr;
	    }
	    var i,len = this.elements.length;
	    if(!this.completeLayers){
	        this.checkLayers(this.renderedFrame);
	    }
	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
	        }
	    }
	};

	ICompElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    var i,len = this.layers.length;
	    if(renderParent===false){
	        this.hide();
	        return;
	    }

	    this.hidden = false;
	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	ICompElement.prototype.setElements = function(elems){
	    this.elements = elems;
	};

	ICompElement.prototype.getElements = function(){
	    return this.elements;
	};

	ICompElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    var i,len = this.layers.length;
	    for( i = 0; i < len; i+=1 ){
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	};

	ICompElement.prototype.checkLayers = SVGRenderer.prototype.checkLayers;
	ICompElement.prototype.buildItem = SVGRenderer.prototype.buildItem;
	ICompElement.prototype.buildAllItems = SVGRenderer.prototype.buildAllItems;
	ICompElement.prototype.buildElementParenting = SVGRenderer.prototype.buildElementParenting;
	ICompElement.prototype.createItem = SVGRenderer.prototype.createItem;
	ICompElement.prototype.createImage = SVGRenderer.prototype.createImage;
	ICompElement.prototype.createComp = SVGRenderer.prototype.createComp;
	ICompElement.prototype.createSolid = SVGRenderer.prototype.createSolid;
	ICompElement.prototype.createShape = SVGRenderer.prototype.createShape;
	ICompElement.prototype.createText = SVGRenderer.prototype.createText;
	ICompElement.prototype.createBase = SVGRenderer.prototype.createBase;
	ICompElement.prototype.appendElementInPos = SVGRenderer.prototype.appendElementInPos;
	ICompElement.prototype.checkPendingElements = SVGRenderer.prototype.checkPendingElements;
	ICompElement.prototype.addPendingElement = SVGRenderer.prototype.addPendingElement;
	function IImageElement(data,parentContainer,globalData,comp,placeholder){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp,placeholder);
	}
	createElement(SVGBaseElement, IImageElement);

	IImageElement.prototype.createElements = function(){

	    var assetPath = this.globalData.getAssetsPath(this.assetData);

	    this._parent.createElements.call(this);

	    this.innerElem = document.createElementNS(svgNS,'image');
	    this.innerElem.setAttribute('width',this.assetData.w+"px");
	    this.innerElem.setAttribute('height',this.assetData.h+"px");
	    this.innerElem.setAttribute('preserveAspectRatio','xMidYMid slice');
	    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	    this.maskedElement = this.innerElem;
	    this.layerElement.appendChild(this.innerElem);
	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }

	};

	IImageElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.layerElement.style.display = 'none';
	        this.hidden = true;
	    }
	};

	IImageElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.hidden = false;
	        this.layerElement.style.display = 'block';
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	IImageElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    this.innerElem =  null;
	};
	function IShapeElement(data,parentContainer,globalData,comp, placeholder){
	    this.shapes = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.viewData = [];
	    this.shapeModifiers = [];
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, IShapeElement);

	IShapeElement.prototype.lcEnum = {
	    '1': 'butt',
	    '2': 'round',
	    '3': 'butt'
	}

	IShapeElement.prototype.ljEnum = {
	    '1': 'miter',
	    '2': 'round',
	    '3': 'butt'
	}

	IShapeElement.prototype.buildExpressionInterface = function(){};

	IShapeElement.prototype.createElements = function(){
	    //TODO check if I can use symbol so i can set its viewBox
	    this._parent.createElements.call(this);
	    this.searchShapes(this.shapesData,this.viewData,this.layerElement,this.dynamicProperties, 0);
	    if(!this.data.hd || this.data.td){
	        styleUnselectableDiv(this.layerElement);
	    }
	    //this.elemInterface.registerShapeExpressionInterface(ShapeExpressionInterface.createShapeInterface(this.shapesData,this.viewData,this.elemInterface));
	};

	IShapeElement.prototype.setGradientData = function(pathElement,arr,data){

	    var gradientId = 'gr_'+randomString(10);
	    var gfill;
	    if(arr.t === 1){
	        gfill = document.createElementNS(svgNS,'linearGradient');
	    } else {
	        gfill = document.createElementNS(svgNS,'radialGradient');
	    }
	    gfill.setAttribute('id',gradientId);
	    gfill.setAttribute('spreadMethod','pad');
	    gfill.setAttribute('gradientUnits','userSpaceOnUse');
	    var stops = [];
	    var stop, j, jLen;
	    jLen = arr.g.p*4;
	    for(j=0;j<jLen;j+=4){
	        stop = document.createElementNS(svgNS,'stop');
	        gfill.appendChild(stop);
	        stops.push(stop);
	    }
	    pathElement.setAttribute( arr.ty === 'gf' ? 'fill':'stroke','url(#'+gradientId+')');
	    this.globalData.defs.appendChild(gfill);
	    data.gf = gfill;
	    data.cst = stops;
	}

	IShapeElement.prototype.setGradientOpacity = function(arr, data, styleOb){
	    if((arr.g.k.k[0].s && arr.g.k.k[0].s.length > arr.g.p*4) || arr.g.k.k.length > arr.g.p*4){
	        var opFill;
	        var stop, j, jLen;
	        var mask = document.createElementNS(svgNS,"mask");
	        var maskElement = document.createElementNS(svgNS, 'path');
	        mask.appendChild(maskElement);
	        var opacityId = 'op_'+randomString(10);
	        var maskId = 'mk_'+randomString(10);
	        mask.setAttribute('id',maskId);
	        if(arr.t === 1){
	            opFill = document.createElementNS(svgNS,'linearGradient');
	        } else {
	            opFill = document.createElementNS(svgNS,'radialGradient');
	        }
	        opFill.setAttribute('id',opacityId);
	        opFill.setAttribute('spreadMethod','pad');
	        opFill.setAttribute('gradientUnits','userSpaceOnUse');
	        jLen = arr.g.k.k[0].s ? arr.g.k.k[0].s.length : arr.g.k.k.length;
	        var stops = [];
	        for(j=arr.g.p*4;j<jLen;j+=2){
	            stop = document.createElementNS(svgNS,'stop');
	            stop.setAttribute('stop-color','rgb(255,255,255)');
	            //stop.setAttribute('offset',Math.round(arr.y[j][0]*100)+'%');
	            //stop.setAttribute('style','stop-color:rgb(255,255,255);stop-opacity:'+arr.y[j][1]);
	            opFill.appendChild(stop);
	            stops.push(stop);
	        }
	        maskElement.setAttribute( arr.ty === 'gf' ? 'fill':'stroke','url(#'+opacityId+')');
	        this.globalData.defs.appendChild(opFill);
	        this.globalData.defs.appendChild(mask);
	        data.of = opFill;
	        data.ost = stops;
	        styleOb.msElem = maskElement;
	        return maskId;
	    }
	};

	IShapeElement.prototype.searchShapes = function(arr,data,container,dynamicProperties, level, transformers){
	    transformers = transformers || [];
	    var ownTransformers = [].concat(transformers);
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownArrays = [], ownModifiers = [], styleOb, currentTransform;
	    for(i=len;i>=0;i-=1){
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs'){
	            data[i] = {};
	            styleOb = {
	                type: arr[i].ty,
	                d: '',
	                ld: '',
	                lvl: level,
	                mdf: false
	            };
	            var pathElement = document.createElementNS(svgNS, "path");
	            data[i].o = PropertyFactory.getProp(this,arr[i].o,0,0.01,dynamicProperties);
	            if(arr[i].ty == 'st' || arr[i].ty == 'gs') {
	                pathElement.setAttribute('stroke-linecap', this.lcEnum[arr[i].lc] || 'round');
	                ////pathElement.style.strokeLinecap = this.lcEnum[arr[i].lc] || 'round';
	                pathElement.setAttribute('stroke-linejoin',this.ljEnum[arr[i].lj] || 'round');
	                ////pathElement.style.strokeLinejoin = this.ljEnum[arr[i].lj] || 'round';
	                pathElement.setAttribute('fill-opacity','0');
	                ////pathElement.style.fillOpacity = 0;
	                if(arr[i].lj == 1) {
	                    pathElement.setAttribute('stroke-miterlimit',arr[i].ml);
	                    ////pathElement.style.strokeMiterlimit = arr[i].ml;
	                }

	                data[i].w = PropertyFactory.getProp(this,arr[i].w,0,null,dynamicProperties);
	                if(arr[i].d){
	                    var d = PropertyFactory.getDashProp(this,arr[i].d,'svg',dynamicProperties);
	                    if(!d.k){
	                        pathElement.setAttribute('stroke-dasharray', d.dasharray);
	                        ////pathElement.style.strokeDasharray = d.dasharray;
	                        pathElement.setAttribute('stroke-dashoffset', d.dashoffset);
	                        ////pathElement.style.strokeDashoffset = d.dashoffset;
	                    }
	                    data[i].d = d;
	                }

	            }
	            if(arr[i].ty == 'fl' || arr[i].ty == 'st'){
	                data[i].c = PropertyFactory.getProp(this,arr[i].c,1,255,dynamicProperties);
	                container.appendChild(pathElement);
	            } else {
	                data[i].g = PropertyFactory.getGradientProp(this,arr[i].g,dynamicProperties);
	                if(arr[i].t == 2){
	                    data[i].h = PropertyFactory.getProp(this,arr[i].h,1,0.01,dynamicProperties);
	                    data[i].a = PropertyFactory.getProp(this,arr[i].a,1,degToRads,dynamicProperties);
	                }
	                data[i].s = PropertyFactory.getProp(this,arr[i].s,1,null,dynamicProperties);
	                data[i].e = PropertyFactory.getProp(this,arr[i].e,1,null,dynamicProperties);
	                this.setGradientData(pathElement,arr[i],data[i], styleOb);
	                var maskId = this.setGradientOpacity(arr[i],data[i], styleOb);
	                if(maskId){
	                    pathElement.setAttribute('mask','url(#'+maskId+')');
	                }
	                data[i].elem = pathElement;
	                container.appendChild(pathElement);
	            }
	            if(arr[i].r === 2) {
	                pathElement.setAttribute('fill-rule', 'evenodd');
	            }

	            if(arr[i].ln){
	                pathElement.setAttribute('id',arr[i].ln);
	            }
	            if(arr[i].cl){
	                pathElement.setAttribute('class',arr[i].cl);
	            }
	            styleOb.pElem = pathElement;
	            this.stylesList.push(styleOb);
	            data[i].style = styleOb;
	            ownArrays.push(styleOb);
	        }else if(arr[i].ty == 'gr'){
	            data[i] = {
	                it: []
	            };
	            var g = document.createElementNS(svgNS,'g');
	            container.appendChild(g);
	            data[i].gr = g;
	            this.searchShapes(arr[i].it,data[i].it,g,dynamicProperties, level + 1, ownTransformers);
	        }else if(arr[i].ty == 'tr'){
	            data[i] = {
	                transform : {
	                    op: PropertyFactory.getProp(this,arr[i].o,0,0.01,dynamicProperties),
	                    mProps: PropertyFactory.getProp(this,arr[i],2,null,dynamicProperties)
	                },
	                elements: []
	            };
	            currentTransform = data[i].transform;
	            ownTransformers.push(currentTransform);
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            data[i] = {
	                elements : [],
	                caches:[],
	                styles : [],
	                transformers: ownTransformers,
	                lStr: ''
	            };
	            var ty = 4;
	            if(arr[i].ty == 'rc'){
	                ty = 5;
	            }else if(arr[i].ty == 'el'){
	                ty = 6;
	            }else if(arr[i].ty == 'sr'){
	                ty = 7;
	            }
	            data[i].sh = ShapePropertyFactory.getShapeProp(this,arr[i],ty,dynamicProperties);
	            data[i].lvl = level;
	            this.shapes.push(data[i].sh);
	            this.addShapeToModifiers(data[i]);
	            jLen = this.stylesList.length;
	            for(j=0;j<jLen;j+=1){
	                if(!this.stylesList[j].closed){
	                    data[i].elements.push({
	                        ty:this.stylesList[j].type,
	                        st: this.stylesList[j]
	                    });
	                }
	            }
	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms' || arr[i].ty == 'rp'){
	            var modifier = ShapeModifiers.getModifier(arr[i].ty);
	            modifier.init(this,arr[i],dynamicProperties);
	            this.shapeModifiers.push(modifier);
	            ownModifiers.push(modifier);
	            data[i] = modifier;
	        }
	    }
	    len = ownArrays.length;
	    for(i=0;i<len;i+=1){
	        ownArrays[i].closed = true;
	    }
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};

	IShapeElement.prototype.addShapeToModifiers = function(data) {
	    var i, len = this.shapeModifiers.length;
	    for(i=0;i<len;i+=1){
	        this.shapeModifiers[i].addShape(data);
	    }
	};

	IShapeElement.prototype.renderModifiers = function() {
	    if(!this.shapeModifiers.length){
	        return;
	    }
	    var i, len = this.shapes.length;
	    for(i=0;i<len;i+=1){
	        this.shapes[i].reset();
	    }


	    len = this.shapeModifiers.length;

	    for(i=len-1;i>=0;i-=1){
	        this.shapeModifiers[i].processShapes(this.firstFrame);
	    }
	};

	IShapeElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    this.globalToLocal([0,0,0]);
	    if(this.hidden){
	        this.layerElement.style.display = 'block';
	        this.hidden = false;
	    }
	    this.renderModifiers();
	    this.renderShape(null,null,true, null);
	};

	IShapeElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.layerElement.style.display = 'none';
	        var i, len = this.stylesList.length;
	        for(i=len-1;i>=0;i-=1){
	            if(this.stylesList[i].ld !== '0'){
	                this.stylesList[i].ld = '0';
	                this.stylesList[i].pElem.style.display = 'none';
	                if(this.stylesList[i].pElem.parentNode){
	                    this.stylesList[i].parent = this.stylesList[i].pElem.parentNode;
	                    //this.stylesList[i].pElem.parentNode.removeChild(this.stylesList[i].pElem);
	                }
	            }
	        }
	        this.hidden = true;
	    }
	};

	IShapeElement.prototype.renderShape = function(items,data,isMain, container){
	    var i, len;
	    if(!items){
	        items = this.shapesData;
	        len = this.stylesList.length;
	        for(i=0;i<len;i+=1){
	            this.stylesList[i].d = '';
	            this.stylesList[i].mdf = false;
	        }
	    }
	    if(!data){
	        data = this.viewData;
	    }
	    ///
	    ///
	    len = items.length - 1;
	    var ty;
	    for(i=len;i>=0;i-=1){
	        ty = items[i].ty;
	        if(ty == 'tr'){
	            if(this.firstFrame || data[i].transform.op.mdf && container){
	                container.setAttribute('opacity',data[i].transform.op.v);
	            }
	            if(this.firstFrame || data[i].transform.mProps.mdf && container){
	                container.setAttribute('transform',data[i].transform.mProps.v.to2dCSS());
	            }
	        }else if(ty == 'sh' || ty == 'el' || ty == 'rc' || ty == 'sr'){
	            this.renderPath(items[i],data[i]);
	        }else if(ty == 'fl'){
	            this.renderFill(items[i],data[i]);
	        }else if(ty == 'gf'){
	            this.renderGradient(items[i],data[i]);
	        }else if(ty == 'gs'){
	            this.renderGradient(items[i],data[i]);
	            this.renderStroke(items[i],data[i]);
	        }else if(ty == 'st'){
	            this.renderStroke(items[i],data[i]);
	        }else if(ty == 'gr'){
	            this.renderShape(items[i].it,data[i].it,false, data[i].gr);
	        }else if(ty == 'tm'){
	            //
	        }
	    }
	    if(isMain) {
	        len = this.stylesList.length;
	        for (i = 0; i < len; i += 1) {
	            if (this.stylesList[i].ld === '0') {
	                this.stylesList[i].ld = '1';
	                this.stylesList[i].pElem.style.display = 'block';
	                //this.stylesList[i].parent.appendChild(this.stylesList[i].pElem);
	            }
	            if (this.stylesList[i].mdf || this.firstFrame) {
	                this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d);
	                if(this.stylesList[i].msElem){
	                    this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
	                }
	            }
	        }
	        if (this.firstFrame) {
	            this.firstFrame = false;
	        }
	    }

	};

	IShapeElement.prototype.renderPath = function(pathData,viewData){
	    var len, i, j, jLen,pathStringTransformed,redraw,pathNodes,l, lLen = viewData.elements.length;
	    var lvl = viewData.lvl;
	    for(l=0;l<lLen;l+=1){
	        redraw = viewData.sh.mdf || this.firstFrame;
	        pathStringTransformed = 'M0 0';
	        var paths = viewData.sh.paths;
	        jLen = paths._length;
	        if(viewData.elements[l].st.lvl < lvl){
	            var mat = this.mHelper.reset(), props;
	            var iterations = lvl - viewData.elements[l].st.lvl;
	            var k = viewData.transformers.length-1;
	            while(iterations > 0) {
	                redraw = viewData.transformers[k].mProps.mdf || redraw;
	                props = viewData.transformers[k].mProps.v.props;
	                mat.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	                iterations --;
	                k --;
	            }
	            if(redraw){
	                for(j=0;j<jLen;j+=1){
	                    pathNodes = paths.shapes[j];
	                    if(pathNodes && pathNodes._length){
	                        len = pathNodes._length;
	                        for (i = 1; i < len; i += 1) {
	                            if (i == 1) {
	                                pathStringTransformed += " M" + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                            }
	                            pathStringTransformed += " C" + mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + mat.applyToPointStringified(pathNodes.i[i][0], pathNodes.i[i][1]) + " " + mat.applyToPointStringified(pathNodes.v[i][0], pathNodes.v[i][1]);
	                        }
	                        if (len == 1) {
	                            pathStringTransformed += " M" + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                        }
	                        if (pathNodes.c) {
	                            pathStringTransformed += " C" + mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + mat.applyToPointStringified(pathNodes.i[0][0], pathNodes.i[0][1]) + " " + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                            pathStringTransformed += 'z';
	                        }
	                    }
	                }
	                viewData.caches[l] = pathStringTransformed;
	            } else {
	                pathStringTransformed = viewData.caches[l];
	            }
	        } else {
	            if(redraw){
	                for(j=0;j<jLen;j+=1){
	                    pathNodes = paths.shapes[j];
	                    if(pathNodes && pathNodes._length){
	                        len = pathNodes._length;
	                        for (i = 1; i < len; i += 1) {
	                            if (i == 1) {
	                                //pathStringTransformed += " M" + groupTransform.mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                                pathStringTransformed += " M" + pathNodes.v[0].join(',');
	                            }
	                            //pathStringTransformed += " C" + groupTransform.mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + groupTransform.mat.applyToPointStringified(pathNodes.i[i][0], pathNodes.i[i][1]) + " " + groupTransform.mat.applyToPointStringified(pathNodes.v[i][0], pathNodes.v[i][1]);
	                            pathStringTransformed += " C" + pathNodes.o[i - 1].join(',') + " " + pathNodes.i[i].join(',') + " " + pathNodes.v[i].join(',');
	                        }
	                        if (len == 1) {
	                            //pathStringTransformed += " M" + groupTransform.mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                            pathStringTransformed += " M" + pathNodes.v[0].join(',');
	                        }
	                        if (pathNodes.c && len) {
	                            //pathStringTransformed += " C" + groupTransform.mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + groupTransform.mat.applyToPointStringified(pathNodes.i[0][0], pathNodes.i[0][1]) + " " + groupTransform.mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	                            pathStringTransformed += " C" + pathNodes.o[i - 1].join(',') + " " + pathNodes.i[0].join(',') + " " + pathNodes.v[0].join(',');
	                            pathStringTransformed += 'z';
	                        }
	                    }
	                }
	                viewData.caches[l] = pathStringTransformed;
	            } else {
	                pathStringTransformed = viewData.caches[l];
	            }
	        }
	        viewData.elements[l].st.d += pathStringTransformed;
	        viewData.elements[l].st.mdf = redraw || viewData.elements[l].st.mdf;
	    }

	};

	IShapeElement.prototype.renderFill = function(styleData,viewData){
	    var styleElem = viewData.style;

	    if(viewData.c.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('fill','rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')');
	        ////styleElem.pElem.style.fill = 'rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')';
	    }
	    if(viewData.o.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('fill-opacity',viewData.o.v);
	    }
	};

	IShapeElement.prototype.renderGradient = function(styleData,viewData){
	    var gfill = viewData.gf;
	    var opFill = viewData.of;
	    var pt1 = viewData.s.v,pt2 = viewData.e.v;

	    if(viewData.o.mdf || this.firstFrame){
	        var attr = styleData.ty === 'gf' ? 'fill-opacity':'stroke-opacity';
	        viewData.elem.setAttribute(attr,viewData.o.v);
	    }
	    //clippedElement.setAttribute('transform','matrix(1,0,0,1,-100,0)');
	    if(viewData.s.mdf || this.firstFrame){
	        var attr1 = styleData.t === 1 ? 'x1':'cx';
	        var attr2 = attr1 === 'x1' ? 'y1':'cy';
	        gfill.setAttribute(attr1,pt1[0]);
	        gfill.setAttribute(attr2,pt1[1]);
	        if(opFill){
	            opFill.setAttribute(attr1,pt1[0]);
	            opFill.setAttribute(attr2,pt1[1]);
	        }
	    }
	    var stops, i, len, stop;
	    if(viewData.g.cmdf || this.firstFrame){
	        stops = viewData.cst;
	        var cValues = viewData.g.c;
	        len = stops.length;
	        for(i=0;i<len;i+=1){
	            stop = stops[i];
	            stop.setAttribute('offset',cValues[i*4]+'%');
	            stop.setAttribute('stop-color','rgb('+cValues[i*4+1]+','+cValues[i*4+2]+','+cValues[i*4+3]+')');
	        }
	    }
	    if(opFill && (viewData.g.omdf || this.firstFrame)){
	        stops = viewData.ost;
	        var oValues = viewData.g.o;
	        len = stops.length;
	        for(i=0;i<len;i+=1){
	            stop = stops[i];
	            stop.setAttribute('offset',oValues[i*2]+'%');
	            stop.setAttribute('stop-opacity',oValues[i*2+1]);
	        }
	    }
	    if(styleData.t === 1){
	        if(viewData.e.mdf  || this.firstFrame){
	            gfill.setAttribute('x2',pt2[0]);
	            gfill.setAttribute('y2',pt2[1]);
	            if(opFill){
	                opFill.setAttribute('x2',pt2[0]);
	                opFill.setAttribute('y2',pt2[1]);
	            }
	        }
	    } else {
	        var rad;
	        if(viewData.s.mdf || viewData.e.mdf || this.firstFrame){
	            rad = Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));
	            gfill.setAttribute('r',rad);
	            if(opFill){
	                opFill.setAttribute('r',rad);
	            }
	        }
	        if(viewData.e.mdf || viewData.h.mdf || viewData.a.mdf || this.firstFrame){
	            if(!rad){
	                rad = Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));
	            }
	            var ang = Math.atan2(pt2[1]-pt1[1], pt2[0]-pt1[0]);

	            var percent = viewData.h.v >= 1 ? 0.99 : viewData.h.v <= -1 ? -0.99:viewData.h.v;
	            var dist = rad*percent;
	            var x = Math.cos(ang + viewData.a.v)*dist + pt1[0];
	            var y = Math.sin(ang + viewData.a.v)*dist + pt1[1];
	            gfill.setAttribute('fx',x);
	            gfill.setAttribute('fy',y);
	            if(opFill){
	                opFill.setAttribute('fx',x);
	                opFill.setAttribute('fy',y);
	            }
	        }
	        //gfill.setAttribute('fy','200');
	    }
	};

	IShapeElement.prototype.renderStroke = function(styleData,viewData){
	    var styleElem = viewData.style;
	    //TODO fix dashes
	    var d = viewData.d;
	    var dasharray,dashoffset;
	    if(d && d.k && (d.mdf || this.firstFrame)){
	        styleElem.pElem.setAttribute('stroke-dasharray', d.dasharray);
	        ////styleElem.pElem.style.strokeDasharray = d.dasharray;
	        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset);
	        ////styleElem.pElem.style.strokeDashoffset = d.dashoffset;
	    }
	    if(viewData.c && (viewData.c.mdf || this.firstFrame)){
	        styleElem.pElem.setAttribute('stroke','rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')');
	        ////styleElem.pElem.style.stroke = 'rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')';
	    }
	    if(viewData.o.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('stroke-opacity',viewData.o.v);
	    }
	    if(viewData.w.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('stroke-width',viewData.w.v);
	        if(styleElem.msElem){
	            styleElem.msElem.setAttribute('stroke-width',viewData.w.v);
	        }
	        ////styleElem.pElem.style.strokeWidth = viewData.w.v;
	    }
	};

	IShapeElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    this.shapeData = null;
	    this.viewData = null;
	    this.parentContainer = null;
	    this.placeholder = null;
	};

	function ISolidElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, ISolidElement);

	ISolidElement.prototype.createElements = function(){
	    this._parent.createElements.call(this);

	    var rect = document.createElementNS(svgNS,'rect');
	    ////rect.style.width = this.data.sw;
	    ////rect.style.height = this.data.sh;
	    ////rect.style.fill = this.data.sc;
	    rect.setAttribute('width',this.data.sw);
	    rect.setAttribute('height',this.data.sh);
	    rect.setAttribute('fill',this.data.sc);
	    this.layerElement.appendChild(rect);
	    this.innerElem = rect;
	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }
	};

	ISolidElement.prototype.hide = IImageElement.prototype.hide;
	ISolidElement.prototype.renderFrame = IImageElement.prototype.renderFrame;
	ISolidElement.prototype.destroy = IImageElement.prototype.destroy;

	var animationManager = (function(){
	    var moduleOb = {};
	    var registeredAnimations = [];
	    var initTime = 0;
	    var len = 0;
	    var idled = true;
	    var playingAnimationsNum = 0;

	    function removeElement(ev){
	        var i = 0;
	        var animItem = ev.target;
	        while(i<len) {
	            if (registeredAnimations[i].animation === animItem) {
	                registeredAnimations.splice(i, 1);
	                i -= 1;
	                len -= 1;
	                if(!animItem.isPaused){
	                    subtractPlayingCount();   
	                }
	            }
	            i += 1;
	        }
	    }

	    function registerAnimation(element, animationData){
	        if(!element){
	            return null;
	        }
	        var i=0;
	        while(i<len){
	            if(registeredAnimations[i].elem == element && registeredAnimations[i].elem !== null ){
	                return registeredAnimations[i].animation;
	            }
	            i+=1;
	        }
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, element);
	        animItem.setData(element, animationData);
	        return animItem;
	    }

	    function addPlayingCount(){
	        playingAnimationsNum += 1;
	        activate();
	    }

	    function subtractPlayingCount(){
	        playingAnimationsNum -= 1;
	        if(playingAnimationsNum === 0){
	            idled = true;
	        }
	    }

	    function setupAnimation(animItem, element){
	        animItem.addEventListener('destroy',removeElement);
	        animItem.addEventListener('_active',addPlayingCount);
	        animItem.addEventListener('_idle',subtractPlayingCount);
	        registeredAnimations.push({elem: element,animation:animItem});
	        len += 1;
	    }

	    function loadAnimation(params){
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, null);
	        animItem.setParams(params);
	        return animItem;
	    }


	    function setSpeed(val,animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setSpeed(val, animation);
	        }
	    }

	    function setDirection(val, animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setDirection(val, animation);
	        }
	    }

	    function play(animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.play(animation);
	        }
	    }

	    function moveFrame (value, animation) {
	        initTime = Date.now();
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.moveFrame(value,animation);
	        }
	    }

	    function resume(nowTime) {

	        var elapsedTime = nowTime - initTime;
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.advanceTime(elapsedTime);
	        }
	        initTime = nowTime;
	        if(!idled) {
	            requestAnimationFrame(resume);
	        }
	    }

	    function first(nowTime){
	        initTime = nowTime;
	        requestAnimationFrame(resume);
	    }

	    function pause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.pause(animation);
	        }
	    }

	    function goToAndStop(value,isFrame,animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);
	        }
	    }

	    function stop(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.stop(animation);
	        }
	    }

	    function togglePause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.togglePause(animation);
	        }
	    }

	    function destroy(animation) {
	        var i;
	        for(i=(len-1);i>=0;i-=1){
	            registeredAnimations[i].animation.destroy(animation);
	        }
	    }

	    function searchAnimations(animationData, standalone, renderer){
	        var animElements = document.getElementsByClassName('bodymovin');
	        var i, len = animElements.length;
	        for(i=0;i<len;i+=1){
	            if(renderer){
	                animElements[i].setAttribute('data-bm-type',renderer);
	            }
	            registerAnimation(animElements[i], animationData);
	        }
	        if(standalone && len === 0){
	            if(!renderer){
	                renderer = 'svg';
	            }
	            var body = document.getElementsByTagName('body')[0];
	            body.innerHTML = '';
	            var div = document.createElement('div');
	            div.style.width = '100%';
	            div.style.height = '100%';
	            div.setAttribute('data-bm-type',renderer);
	            body.appendChild(div);
	            registerAnimation(div, animationData);
	        }
	    }

	    function resize(){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.resize();
	        }
	    }

	    function start(){
	        requestAnimationFrame(first);
	    }

	    function activate(){
	        if(idled){
	            idled = false;
	            requestAnimationFrame(first);
	        }
	    }

	    //start();

	    setTimeout(start,0);

	    moduleOb.registerAnimation = registerAnimation;
	    moduleOb.loadAnimation = loadAnimation;
	    moduleOb.setSpeed = setSpeed;
	    moduleOb.setDirection = setDirection;
	    moduleOb.play = play;
	    moduleOb.moveFrame = moveFrame;
	    moduleOb.pause = pause;
	    moduleOb.stop = stop;
	    moduleOb.togglePause = togglePause;
	    moduleOb.searchAnimations = searchAnimations;
	    moduleOb.resize = resize;
	    moduleOb.start = start;
	    moduleOb.goToAndStop = goToAndStop;
	    moduleOb.destroy = destroy;
	    return moduleOb;
	}());
	var AnimationItem = function () {
	    this._cbs = [];
	    this.name = '';
	    this.path = '';
	    this.isLoaded = false;
	    this.currentFrame = 0;
	    this.currentRawFrame = 0;
	    this.totalFrames = 0;
	    this.frameRate = 0;
	    this.frameMult = 0;
	    this.playSpeed = 1;
	    this.playDirection = 1;
	    this.pendingElements = 0;
	    this.playCount = 0;
	    this.prerenderFramesFlag = true;
	    this.animationData = {};
	    this.layers = [];
	    this.assets = [];
	    this.isPaused = true;
	    this.autoplay = false;
	    this.loop = true;
	    this.renderer = null;
	    this.animationID = randomString(10);
	    this.scaleMode = 'fit';
	    this.assetsPath = '';
	    this.timeCompleted = 0;
	    this.segmentPos = 0;
	    this.subframeEnabled = subframeEnabled;
	    this.segments = [];
	    this.pendingSegment = false;
	    this._idle = true;
	    this.projectInterface = ProjectInterface();
	};

	AnimationItem.prototype.setParams = function(params) {
	    var self = this;
	    if(params.context){
	        this.context = params.context;
	    }
	    if(params.wrapper || params.container){
	        this.wrapper = params.wrapper || params.container;
	    }
	    var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';
	    switch(animType){
	        case 'canvas':
	            this.renderer = new CanvasRenderer(this, params.rendererSettings);
	            break;
	        case 'svg':
	            this.renderer = new SVGRenderer(this, params.rendererSettings);
	            break;
	        case 'hybrid':
	        case 'html':
	        default:
	            this.renderer = new HybridRenderer(this, params.rendererSettings);
	            break;
	    }
	    this.renderer.setProjectInterface(this.projectInterface);
	    this.animType = animType;

	    if(params.loop === '' || params.loop === null){
	    }else if(params.loop === false){
	        this.loop = false;
	    }else if(params.loop === true){
	        this.loop = true;
	    }else{
	        this.loop = parseInt(params.loop);
	    }
	    this.autoplay = 'autoplay' in params ? params.autoplay : true;
	    this.name = params.name ? params.name :  '';
	    this.prerenderFramesFlag = 'prerender' in params ? params.prerender : true;
	    this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments :  true;
	    if(params.animationData){
	        self.configAnimation(params.animationData);
	    }else if(params.path){
	        if(params.path.substr(-4) != 'json'){
	            if (params.path.substr(-1, 1) != '/') {
	                params.path += '/';
	            }
	            params.path += 'data.json';
	        }

	        var xhr = new XMLHttpRequest();
	        if(params.path.lastIndexOf('\\') != -1){
	            this.path = params.path.substr(0,params.path.lastIndexOf('\\')+1);
	        }else{
	            this.path = params.path.substr(0,params.path.lastIndexOf('/')+1);
	        }
	        this.assetsPath = params.assetsPath;
	        this.fileName = params.path.substr(params.path.lastIndexOf('/')+1);
	        this.fileName = this.fileName.substr(0,this.fileName.lastIndexOf('.json'));
	        xhr.open('GET', params.path, true);
	        xhr.send();
	        xhr.onreadystatechange = function () {
	            if (xhr.readyState == 4) {
	                if(xhr.status == 200){
	                    self.configAnimation(JSON.parse(xhr.responseText));
	                }else{
	                    try{
	                        var response = JSON.parse(xhr.responseText);
	                        self.configAnimation(response);
	                    }catch(err){
	                    }
	                }
	            }
	        };
	    }
	};

	AnimationItem.prototype.setData = function (wrapper, animationData) {
	    var params = {
	        wrapper: wrapper,
	        animationData: animationData ? (typeof animationData  === "object") ? animationData : JSON.parse(animationData) : null
	    };
	    var wrapperAttributes = wrapper.attributes;

	    params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value :  wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
	    params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value :  wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';

	    var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value :  wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value :  wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
	    if(loop === ''){
	    }else if(loop === 'false'){
	        params.loop = false;
	    }else if(loop === 'true'){
	        params.loop = true;
	    }else{
	        params.loop = parseInt(loop);
	    }
	    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value :  wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value :  wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
	    params.autoplay = autoplay !== "false";

	    params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value :  wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value :  '';
	    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value :  wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value :  wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';

	    if(prerender === 'false'){
	        params.prerender = false;
	    }
	    this.setParams(params);
	};

	AnimationItem.prototype.includeLayers = function(data) {
	    if(data.op > this.animationData.op){
	        this.animationData.op = data.op;
	        this.totalFrames = Math.floor(data.op - this.animationData.ip);
	        this.animationData.tf = this.totalFrames;
	    }
	    var layers = this.animationData.layers;
	    var i, len = layers.length;
	    var newLayers = data.layers;
	    var j, jLen = newLayers.length;
	    for(j=0;j<jLen;j+=1){
	        i = 0;
	        while(i<len){
	            if(layers[i].id == newLayers[j].id){
	                layers[i] = newLayers[j];
	                break;
	            }
	            i += 1;
	        }
	    }
	    if(data.chars || data.fonts){
	        this.renderer.globalData.fontManager.addChars(data.chars);
	        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
	    }
	    if(data.assets){
	        len = data.assets.length;
	        for(i = 0; i < len; i += 1){
	            this.animationData.assets.push(data.assets[i]);
	        }
	    }
	    //this.totalFrames = 50;
	    //this.animationData.tf = 50;
	    this.animationData.__complete = false;
	    dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	    this.renderer.includeLayers(data.layers);
	    if(expressionsPlugin){
	        expressionsPlugin.initExpressions(this);
	    }
	    this.renderer.renderFrame(null);
	    this.loadNextSegment();
	};

	AnimationItem.prototype.loadNextSegment = function() {
	    var segments = this.animationData.segments;
	    if(!segments || segments.length === 0 || !this.autoloadSegments){
	        this.trigger('data_ready');
	        this.timeCompleted = this.animationData.tf;
	        return;
	    }
	    var segment = segments.shift();
	    this.timeCompleted = segment.time * this.frameRate;
	    var xhr = new XMLHttpRequest();
	    var self = this;
	    var segmentPath = this.path+this.fileName+'_' + this.segmentPos + '.json';
	    this.segmentPos += 1;
	    xhr.open('GET', segmentPath, true);
	    xhr.send();
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState == 4) {
	            if(xhr.status == 200){
	                self.includeLayers(JSON.parse(xhr.responseText));
	            }else{
	                try{
	                    var response = JSON.parse(xhr.responseText);
	                    self.includeLayers(response);
	                }catch(err){
	                }
	            }
	        }
	    };
	};

	AnimationItem.prototype.loadSegments = function() {
	    var segments = this.animationData.segments;
	    if(!segments) {
	        this.timeCompleted = this.animationData.tf;
	    }
	    this.loadNextSegment();
	};

	AnimationItem.prototype.configAnimation = function (animData) {
	    if(this.renderer && this.renderer.destroyed){
	        return;
	    }
	    //console.log(JSON.parse(JSON.stringify(animData)));
	    //animData.w = Math.round(animData.w/blitter);
	    //animData.h = Math.round(animData.h/blitter);
	    this.animationData = animData;
	    this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
	    this.animationData.tf = this.totalFrames;
	    this.renderer.configAnimation(animData);
	    if(!animData.assets){
	        animData.assets = [];
	    }
	    if(animData.comps) {
	        animData.assets = animData.assets.concat(animData.comps);
	        animData.comps = null;
	    }
	    this.renderer.searchExtraCompositions(animData.assets);

	    this.layers = this.animationData.layers;
	    this.assets = this.animationData.assets;
	    this.frameRate = this.animationData.fr;
	    this.firstFrame = Math.round(this.animationData.ip);
	    this.frameMult = this.animationData.fr / 1000;
	    this.trigger('config_ready');
	    this.imagePreloader = new ImagePreloader();
	    this.imagePreloader.setAssetsPath(this.assetsPath);
	    this.imagePreloader.setPath(this.path);
	    this.imagePreloader.loadAssets(animData.assets);
	    this.loadSegments();
	    this.updaFrameModifier();
	    if(this.renderer.globalData.fontManager){
	        this.waitForFontsLoaded();
	    }else{
	        dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	        this.checkLoaded();
	    }
	};

	AnimationItem.prototype.waitForFontsLoaded = (function(){
	    function checkFontsLoaded(){
	        if(this.renderer.globalData.fontManager.loaded){
	            dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	            //this.renderer.buildItems(this.animationData.layers);
	            this.checkLoaded();
	        }else{
	            setTimeout(checkFontsLoaded.bind(this),20);
	        }
	    }

	    return function(){
	        checkFontsLoaded.bind(this)();
	    }
	}());

	AnimationItem.prototype.addPendingElement = function () {
	    this.pendingElements += 1;
	}

	AnimationItem.prototype.elementLoaded = function () {
	    this.pendingElements--;
	    this.checkLoaded();
	};

	AnimationItem.prototype.checkLoaded = function () {
	    if (this.pendingElements === 0) {
	        if(expressionsPlugin){
	            expressionsPlugin.initExpressions(this);
	        }
	        this.renderer.initItems();
	        setTimeout(function(){
	            this.trigger('DOMLoaded');
	        }.bind(this),0);
	        this.isLoaded = true;
	        this.gotoFrame();
	        if(this.autoplay){
	            this.play();
	        }
	    }
	};

	AnimationItem.prototype.resize = function () {
	    this.renderer.updateContainerSize();
	};

	AnimationItem.prototype.setSubframe = function(flag){
	    this.subframeEnabled = flag ? true : false;
	}

	AnimationItem.prototype.gotoFrame = function () {
	    if(this.subframeEnabled){
	        this.currentFrame = this.currentRawFrame;
	    }else{
	        this.currentFrame = Math.floor(this.currentRawFrame);
	    }

	    if(this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted){
	        this.currentFrame = this.timeCompleted;
	    }
	    this.trigger('enterFrame');
	    this.renderFrame();
	};

	AnimationItem.prototype.renderFrame = function () {
	    if(this.isLoaded === false){
	        return;
	    }
	    //console.log('this.currentFrame:',this.currentFrame + this.firstFrame);
	    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
	};

	AnimationItem.prototype.play = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.isPaused = false;
	        if(this._idle){
	            this._idle = false;
	            this.trigger('_active');
	        }
	    }
	};

	AnimationItem.prototype.pause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === false){
	        this.isPaused = true;
	        if(!this.pendingSegment){
	            this._idle = true;
	            this.trigger('_idle');
	        }
	    }
	};

	AnimationItem.prototype.togglePause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.play();
	    }else{
	        this.pause();
	    }
	};

	AnimationItem.prototype.stop = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.pause();
	    this.currentFrame = this.currentRawFrame = 0;
	    this.playCount = 0;
	    this.gotoFrame();
	};

	AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(isFrame){
	        this.setCurrentRawFrameValue(value);
	    }else{
	        this.setCurrentRawFrameValue(value * this.frameModifier);
	    }
	    this.pause();
	};

	AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
	    this.goToAndStop(value, isFrame, name);
	    this.play();
	};

	AnimationItem.prototype.advanceTime = function (value) {
	    if(this.pendingSegment){
	        this.pendingSegment = false;
	        this.adjustSegment(this.segments.shift());
	        if(this.isPaused){
	            this.play();
	        }
	        return;
	    }
	    if (this.isPaused === true || this.isLoaded === false) {
	        return;
	    }
	    this.setCurrentRawFrameValue(this.currentRawFrame + value * this.frameModifier);
	};

	AnimationItem.prototype.updateAnimation = function (perc) {
	    this.setCurrentRawFrameValue(this.totalFrames * perc);
	};

	AnimationItem.prototype.moveFrame = function (value, name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.setCurrentRawFrameValue(this.currentRawFrame+value);
	};

	AnimationItem.prototype.adjustSegment = function(arr){
	    this.playCount = 0;
	    if(arr[1] < arr[0]){
	        if(this.frameModifier > 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(-1);
	            }
	        }
	        this.totalFrames = arr[0] - arr[1];
	        this.firstFrame = arr[1];
	        this.setCurrentRawFrameValue(this.totalFrames - 0.01);
	    } else if(arr[1] > arr[0]){
	        if(this.frameModifier < 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(1);
	            }
	        }
	        this.totalFrames = arr[1] - arr[0];
	        this.firstFrame = arr[0];
	        this.setCurrentRawFrameValue(0);
	    }
	    this.trigger('segmentStart');
	};
	AnimationItem.prototype.setSegment = function (init,end) {
	    var pendingFrame = -1;
	    if(this.isPaused) {
	        if (this.currentRawFrame + this.firstFrame < init) {
	            pendingFrame = init;
	        } else if (this.currentRawFrame + this.firstFrame > end) {
	            pendingFrame = end - init - 0.01;
	        }
	    }

	    this.firstFrame = init;
	    this.totalFrames = end - init;
	    if(pendingFrame !== -1) {
	        this.goToAndStop(pendingFrame,true);
	    }
	}

	AnimationItem.prototype.playSegments = function (arr,forceFlag) {
	    if(typeof arr[0] === 'object'){
	        var i, len = arr.length;
	        for(i=0;i<len;i+=1){
	            this.segments.push(arr[i]);
	        }
	    }else{
	        this.segments.push(arr);
	    }
	    if(forceFlag){
	        this.adjustSegment(this.segments.shift());
	    }
	    if(this.isPaused){
	        this.play();
	    }
	};

	AnimationItem.prototype.resetSegments = function (forceFlag) {
	    this.segments.length = 0;
	    this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
	    if(forceFlag){
	        this.adjustSegment(this.segments.shift());
	    }
	};
	AnimationItem.prototype.checkSegments = function(){
	    if(this.segments.length){
	        this.pendingSegment = true;
	    }
	}

	AnimationItem.prototype.remove = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.renderer.destroy();
	};

	AnimationItem.prototype.destroy = function (name) {
	    if((name && this.name != name) || (this.renderer && this.renderer.destroyed)){
	        return;
	    }
	    this.renderer.destroy();
	    this.trigger('destroy');
	    this._cbs = null;
	    this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;
	};

	AnimationItem.prototype.setCurrentRawFrameValue = function(value){
	    this.currentRawFrame = value;
	    //console.log(this.totalFrames);
	    if (this.currentRawFrame >= this.totalFrames) {
	        this.checkSegments();
	        if(this.loop === false){
	            this.currentRawFrame = this.totalFrames - 0.01;
	            this.gotoFrame();
	            this.pause();
	            this.trigger('complete');
	            return;
	        }else{
	            this.trigger('loopComplete');
	            this.playCount += 1;
	            if((this.loop !== true && this.playCount == this.loop) || this.pendingSegment){
	                this.currentRawFrame = this.totalFrames - 0.01;
	                this.gotoFrame();
	                this.pause();
	                this.trigger('complete');
	                return;
	            } else {
	                this.currentRawFrame = this.currentRawFrame % this.totalFrames;
	            }
	        }
	    } else if (this.currentRawFrame < 0) {
	        this.checkSegments();
	        this.playCount -= 1;
	        if(this.playCount < 0){
	            this.playCount = 0;
	        }
	        if(this.loop === false  || this.pendingSegment){
	            this.currentRawFrame = 0;
	            this.gotoFrame();
	            this.pause();
	            this.trigger('complete');
	            return;
	        }else{
	            this.trigger('loopComplete');
	            this.currentRawFrame = (this.totalFrames + this.currentRawFrame) % this.totalFrames;
	            this.gotoFrame();
	            return;
	        }
	    }

	    this.gotoFrame();
	};

	AnimationItem.prototype.setSpeed = function (val) {
	    this.playSpeed = val;
	    this.updaFrameModifier();
	};

	AnimationItem.prototype.setDirection = function (val) {
	    this.playDirection = val < 0 ? -1 : 1;
	    this.updaFrameModifier();
	};

	AnimationItem.prototype.updaFrameModifier = function () {
	    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
	};

	AnimationItem.prototype.getPath = function () {
	    return this.path;
	};

	AnimationItem.prototype.getAssetsPath = function (assetData) {
	    var path = '';
	    if(this.assetsPath){
	        var imagePath = assetData.p;
	        if(imagePath.indexOf('images/') !== -1){
	            imagePath = imagePath.split('/')[1];
	        }
	        path = this.assetsPath + imagePath;
	    } else {
	        path = this.path;
	        path += assetData.u ? assetData.u : '';
	        path += assetData.p;
	    }
	    return path;
	};

	AnimationItem.prototype.getAssetData = function (id) {
	    var i = 0, len = this.assets.length;
	    while (i < len) {
	        if(id == this.assets[i].id){
	            return this.assets[i];
	        }
	        i += 1;
	    }
	};

	AnimationItem.prototype.hide = function () {
	    this.renderer.hide();
	};

	AnimationItem.prototype.show = function () {
	    this.renderer.show();
	};

	AnimationItem.prototype.getAssets = function () {
	    return this.assets;
	};

	AnimationItem.prototype.trigger = function(name){
	    if(this._cbs && this._cbs[name]){
	        switch(name){
	            case 'enterFrame':
	                this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
	                break;
	            case 'loopComplete':
	                this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	                break;
	            case 'complete':
	                this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));
	                break;
	            case 'segmentStart':
	                this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	                break;
	            case 'destroy':
	                this.triggerEvent(name,new BMDestroyEvent(name,this));
	                break;
	            default:
	                this.triggerEvent(name);
	        }
	    }
	    if(name === 'enterFrame' && this.onEnterFrame){
	        this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
	    }
	    if(name === 'loopComplete' && this.onLoopComplete){
	        this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	    }
	    if(name === 'complete' && this.onComplete){
	        this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));
	    }
	    if(name === 'segmentStart' && this.onSegmentStart){
	        this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	    }
	    if(name === 'destroy' && this.onDestroy){
	        this.onDestroy.call(this,new BMDestroyEvent(name,this));
	    }
	};

	AnimationItem.prototype.addEventListener = _addEventListener;
	AnimationItem.prototype.removeEventListener = _removeEventListener;
	AnimationItem.prototype.triggerEvent = _triggerEvent;

	function CanvasRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.renderConfig = {
	        clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
	        context: (config && config.context) || null,
	        progressiveLoad: (config && config.progressiveLoad) || false,
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet'
	    };
	    this.renderConfig.dpr = (config && config.dpr) || 1;
	    if (this.animationItem.wrapper) {
	        this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
	    }
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.contextData = {
	        saved : Array.apply(null,{length:15}),
	        savedOp: Array.apply(null,{length:15}),
	        cArrPos : 0,
	        cTr : new Matrix(),
	        cO : 1
	    };
	    var i, len = 15;
	    for(i=0;i<len;i+=1){
	        this.contextData.saved[i] = Array.apply(null,{length:16});
	    }
	    this.elements = [];
	    this.pendingElements = [];
	    this.transformMat = new Matrix();
	    this.completeLayers = false;
	}
	extendPrototype(BaseRenderer,CanvasRenderer);

	CanvasRenderer.prototype.createBase = function (data) {
	    return new CVBaseElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createShape = function (data) {
	    return new CVShapeElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createText = function (data) {
	    return new CVTextElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createImage = function (data) {
	    return new CVImageElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createComp = function (data) {
	    return new CVCompElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createSolid = function (data) {
	    return new CVSolidElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.ctxTransform = function(props){
	    if(props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0){
	        return;
	    }
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);
	        return;
	    }
	    this.transformMat.cloneFromProps(props);
	    this.transformMat.transform(this.contextData.cTr.props[0],this.contextData.cTr.props[1],this.contextData.cTr.props[2],this.contextData.cTr.props[3],this.contextData.cTr.props[4],this.contextData.cTr.props[5],this.contextData.cTr.props[6],this.contextData.cTr.props[7],this.contextData.cTr.props[8],this.contextData.cTr.props[9],this.contextData.cTr.props[10],this.contextData.cTr.props[11],this.contextData.cTr.props[12],this.contextData.cTr.props[13],this.contextData.cTr.props[14],this.contextData.cTr.props[15])
	    //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	    this.contextData.cTr.cloneFromProps(this.transformMat.props);
	    var trProps = this.contextData.cTr.props;
	    this.canvasContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);
	};

	CanvasRenderer.prototype.ctxOpacity = function(op){
	    if(op === 1){
	        return;
	    }
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
	        return;
	    }
	    this.contextData.cO *= op < 0 ? 0 : op;
	    this.canvasContext.globalAlpha = this.contextData.cO;
	};

	CanvasRenderer.prototype.reset = function(){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    this.contextData.cArrPos = 0;
	    this.contextData.cTr.reset();
	    this.contextData.cO = 1;
	};

	CanvasRenderer.prototype.save = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.save();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.save();
	    }
	    var props = this.contextData.cTr.props;
	    if(this.contextData.saved[this.contextData.cArrPos] === null || this.contextData.saved[this.contextData.cArrPos] === undefined){
	        this.contextData.saved[this.contextData.cArrPos] = new Array(16);
	    }
	    var i,arr = this.contextData.saved[this.contextData.cArrPos];
	    for(i=0;i<16;i+=1){
	        arr[i] = props[i];
	    }
	    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
	    this.contextData.cArrPos += 1;
	};

	CanvasRenderer.prototype.restore = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.restore();
	    }
	    this.contextData.cArrPos -= 1;
	    var popped = this.contextData.saved[this.contextData.cArrPos];
	    var i,arr = this.contextData.cTr.props;
	    for(i=0;i<16;i+=1){
	        arr[i] = popped[i];
	    }
	    this.canvasContext.setTransform(popped[0],popped[1],popped[4],popped[5],popped[12],popped[13]);
	    popped = this.contextData.savedOp[this.contextData.cArrPos];
	    this.contextData.cO = popped;
	    this.canvasContext.globalAlpha = popped;
	};

	CanvasRenderer.prototype.configAnimation = function(animData){
	    if(this.animationItem.wrapper){
	        this.animationItem.container = document.createElement('canvas');
	        this.animationItem.container.style.width = '100%';
	        this.animationItem.container.style.height = '100%';
	        //this.animationItem.container.style.transform = 'translate3d(0,0,0)';
	        //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';
	        this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = "0px 0px 0px";
	        this.animationItem.wrapper.appendChild(this.animationItem.container);
	        this.canvasContext = this.animationItem.container.getContext('2d');
	    }else{
	        this.canvasContext = this.renderConfig.context;
	    }
	    this.data = animData;
	    this.globalData.canvasContext = this.canvasContext;
	    this.globalData.renderer = this;
	    this.globalData.isDashed = false;
	    this.globalData.totalFrames = Math.floor(animData.tf);
	    this.globalData.compWidth = animData.w;
	    this.globalData.compHeight = animData.h;
	    this.globalData.frameRate = animData.fr;
	    this.globalData.frameId = 0;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.layers = animData.layers;
	    this.transformCanvas = {};
	    this.transformCanvas.w = animData.w;
	    this.transformCanvas.h = animData.h;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,document.body);
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.elementLoaded = this.animationItem.elementLoaded.bind(this.animationItem);
	    this.globalData.addPendingElement = this.animationItem.addPendingElement.bind(this.animationItem);
	    this.globalData.transformCanvas = this.transformCanvas;
	    this.elements = Array.apply(null,{length:animData.layers.length});

	    this.updateContainerSize();
	};

	CanvasRenderer.prototype.updateContainerSize = function () {
	    var elementWidth,elementHeight;
	    if(this.animationItem.wrapper && this.animationItem.container){
	        elementWidth = this.animationItem.wrapper.offsetWidth;
	        elementHeight = this.animationItem.wrapper.offsetHeight;
	        this.animationItem.container.setAttribute('width',elementWidth * this.renderConfig.dpr );
	        this.animationItem.container.setAttribute('height',elementHeight * this.renderConfig.dpr);
	    }else{
	        elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
	        elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
	    }
	    var elementRel,animationRel;
	    if(this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1){
	        var par = this.renderConfig.preserveAspectRatio.split(' ');
	        var fillType = par[1] || 'meet';
	        var pos = par[0] || 'xMidYMid';
	        var xPos = pos.substr(0,4);
	        var yPos = pos.substr(4);
	        elementRel = elementWidth/elementHeight;
	        animationRel = this.transformCanvas.w/this.transformCanvas.h;
	        if(animationRel>elementRel && fillType === 'meet' || animationRel<elementRel && fillType === 'slice'){
	            this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	            this.transformCanvas.sy = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        }else{
	            this.transformCanvas.sx = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	            this.transformCanvas.sy = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	        }

	        if(xPos === 'xMid' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;
	        } else if(xPos === 'xMax' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.tx = 0;
	        }
	        if(yPos === 'YMid' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2)*this.renderConfig.dpr;
	        } else if(yPos === 'YMax' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w)))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.ty = 0;
	        }

	    }else if(this.renderConfig.preserveAspectRatio == 'none'){
	        this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        this.transformCanvas.sy = elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }else{
	        this.transformCanvas.sx = this.renderConfig.dpr;
	        this.transformCanvas.sy = this.renderConfig.dpr;
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }
	    this.transformCanvas.props = [this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];
	    var i, len = this.elements.length;
	    for(i=0;i<len;i+=1){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(this.globalData.transformCanvas);
	        }
	    }
	};

	CanvasRenderer.prototype.destroy = function () {
	    if(this.renderConfig.clearCanvas) {
	        this.animationItem.wrapper.innerHTML = '';
	    }
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = len - 1; i >= 0; i-=1) {
	        this.elements[i].destroy();
	    }
	    this.elements.length = 0;
	    this.globalData.canvasContext = null;
	    this.animationItem.container = null;
	    this.destroyed = true;
	};

	CanvasRenderer.prototype.renderFrame = function(num){
	    if((this.renderedFrame == num && this.renderConfig.clearCanvas === true) || this.destroyed || num === null){
	        return;
	    }
	    this.renderedFrame = num;
	    this.globalData.frameNum = num - this.animationItem.firstFrame;
	    this.globalData.frameId += 1;
	    this.globalData.projectInterface.currentFrame = num;
	    if(this.renderConfig.clearCanvas === true){
	        this.reset();
	        this.canvasContext.save();
	        //this.canvasContext.canvas.width = this.canvasContext.canvas.width;
	        this.canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w*this.transformCanvas.sx, this.transformCanvas.h*this.transformCanvas.sy);
	    }else{
	        this.save();
	    }
	    this.ctxTransform(this.transformCanvas.props);
	    this.canvasContext.beginPath();
	    this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);
	    this.canvasContext.closePath();
	    this.canvasContext.clip();

	    //console.log('--------');
	    //console.log('NEW: ',num);
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }

	    for (i = 0; i < len; i++) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    for (i = len - 1; i >= 0; i-=1) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.renderConfig.clearCanvas !== true){
	        this.restore();
	    } else {
	        this.canvasContext.restore();
	    }
	};

	CanvasRenderer.prototype.buildItem = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    var element = this.createItem(this.layers[pos], this,this.globalData);
	    elements[pos] = element;
	    element.initExpressions();
	    if(this.layers[pos].ty === 0){
	        element.resize(this.globalData.transformCanvas);
	    }
	};

	CanvasRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};

	CanvasRenderer.prototype.hide = function(){
	    this.animationItem.container.style.display = 'none';
	};

	CanvasRenderer.prototype.show = function(){
	    this.animationItem.container.style.display = 'block';
	};

	CanvasRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElementNS(svgNS,'g');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],this.globalData.comp,this.globalData);
	            comp.initExpressions();
	            //comp.compInterface = CompExpressionInterface(comp);
	            //Expressions.addLayersInterface(comp.elements, this.globalData.projectInterface);
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};
	function HybridRenderer(animationItem){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.pendingElements = [];
	    this.elements = [];
	    this.threeDElements = [];
	    this.destroyed = false;
	    this.camera = null;
	    this.supports3d = true;

	}

	extendPrototype(BaseRenderer,HybridRenderer);

	HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

	HybridRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};

	HybridRenderer.prototype.appendElementInPos = function(element, pos){
	    var newElement = element.getBaseElement();
	    if(!newElement){
	        return;
	    }
	    var layer = this.layers[pos];
	    if(!layer.ddd || !this.supports3d){
	        var i = 0;
	        var nextElement;
	        while(i<pos){
	            if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement){
	                nextElement = this.elements[i].getBaseElement();
	            }
	            i += 1;
	        }
	        if(nextElement){
	            if(!layer.ddd || !this.supports3d){
	                this.layerElement.insertBefore(newElement, nextElement);
	            }
	        } else {
	            if(!layer.ddd || !this.supports3d){
	                this.layerElement.appendChild(newElement);
	            }
	        }
	    } else {
	        this.addTo3dContainer(newElement,pos);
	    }
	};


	HybridRenderer.prototype.createBase = function (data) {
	    return new SVGBaseElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createShape = function (data) {
	    if(!this.supports3d){
	        return new IShapeElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HShapeElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createText = function (data) {
	    if(!this.supports3d){
	        return new SVGTextElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HTextElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createCamera = function (data) {
	    this.camera = new HCameraElement(data, this.layerElement,this.globalData,this);
	    return this.camera;
	};

	HybridRenderer.prototype.createImage = function (data) {
	    if(!this.supports3d){
	        return new IImageElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HImageElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createComp = function (data) {
	    if(!this.supports3d){
	        return new ICompElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HCompElement(data, this.layerElement,this.globalData,this);

	};

	HybridRenderer.prototype.createSolid = function (data) {
	    if(!this.supports3d){
	        return new ISolidElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HSolidElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.getThreeDContainer = function(pos){
	    var perspectiveElem = document.createElement('div');
	    styleDiv(perspectiveElem);
	    perspectiveElem.style.width = this.globalData.compSize.w+'px';
	    perspectiveElem.style.height = this.globalData.compSize.h+'px';
	    perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = "50% 50%";
	    var container = document.createElement('div');
	    styleDiv(container);
	    container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    perspectiveElem.appendChild(container);
	    this.resizerElem.appendChild(perspectiveElem);
	    var threeDContainerData = {
	        container:container,
	        perspectiveElem:perspectiveElem,
	        startPos: pos,
	        endPos: pos
	    };
	    this.threeDElements.push(threeDContainerData);
	    return threeDContainerData;
	};

	HybridRenderer.prototype.build3dContainers = function(){
	    var i, len = this.layers.length;
	    var lastThreeDContainerData;
	    for(i=0;i<len;i+=1){
	        if(this.layers[i].ddd){
	            if(!lastThreeDContainerData){
	                lastThreeDContainerData = this.getThreeDContainer(i);
	            }
	            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
	        } else {
	            lastThreeDContainerData = null;
	        }
	    }
	};

	HybridRenderer.prototype.addTo3dContainer = function(elem,pos){
	    var i = 0, len = this.threeDElements.length;
	    while(i<len){
	        if(pos <= this.threeDElements[i].endPos){
	            var j = this.threeDElements[i].startPos;
	            var nextElement;
	            while(j<pos){
	                if(this.elements[j] && this.elements[j].getBaseElement){
	                    nextElement = this.elements[j].getBaseElement();
	                }
	                j += 1;
	            }
	            if(nextElement){
	                this.threeDElements[i].container.insertBefore(elem, nextElement);
	            } else {
	                this.threeDElements[i].container.appendChild(elem);
	            }
	            break;
	        }
	        i += 1;
	    }
	};

	HybridRenderer.prototype.configAnimation = function(animData){
	    var resizerElem = document.createElement('div');
	    var wrapper = this.animationItem.wrapper;
	    resizerElem.style.width = animData.w+'px';
	    resizerElem.style.height = animData.h+'px';
	    this.resizerElem = resizerElem;
	    styleDiv(resizerElem);
	    resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = "flat";
	    wrapper.appendChild(resizerElem);

	    resizerElem.style.overflow = 'hidden';
	    var svg = document.createElementNS(svgNS,'svg');
	    svg.setAttribute('width','1');
	    svg.setAttribute('height','1');
	    styleDiv(svg);
	    this.resizerElem.appendChild(svg);
	    var defs = document.createElementNS(svgNS,'defs');
	    svg.appendChild(defs);
	    this.globalData.defs = defs;
	    this.data = animData;
	    //Mask animation
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.elementLoaded = this.animationItem.elementLoaded.bind(this.animationItem);
	    this.globalData.frameId = 0;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.globalData.frameRate = animData.fr;
	    this.layers = animData.layers;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,svg);
	    this.layerElement = this.resizerElem;
	    this.build3dContainers();
	    this.updateContainerSize();
	};

	HybridRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.animationItem.container = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        this.elements[i].destroy();
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};

	HybridRenderer.prototype.updateContainerSize = function () {
	    var elementWidth = this.animationItem.wrapper.offsetWidth;
	    var elementHeight = this.animationItem.wrapper.offsetHeight;
	    var elementRel = elementWidth/elementHeight;
	    var animationRel = this.globalData.compSize.w/this.globalData.compSize.h;
	    var sx,sy,tx,ty;
	    if(animationRel>elementRel){
	        sx = elementWidth/(this.globalData.compSize.w);
	        sy = elementWidth/(this.globalData.compSize.w);
	        tx = 0;
	        ty = ((elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2);
	    }else{
	        sx = elementHeight/(this.globalData.compSize.h);
	        sy = elementHeight/(this.globalData.compSize.h);
	        tx = (elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;
	        ty = 0;
	    }
	    this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';
	};

	HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

	HybridRenderer.prototype.hide = function(){
	    this.resizerElem.style.display = 'none';
	};

	HybridRenderer.prototype.show = function(){
	    this.resizerElem.style.display = 'block';
	};

	HybridRenderer.prototype.initItems = function(){
	    this.buildAllItems();
	    if(this.camera){
	        this.camera.setup();
	    } else {
	        var cWidth = this.globalData.compSize.w;
	        var cHeight = this.globalData.compSize.h;
	        var i, len = this.threeDElements.length;
	        for(i=0;i<len;i+=1){
	            this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth,2) + Math.pow(cHeight,2)) + 'px';
	        }
	    }
	};

	HybridRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElement('div');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
	            comp.initExpressions();
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};
	function CVBaseElement(data, comp,globalData){
	    this.globalData = globalData;
	    this.data = data;
	    this.comp = comp;
	    this.canvasContext = globalData.canvasContext;
	    this.init();
	}

	createElement(BaseElement, CVBaseElement);

	CVBaseElement.prototype.createElements = function(){
	    this.checkParenting();
	};

	CVBaseElement.prototype.checkBlendMode = function(globalData){
	    if(globalData.blendMode !== this.data.bm) {
	        globalData.blendMode = this.data.bm;

	        var blendModeValue = '';
	        switch (this.data.bm) {
	            case 0:
	                blendModeValue = 'normal';
	                break;
	            case 1:
	                blendModeValue = 'multiply';
	                break;
	            case 2:
	                blendModeValue = 'screen';
	                break;
	            case 3:
	                blendModeValue = 'overlay';
	                break;
	            case 4:
	                blendModeValue = 'darken';
	                break;
	            case 5:
	                blendModeValue = 'lighten';
	                break;
	            case 6:
	                blendModeValue = 'color-dodge';
	                break;
	            case 7:
	                blendModeValue = 'color-burn';
	                break;
	            case 8:
	                blendModeValue = 'hard-light';
	                break;
	            case 9:
	                blendModeValue = 'soft-light';
	                break;
	            case 10:
	                blendModeValue = 'difference';
	                break;
	            case 11:
	                blendModeValue = 'exclusion';
	                break;
	            case 12:
	                blendModeValue = 'hue';
	                break;
	            case 13:
	                blendModeValue = 'saturation';
	                break;
	            case 14:
	                blendModeValue = 'color';
	                break;
	            case 15:
	                blendModeValue = 'luminosity';
	                break;
	        }
	        globalData.canvasContext.globalCompositeOperation = blendModeValue;
	    }
	};


	CVBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3){
	        return false;
	    }
	        this.checkBlendMode(this.data.ty === 0?this.parentGlobalData:this.globalData);

	    if(!this.isVisible){
	        return this.isVisible;
	    }
	    this.finalTransform.opMdf = this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i, len = this.hierarchy.length;
	        mat = this.finalTransform.mProp.v.props;
	        finalMat.cloneFromProps(mat);
	        for(i=0;i<len;i+=1){
	            this.finalTransform.matMdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : this.finalTransform.matMdf;
	            mat = this.hierarchy[i].finalTransform.mProp.v.props;
	            finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        }
	    }else{
	        if(!parentTransform){
	            finalMat.cloneFromProps(this.finalTransform.mProp.v.props);
	        }else{
	            mat = this.finalTransform.mProp.v.props;
	            finalMat.cloneFromProps(mat);
	        }
	    }

	    if(parentTransform){
	        mat = parentTransform.mat.props;
	        finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        this.finalTransform.opacity *= parentTransform.opacity;
	        this.finalTransform.opMdf = parentTransform.opMdf ? true : this.finalTransform.opMdf;
	        this.finalTransform.matMdf = parentTransform.matMdf ? true : this.finalTransform.matMdf
	    }

	    if(this.data.hasMask){
	        this.globalData.renderer.save(true);
	        this.maskManager.renderFrame(this.data.ty === 0?null:finalMat);
	    }
	    if(this.data.hd){
	        this.isVisible = false;
	    }
	    return this.isVisible;

	};

	CVBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new CVMaskElement(data,this,this.globalData);
	};


	CVBaseElement.prototype.destroy = function(){
	    this.canvasContext = null;
	    this.data = null;
	    this.globalData = null;
	    if(this.maskManager) {
	        this.maskManager.destroy();
	    }
	};

	CVBaseElement.prototype.mHelper = new Matrix();

	function CVCompElement(data, comp,globalData){
	    this._parent.constructor.call(this,data, comp,globalData);
	    var compGlobalData = {};
	    for(var s in globalData){
	        if(globalData.hasOwnProperty(s)){
	            compGlobalData[s] = globalData[s];
	        }
	    }
	    compGlobalData.renderer = this;
	    compGlobalData.compHeight = this.data.h;
	    compGlobalData.compWidth = this.data.w;
	    this.renderConfig = {
	        clearCanvas: true
	    };
	    this.contextData = {
	        saved : Array.apply(null,{length:15}),
	        savedOp: Array.apply(null,{length:15}),
	        cArrPos : 0,
	        cTr : new Matrix(),
	        cO : 1
	    };
	    this.completeLayers = false;
	    var i, len = 15;
	    for(i=0;i<len;i+=1){
	        this.contextData.saved[i] = Array.apply(null,{length:16});
	    }
	    this.transformMat = new Matrix();
	    this.parentGlobalData = this.globalData;
	    var cv = document.createElement('canvas');
	    //document.body.appendChild(cv);
	    compGlobalData.canvasContext = cv.getContext('2d');
	    this.canvasContext = compGlobalData.canvasContext;
	    cv.width = this.data.w;
	    cv.height = this.data.h;
	    this.canvas = cv;
	    this.globalData = compGlobalData;
	    this.layers = data.layers;
	    this.pendingElements = [];
	    this.elements = Array.apply(null,{length:this.layers.length});
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.xt || !globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	}
	createElement(CVBaseElement, CVCompElement);

	CVCompElement.prototype.ctxTransform = CanvasRenderer.prototype.ctxTransform;
	CVCompElement.prototype.ctxOpacity = CanvasRenderer.prototype.ctxOpacity;
	CVCompElement.prototype.save = CanvasRenderer.prototype.save;
	CVCompElement.prototype.restore = CanvasRenderer.prototype.restore;
	CVCompElement.prototype.reset =  function(){
	    this.contextData.cArrPos = 0;
	    this.contextData.cTr.reset();
	    this.contextData.cO = 1;
	};
	CVCompElement.prototype.resize = function(transformCanvas){
	    var maxScale = Math.max(transformCanvas.sx,transformCanvas.sy);
	    this.canvas.width = this.data.w*maxScale;
	    this.canvas.height = this.data.h*maxScale;
	    this.transformCanvas = {
	        sc:maxScale,
	        w:this.data.w*maxScale,
	        h:this.data.h*maxScale,
	        props:[maxScale,0,0,0,0,maxScale,0,0,0,0,1,0,0,0,0,1]
	    }
	    var i,len = this.elements.length;
	    for( i = 0; i < len; i+=1 ){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(transformCanvas);
	        }
	    }
	};

	CVCompElement.prototype.prepareFrame = function(num){
	    this.globalData.frameId = this.parentGlobalData.frameId;
	    this.globalData.mdf = false;
	    this._parent.prepareFrame.call(this,num);
	    if(this.isVisible===false && !this.data.xt){
	        return;
	    }
	    var timeRemapped = num;
	    if(this.tm){
	        timeRemapped = this.tm.v;
	        if(timeRemapped === this.data.op){
	            timeRemapped = this.data.op - 1;
	        }
	    }
	    this.renderedFrame = timeRemapped/this.data.sr;
	    var i,len = this.elements.length;

	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }

	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(timeRemapped/this.data.sr - this.layers[i].st);
	            if(this.elements[i].data.ty === 0 && this.elements[i].globalData.mdf){
	                this.globalData.mdf = true;
	            }
	        }
	    }
	    if(this.globalData.mdf && !this.data.xt){
	        this.canvasContext.clearRect(0, 0, this.data.w, this.data.h);
	        this.ctxTransform(this.transformCanvas.props);
	    }
	};

	CVCompElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this,parentMatrix)===false){
	        return;
	    }
	    if(this.globalData.mdf){
	        var i,len = this.layers.length;
	        for( i = len - 1; i >= 0; i -= 1 ){
	            if(this.completeLayers || this.elements[i]){
	                this.elements[i].renderFrame();
	            }
	        }
	    }
	    if(this.data.hasMask){
	        this.globalData.renderer.restore(true);
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	    this.parentGlobalData.renderer.save();
	    this.parentGlobalData.renderer.ctxTransform(this.finalTransform.mat.props);
	    this.parentGlobalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    this.parentGlobalData.renderer.canvasContext.drawImage(this.canvas,0,0,this.data.w,this.data.h);
	    this.parentGlobalData.renderer.restore();

	    if(this.globalData.mdf){
	        this.reset();
	    }
	};

	CVCompElement.prototype.setElements = function(elems){
	    this.elements = elems;
	};

	CVCompElement.prototype.getElements = function(){
	    return this.elements;
	};

	CVCompElement.prototype.destroy = function(){
	    var i,len = this.layers.length;
	    for( i = len - 1; i >= 0; i -= 1 ){
	        this.elements[i].destroy();
	    }
	    this.layers = null;
	    this.elements = null;
	    this._parent.destroy.call(this._parent);
	};
	CVCompElement.prototype.checkLayers = CanvasRenderer.prototype.checkLayers;
	CVCompElement.prototype.buildItem = CanvasRenderer.prototype.buildItem;
	CVCompElement.prototype.checkPendingElements = CanvasRenderer.prototype.checkPendingElements;
	CVCompElement.prototype.addPendingElement = CanvasRenderer.prototype.addPendingElement;
	CVCompElement.prototype.buildAllItems = CanvasRenderer.prototype.buildAllItems;
	CVCompElement.prototype.createItem = CanvasRenderer.prototype.createItem;
	CVCompElement.prototype.createImage = CanvasRenderer.prototype.createImage;
	CVCompElement.prototype.createComp = CanvasRenderer.prototype.createComp;
	CVCompElement.prototype.createSolid = CanvasRenderer.prototype.createSolid;
	CVCompElement.prototype.createShape = CanvasRenderer.prototype.createShape;
	CVCompElement.prototype.createText = CanvasRenderer.prototype.createText;
	CVCompElement.prototype.createBase = CanvasRenderer.prototype.createBase;
	CVCompElement.prototype.buildElementParenting = CanvasRenderer.prototype.buildElementParenting;
	function CVImageElement(data, comp,globalData){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data, comp,globalData);
	    this.globalData.addPendingElement();
	}
	createElement(CVBaseElement, CVImageElement);

	CVImageElement.prototype.createElements = function(){
	    var imageLoaded = function(){
	        this.globalData.elementLoaded();
	        if(this.assetData.w !== this.img.width || this.assetData.h !== this.img.height){
	            var canvas = document.createElement('canvas');
	            canvas.width = this.assetData.w;
	            canvas.height = this.assetData.h;
	            var ctx = canvas.getContext('2d');

	            var imgW = this.img.width;
	            var imgH = this.img.height;
	            var imgRel = imgW / imgH;
	            var canvasRel = this.assetData.w/this.assetData.h;
	            var widthCrop, heightCrop;
	            if(imgRel>canvasRel){
	                heightCrop = imgH;
	                widthCrop = heightCrop*canvasRel;
	            } else {
	                widthCrop = imgW;
	                heightCrop = widthCrop/canvasRel;
	            }
	            ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);
	            this.img = canvas;
	        }
	    }.bind(this);
	    var imageFailed = function(){
	        this.failed = true;
	        this.globalData.elementLoaded();
	    }.bind(this);

	    this.img = new Image();
	    this.img.addEventListener('load', imageLoaded, false);
	    this.img.addEventListener('error', imageFailed, false);
	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	    this.img.src = assetPath;

	    this._parent.createElements.call(this);

	};

	CVImageElement.prototype.renderFrame = function(parentMatrix){
	    if(this.failed){
	        return;
	    }
	    if(this._parent.renderFrame.call(this,parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    this.globalData.renderer.save();
	    var finalMat = this.finalTransform.mat.props;
	    this.globalData.renderer.ctxTransform(finalMat);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.drawImage(this.img,0,0);
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	CVImageElement.prototype.destroy = function(){
	    this.img = null;
	    this._parent.destroy.call(this._parent);
	};

	function CVMaskElement(data,element){
	    this.data = data;
	    this.element = element;
	    this.dynamicProperties = [];
	    this.masksProperties = this.data.masksProperties;
	    this.viewData = new Array(this.masksProperties.length);
	    var i, len = this.masksProperties.length;
	    for (i = 0; i < len; i++) {
	        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3,this.dynamicProperties,null);
	    }
	}

	CVMaskElement.prototype.getMaskProperty = function(pos){
	    return this.viewData[pos];
	};

	CVMaskElement.prototype.prepareFrame = function(num){
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue(num);
	        if(this.dynamicProperties[i].mdf){
	            this.element.globalData.mdf = true;
	        }
	    }
	};

	CVMaskElement.prototype.renderFrame = function (transform) {
	    var ctx = this.element.canvasContext;
	    var i, len = this.data.masksProperties.length;
	    var pt,pt2,pt3,data, hasMasks = false;
	    for (i = 0; i < len; i++) {
	        if(this.masksProperties[i].mode === 'n'){
	            continue;
	        }
	        if(hasMasks === false){
	            ctx.beginPath();
	            hasMasks = true;
	        }
	        if (this.masksProperties[i].inv) {
	            ctx.moveTo(0, 0);
	            ctx.lineTo(this.element.globalData.compWidth, 0);
	            ctx.lineTo(this.element.globalData.compWidth, this.element.globalData.compHeight);
	            ctx.lineTo(0, this.element.globalData.compHeight);
	            ctx.lineTo(0, 0);
	        }
	        data = this.viewData[i].v;
	        pt = transform ? transform.applyToPointArray(data.v[0][0],data.v[0][1],0):data.v[0];
	        ctx.moveTo(pt[0], pt[1]);
	        var j, jLen = data._length;
	        for (j = 1; j < jLen; j++) {
	            pt = transform ? transform.applyToPointArray(data.o[j - 1][0],data.o[j - 1][1],0) : data.o[j - 1];
	            pt2 = transform ? transform.applyToPointArray(data.i[j][0],data.i[j][1],0) : data.i[j];
	            pt3 = transform ? transform.applyToPointArray(data.v[j][0],data.v[j][1],0) : data.v[j];
	            ctx.bezierCurveTo(pt[0], pt[1], pt2[0], pt2[1], pt3[0], pt3[1]);
	        }
	        pt = transform ? transform.applyToPointArray(data.o[j - 1][0],data.o[j - 1][1],0) : data.o[j - 1];
	        pt2 = transform ? transform.applyToPointArray(data.i[0][0],data.i[0][1],0) : data.i[0];
	        pt3 = transform ? transform.applyToPointArray(data.v[0][0],data.v[0][1],0) : data.v[0];
	        ctx.bezierCurveTo(pt[0], pt[1], pt2[0], pt2[1], pt3[0], pt3[1]);
	    }
	    if(hasMasks){
	        ctx.clip();
	    }
	};

	CVMaskElement.prototype.getMask = function(nm){
	    var i = 0, len = this.masksProperties.length;
	    while(i<len){
	        if(this.masksProperties[i].nm === nm){
	            return {
	                maskPath: this.viewData[i].pv
	            }
	        }
	        i += 1;
	    }
	};

	CVMaskElement.prototype.destroy = function(){
	    this.element = null;
	};
	function CVShapeElement(data, comp,globalData){
	    this.shapes = [];
	    this.stylesList = [];
	    this.viewData = [];
	    this.shapeModifiers = [];
	    this.shapesData = data.shapes;
	    this.firstFrame = true;
	    this._parent.constructor.call(this,data, comp,globalData);
	}
	createElement(CVBaseElement, CVShapeElement);

	CVShapeElement.prototype.lcEnum = {
	    '1': 'butt',
	    '2': 'round',
	    '3': 'butt'
	}

	CVShapeElement.prototype.ljEnum = {
	    '1': 'miter',
	    '2': 'round',
	    '3': 'butt'
	};
	CVShapeElement.prototype.transformHelper = {opacity:1,mat:new Matrix(),matMdf:false,opMdf:false};

	CVShapeElement.prototype.dashResetter = [];

	CVShapeElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);
	    this.searchShapes(this.shapesData,this.viewData,this.dynamicProperties);
	};
	CVShapeElement.prototype.searchShapes = function(arr,data,dynamicProperties){
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownArrays = [], ownModifiers = [], styleElem;
	    for(i=len;i>=0;i-=1){
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st'){
	            styleElem = {
	                type: arr[i].ty,
	                elements: []
	            };
	            data[i] = {};
	            if(arr[i].ty == 'fl' || arr[i].ty == 'st'){
	                data[i].c = PropertyFactory.getProp(this,arr[i].c,1,255,dynamicProperties);
	                if(!data[i].c.k){
	                    styleElem.co = 'rgb('+bm_floor(data[i].c.v[0])+','+bm_floor(data[i].c.v[1])+','+bm_floor(data[i].c.v[2])+')';
	                }
	            }
	            data[i].o = PropertyFactory.getProp(this,arr[i].o,0,0.01,dynamicProperties);
	            if(arr[i].ty == 'st') {
	                styleElem.lc = this.lcEnum[arr[i].lc] || 'round';
	                styleElem.lj = this.ljEnum[arr[i].lj] || 'round';
	                if(arr[i].lj == 1) {
	                    styleElem.ml = arr[i].ml;
	                }
	                data[i].w = PropertyFactory.getProp(this,arr[i].w,0,null,dynamicProperties);
	                if(!data[i].w.k){
	                    styleElem.wi = data[i].w.v;
	                }
	                if(arr[i].d){
	                    var d = PropertyFactory.getDashProp(this,arr[i].d,'canvas',dynamicProperties);
	                    data[i].d = d;
	                    if(!data[i].d.k){
	                        styleElem.da = data[i].d.dasharray;
	                        styleElem.do = data[i].d.dashoffset;
	                    }
	                }

	            } else {

	                styleElem.r = arr[i].r === 2 ? 'evenodd' : 'nonzero';
	            }
	            this.stylesList.push(styleElem);
	            data[i].style = styleElem;
	            ownArrays.push(data[i].style);
	        }else if(arr[i].ty == 'gr'){
	            data[i] = {
	                it: []
	            };
	            this.searchShapes(arr[i].it,data[i].it,dynamicProperties);
	        }else if(arr[i].ty == 'tr'){
	            data[i] = {
	                transform : {
	                    mat: new Matrix(),
	                    opacity: 1,
	                    matMdf:false,
	                    opMdf:false,
	                    op: PropertyFactory.getProp(this,arr[i].o,0,0.01,dynamicProperties),
	                    mProps: PropertyFactory.getProp(this,arr[i],2,null,dynamicProperties)
	                },
	                elements: []
	            };
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            data[i] = {
	                nodes:[],
	                trNodes:[],
	                tr:[0,0,0,0,0,0]
	            };
	            var ty = 4;
	            if(arr[i].ty == 'rc'){
	                ty = 5;
	            }else if(arr[i].ty == 'el'){
	                ty = 6;
	            }else if(arr[i].ty == 'sr'){
	                ty = 7;
	            }
	            data[i].sh = ShapePropertyFactory.getShapeProp(this,arr[i],ty,dynamicProperties);
	            this.shapes.push(data[i].sh);
	            this.addShapeToModifiers(data[i]);
	            jLen = this.stylesList.length;
	            var hasStrokes = false, hasFills = false;
	            for(j=0;j<jLen;j+=1){
	                if(!this.stylesList[j].closed){
	                    this.stylesList[j].elements.push(data[i]);
	                    if(this.stylesList[j].type === 'st'){
	                        hasStrokes = true;
	                    }else{
	                        hasFills = true;
	                    }
	                }
	            }
	            data[i].st = hasStrokes;
	            data[i].fl = hasFills;
	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'rp'){
	            var modifier = ShapeModifiers.getModifier(arr[i].ty);
	            modifier.init(this,arr[i],dynamicProperties);
	            this.shapeModifiers.push(modifier);
	            ownModifiers.push(modifier);
	            data[i] = modifier;
	        }
	    }
	    len = ownArrays.length;
	    for(i=0;i<len;i+=1){
	        ownArrays[i].closed = true;
	    }
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};

	CVShapeElement.prototype.addShapeToModifiers = IShapeElement.prototype.addShapeToModifiers;
	CVShapeElement.prototype.renderModifiers = IShapeElement.prototype.renderModifiers;

	CVShapeElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    this.transformHelper.mat.reset();
	    this.transformHelper.opacity = this.finalTransform.opacity;
	    this.transformHelper.matMdf = false;
	    this.transformHelper.opMdf = this.finalTransform.opMdf;
	    this.renderModifiers();
	    this.renderShape(this.transformHelper,null,null,true);
	    if(this.data.hasMask){
	        this.globalData.renderer.restore(true);
	    }
	};

	CVShapeElement.prototype.renderShape = function(parentTransform,items,data,isMain){
	    var i, len;
	    if(!items){
	        items = this.shapesData;
	        len = this.stylesList.length;
	        for(i=0;i<len;i+=1){
	            this.stylesList[i].d = '';
	            this.stylesList[i].mdf = false;
	        }
	    }
	    if(!data){
	        data = this.viewData;
	    }
	    ///
	    ///
	    len = items.length - 1;
	    var groupTransform,groupMatrix;
	    groupTransform = parentTransform;
	    for(i=len;i>=0;i-=1){
	        if(items[i].ty == 'tr'){
	            groupTransform = data[i].transform;
	            var mtArr = data[i].transform.mProps.v.props;
	            groupTransform.matMdf = groupTransform.mProps.mdf;
	            groupTransform.opMdf = groupTransform.op.mdf;
	            groupMatrix = groupTransform.mat;
	            groupMatrix.cloneFromProps(mtArr);
	            if(parentTransform){
	                var props = parentTransform.mat.props;
	                groupTransform.opacity = parentTransform.opacity;
	                groupTransform.opacity *= data[i].transform.op.v;
	                groupTransform.matMdf = parentTransform.matMdf ? true : groupTransform.matMdf;
	                groupTransform.opMdf = parentTransform.opMdf ? true : groupTransform.opMdf;
	                groupMatrix.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	            }else{
	                groupTransform.opacity = groupTransform.op.o;
	            }
	        }else if(items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr'){
	            this.renderPath(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'fl'){
	            this.renderFill(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'st'){
	            this.renderStroke(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'gr'){
	            this.renderShape(groupTransform,items[i].it,data[i].it);
	        }else if(items[i].ty == 'tm'){
	            //
	        }
	    }
	    if(!isMain){
	        return;
	    }
	    len = this.stylesList.length;
	    var j, jLen, k, kLen,elems,nodes, renderer = this.globalData.renderer, ctx = this.globalData.canvasContext, type;
	    renderer.save();
	    renderer.ctxTransform(this.finalTransform.mat.props);
	    for(i=0;i<len;i+=1){
	        type = this.stylesList[i].type;
	        if(type === 'st' && this.stylesList[i].wi === 0){
	            continue;
	        }
	        renderer.save();
	        elems = this.stylesList[i].elements;
	        if(type === 'st'){
	            ctx.strokeStyle = this.stylesList[i].co;
	            ctx.lineWidth = this.stylesList[i].wi;
	            ctx.lineCap = this.stylesList[i].lc;
	            ctx.lineJoin = this.stylesList[i].lj;
	            ctx.miterLimit = this.stylesList[i].ml || 0;
	        }else{
	            ctx.fillStyle = this.stylesList[i].co;
	        }
	        renderer.ctxOpacity(this.stylesList[i].coOp);
	        if(type !== 'st'){
	            ctx.beginPath();
	        }
	        jLen = elems.length;
	        for(j=0;j<jLen;j+=1){
	            if(type === 'st'){
	                ctx.beginPath();
	                if(this.stylesList[i].da){
	                    ctx.setLineDash(this.stylesList[i].da);
	                    ctx.lineDashOffset = this.stylesList[i].do;
	                    this.globalData.isDashed = true;
	                }else if(this.globalData.isDashed){
	                    ctx.setLineDash(this.dashResetter);
	                    this.globalData.isDashed = false;
	                }
	            }
	            nodes = elems[j].trNodes;
	            kLen = nodes.length;

	            for(k=0;k<kLen;k+=1){
	                if(nodes[k].t == 'm'){
	                    ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);
	                }else if(nodes[k].t == 'c'){
	                    ctx.bezierCurveTo(nodes[k].p1[0],nodes[k].p1[1],nodes[k].p2[0],nodes[k].p2[1],nodes[k].p3[0],nodes[k].p3[1]);
	                }else{
	                    ctx.closePath();
	                }
	            }
	            if(type === 'st'){
	                ctx.stroke();
	            }
	        }
	        if(type !== 'st'){
	            ctx.fill(this.stylesList[i].r);
	        }
	        renderer.restore();
	    }
	    renderer.restore();
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	CVShapeElement.prototype.renderPath = function(pathData,viewData,groupTransform){
	    var len, i, j,jLen;
	    var redraw = groupTransform.matMdf || viewData.sh.mdf || this.firstFrame;
	    if(redraw) {
	        var paths = viewData.sh.paths;
	        jLen = paths._length;
	        var pathStringTransformed = viewData.trNodes;
	        pathStringTransformed.length = 0;
	        for(j=0;j<jLen;j+=1){
	            var pathNodes = paths.shapes[j];
	            if(pathNodes && pathNodes.v){
	                len = pathNodes._length;
	                for (i = 1; i < len; i += 1) {
	                    if (i == 1) {
	                        pathStringTransformed.push({
	                            t: 'm',
	                            p: groupTransform.mat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                        });
	                    }
	                    pathStringTransformed.push({
	                        t: 'c',
	                        p1: groupTransform.mat.applyToPointArray(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1], 0),
	                        p2: groupTransform.mat.applyToPointArray(pathNodes.i[i][0], pathNodes.i[i][1], 0),
	                        p3: groupTransform.mat.applyToPointArray(pathNodes.v[i][0], pathNodes.v[i][1], 0)
	                    });
	                }
	                if (len == 1) {
	                    pathStringTransformed.push({
	                        t: 'm',
	                        p: groupTransform.mat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                    });
	                }
	                if (pathNodes.c && len) {
	                    pathStringTransformed.push({
	                        t: 'c',
	                        p1: groupTransform.mat.applyToPointArray(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1], 0),
	                        p2: groupTransform.mat.applyToPointArray(pathNodes.i[0][0], pathNodes.i[0][1], 0),
	                        p3: groupTransform.mat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                    });
	                    pathStringTransformed.push({
	                        t: 'z'
	                    });
	                }
	                viewData.lStr = pathStringTransformed;
	            }

	        }

	        if (viewData.st) {
	            for (i = 0; i < 16; i += 1) {
	                viewData.tr[i] = groupTransform.mat.props[i];
	            }
	        }
	        viewData.trNodes = pathStringTransformed;

	    }
	};



	CVShapeElement.prototype.renderFill = function(styleData,viewData, groupTransform){
	    var styleElem = viewData.style;

	    if(viewData.c.mdf || this.firstFrame){
	        styleElem.co = 'rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')';
	    }
	    if(viewData.o.mdf || groupTransform.opMdf || this.firstFrame){
	        styleElem.coOp = viewData.o.v*groupTransform.opacity;
	    }
	};

	CVShapeElement.prototype.renderStroke = function(styleData,viewData, groupTransform){
	    var styleElem = viewData.style;
	    //TODO fix dashes
	    var d = viewData.d;
	    var dasharray,dashoffset;
	    if(d && (d.mdf  || this.firstFrame)){
	        styleElem.da = d.dasharray;
	        styleElem.do = d.dashoffset;
	    }
	    if(viewData.c.mdf || this.firstFrame){
	        styleElem.co = 'rgb('+bm_floor(viewData.c.v[0])+','+bm_floor(viewData.c.v[1])+','+bm_floor(viewData.c.v[2])+')';
	    }
	    if(viewData.o.mdf || groupTransform.opMdf || this.firstFrame){
	        styleElem.coOp = viewData.o.v*groupTransform.opacity;
	    }
	    if(viewData.w.mdf || this.firstFrame){
	        styleElem.wi = viewData.w.v;
	    }
	};


	CVShapeElement.prototype.destroy = function(){
	    this.shapesData = null;
	    this.globalData = null;
	    this.canvasContext = null;
	    this.stylesList.length = 0;
	    this.viewData.length = 0;
	    this._parent.destroy.call(this._parent);
	};


	function CVSolidElement(data, comp,globalData){
	    this._parent.constructor.call(this,data, comp,globalData);
	}
	createElement(CVBaseElement, CVSolidElement);

	CVSolidElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    this.globalData.renderer.save();
	    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.fillStyle=this.data.sc;
	    ctx.fillRect(0,0,this.data.sw,this.data.sh);
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	function CVTextElement(data, comp, globalData){
	    this.textSpans = [];
	    this.yOffset = 0;
	    this.fillColorAnim = false;
	    this.strokeColorAnim = false;
	    this.strokeWidthAnim = false;
	    this.stroke = false;
	    this.fill = false;
	    this.justifyOffset = 0;
	    this.currentRender = null;
	    this.renderType = 'canvas';
	    this.values = {
	        fill: 'rgba(0,0,0,0)',
	        stroke: 'rgba(0,0,0,0)',
	        sWidth: 0,
	        fValue: ''
	    }
	    this._parent.constructor.call(this,data,comp, globalData);
	}
	createElement(CVBaseElement, CVTextElement);

	CVTextElement.prototype.init = ITextElement.prototype.init;
	CVTextElement.prototype.getMeasures = ITextElement.prototype.getMeasures;
	CVTextElement.prototype.getMult = ITextElement.prototype.getMult;
	CVTextElement.prototype.prepareFrame = ITextElement.prototype.prepareFrame;

	CVTextElement.prototype.tHelper = document.createElement('canvas').getContext('2d');

	CVTextElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);
	    //console.log('this.data: ',this.data);

	};

	CVTextElement.prototype.buildNewText = function(){
	    var documentData = this.currentTextDocumentData;
	    this.renderedLetters = Array.apply(null,{length:this.currentTextDocumentData.l ? this.currentTextDocumentData.l.length : 0});

	    var hasFill = false;
	    if(documentData.fc) {
	        hasFill = true;
	        this.values.fill = 'rgb(' + Math.round(documentData.fc[0]*255) + ',' + Math.round(documentData.fc[1]*255) + ',' + Math.round(documentData.fc[2]*255) + ')';
	    }else{
	        this.values.fill = 'rgba(0,0,0,0)';
	    }
	    this.fill = hasFill;
	    var hasStroke = false;
	    if(documentData.sc){
	        hasStroke = true;
	        this.values.stroke = 'rgb(' + Math.round(documentData.sc[0]*255) + ',' + Math.round(documentData.sc[1]*255) + ',' + Math.round(documentData.sc[2]*255) + ')';
	        this.values.sWidth = documentData.sw;
	    }
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    var i, len;
	    var letters = documentData.l;
	    var matrixHelper = this.mHelper;
	    this.stroke = hasStroke;
	    this.values.fValue = documentData.s + 'px '+ this.globalData.fontManager.getFontByName(documentData.f).fFamily;
	    len = documentData.t.length;
	    this.tHelper.font = this.values.fValue;
	    var charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, singleShape = this.data.singleShape;
	    if (singleShape) {
	        var xPos = 0, yPos = 0, lineWidths = documentData.lineWidths, boxWidth = documentData.boxWidth, firstLine = true;
	    }
	    var cnt = 0;
	    for (i = 0;i < len ;i += 1) {
	        charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	        var shapeData;
	        if(charData){
	            shapeData = charData.data;
	        } else {
	            shapeData = null;
	        }
	        matrixHelper.reset();
	        if(singleShape && letters[i].n) {
	            xPos = 0;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            firstLine = false;
	        }

	        if(shapeData && shapeData.shapes){
	            shapes = shapeData.shapes[0].it;
	            jLen = shapes.length;
	            matrixHelper.scale(documentData.s/100,documentData.s/100);
	            if(singleShape){
	                if(documentData.ps){
	                    matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	                }
	                switch(documentData.j){
	                    case 1:
	                        matrixHelper.translate(documentData.justifyOffset + (boxWidth - lineWidths[letters[i].line]),0,0);
	                        break;
	                    case 2:
	                        matrixHelper.translate(documentData.justifyOffset + (boxWidth - lineWidths[letters[i].line])/2,0,0);
	                        break;
	                }
	                matrixHelper.translate(xPos,yPos,0);
	            }
	            commands = new Array(jLen);
	            for(j=0;j<jLen;j+=1){
	                kLen = shapes[j].ks.k.i.length;
	                pathNodes = shapes[j].ks.k;
	                pathArr = [];
	                for(k=1;k<kLen;k+=1){
	                    if(k==1){
	                        pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	                    }
	                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));
	                }
	                pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	                commands[j] = pathArr;
	            }
	        }else{
	            commands = [];
	        }
	        if(singleShape){
	            xPos += letters[i].l;
	        }
	        if(this.textSpans[cnt]){
	            this.textSpans[cnt].elem = commands;
	        } else {
	            this.textSpans[cnt] = {elem: commands};
	        }
	        cnt +=1;
	    }
	}

	CVTextElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    var finalMat = this.finalTransform.mat.props;
	    this.globalData.renderer.save();
	    this.globalData.renderer.ctxTransform(finalMat);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.font = this.values.fValue;
	    ctx.lineCap = 'butt';
	    ctx.lineJoin = 'miter';
	    ctx.miterLimit = 4;

	    if(!this.data.singleShape){
	        this.getMeasures();
	    }

	    var  i,len, j, jLen, k, kLen;
	    var renderedLetters = this.renderedLetters;

	    var letters = this.currentTextDocumentData.l;

	    len = letters.length;
	    var renderedLetter;
	    var lastFill = null, lastStroke = null, lastStrokeW = null, commands, pathArr;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            continue;
	        }
	        renderedLetter = renderedLetters[i];
	        if(renderedLetter){
	            this.globalData.renderer.save();
	            this.globalData.renderer.ctxTransform(renderedLetter.props);
	            this.globalData.renderer.ctxOpacity(renderedLetter.o);
	        }
	        if(this.fill){
	            if(renderedLetter && renderedLetter.fc){
	                if(lastFill !== renderedLetter.fc){
	                    lastFill = renderedLetter.fc;
	                    ctx.fillStyle = renderedLetter.fc;
	                }
	            }else if(lastFill !== this.values.fill){
	                lastFill = this.values.fill;
	                ctx.fillStyle = this.values.fill;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.fill();
	            ///ctx.fillText(this.textSpans[i].val,0,0);
	        }
	        if(this.stroke){
	            if(renderedLetter && renderedLetter.sw){
	                if(lastStrokeW !== renderedLetter.sw){
	                    lastStrokeW = renderedLetter.sw;
	                    ctx.lineWidth = renderedLetter.sw;
	                }
	            }else if(lastStrokeW !== this.values.sWidth){
	                lastStrokeW = this.values.sWidth;
	                ctx.lineWidth = this.values.sWidth;
	            }
	            if(renderedLetter && renderedLetter.sc){
	                if(lastStroke !== renderedLetter.sc){
	                    lastStroke = renderedLetter.sc;
	                    ctx.strokeStyle = renderedLetter.sc;
	                }
	            }else if(lastStroke !== this.values.stroke){
	                lastStroke = this.values.stroke;
	                ctx.strokeStyle = this.values.stroke;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.stroke();
	            ///ctx.strokeText(letters[i].val,0,0);
	        }
	        if(renderedLetter) {
	            this.globalData.renderer.restore();
	        }
	    }
	    /*if(this.data.hasMask){
	     this.globalData.renderer.restore(true);
	     }*/
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	function HBaseElement(data,parentContainer,globalData,comp, placeholder){
	    this.globalData = globalData;
	    this.comp = comp;
	    this.data = data;
	    this.matteElement = null;
	    this.parentContainer = parentContainer;
	    this.layerId = placeholder ? placeholder.layerId : 'ly_'+randomString(10);
	    this.placeholder = placeholder;
	    this.init();
	};

	createElement(BaseElement, HBaseElement);
	HBaseElement.prototype.checkBlendMode = function(){

	};
	HBaseElement.prototype.setBlendMode = BaseElement.prototype.setBlendMode;

	/*HBaseElement.prototype.appendNodeToParent = function(node) {
	    if(this.data.hd){
	        return;
	    }
	    if(this.placeholder){
	        var g = this.placeholder.phElement;
	        g.parentNode.insertBefore(node, g);
	        //g.parentNode.removeChild(g);
	    }else{
	        this.parentContainer.appendChild(node);
	    }
	};*/


	HBaseElement.prototype.getBaseElement = function(){
	    return this.baseElement;
	};

	HBaseElement.prototype.createElements = function(){
	    if(this.data.hasMask){
	        this.layerElement = document.createElementNS(svgNS,'svg');
	        styleDiv(this.layerElement);
	        //this.appendNodeToParent(this.layerElement);
	        this.baseElement = this.layerElement;
	        this.maskedElement = this.layerElement;
	    }else{
	        this.layerElement = this.parentContainer;
	    }
	    this.transformedElement = this.layerElement;
	    if(this.data.ln && (this.data.ty === 4 || this.data.ty === 0)){
	        if(this.layerElement === this.parentContainer){
	            this.layerElement = document.createElementNS(svgNS,'g');
	            //this.appendNodeToParent(this.layerElement);
	            this.baseElement = this.layerElement;
	        }
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    this.setBlendMode();
	    if(this.layerElement !== this.parentContainer){
	        this.placeholder = null;
	    }
	    this.checkParenting();
	};

	HBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3){
	        return false;
	    }

	    if(this.currentFrameNum === this.lastNum || !this.isVisible){
	        return this.isVisible;
	    }
	    this.lastNum = this.currentFrameNum;

	    this.finalTransform.opMdf = this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;
	    if(this.firstFrame){
	        this.finalTransform.opMdf = true;
	        this.finalTransform.matMdf = true;
	    }

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i, len = this.hierarchy.length;

	        mat = this.finalTransform.mProp.v.props;
	        finalMat.cloneFromProps(mat);
	        for(i=0;i<len;i+=1){
	            this.finalTransform.matMdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : this.finalTransform.matMdf;
	            mat = this.hierarchy[i].finalTransform.mProp.v.props;
	            finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        }
	    }else{
	        if(this.isVisible && this.finalTransform.matMdf){
	            if(!parentTransform){
	                finalMat.cloneFromProps(this.finalTransform.mProp.v.props);
	            }else{
	                mat = this.finalTransform.mProp.v.props;
	                finalMat.cloneFromProps(mat);
	            }
	        }
	    }
	    if(this.data.hasMask){
	        this.maskManager.renderFrame(finalMat);
	    }

	    if(parentTransform){
	        mat = parentTransform.mat.props;
	        finalMat.cloneFromProps(mat);
	        this.finalTransform.opacity *= parentTransform.opacity;
	        this.finalTransform.opMdf = parentTransform.opMdf ? true : this.finalTransform.opMdf;
	        this.finalTransform.matMdf = parentTransform.matMdf ? true : this.finalTransform.matMdf
	    }

	    if(this.finalTransform.matMdf){
	        this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = finalMat.toCSS();
	        this.finalMat = finalMat;
	    }
	    if(this.finalTransform.opMdf){
	        this.transformedElement.style.opacity = this.finalTransform.opacity;
	    }
	    return this.isVisible;
	};

	HBaseElement.prototype.destroy = function(){
	    this.layerElement = null;
	    this.transformedElement = null;
	    this.parentContainer = null;
	    if(this.matteElement) {
	        this.matteElement = null;
	    }
	    if(this.maskManager) {
	        this.maskManager.destroy();
	        this.maskManager = null;
	    }
	};

	HBaseElement.prototype.getDomElement = function(){
	    return this.layerElement;
	};
	HBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new MaskElement(data,this,this.globalData);
	};

	HBaseElement.prototype.hide = function(){
	};

	HBaseElement.prototype.setMatte = function(){

	}

	HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
	function HSolidElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(HBaseElement, HSolidElement);

	HSolidElement.prototype.createElements = function(){
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    var cont = document.createElementNS(svgNS,'svg');
	    styleDiv(cont);
	    cont.setAttribute('width',this.data.sw);
	    cont.setAttribute('height',this.data.sh);
	    parent.appendChild(cont);
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    //this.appendNodeToParent(parent);
	    this.baseElement = parent;
	    this.innerElem = parent;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    var rect = document.createElementNS(svgNS,'rect');
	    rect.setAttribute('width',this.data.sw);
	    rect.setAttribute('height',this.data.sh);
	    rect.setAttribute('fill',this.data.sc);
	    cont.appendChild(rect);
	    if(this.data.hasMask){
	        this.maskedElement = rect;
	    }
	    this.checkParenting();
	};



	HSolidElement.prototype.hide = IImageElement.prototype.hide;
	HSolidElement.prototype.renderFrame = IImageElement.prototype.renderFrame;
	HSolidElement.prototype.destroy = IImageElement.prototype.destroy;
	function HCompElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.layers = data.layers;
	    this.supports3d = true;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = Array.apply(null,{length:this.layers.length});
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.hasMask) {
	        this.supports3d = false;
	    }
	    if(this.data.xt){
	        this.layerElement = document.createElement('div');
	    }
	    this.buildAllItems();

	}
	createElement(HBaseElement, HCompElement);

	HCompElement.prototype.createElements = function(){
	    var divElement = document.createElement('div');
	    styleDiv(divElement);
	    if(this.data.ln){
	        divElement.setAttribute('id',this.data.ln);
	    }
	    divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
	    if(this.data.hasMask){
	        var compSvg = document.createElementNS(svgNS,'svg');
	        styleDiv(compSvg);
	        compSvg.setAttribute('width',this.data.w);
	        compSvg.setAttribute('height',this.data.h);
	        var g = document.createElementNS(svgNS,'g');
	        compSvg.appendChild(g);
	        divElement.appendChild(compSvg);
	        this.maskedElement = g;
	        this.baseElement = divElement;
	        this.layerElement = g;
	        this.transformedElement = divElement;
	    }else{
	        this.layerElement = divElement;
	        this.baseElement = this.layerElement;
	        this.transformedElement = divElement;
	    }
	    //this.appendNodeToParent(this.layerElement);
	    this.checkParenting();
	};

	HCompElement.prototype.hide = ICompElement.prototype.hide;
	HCompElement.prototype.prepareFrame = ICompElement.prototype.prepareFrame;
	HCompElement.prototype.setElements = ICompElement.prototype.setElements;
	HCompElement.prototype.getElements = ICompElement.prototype.getElements;
	HCompElement.prototype.destroy = ICompElement.prototype.destroy;

	HCompElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    var i,len = this.layers.length;
	    if(renderParent===false){
	        this.hide();
	        return;
	    }

	    this.hidden = false;

	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	HCompElement.prototype.checkLayers = BaseRenderer.prototype.checkLayers;
	HCompElement.prototype.buildItem = HybridRenderer.prototype.buildItem;
	HCompElement.prototype.checkPendingElements = HybridRenderer.prototype.checkPendingElements;
	HCompElement.prototype.addPendingElement = HybridRenderer.prototype.addPendingElement;
	HCompElement.prototype.buildAllItems = BaseRenderer.prototype.buildAllItems;
	HCompElement.prototype.createItem = HybridRenderer.prototype.createItem;
	HCompElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
	HCompElement.prototype.createImage = HybridRenderer.prototype.createImage;
	HCompElement.prototype.createComp = HybridRenderer.prototype.createComp;
	HCompElement.prototype.createSolid = HybridRenderer.prototype.createSolid;
	HCompElement.prototype.createShape = HybridRenderer.prototype.createShape;
	HCompElement.prototype.createText = HybridRenderer.prototype.createText;
	HCompElement.prototype.createBase = HybridRenderer.prototype.createBase;
	HCompElement.prototype.appendElementInPos = HybridRenderer.prototype.appendElementInPos;
	function HShapeElement(data,parentContainer,globalData,comp, placeholder){
	    this.shapes = [];
	    this.shapeModifiers = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.viewData = [];
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.addedTransforms = {
	        mdf: false,
	        mats: [this.finalTransform.mat]
	    };
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    };
	}
	createElement(HBaseElement, HShapeElement);
	var parent = HShapeElement.prototype._parent;
	extendPrototype(IShapeElement, HShapeElement);
	HShapeElement.prototype._parent = parent;

	HShapeElement.prototype.createElements = function(){
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    var cont = document.createElementNS(svgNS,'svg');
	    styleDiv(cont);
	    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
	    cont.setAttribute('width',size.w);
	    cont.setAttribute('height',size.h);
	    if(this.data.hasMask){
	        var g = document.createElementNS(svgNS,'g');
	        parent.appendChild(cont);
	        cont.appendChild(g);
	        this.maskedElement = g;
	        this.layerElement = g;
	        this.shapesContainer = g;
	    }else{
	        parent.appendChild(cont);
	        this.layerElement = cont;
	        this.shapesContainer = document.createElementNS(svgNS,'g');
	        this.layerElement.appendChild(this.shapesContainer);
	    }
	    if(!this.data.hd){
	        //this.parentContainer.appendChild(parent);
	        this.baseElement = parent;
	    }
	    this.innerElem = parent;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }
	    this.searchShapes(this.shapesData,this.viewData,this.layerElement,this.dynamicProperties,0);
	    this.buildExpressionInterface();
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    this.shapeCont = cont;
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    this.checkParenting();
	};

	HShapeElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.layerElement.style.display = 'block';
	        this.hidden = false;
	    }
	    this.renderModifiers();
	    this.addedTransforms.mdf = this.finalTransform.matMdf;
	    this.addedTransforms.mats.length = 1;
	    this.addedTransforms.mats[0] = this.finalTransform.mat;
	    this.renderShape(null,null,true, null);

	    if(this.isVisible && (this.elemMdf || this.firstFrame)){
	        var boundingBox = this.shapeCont.getBBox();
	        var changed = false;
	        if(this.currentBBox.w !== boundingBox.width){
	            this.currentBBox.w = boundingBox.width;
	            this.shapeCont.setAttribute('width',boundingBox.width);
	            changed = true;
	        }
	        if(this.currentBBox.h !== boundingBox.height){
	            this.currentBBox.h = boundingBox.height;
	            this.shapeCont.setAttribute('height',boundingBox.height);
	            changed = true;
	        }
	        if(changed  || this.currentBBox.x !== boundingBox.x  || this.currentBBox.y !== boundingBox.y){
	            this.currentBBox.w = boundingBox.width;
	            this.currentBBox.h = boundingBox.height;
	            this.currentBBox.x = boundingBox.x;
	            this.currentBBox.y = boundingBox.y;

	            this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	            this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	        }
	    }

	};
	function HTextElement(data,parentContainer,globalData,comp, placeholder){
	    this.textSpans = [];
	    this.textPaths = [];
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    }
	    this.renderType = 'svg';
	    this.isMasked = false;
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);

	}
	createElement(HBaseElement, HTextElement);

	HTextElement.prototype.init = ITextElement.prototype.init;
	HTextElement.prototype.getMeasures = ITextElement.prototype.getMeasures;
	HTextElement.prototype.createPathShape = ITextElement.prototype.createPathShape;
	HTextElement.prototype.prepareFrame = ITextElement.prototype.prepareFrame;

	HTextElement.prototype.createElements = function(){
	    this.isMasked = this.checkMasks();
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    if(this.isMasked){
	        this.renderType = 'svg';
	        var cont = document.createElementNS(svgNS,'svg');
	        styleDiv(cont);
	        this.cont = cont;
	        this.compW = this.comp.data.w;
	        this.compH = this.comp.data.h;
	        cont.setAttribute('width',this.compW);
	        cont.setAttribute('height',this.compH);
	        var g = document.createElementNS(svgNS,'g');
	        cont.appendChild(g);
	        parent.appendChild(cont);
	        this.maskedElement = g;
	        this.innerElem = g;
	    } else {
	        this.renderType = 'html';
	        this.innerElem = parent;
	    }
	    this.baseElement = parent;

	    this.checkParenting();

	};

	HTextElement.prototype.buildNewText = function(){
	    var documentData = this.currentTextDocumentData;
	    this.renderedLetters = Array.apply(null,{length:this.currentTextDocumentData.l ? this.currentTextDocumentData.l.length : 0});
	    if(documentData.fc) {
	        this.innerElem.style.color = this.innerElem.style.fill = 'rgb(' + Math.round(documentData.fc[0]*255) + ',' + Math.round(documentData.fc[1]*255) + ',' + Math.round(documentData.fc[2]*255) + ')';
	        ////this.innerElem.setAttribute('fill', 'rgb(' + documentData.fc[0] + ',' + documentData.fc[1] + ',' + documentData.fc[2] + ')');
	    }else{
	        this.innerElem.style.color = this.innerElem.style.fill = 'rgba(0,0,0,0)';
	        ////this.innerElem.setAttribute('fill', 'rgba(0,0,0,0)');
	    }
	    if(documentData.sc){
	        ////this.innerElem.setAttribute('stroke', 'rgb(' + documentData.sc[0] + ',' + documentData.sc[1] + ',' + documentData.sc[2] + ')');
	        this.innerElem.style.stroke = 'rgb(' + Math.round(documentData.sc[0]*255) + ',' + Math.round(documentData.sc[1]*255) + ',' + Math.round(documentData.sc[2]*255) + ')';
	        ////this.innerElem.setAttribute('stroke-width', documentData.sw);
	        this.innerElem.style.strokeWidth = documentData.sw+'px';
	    }
	    ////this.innerElem.setAttribute('font-size', documentData.s);
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(!this.globalData.fontManager.chars){
	        this.innerElem.style.fontSize = documentData.s+'px';
	        this.innerElem.style.lineHeight = documentData.s+'px';
	        if(fontData.fClass){
	            this.innerElem.className = fontData.fClass;
	        } else {
	            ////this.innerElem.setAttribute('font-family', fontData.fFamily);
	            this.innerElem.style.fontFamily = fontData.fFamily;
	            var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	            ////this.innerElem.setAttribute('font-style', fStyle);
	            this.innerElem.style.fontStyle = fStyle;
	            ////this.innerElem.setAttribute('font-weight', fWeight);
	            this.innerElem.style.fontWeight = fWeight;
	        }
	    }
	    var i, len;

	    var letters = documentData.l;
	    len = letters.length;
	    var tSpan,tParent,tCont;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '';
	    var cnt = 0;
	    for (i = 0;i < len ;i += 1) {
	        if(this.globalData.fontManager.chars){
	            if(!this.textPaths[cnt]){
	                tSpan = document.createElementNS(svgNS,'path');
	                tSpan.setAttribute('stroke-linecap', 'butt');
	                tSpan.setAttribute('stroke-linejoin','round');
	                tSpan.setAttribute('stroke-miterlimit','4');
	            } else {
	                tSpan = this.textPaths[cnt];
	            }
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tCont = tParent.children[0];
	                } else {

	                    tParent = document.createElement('div');
	                    tCont = document.createElementNS(svgNS,'svg');
	                    tCont.appendChild(tSpan);
	                    styleDiv(tParent);
	                }
	            }
	        }else{
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tSpan = this.textPaths[cnt];
	                } else {
	                    tParent = document.createElement('span');
	                    styleDiv(tParent);
	                    tSpan = document.createElement('span');
	                    styleDiv(tSpan);
	                    tParent.appendChild(tSpan);
	                }
	            } else {
	                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : document.createElementNS(svgNS,'text');
	            }
	        }
	        //tSpan.setAttribute('visibility', 'hidden');
	        if(this.globalData.fontManager.chars){
	            var charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	            var shapeData;
	            if(charData){
	                shapeData = charData.data;
	            } else {
	                shapeData = null;
	            }
	            matrixHelper.reset();
	            if(shapeData && shapeData.shapes){
	                shapes = shapeData.shapes[0].it;
	                matrixHelper.scale(documentData.s/100,documentData.s/100);
	                shapeStr = this.createPathShape(matrixHelper,shapes);
	                tSpan.setAttribute('d',shapeStr);
	            }
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                if(shapeData && shapeData.shapes){
	                    document.body.appendChild(tCont);

	                    var boundingBox = tCont.getBBox();
	                    tCont.setAttribute('width',boundingBox.width);
	                    tCont.setAttribute('height',boundingBox.height);
	                    tCont.setAttribute('viewBox',boundingBox.x+' '+ boundingBox.y+' '+ boundingBox.width+' '+ boundingBox.height);
	                    tCont.style.transform = tCont.style.webkitTransform = 'translate(' + boundingBox.x + 'px,' + boundingBox.y + 'px)';

	                    letters[i].yOffset = boundingBox.y;
	                    tParent.appendChild(tCont);

	                } else{
	                    tCont.setAttribute('width',1);
	                    tCont.setAttribute('height',1);
	                }
	            }else{
	                this.innerElem.appendChild(tSpan);
	            }
	        }else{
	            tSpan.textContent = letters[i].val;
	            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                //
	                tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,'+ -documentData.s/1.2+'px,0)';
	            } else {
	                this.innerElem.appendChild(tSpan);
	            }
	        }
	        //
	        if(!this.isMasked){
	            this.textSpans[cnt] = tParent;
	        }else{
	            this.textSpans[cnt] = tSpan;
	        }
	        this.textSpans[cnt].style.display = 'block';
	        this.textPaths[cnt] = tSpan;
	        cnt += 1;
	    }
	    while(cnt < this.textSpans.length){
	        this.textSpans[cnt].style.display = 'none';
	        cnt += 1;
	    }
	}

	HTextElement.prototype.hide = SVGTextElement.prototype.hide;

	HTextElement.prototype.renderFrame = function(parentMatrix){

	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.hidden = false;
	        this.innerElem.style.display = 'block';
	        this.layerElement.style.display = 'block';
	    }

	    if(this.data.singleShape){
	        if(!this.firstFrame && !this.lettersChangedFlag){
	            return;
	        } else {
	            // Todo Benchmark if using this is better than getBBox
	             if(this.isMasked && this.finalTransform.matMdf){
	                 this.cont.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+ -this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);
	                this.cont.style.transform = this.cont.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
	             }
	        }
	    }

	    this.getMeasures();
	    if(!this.lettersChangedFlag){
	        return;
	    }
	    var  i,len;
	    var renderedLetters = this.renderedLetters;

	    var letters = this.currentTextDocumentData.l;

	    len = letters.length;
	    var renderedLetter;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            continue;
	        }
	        renderedLetter = renderedLetters[i];
	        if(!this.isMasked){
	            this.textSpans[i].style.transform = this.textSpans[i].style.webkitTransform = renderedLetter.m;
	        }else{
	            this.textSpans[i].setAttribute('transform',renderedLetter.m);
	        }
	        ////this.textSpans[i].setAttribute('opacity',renderedLetter.o);
	        this.textSpans[i].style.opacity = renderedLetter.o;
	        if(renderedLetter.sw){
	            this.textPaths[i].setAttribute('stroke-width',renderedLetter.sw);
	        }
	        if(renderedLetter.sc){
	            this.textPaths[i].setAttribute('stroke',renderedLetter.sc);
	        }
	        if(renderedLetter.fc){
	            this.textPaths[i].setAttribute('fill',renderedLetter.fc);
	            this.textPaths[i].style.color = renderedLetter.fc;
	        }
	    }
	    if(this.isVisible && (this.elemMdf || this.firstFrame)){
	        if(this.innerElem.getBBox){
	            var boundingBox = this.innerElem.getBBox();

	            if(this.currentBBox.w !== boundingBox.width){
	                this.currentBBox.w = boundingBox.width;
	                this.cont.setAttribute('width',boundingBox.width);
	            }
	            if(this.currentBBox.h !== boundingBox.height){
	                this.currentBBox.h = boundingBox.height;
	                this.cont.setAttribute('height',boundingBox.height);
	            }
	            if(this.currentBBox.w !== boundingBox.width || this.currentBBox.h !== boundingBox.height  || this.currentBBox.x !== boundingBox.x  || this.currentBBox.y !== boundingBox.y){
	                this.currentBBox.w = boundingBox.width;
	                this.currentBBox.h = boundingBox.height;
	                this.currentBBox.x = boundingBox.x;
	                this.currentBBox.y = boundingBox.y;

	                this.cont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	                this.cont.style.transform = this.cont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	            }
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	}


	HTextElement.prototype.destroy = SVGTextElement.prototype.destroy;
	function HImageElement(data,parentContainer,globalData,comp, placeholder){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(HBaseElement, HImageElement);

	HImageElement.prototype.createElements = function(){

	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	    var img = new Image();

	    if(this.data.hasMask){
	        var parent = document.createElement('div');
	        styleDiv(parent);
	        var cont = document.createElementNS(svgNS,'svg');
	        styleDiv(cont);
	        cont.setAttribute('width',this.assetData.w);
	        cont.setAttribute('height',this.assetData.h);
	        parent.appendChild(cont);
	        this.imageElem = document.createElementNS(svgNS,'image');
	        this.imageElem.setAttribute('width',this.assetData.w+"px");
	        this.imageElem.setAttribute('height',this.assetData.h+"px");
	        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	        cont.appendChild(this.imageElem);
	        this.layerElement = parent;
	        this.transformedElement = parent;
	        this.baseElement = parent;
	        this.innerElem = parent;
	        this.maskedElement = this.imageElem;
	    } else {
	        styleDiv(img);
	        this.layerElement = img;
	        this.baseElement = img;
	        this.innerElem = img;
	        this.transformedElement = img;
	    }
	    img.src = assetPath;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }
	    this.checkParenting();
	};

	HImageElement.prototype.hide = HSolidElement.prototype.hide;
	HImageElement.prototype.renderFrame = HSolidElement.prototype.renderFrame;
	HImageElement.prototype.destroy = HSolidElement.prototype.destroy;
	function HCameraElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.pe = PropertyFactory.getProp(this,data.pe,0,0,this.dynamicProperties);
	    if(data.ks.p.s){
	        this.px = PropertyFactory.getProp(this,data.ks.p.x,1,0,this.dynamicProperties);
	        this.py = PropertyFactory.getProp(this,data.ks.p.y,1,0,this.dynamicProperties);
	        this.pz = PropertyFactory.getProp(this,data.ks.p.z,1,0,this.dynamicProperties);
	    }else{
	        this.p = PropertyFactory.getProp(this,data.ks.p,1,0,this.dynamicProperties);
	    }
	    if(data.ks.a){
	        this.a = PropertyFactory.getProp(this,data.ks.a,1,0,this.dynamicProperties);
	    }
	    if(data.ks.or.k.length){
	        var i,len = data.ks.or.k.length;
	        for(i=0;i<len;i+=1){
	            data.ks.or.k[i].to = null;
	            data.ks.or.k[i].ti = null;
	        }
	    }
	    this.or = PropertyFactory.getProp(this,data.ks.or,1,degToRads,this.dynamicProperties);
	    this.or.sh = true;
	    this.rx = PropertyFactory.getProp(this,data.ks.rx,0,degToRads,this.dynamicProperties);
	    this.ry = PropertyFactory.getProp(this,data.ks.ry,0,degToRads,this.dynamicProperties);
	    this.rz = PropertyFactory.getProp(this,data.ks.rz,0,degToRads,this.dynamicProperties);
	    this.mat = new Matrix();
	}
	createElement(HBaseElement, HCameraElement);

	HCameraElement.prototype.setup = function() {
	    var i, len = this.comp.threeDElements.length, comp;
	    for(i=0;i<len;i+=1){
	        //[perspectiveElem,container]
	        comp = this.comp.threeDElements[i];
	        comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
	        comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = "0px 0px 0px";
	        comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    }
	};

	HCameraElement.prototype.createElements = function(){
	};

	HCameraElement.prototype.hide = function(){
	};

	HCameraElement.prototype.renderFrame = function(){
	    var mdf = this.firstFrame;
	    var i, len;
	    if(this.hierarchy){
	        len = this.hierarchy.length;
	        for(i=0;i<len;i+=1){
	            mdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : mdf;
	        }
	    }
	    if(mdf || (this.p && this.p.mdf) || (this.px && (this.px.mdf || this.py.mdf || this.pz.mdf)) || this.rx.mdf || this.ry.mdf || this.rz.mdf || this.or.mdf || (this.a && this.a.mdf)) {
	        this.mat.reset();

	        if(this.p){
	            this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);
	        }else{
	            this.mat.translate(-this.px.v,-this.py.v,this.pz.v);
	        }
	        if(this.a){
	            var diffVector = [this.p.v[0]-this.a.v[0],this.p.v[1]-this.a.v[1],this.p.v[2]-this.a.v[2]];
	            var mag = Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));
	            //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
	            var lookDir = [diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];
	            var lookLengthOnXZ = Math.sqrt( lookDir[2]*lookDir[2] + lookDir[0]*lookDir[0] );
	            var m_rotationX = (Math.atan2( lookDir[1], lookLengthOnXZ ));
	            var m_rotationY = (Math.atan2( lookDir[0], -lookDir[2]));
	            this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);

	        }
	        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
	        this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);
	        this.mat.translate(0,0,this.pe.v);
	        if(this.hierarchy){
	            var mat;
	            len = this.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                mat = this.hierarchy[i].finalTransform.mProp.iv.props;
	                this.mat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],-mat[12],-mat[13],mat[14],mat[15]);
	            }
	        }
	        len = this.comp.threeDElements.length;
	        var comp;
	        for(i=0;i<len;i+=1){
	            comp = this.comp.threeDElements[i];
	            comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();
	        }
	    }
	    this.firstFrame = false;
	};

	HCameraElement.prototype.destroy = function(){
	};
	var Expressions = (function(){
	    var ob = {};
	    ob.initExpressions = initExpressions;


	    function initExpressions(animation){
	        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
	        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
	    }
	   return ob;
	}());

	expressionsPlugin = Expressions;

	(function addPropertyDecorator() {

	    function getStaticValueAtTime() {
	        return this.pv;
	    }

	    function getValueAtTime(frameNum, offsetTime) {
	        frameNum *= this.elem.globalData.frameRate;
	        var i = 0,len = this.keyframes.length- 1,dir= 1,flag = true;
	        var keyData, nextKeyData;
	        offsetTime = offsetTime === undefined ? this.offsetTime : 0;
	        //console.log(this.offsetTime);
	        var retVal = typeof this.pv === 'object' ? [this.pv.length] : 0;

	        while(flag){
	            keyData = this.keyframes[i];
	            nextKeyData = this.keyframes[i+1];
	            if(i == len-1 && frameNum >= nextKeyData.t - offsetTime){
	                if(keyData.h){
	                    keyData = nextKeyData;
	                }
	                break;
	            }
	            if((nextKeyData.t - offsetTime) > frameNum){
	                break;
	            }
	            if(i < len - 1){
	                i += dir;
	            }else{
	                flag = false;
	            }
	        }

	        var k, kLen,perc,jLen, j = 0, fnc;
	        if (keyData.to) {

	            if (!keyData.bezierData) {
	                bez.buildBezierData(keyData);
	            }
	            var bezierData = keyData.bezierData;
	            if (frameNum >= nextKeyData.t-offsetTime || frameNum < keyData.t-offsetTime) {
	                var ind = frameNum >= nextKeyData.t-offsetTime ? bezierData.points.length - 1 : 0;
	                kLen = bezierData.points[ind].point.length;
	                for(k = 0; k < kLen; k += 1){
	                    retVal[k] = bezierData.points[ind].point[k];
	                }
	            } else {
	                if (keyData.__fnct) {
	                    fnc = keyData.__fnct;
	                } else {
	                    //fnc = bez.getEasingCurve(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y,keyData.n);
	                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
	                    keyData.__fnct = fnc;
	                }
	                perc = fnc((frameNum - (keyData.t - offsetTime)) / ((nextKeyData.t - offsetTime) - (keyData.t - offsetTime)));
	                var distanceInLine = bezierData.segmentLength * perc;

	                var segmentPerc;
	                var addedLength = 0;
	                dir = 1;
	                flag = true;
	                jLen = bezierData.points.length;
	                while(flag) {
	                    addedLength += bezierData.points[j].partialLength*dir;
	                    if (distanceInLine === 0 || perc === 0 || j == bezierData.points.length - 1) {
	                        kLen = bezierData.points[j].point.length;
	                        for (k = 0; k < kLen; k += 1) {
	                            retVal[k] = bezierData.points[j].point[k];
	                        }
	                        break;
	                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j+1].partialLength){
	                        segmentPerc = (distanceInLine - addedLength) / (bezierData.points[j + 1].partialLength);
	                        kLen = bezierData.points[j].point.length;
	                        for (k = 0; k < kLen; k += 1) {
	                            retVal[k] = bezierData.points[j].point[k] + (bezierData.points[j+1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
	                        }
	                        break;
	                    }
	                    if (j < jLen - 1 && dir == 1 || j > 0 && dir == -1) {
	                        j += dir;
	                    } else {
	                        flag = false;
	                    }
	                }
	            }
	        } else {
	            var outX,outY,inX,inY, isArray = false, keyValue;
	            len = keyData.s.length;
	            for(i=0;i<len;i+=1){
	                if(keyData.h !== 1){
	                    if(keyData.o.x instanceof Array){
	                        isArray = true;
	                        if(!keyData.__fnct){
	                            keyData.__fnct = [];
	                        }
	                        if(!keyData.__fnct[i]){
	                            outX = keyData.o.x[i] || keyData.o.x[0];
	                            outY = keyData.o.y[i] || keyData.o.y[0];
	                            inX = keyData.i.x[i] || keyData.i.x[0];
	                            inY = keyData.i.y[i] || keyData.i.y[0];
	                        }
	                    }else{
	                        isArray = false;
	                        if(!keyData.__fnct) {
	                            outX = keyData.o.x;
	                            outY = keyData.o.y;
	                            inX = keyData.i.x;
	                            inY = keyData.i.y;
	                        }
	                    }
	                    if(isArray){
	                        if(keyData.__fnct[i]){
	                            fnc = keyData.__fnct[i];
	                        }else{
	                            //fnc = bez.getEasingCurve(outX,outY,inX,inY);
	                            fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                            keyData.__fnct[i] = fnc;
	                        }
	                    }else{
	                        if(keyData.__fnct){
	                            fnc = keyData.__fnct;
	                        }else{
	                            //fnc = bez.getEasingCurve(outX,outY,inX,inY);
	                            fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                            keyData.__fnct = fnc;
	                        }
	                    }
	                    if(frameNum >= nextKeyData.t-offsetTime){
	                        perc = 1;
	                    }else if(frameNum < keyData.t-offsetTime){
	                        perc = 0;
	                    }else{
	                        perc = fnc((frameNum-(keyData.t-offsetTime))/((nextKeyData.t-offsetTime)-(keyData.t-offsetTime)));
	                    }
	                }
	                if(this.sh && keyData.h !== 1){
	                    var initP = keyData.s[i];
	                    var endP = keyData.e[i];
	                    if(initP-endP < -180){
	                        initP += 360;
	                    } else if(initP-endP > 180){
	                        initP -= 360;
	                    }
	                    keyValue = initP+(endP-initP)*perc;
	                } else {
	                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i]+(keyData.e[i]-keyData.s[i])*perc;
	                }
	                if(len === 1){
	                    retVal = keyValue;
	                }else{
	                    retVal[i] = keyValue;
	                }
	            }
	        }
	        return retVal;
	    }

	    function getVelocityAtTime(frameNum) {
	        if(this.vel !== undefined){
	            return this.vel;
	        }
	        var delta = -0.01;
	        //frameNum += this.elem.data.st;
	        var v1 = this.getValueAtTime(frameNum, 0);
	        var v2 = this.getValueAtTime(frameNum + delta, 0);
	        var velocity;
	        if(v1.length){
	            velocity = Array.apply(null,{length:v1.length});
	            var i;
	            for(i=0;i<v1.length;i+=1){
	                velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
	            }
	        } else {
	            velocity = (v2 - v1)/delta;
	        }
	        return velocity;
	    };

	    function setGroupProperty(propertyGroup){
	        this.propertyGroup = propertyGroup;
	    }

	    function searchExpressions(elem,data,prop){
	        if(data.x){
	            prop.k = true;
	            prop.x = true;
	            if(prop.getValue) {
	                prop.getPreValue = prop.getValue;
	            }
	            prop.getValue = ExpressionManager.initiateExpression.bind(prop)(elem,data,prop);
	        }
	    }

	    var TextExpressionSelectorProp = (function(){

	        function getValueProxy(index,total){
	            this.textIndex = index+1;
	            this.textTotal = total;
	            this.getValue();
	            return this.v;
	        }

	        return function TextExpressionSelectorProp(elem,data){
	            this.pv = 1;
	            this.comp = elem.comp;
	            this.elem = elem;
	            this.mult = .01;
	            this.type = 'textSelector';
	            this.textTotal = data.totalChars;
	            this.selectorValue = 100;
	            this.lastValue = [1,1,1];
	            searchExpressions.bind(this)(elem,data,this);
	            this.getMult = getValueProxy;
	            this.getVelocityAtTime = getVelocityAtTime;
	            if(this.kf){
	                this.getValueAtTime = getValueAtTime.bind(this);
	            } else {
	                this.getValueAtTime = getStaticValueAtTime.bind(this);
	            }
	            this.setGroupProperty = setGroupProperty;
	        }
	    }());


	    var propertyGetProp = PropertyFactory.getProp;
	    PropertyFactory.getProp = function(elem,data,type, mult, arr){
	        var prop = propertyGetProp(elem,data,type, mult, arr);
	        prop.getVelocityAtTime = getVelocityAtTime;
	        if(prop.kf){
	            prop.getValueAtTime = getValueAtTime.bind(prop);
	        } else {
	            prop.getValueAtTime = getStaticValueAtTime.bind(prop);
	        }
	        prop.setGroupProperty = setGroupProperty;
	        var isAdded = prop.k;
	        if(data.ix !== undefined){
	            Object.defineProperty(prop,'propertyIndex',{
	                get: function(){
	                    return data.ix;
	                }
	            })
	        }
	        searchExpressions(elem,data,prop);
	        if(!isAdded && prop.x){
	            arr.push(prop);
	        }

	        return prop;
	    }

	    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
	    ShapePropertyFactory.getShapeProp = function(elem,data,type, arr, trims){
	        var prop = propertyGetShapeProp(elem,data,type, arr, trims);
	        prop.setGroupProperty = setGroupProperty;
	        if(prop.kf){
	            prop.getValueAtTime = getValueAtTime;
	        } else {
	            prop.getValueAtTime = getStaticValueAtTime;
	        }
	        var isAdded = prop.k;
	        if(data.ix !== undefined){
	            Object.defineProperty(prop,'propertyIndex',{
	                get: function(){
	                    return data.ix;
	                }
	            })
	        }
	        if(type === 3){
	            searchExpressions(elem,data.pt,prop);
	        } else if(type === 4){
	            searchExpressions(elem,data.ks,prop);
	        }
	        if(!isAdded && prop.x){
	            arr.push(prop);
	        }
	        return prop;
	    }

	    var propertyGetTextProp = PropertyFactory.getTextSelectorProp;
	    PropertyFactory.getTextSelectorProp = function(elem, data,arr){
	        if(data.t === 1){
	            return new TextExpressionSelectorProp(elem, data,arr);
	        } else {
	            return propertyGetTextProp(elem,data,arr);
	        }
	    }
	}());
	var ExpressionManager = (function(){
	    var ob = {};
	    var Math = BMMath;

	    function duplicatePropertyValue(value, mult){
	        mult = mult || 1;

	        if(typeof value === 'number'  || value instanceof Number){
	            return value*mult;
	        }else if(value.i){
	            return JSON.parse(JSON.stringify(value));
	        }else{
	            var arr = Array.apply(null,{length:value.length});
	            var i, len = value.length;
	            for(i=0;i<len;i+=1){
	                arr[i]=value[i]*mult;
	            }
	            return arr;
	        }
	    }

	    function shapesEqual(shape1, shape2) {
	        if(shape1._length !== shape2._length || shape1.c !== shape2.c){
	            return false;
	        }
	        var i, len = shape1._length;
	        for(i = 0; i < len; i += 1) {
	            if(shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1]
	                || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1]
	                || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]){
	                return false;
	            }
	        }
	        return true;
	    }

	    function $bm_neg(a){
	        var tOfA = typeof a;
	        if(tOfA === 'number' || tOfA === 'boolean'  || a instanceof Number ){
	            return -a;
	        }
	        if(a.constructor === Array){
	            var i, lenA = a.length;
	            var retArr = [];
	            for(i=0;i<lenA;i+=1){
	                retArr[i] = -a[i];
	            }
	            return retArr;
	        }
	    }

	    function sum(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if(tOfA === 'string' || tOfB === 'string'){
	            return a + b;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string'  || b instanceof Number)) {
	            return a + b;
	        }
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            a[0] = a[0] + b;
	            return a;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b .constructor === Array){
	            b[0] = a + b[0];
	            return b;
	        }
	        if(a.constructor === Array && b.constructor === Array){
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if(typeof a[i] === 'number' && typeof b[i] === 'number'){
	                    retArr[i] = a[i] + b[i];
	                }else{
	                    retArr[i] = b[i] == undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }
	    var add = sum;

	    function sub(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            return a - b;
	        }
	        if( a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            a[0] = a[0] - b;
	            return a;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) &&  b.constructor === Array){
	            b[0] = a - b[0];
	            return b;
	        }
	        if(a.constructor === Array && b.constructor === Array){
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if(typeof a[i] === 'number' && typeof b[i] === 'number'){
	                    retArr[i] = a[i] - b[i];
	                }else{
	                    retArr[i] = b[i] == undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }

	    function mul(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            return a * b;
	        }

	        var i, len;
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            len = a.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] * b;
	            }
	            return arr;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b.constructor === Array){
	            len = b.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a * b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }

	    function div(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            return a / b;
	        }
	        var i, len;
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number  )){
	            len = a.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] / b;
	            }
	            return arr;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b.constructor === Array){
	            len = b.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a / b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }

	    function clamp(num, min, max) {
	        if(min > max){
	            var mm = max;
	            max = min;
	            min = mm;
	        }
	        return Math.min(Math.max(num, min), max);
	    }

	    function radiansToDegrees(val) {
	        return val/degToRads;
	    }
	    var radians_to_degrees = radiansToDegrees;

	    function degreesToRadians(val) {
	        return val*degToRads;
	    }
	    var degrees_to_radians = radiansToDegrees;

	    var helperLengthArray = [0,0,0,0,0,0];

	    function length(arr1,arr2){
	        if(typeof arr1 === "number"){
	            arr2 = arr2 || 0;
	            return Math.abs(arr1 - arr2);
	        }
	        if(!arr2){
	            arr2 = helperLengthArray;
	        }
	        var i,len = Math.min(arr1.length,arr2.length);
	        var addedLength = 0;
	        for(i=0;i<len;i+=1){
	            addedLength += Math.pow(arr2[i]-arr1[i],2);
	        }
	        return Math.sqrt(addedLength);
	    }

	    function normalize(vec){
	        return div(vec, length(vec));
	    }

	    function rgbToHsl(val){
	        var r = val[0]; var g = val[1]; var b = val[2];
	        var max = Math.max(r, g, b), min = Math.min(r, g, b);
	        var h, s, l = (max + min) / 2;

	        if(max == min){
	            h = s = 0; // achromatic
	        }else{
	            var d = max - min;
	            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	            switch(max){
	                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	                case g: h = (b - r) / d + 2; break;
	                case b: h = (r - g) / d + 4; break;
	            }
	            h /= 6;
	        }

	        return [h, s, l,val[3]];
	    }
	    function hslToRgb(val){
	        var h = val[0];
	        var s = val[1];
	        var l = val[2];

	        var r, g, b;

	        if(s == 0){
	            r = g = b = l; // achromatic
	        }else{
	            function hue2rgb(p, q, t){
	                if(t < 0) t += 1;
	                if(t > 1) t -= 1;
	                if(t < 1/6) return p + (q - p) * 6 * t;
	                if(t < 1/2) return q;
	                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	                return p;
	            }

	            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	            var p = 2 * l - q;
	            r = hue2rgb(p, q, h + 1/3);
	            g = hue2rgb(p, q, h);
	            b = hue2rgb(p, q, h - 1/3);
	        }

	        return [r, g , b, val[3]];
	    }

	    function linear(t, tMin, tMax, value1, value2){
	        if(value1 === undefined || value2 === undefined){
	            return linear(t,0,1,tMin,tMax);
	        }
	        if(t <= tMin) {
	            return value1;
	        }else if(t >= tMax){
	            return value2;
	        }
	        var perc = tMax === tMin ? 0 : (t-tMin)/(tMax-tMin);
	        if(!value1.length){
	            return value1 + (value2-value1)*perc;
	        }
	        var i, len = value1.length;
	        var arr = Array.apply( null, { length: len } );
	        for(i=0;i<len;i+=1){
	            arr[i] = value1[i] + (value2[i]-value1[i])*perc;
	        }
	        return arr;
	    }
	    function random(min,max){
	        if(max === undefined){
	            if(min === undefined){
	                min = 0;
	                max = 1;
	            } else {
	                max = min;
	                min = undefined;
	            }
	        }
	        if(max.length){
	            var i, len = max.length;
	            if(!min){
	                min = Array.apply(null,{length:len});
	            }
	            var arr = Array.apply(null,{length:len});
	            var rnd = BMMath.random();
	            for(i=0;i<len;i+=1){
	                arr[i] = min[i] + rnd*(max[i]-min[i])
	            }
	            return arr;
	        }
	        if(min === undefined){
	            min = 0;
	        }
	        var rndm = BMMath.random();
	        return min + rndm*(max-min);
	    }

	    function initiateExpression(elem,data,property){
	        var val = data.x;
	        var needsVelocity = val.indexOf('velocity') !== -1;
	        var _needsRandom = val.indexOf('random') !== -1;
	        var elemType = elem.data.ty;
	        var transform,content,effect;
	        var thisComp = elem.comp;
	        var thisProperty = property;
	        elem.comp.frameDuration = 1/elem.comp.globalData.frameRate;
	        var inPoint = elem.data.ip/elem.comp.globalData.frameRate;
	        var outPoint = elem.data.op/elem.comp.globalData.frameRate;
	        var thisLayer,thisComp;
	        var fn = new Function();
	        //var fnStr = 'var fn = function(){'+val+';this.v = $bm_rt;}';
	        //eval(fnStr);
	        var fn = eval('[function(){' + val+';this.v = $bm_rt;}' + ']')[0];
	        var bindedFn = fn.bind(this);
	        var numKeys = property.kf ? data.k.length : 0;

	        var wiggle = function wiggle(freq,amp){
	            var i,j, len = this.pv.length ? this.pv.length : 1;
	            var addedAmps = Array.apply(null,{len:len});
	            for(j=0;j<len;j+=1){
	                addedAmps[j] = 0;
	            }
	            freq = 5;
	            var iterations = Math.floor(time*freq);
	            i = 0;
	            j = 0;
	            while(i<iterations){
	                //var rnd = BMMath.random();
	                for(j=0;j<len;j+=1){
	                    addedAmps[j] += -amp + amp*2*BMMath.random();
	                    //addedAmps[j] += -amp + amp*2*rnd;
	                }
	                i += 1;
	            }
	            //var rnd2 = BMMath.random();
	            var periods = time*freq;
	            var perc = periods - Math.floor(periods);
	            var arr = Array.apply({length:len});
	            for(j=0;j<len;j+=1){
	                arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*BMMath.random())*perc;
	                //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
	                //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
	            }
	            return arr;
	        }.bind(this);

	        var loopIn = function loopIn(type,duration, durationFlag) {
	            if(!this.k){
	                return this.pv;
	            }
	            var currentFrame = time*elem.comp.globalData.frameRate;
	            var keyframes = this.keyframes;
	            var firstKeyFrame = keyframes[0].t;
	            if(currentFrame>=firstKeyFrame){
	                return this.pv;
	            }else{
	                var cycleDuration, lastKeyFrame;
	                if(!durationFlag){
	                    if(!duration || duration > keyframes.length - 1){
	                        duration = keyframes.length - 1;
	                    }
	                    lastKeyFrame = keyframes[duration].t;
	                    cycleDuration = lastKeyFrame - firstKeyFrame;
	                } else {
	                    if(!duration){
	                        cycleDuration = Math.max(0,this.elem.data.op - firstKeyFrame);
	                    } else {
	                        cycleDuration = Math.abs(elem.comp.globalData.frameRate*duration);
	                    }
	                    lastKeyFrame = firstKeyFrame + cycleDuration;
	                }
	                var i, len, ret;
	                if(type === 'pingpong') {
	                    var iterations = Math.floor((firstKeyFrame - currentFrame)/cycleDuration);
	                    if(iterations % 2 === 0){
	                        return this.getValueAtTime(((firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                    }
	                } else if(type === 'offset'){
	                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                    var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                    var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                    var repeats = Math.floor((firstKeyFrame - currentFrame)/cycleDuration)+1;
	                    if(this.pv.length){
	                        ret = new Array(initV.length);
	                        len = ret.length;
	                        for(i=0;i<len;i+=1){
	                            ret[i] = current[i]-(endV[i]-initV[i])*repeats;
	                        }
	                        return ret;
	                    }
	                    return current-(endV-initV)*repeats;
	                } else if(type === 'continue'){
	                    var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                    var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
	                    if(this.pv.length){
	                        ret = new Array(firstValue.length);
	                        len = ret.length;
	                        for(i=0;i<len;i+=1){
	                            ret[i] = firstValue[i] + (firstValue[i]-nextFirstValue[i])*(firstKeyFrame - currentFrame)/0.001;
	                        }
	                        return ret;
	                    }
	                    return firstValue + (firstValue-nextFirstValue)*(firstKeyFrame - currentFrame)/0.001;
	                }
	                return this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	            }
	        }.bind(this);

	        var loopInDuration = function loopInDuration(type,duration){
	            return loopIn(type,duration,true);
	        }.bind(this);

	        var loopOut = function loopOut(type,duration,durationFlag){
	            if(!this.k || !this.keyframes){
	                return this.pv;
	            }
	            var currentFrame = time*elem.comp.globalData.frameRate;
	            var keyframes = this.keyframes;
	            var lastKeyFrame = keyframes[keyframes.length - 1].t;
	            if(currentFrame<=lastKeyFrame){
	                return this.pv;
	            }else{
	                var cycleDuration, firstKeyFrame;
	                if(!durationFlag){
	                    if(!duration || duration > keyframes.length - 1){
	                        duration = keyframes.length - 1;
	                    }
	                    firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
	                    cycleDuration = lastKeyFrame - firstKeyFrame;
	                } else {
	                    if(!duration){
	                        cycleDuration = Math.max(0,lastKeyFrame - this.elem.data.ip);
	                    } else {
	                        cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate*duration);
	                    }
	                    firstKeyFrame = lastKeyFrame - cycleDuration;
	                }
	                var i, len, ret;
	                if(type === 'pingpong') {
	                    var iterations = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                    if(iterations % 2 !== 0){
	                        return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                    }
	                } else if(type === 'offset'){
	                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                    var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                    var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                    var repeats = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                    if(this.pv.length){
	                        ret = new Array(initV.length);
	                        len = ret.length;
	                        for(i=0;i<len;i+=1){
	                            ret[i] = (endV[i]-initV[i])*repeats + current[i];
	                        }
	                        return ret;
	                    }
	                    return (endV-initV)*repeats + current;
	                } else if(type === 'continue'){
	                    var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                    var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
	                    if(this.pv.length){
	                        ret = new Array(lastValue.length);
	                        len = ret.length;
	                        for(i=0;i<len;i+=1){
	                            ret[i] = lastValue[i] + (lastValue[i]-nextLastValue[i])*((currentFrame - lastKeyFrame)/ this.comp.globalData.frameRate)/0.0005;
	                        }
	                        return ret;
	                    }
	                    return lastValue + (lastValue-nextLastValue)*(((currentFrame - lastKeyFrame))/0.001);
	                }
	                return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	            }
	        }.bind(this);
	        var loop_out = loopOut;

	        var loopOutDuration = function loopOutDuration(type,duration){
	            return loopOut(type,duration,true);
	        }.bind(this);

	        var valueAtTime = function valueAtTime(t) {
	            return this.getValueAtTime(t, 0);
	        }.bind(this);

	        var velocityAtTime = function velocityAtTime(t) {
	            return this.getVelocityAtTime(t);
	        }.bind(this);

	        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

	        function lookAt(elem1,elem2){
	            var fVec = [elem2[0]-elem1[0],elem2[1]-elem1[1],elem2[2]-elem1[2]];
	            var pitch = Math.atan2(fVec[0],Math.sqrt(fVec[1]*fVec[1]+fVec[2]*fVec[2]))/degToRads;
	            var yaw = -Math.atan2(fVec[1],fVec[2])/degToRads;
	            return [yaw,pitch,0];
	        }

	        function easeOut(t, val1, val2){
	            return -(val2-val1) * t*(t-2) + val1;
	        }

	        function nearestKey(time){
	            var i, len = data.k.length,index,keyTime;
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                index = 0;
	                keyTime = 0;
	            } else {
	                index = -1;
	                time *= elem.comp.globalData.frameRate;
	                for(i=0;i<len-1;i+=1){
	                    if(time === data.k[i].t){
	                        index = i + 1;
	                        keyTime = data.k[i].t;
	                        break;
	                    }else if(time>data.k[i].t && time<data.k[i+1].t){
	                        if(time-data.k[i].t > data.k[i+1].t - time){
	                            index = i + 2;
	                            keyTime = data.k[i+1].t;
	                        } else {
	                            index = i + 1;
	                            keyTime = data.k[i].t;
	                        }
	                        break;
	                    }
	                }
	                if(index === -1){
	                    index = i + 1;
	                    keyTime = data.k[i].t;
	                }
	            }
	            var ob = {};
	            ob.index = index;
	            ob.time = keyTime/elem.comp.globalData.frameRate;
	            return ob;
	        }

	        function key(ind){
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                return {time:0};
	            }
	            ind -= 1;
	            var ob = {
	                time: data.k[ind].t/elem.comp.globalData.frameRate
	            };
	            var arr;
	            if(ind === data.k.length - 1 && !data.k[ind].h){
	                arr = data.k[ind-1].e;
	            }else{
	                arr = data.k[ind].s;
	            }
	            var i, len = arr.length;
	            for(i=0;i<len;i+=1){
	                ob[i] = arr[i];
	            }
	            return ob;
	        }

	        function framesToTime(frames,fps){
	            if(!fps){
	                fps = elem.comp.globalData.frameRate;
	            }
	            return frames/fps;
	        }

	        function timeToFrames(t,fps){
	            if(!t){
	                t = time;
	            }
	            if(!fps){
	                fps = elem.comp.globalData.frameRate;
	            }
	            return t*fps;
	        }

	        var toworldMatrix = new Matrix();
	        function toWorld(arr){
	            toworldMatrix.reset();
	            elem.finalTransform.mProp.applyToMatrix(toworldMatrix);
	            if(elem.hierarchy && elem.hierarchy.length){
	                var i, len = elem.hierarchy.length;
	                for(i=0;i<len;i+=1){
	                    elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toworldMatrix);
	                }
	                return toworldMatrix.applyToPointArray(arr[0],arr[1],arr[2]||0);
	            }
	            return toworldMatrix.applyToPointArray(arr[0],arr[1],arr[2]||0);
	        }

	        var fromworldMatrix = new Matrix();
	        function fromWorld(arr){
	            fromworldMatrix.reset();
	            var pts = [];
	            pts.push(arr);
	            elem.finalTransform.mProp.applyToMatrix(fromworldMatrix);
	            if(elem.hierarchy && elem.hierarchy.length){
	                var i, len = elem.hierarchy.length;
	                for(i=0;i<len;i+=1){
	                    elem.hierarchy[i].finalTransform.mProp.applyToMatrix(fromworldMatrix);
	                }
	                return fromworldMatrix.inversePoints(pts)[0];
	            }
	            return fromworldMatrix.inversePoints(pts)[0];
	        }

	        function seedRandom(seed){
	            BMMath.seedrandom(randSeed + seed);
	        };

	        var time,velocity, value,textIndex,textTotal,selectorValue;
	        var index = elem.data.ind;
	        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	        var parent;
	        var randSeed = Math.floor(Math.random()*1000000);
	        function execute(){
	            if(_needsRandom){
	                seedRandom(randSeed);
	            }
	            if(this.frameExpressionId === elem.globalData.frameId && this.type !== 'textSelector'){
	                return;
	            }
	            if(this.lock){
	                this.v = duplicatePropertyValue(this.pv,this.mult);
	                return true;
	            }
	            if(this.type === 'textSelector'){
	                textIndex = this.textIndex;
	                textTotal = this.textTotal;
	                selectorValue = this.selectorValue;
	            }
	            if(!thisLayer){
	                thisLayer = elem.layerInterface;
	                thisComp = elem.comp.compInterface;
	            }
	            if(!transform){
	                transform = elem.layerInterface("ADBE Transform Group");
	            }
	            if(elemType === 4 && !content){
	                content = thisLayer("ADBE Root Vectors Group");
	            }
	            if(!effect){
	                effect = thisLayer(4);
	            }
	            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	            if(hasParent && !parent){
	                parent = elem.hierarchy[elem.hierarchy.length - 1].layerInterface;
	            }
	            this.lock = true;
	            if(this.getPreValue){
	                this.getPreValue();
	            }
	            value = this.pv;
	            time = this.comp.renderedFrame/this.comp.globalData.frameRate;
	            if(needsVelocity){
	                velocity = velocityAtTime(time);
	            }
	            bindedFn();
	            this.frameExpressionId = elem.globalData.frameId;
	            var i,len;
	            if(this.mult){
	                if(typeof this.v === 'number' || this.v instanceof Number || typeof this.v === 'string'){
	                    this.v *= this.mult;
	                }else if(this.v.length === 1){
	                    this.v = this.v[0] * this.mult;
	                }else{
	                    len = this.v.length;
	                    if(value === this.v){
	                        this.v = len === 2 ? [value[0],value[1]] : [value[0],value[1],value[2]];
	                    }
	                    for(i = 0; i < len; i += 1){
	                        this.v[i] *= this.mult;
	                    }
	                }
	            }

	            if(this.v.length === 1){
	                this.v = this.v[0];
	            }
	            if(typeof this.v === 'number' || this.v instanceof Number || typeof this.v === 'string'){
	                if(this.lastValue !== this.v){
	                    this.lastValue = this.v;
	                    this.mdf = true;
	                }
	            }else if(this.v._length){
	                if(!shapesEqual(this.v,this.localShapeCollection.shapes[0])){
	                    this.mdf = true;
	                    this.localShapeCollection.releaseShapes();
	                    this.localShapeCollection.addShape(shape_pool.clone(this.v));
	                }
	            }else{
	                len = this.v.length;
	                for(i = 0; i < len; i += 1){
	                    if(this.v[i] !== this.lastValue[i]){
	                        this.lastValue[i] = this.v[i];
	                        this.mdf = true;
	                    }
	                }
	            }
	            this.lock = false;
	        }
	        return execute;
	    }

	    ob.initiateExpression = initiateExpression;
	    return ob;
	}());
	var ShapeExpressionInterface = (function(){
	    var ob = {
	        createShapeInterface:createShapeInterface,
	        createGroupInterface:createGroupInterface,
	        createTrimInterface:createTrimInterface,
	        createStrokeInterface:createStrokeInterface,
	        createTransformInterface:createTransformInterface,
	        createEllipseInterface:createEllipseInterface,
	        createStarInterface:createStarInterface,
	        createRectInterface:createRectInterface,
	        createRoundedInterface:createRoundedInterface,
	        createRepatearInterface:createRepatearInterface,
	        createPathInterface:createPathInterface,
	        createFillInterface:createFillInterface
	    };
	    function createShapeInterface(shapes,view,propertyGroup){
	        return shapeInterfaceFactory(shapes,view,propertyGroup);
	    }
	    function createGroupInterface(shapes,view,propertyGroup){
	        return groupInterfaceFactory(shapes,view,propertyGroup);
	    }
	    function createFillInterface(shape,view,propertyGroup){
	        return fillInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createStrokeInterface(shape,view,propertyGroup){
	        return strokeInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createTrimInterface(shape,view,propertyGroup){
	        return trimInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createTransformInterface(shape,view,propertyGroup){
	        return transformInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createEllipseInterface(shape,view,propertyGroup){
	        return ellipseInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createStarInterface(shape,view,propertyGroup){
	        return starInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRectInterface(shape,view,propertyGroup){
	        return rectInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRoundedInterface(shape,view,propertyGroup){
	        return roundedInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRepatearInterface(shape,view,propertyGroup){
	        return repeaterInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createPathInterface(shape,view,propertyGroup){
	        return pathInterfaceFactory(shape,view,propertyGroup);
	    }

	    function iterateElements(shapes,view, propertyGroup){
	        var arr = [];
	        var i, len = shapes ? shapes.length : 0;
	        for(i=0;i<len;i+=1){
	            if(shapes[i].ty == 'gr'){
	                arr.push(ShapeExpressionInterface.createGroupInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'fl'){
	                arr.push(ShapeExpressionInterface.createFillInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'st'){
	                arr.push(ShapeExpressionInterface.createStrokeInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tm'){
	                arr.push(ShapeExpressionInterface.createTrimInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tr'){
	                //arr.push(ShapeExpressionInterface.createTransformInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'el'){
	                arr.push(ShapeExpressionInterface.createEllipseInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'sr'){
	                arr.push(ShapeExpressionInterface.createStarInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'sh'){
	                arr.push(ShapeExpressionInterface.createPathInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rc'){
	                arr.push(ShapeExpressionInterface.createRectInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rd'){
	                arr.push(ShapeExpressionInterface.createRoundedInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rp'){
	                arr.push(ShapeExpressionInterface.createRepatearInterface(shapes[i],view[i],propertyGroup));
	            } else{
	                //console.log(shapes[i].ty);
	            }
	        }
	        return arr;
	    }

	    var shapeInterfaceFactory = (function(){
	        return function(shapes,view,propertyGroup){
	            var interfaces;
	            function _interfaceFunction(value){
	                if(typeof value === 'number'){
	                    return interfaces[value-1];
	                } else {
	                    var i = 0, len = interfaces.length;
	                    while(i<len){
	                        if(interfaces[i]._name === value){
	                            return interfaces[i];
	                        }
	                        i+=1;
	                    }
	                }
	            }
	            _interfaceFunction.propertyGroup = propertyGroup;
	            interfaces = iterateElements(shapes, view, _interfaceFunction);
	            return _interfaceFunction;
	        }
	    }());

	    var contentsInterfaceFactory = (function(){
	       return function(shape,view, propertyGroup){
	           var interfaces;
	           var interfaceFunction = function _interfaceFunction(value){
	               var i = 0, len = interfaces.length;
	                while(i<len){
	                    if(interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value){
	                       return interfaces[i];
	                    }
	                    i+=1;
	                }
	                if(typeof value === 'number'){
	                   return interfaces[value-1];
	                }
	           };
	           interfaceFunction.propertyGroup = function(val){
	               if(val === 1){
	                   return interfaceFunction;
	               } else{
	                   return propertyGroup(val-1);
	               }
	           };
	           interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
	           interfaceFunction.numProperties = interfaces.length;
	           interfaceFunction.propertyIndex = shape.cix;

	           return interfaceFunction;
	       }
	    }());

	    var groupInterfaceFactory = (function(){
	        return function(shape,view, propertyGroup){
	            var interfaceFunction = function _interfaceFunction(value){
	                switch(value){
	                    case 'ADBE Vectors Group':
	                    case 'Contents':
	                    case 2:
	                        return interfaceFunction.content;
	                    case 'ADBE Vector Transform Group':
	                    case 3:
	                    default:
	                        return interfaceFunction.transform;
	                }
	                /*if(value === 'ADBE Vector Transform Group'){
	                    return interfaceFunction.transform;
	                    var i = 0, len = interfaces.length;
	                    while(i<len){
	                        if(interfaces[i].ty === 'tr'){
	                            return interfaces[i];
	                        }
	                        i+=1;
	                    }
	                    return null;
	                }
	                if(typeof value === 'number'){
	                    return interfaces[value-1];
	                } else {
	                    var i = 0, len = interfaces.length;
	                    while(i<len){
	                        if(interfaces[i]._name === value){
	                            return interfaces[i];
	                        }
	                        i+=1;
	                    }
	                }*/
	            }
	            interfaceFunction.propertyGroup = function(val){
	                if(val === 1){
	                    return interfaceFunction;
	                } else{
	                    return propertyGroup(val-1);
	                }
	            };
	            var content = contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);
	            var transformInterface = ShapeExpressionInterface.createTransformInterface(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);
	            interfaceFunction.content = content;
	            interfaceFunction.transform = transformInterface;
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            //interfaceFunction.content = interfaceFunction;
	            interfaceFunction.numProperties = shape.np;
	            interfaceFunction.propertyIndex = shape.ix;
	            interfaceFunction.nm = shape.nm;
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var fillInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){

	            function interfaceFunction(val){
	                if(val === 'Color' || val === 'color'){
	                    return interfaceFunction.color;
	                } else if(val === 'Opacity' || val === 'opacity'){
	                    return interfaceFunction.opacity;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'color', {
	                get: function(){
	                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.o, 100);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });

	            view.c.setGroupProperty(propertyGroup);
	            view.o.setGroupProperty(propertyGroup);
	            return interfaceFunction;
	        }
	    }());

	    var strokeInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val === 1){
	                    return ob;
	                } else{
	                    return propertyGroup(val-1);
	                }
	            };
	            function _dashPropertyGroup(val){
	                if(val === 1){
	                    return dashOb;
	                } else{
	                    return _propertyGroup(val-1);
	                }
	            };
	            function addPropertyToDashOb(i) {
	                Object.defineProperty(dashOb, shape.d[i].nm, {
	                    get: function(){
	                        return ExpressionValue(view.d.dataProps[i].p)
	                    }
	                });
	            }
	            var i, len = shape.d ? shape.d.length : 0;
	            var dashOb = {}
	            for (i = 0; i < len; i += 1) {
	                addPropertyToDashOb(i);
	                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
	            }

	            function interfaceFunction(val){
	                if(val === 'Color' || val === 'color'){
	                    return interfaceFunction.color;
	                } else if(val === 'Opacity' || val === 'opacity'){
	                    return interfaceFunction.opacity;
	                } else if(val === 'Stroke Width' || val === 'stroke width'){
	                    return interfaceFunction.strokeWidth;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'color', {
	                get: function(){
	                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.o, 100);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'strokeWidth', {
	                get: function(){
	                    return ExpressionValue(view.w);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'dash', {
	                get: function(){
	                    return dashOb;
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });

	            view.c.setGroupProperty(_propertyGroup);
	            view.o.setGroupProperty(_propertyGroup);
	            view.w.setGroupProperty(_propertyGroup);
	            return interfaceFunction;
	        }
	    }());

	    var trimInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;

	            view.s.setGroupProperty(_propertyGroup);
	            view.e.setGroupProperty(_propertyGroup);
	            view.o.setGroupProperty(_propertyGroup);

	            function interfaceFunction(val){
	                if(val === shape.e.ix || val === 'End' || val === 'end'){
	                    return interfaceFunction.end;
	                }
	                if(val === shape.s.ix){
	                    return interfaceFunction.start;
	                }
	                if(val === shape.o.ix){
	                    return interfaceFunction.offset;
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;
	            Object.defineProperty(interfaceFunction, 'start', {
	                get: function(){
	                    return ExpressionValue(view.s, 1 / view.s.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'end', {
	                get: function(){
	                    return ExpressionValue(view.e, 1 / view.e.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'offset', {
	                get: function(){
	                    return ExpressionValue(view.o);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var transformInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            view.transform.mProps.o.setGroupProperty(_propertyGroup);
	            view.transform.mProps.p.setGroupProperty(_propertyGroup);
	            view.transform.mProps.a.setGroupProperty(_propertyGroup);
	            view.transform.mProps.s.setGroupProperty(_propertyGroup);
	            view.transform.mProps.r.setGroupProperty(_propertyGroup);
	            if(view.transform.mProps.sk){
	                view.transform.mProps.sk.setGroupProperty(_propertyGroup);
	                view.transform.mProps.sa.setGroupProperty(_propertyGroup);
	            }
	            view.transform.op.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.a.ix === value){
	                    return interfaceFunction.anchorPoint;
	                }
	                if(shape.o.ix === value){
	                    return interfaceFunction.opacity;
	                }
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.rotation;
	                }
	                if(shape.s.ix === value){
	                    return interfaceFunction.scale;
	                }
	                if(shape.sk && shape.sk.ix === value){
	                    return interfaceFunction.skew;
	                }
	                if(shape.sa && shape.sa.ix === value){
	                    return interfaceFunction.skewAxis;
	                }
	                if(value === 'Opacity') {
	                    return interfaceFunction.opacity;
	                }
	                if(value === 'Position') {
	                    return interfaceFunction.position;
	                }
	                if(value === 'Anchor Point') {
	                    return interfaceFunction.anchorPoint;
	                }
	                if(value === 'Scale') {
	                    return interfaceFunction.scale;
	                }
	                if(value === 'Rotation' || value === 'ADBE Vector Rotation') {
	                    return interfaceFunction.rotation;
	                }
	                if(value === 'Skew') {
	                    return interfaceFunction.skew;
	                }
	                if(value === 'Skew Axis') {
	                    return interfaceFunction.skewAxis;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.o, 1/view.transform.mProps.o.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'anchorPoint', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.a);
	                }
	            });
	            var scaleArray = [];
	            Object.defineProperty(interfaceFunction, 'scale', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.s, 1 / view.transform.mProps.s.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'rotation', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.r, 1 / view.transform.mProps.r.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'skew', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.sk);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'skewAxis', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.sa);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.ty = 'tr';
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var ellipseInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            prop.s.setGroupProperty(_propertyGroup);
	            prop.p.setGroupProperty(_propertyGroup);
	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.s.ix === value){
	                    return interfaceFunction.size;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'size', {
	                get: function(){
	                    return ExpressionValue(prop.s);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var starInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.or.setGroupProperty(_propertyGroup);
	            prop.os.setGroupProperty(_propertyGroup);
	            prop.pt.setGroupProperty(_propertyGroup);
	            prop.p.setGroupProperty(_propertyGroup);
	            prop.r.setGroupProperty(_propertyGroup);
	            if(shape.ir){
	                prop.ir.setGroupProperty(_propertyGroup);
	                prop.is.setGroupProperty(_propertyGroup);
	            }

	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.rotation;
	                }
	                if(shape.pt.ix === value){
	                    return interfaceFunction.points;
	                }
	                if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){
	                    return interfaceFunction.outerRadius;
	                }
	                if(shape.os.ix === value){
	                    return interfaceFunction.outerRoundness;
	                }
	                if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){
	                    return interfaceFunction.innerRadius;
	                }
	                if(shape.is && shape.is.ix === value){
	                    return interfaceFunction.innerRoundness;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'rotation', {
	                get: function(){
	                    return ExpressionValue(prop.r, 1 / prop.r.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'points', {
	                get: function(){
	                    return ExpressionValue(prop.pt);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'outerRadius', {
	                get: function(){
	                    return ExpressionValue(prop.or);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'outerRoundness', {
	                get: function(){
	                    return ExpressionValue(prop.os);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'innerRadius', {
	                get: function(){
	                    if(!prop.ir){
	                        return 0;
	                    }
	                    return ExpressionValue(prop.ir);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'innerRoundness', {
	                get: function(){
	                    if(!prop.is){
	                        return 0;
	                    }
	                    return ExpressionValue(prop.is, 1 / prop.is.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var rectInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.p.setGroupProperty(_propertyGroup);
	            prop.s.setGroupProperty(_propertyGroup);
	            prop.r.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.rotation;
	                }
	                if(shape.pt.ix === value){
	                    return interfaceFunction.points;
	                }
	                if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){
	                    return interfaceFunction.outerRadius;
	                }
	                if(shape.os.ix === value){
	                    return interfaceFunction.outerRoundness;
	                }
	                if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){
	                    return interfaceFunction.innerRadius;
	                }
	                if(shape.is && shape.is.ix === value){
	                    return interfaceFunction.innerRoundness;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'roundness', {
	                get: function(){
	                    return ExpressionValue(prop.r);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'size', {
	                get: function(){
	                    return ExpressionValue(prop.s);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var roundedInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.rd.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.r.ix === value || 'Round Corners 1' === value){
	                    return interfaceFunction.radius;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'radius', {
	                get: function(){
	                    return ExpressionValue(prop.rd);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var repeaterInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.c.setGroupProperty(_propertyGroup);
	            prop.o.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.c.ix === value || 'Copies' === value){
	                    return interfaceFunction.copies;
	                } else if(shape.o.ix === value || 'Offset' === value){
	                    return interfaceFunction.offset;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'copies', {
	                get: function(){
	                    return ExpressionValue(prop.c);
	                }
	            });

	            Object.defineProperty(interfaceFunction, 'offset', {
	                get: function(){
	                    return ExpressionValue(prop.o);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var pathInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            prop.setGroupProperty(_propertyGroup);

	            function interfaceFunction(val){
	                if(val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path'){
	                    return interfaceFunction.path;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'path', {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop.v;
	                    //return shape_pool.clone(prop.v);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'shape', {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop.v;
	                    //return shape_pool.clone(prop.v);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'ix', { value: shape.ix });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });
	            return interfaceFunction;
	        }
	    }());


	    return ob;
	}())

	var TextExpressionInterface = (function(){
		return function(elem){
	        function _thisLayerFunction(){
	        }
	        Object.defineProperty(_thisLayerFunction, "sourceText", {
	            get: function(){
	            	if(!elem.currentTextDocumentData.t) {
	            		return ''
	            	}
	                return elem.currentTextDocumentData.t;
	            }
	        });
	        return _thisLayerFunction;
	    }
	}())
	var LayerExpressionInterface = (function (){
	    function toWorld(arr){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	        }
	        return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	    }


	    return function(elem){

	        var transformInterface = TransformExpressionInterface(elem.transform);

	        function _registerMaskInterface(maskManager){
	            _thisLayerFunction.mask = maskManager.getMask.bind(maskManager);
	        }
	        function _registerEffectsInterface(effects){
	            _thisLayerFunction.effect = effects;
	        }

	        function _thisLayerFunction(name){
	            switch(name){
	                case "ADBE Root Vectors Group":
	                case "Contents":
	                case 2:
	                    return _thisLayerFunction.shapeInterface;
	                case 1:
	                case "Transform":
	                case "transform":
	                case "ADBE Transform Group":
	                    return transformInterface;
	                case 4:
	                case "ADBE Effect Parade":
	                    return _thisLayerFunction.effect;
	            }
	        }
	        _thisLayerFunction.toWorld = toWorld;
	        _thisLayerFunction.toComp = toWorld;
	        _thisLayerFunction._elem = elem;
	        Object.defineProperty(_thisLayerFunction, 'hasParent', {
	            get: function(){
	                return !!elem.hierarchy;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, 'parent', {
	            get: function(){
	                return elem.hierarchy[0].layerInterface;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, "rotation", {
	            get: function(){
	                return transformInterface.rotation;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, "scale", {
	            get: function () {
	                return transformInterface.scale;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "position", {
	            get: function () {
	                return transformInterface.position;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "anchorPoint", {
	            get: function () {
	                return transformInterface.anchorPoint;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "transform", {
	            get: function () {
	                return transformInterface;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "width", {
	            get: function () {
	                if(elem.data.ty === 0) {
	                    return elem.data.w
	                }
	                return 100;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "height", {
	            get: function () {
	                if(elem.data.ty === 0) {
	                    return elem.data.h
	                }
	                return 100;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "source", {
	            get: function () {
	                return elem.data.refId;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "_name", { value:elem.data.nm });
	        Object.defineProperty(_thisLayerFunction, "content", {
	            get: function(){
	                return _thisLayerFunction.shapeInterface;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "active", {
	            get: function(){
	                return elem.isVisible;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "text", {
	            get: function(){
	                return _thisLayerFunction.textInterface;
	            }
	        });

	        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
	        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
	        return _thisLayerFunction;
	    }
	}());

	var CompExpressionInterface = (function (){
	    return function(comp){
	        function _thisLayerFunction(name){
	            var i=0, len = comp.layers.length;
	            while(i<len){
	                if(comp.layers[i].nm === name || comp.layers[i].ind === name){
	                    return comp.elements[i].layerInterface;
	                }
	                i += 1;
	            }
	            return {active:false}
	        }
	        Object.defineProperty(_thisLayerFunction, "_name", { value:comp.data.nm });
	        _thisLayerFunction.layer = _thisLayerFunction;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.height = comp.globalData.compSize.h;
	        _thisLayerFunction.width = comp.globalData.compSize.w;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.frameDuration = 1/comp.globalData.frameRate;
	        return _thisLayerFunction;
	    }
	}());
	var TransformExpressionInterface = (function (){
	    return function(transform){
	        function _thisFunction(name){
	            switch(name){
	                case "scale":
	                case "Scale":
	                case "ADBE Scale":
	                    return _thisFunction.scale;
	                case "rotation":
	                case "Rotation":
	                case "ADBE Rotation":
	                case "ADBE Rotate Z":
	                    return _thisFunction.rotation;
	                case "position":
	                case "Position":
	                case "ADBE Position":
	                    return transform.position;
	                case "anchorPoint":
	                case "AnchorPoint":
	                case "Anchor Point":
	                case "ADBE AnchorPoint":
	                    return _thisFunction.anchorPoint;
	                case "opacity":
	                case "Opacity":
	                    return _thisFunction.opacity;
	            }
	        }

	        Object.defineProperty(_thisFunction, "rotation", {
	            get: function(){
	                return transform.rotation;
	            }
	        });
	        Object.defineProperty(_thisFunction, "scale", {
	            get: function () {
	                return transform.scale;
	            }
	        });

	        Object.defineProperty(_thisFunction, "position", {
	            get: function () {
	                return transform.position;
	            }
	        });

	        Object.defineProperty(_thisFunction, "xPosition", {
	            get: function () {
	                return transform.xPosition;
	            }
	        });

	        Object.defineProperty(_thisFunction, "yPosition", {
	            get: function () {
	                return transform.yPosition;
	            }
	        });

	        Object.defineProperty(_thisFunction, "anchorPoint", {
	            get: function () {
	                return transform.anchorPoint;
	            }
	        });

	        Object.defineProperty(_thisFunction, "opacity", {
	            get: function () {
	                return transform.opacity;
	            }
	        });

	        Object.defineProperty(_thisFunction, "skew", {
	            get: function () {
	                return transform.skew;
	            }
	        });

	        Object.defineProperty(_thisFunction, "skewAxis", {
	            get: function () {
	                return transform.skewAxis;
	            }
	        });

	        return _thisFunction;
	    }
	}());
	var ProjectInterface = (function (){

	    function registerComposition(comp){
	        this.compositions.push(comp);
	    }

	    return function(){
	        function _thisProjectFunction(name){
	            var i = 0, len = this.compositions.length;
	            while(i<len){
	                if(this.compositions[i].data && this.compositions[i].data.nm === name){
	                    this.compositions[i].prepareFrame(this.currentFrame);
	                    return this.compositions[i].compInterface;
	                }
	                i+=1;
	            }
	        }

	        _thisProjectFunction.compositions = [];
	        _thisProjectFunction.currentFrame = 0;

	        _thisProjectFunction.registerComposition = registerComposition;



	        return _thisProjectFunction;
	    }
	}());
	var EffectsExpressionInterface = (function (){
	    var ob = {
	        createEffectsInterface: createEffectsInterface
	    };

	    function createEffectsInterface(elem, propertyGroup){
	        if(elem.effects){

	            var effectElements = [];
	            var effectsData = elem.data.ef;
	            var i, len = elem.effects.effectElements.length;
	            for(i=0;i<len;i+=1){
	                effectElements.push(createGroupInterface(effectsData[i],elem.effects.effectElements[i],propertyGroup,elem));
	            }

	            return function(name){
	                var effects = elem.data.ef, i = 0, len = effects.length;
	                while(i<len) {
	                    if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                        return effectElements[i];
	                    }
	                    i += 1;
	                }
	            }
	        }
	    }

	    function createGroupInterface(data,elements, propertyGroup, elem){
	        var effectElements = [];
	        var i, len = data.ef.length;
	        for(i=0;i<len;i+=1){
	            if(data.ef[i].ty === 5){
	                effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],propertyGroup, elem));
	            } else {
	                effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty, elem));
	            }
	        }
	        var groupInterface = function(name){
	            var effects = data.ef, i = 0, len = effects.length;
	            while(i<len) {
	                if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                    if(effects[i].ty === 5){
	                        return effectElements[i];
	                    } else {
	                        return effectElements[i]();
	                    }
	                }
	                i += 1;
	            }
	            return effectElements[0]();
	        }
	        if(data.mn === 'ADBE Color Control'){
	            Object.defineProperty(groupInterface, 'color', {
	                get: function(){
	                    return effectElements[0]();
	                }
	            });
	        }
	        groupInterface.active = data.en !== 0;
	        return groupInterface
	    }

	    function createValueInterface(element, type, elem){
	        return function(){
	            if(type === 10){
	                return elem.comp.compInterface(element.p.v);
	            }
	            return ExpressionValue(element.p);
	        }
	    }

	    return ob;

	}());
	var ExpressionValue = (function() {
		return function(elementProp, mult, type) {
	        var expressionValue, arrayValue;
			if (elementProp.k) {
	            elementProp.getValue();
	        }
	        var i, len, arrValue;
	        if (type) {
	        	if(type === 'color') {
	        		len = 4;
			        expressionValue = Array.apply(null, {length: len});
			        arrValue = Array.apply(null, {length: len});
			        for (i = 0; i < len; i += 1) {
			            expressionValue[i] = arrValue[i] = (mult && i < 3) ? elementProp.v[i] * mult : 1;
			        }
		        	expressionValue.value = arrValue;
	        	}
	        } else if (typeof elementProp.v === 'number' || elementProp.v instanceof Number){
	            expressionValue = mult ? new Number(elementProp.v * mult) : new Number(elementProp.v);
	            expressionValue.value = mult ? elementProp.v * mult : elementProp.v;
	        } else {
	        	len = elementProp.v.length;
		        expressionValue = Array.apply(null, {length: len});
		        arrValue = Array.apply(null, {length: len});
		        for (i = 0; i < len; i += 1) {
		            expressionValue[i] = arrValue[i] = mult ? elementProp.v[i] * mult : elementProp.v[i];
		        }
		        expressionValue.value = arrValue;
	        }
	        
	        expressionValue.numKeys = elementProp.keyframes ? elementProp.keyframes.length : 0;
	        expressionValue.key = function(pos) {
	            if (!expressionValue.numKeys) {
	                return 0;
	            } else {
	                return elementProp.keyframes[pos-1].t;
	            }
	        };
	        expressionValue.valueAtTime = elementProp.getValueAtTime;
	        expressionValue.propertyGroup = elementProp.propertyGroup;
	        return expressionValue;
		}
	}())
	function SliderEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function AngleEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function ColorEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,dynamicProperties);
	}
	function PointEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,dynamicProperties);
	}
	function LayerIndexEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function MaskIndexEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function CheckboxEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function NoValueEffect(){
	    this.p = {};
	}
	function EffectsManager(data,element,dynamicProperties){
	    var effects = data.ef;
	    this.effectElements = [];
	    var i,len = effects.length;
	    var effectItem;
	    for(i=0;i<len;i++) {
	        effectItem = new GroupEffect(effects[i],element,dynamicProperties);
	        this.effectElements.push(effectItem);
	    }
	}

	function GroupEffect(data,element,dynamicProperties){
	    this.dynamicProperties = [];
	    this.init(data,element,this.dynamicProperties);
	    if(this.dynamicProperties.length){
	        dynamicProperties.push(this);
	    }
	}

	GroupEffect.prototype.getValue = function(){
	    this.mdf = false;
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        this.mdf = this.dynamicProperties[i].mdf ? true : this.mdf;
	    }
	};

	GroupEffect.prototype.init = function(data,element,dynamicProperties){
	    this.data = data;
	    this.mdf = false;
	    this.effectElements = [];
	    var i, len = this.data.ef.length;
	    var eff, effects = this.data.ef;
	    for(i=0;i<len;i+=1){
	        switch(effects[i].ty){
	            case 0:
	                eff = new SliderEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 1:
	                eff = new AngleEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 2:
	                eff = new ColorEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 3:
	                eff = new PointEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 4:
	            case 7:
	                eff = new CheckboxEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 10:
	                eff = new LayerIndexEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 11:
	                eff = new MaskIndexEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 5:
	                eff = new EffectsManager(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 6:
	                eff = new NoValueEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	        }
	    }
	};var bodymovinjs = {}; function play(animation){ animationManager.play(animation); } function pause(animation){ animationManager.pause(animation); } function togglePause(animation){ animationManager.togglePause(animation); } function setSpeed(value,animation){ animationManager.setSpeed(value, animation); } function setDirection(value,animation){ animationManager.setDirection(value, animation); } function stop(animation){ animationManager.stop(animation); } function moveFrame(value){ animationManager.moveFrame(value); } function searchAnimations(){ if(standalone === true){ animationManager.searchAnimations(animationData,standalone, renderer); }else{ animationManager.searchAnimations(); } } function registerAnimation(elem){ return animationManager.registerAnimation(elem); } function resize(){ animationManager.resize(); } function start(){ animationManager.start(); } function goToAndStop(val,isFrame, animation){ animationManager.goToAndStop(val,isFrame, animation); } function setSubframeRendering(flag){ subframeEnabled = flag; } function loadAnimation(params){ if(standalone === true){ params.animationData = JSON.parse(animationData); } return animationManager.loadAnimation(params); } function destroy(animation){ return animationManager.destroy(animation); } function setQuality(value){ if(typeof value === 'string'){ switch(value){ case 'high': defaultCurveSegments = 200; break; case 'medium': defaultCurveSegments = 50; break; case 'low': defaultCurveSegments = 10; break; } }else if(!isNaN(value) && value > 1){ defaultCurveSegments = value; } if(defaultCurveSegments >= 50){ roundValues(false); }else{ roundValues(true); } } function installPlugin(type,plugin){ if(type==='expressions'){ expressionsPlugin = plugin; } } function getFactory(name){ switch(name){ case "propertyFactory": return PropertyFactory;case "shapePropertyFactory": return ShapePropertyFactory; case "matrix": return Matrix; } } bodymovinjs.play = play; bodymovinjs.pause = pause; bodymovinjs.togglePause = togglePause; bodymovinjs.setSpeed = setSpeed; bodymovinjs.setDirection = setDirection; bodymovinjs.stop = stop; bodymovinjs.moveFrame = moveFrame; bodymovinjs.searchAnimations = searchAnimations; bodymovinjs.registerAnimation = registerAnimation; bodymovinjs.loadAnimation = loadAnimation; bodymovinjs.setSubframeRendering = setSubframeRendering; bodymovinjs.resize = resize; bodymovinjs.start = start; bodymovinjs.goToAndStop = goToAndStop; bodymovinjs.destroy = destroy; bodymovinjs.setQuality = setQuality; bodymovinjs.installPlugin = installPlugin; bodymovinjs.__getFactory = getFactory; bodymovinjs.version = '4.6.3'; function checkReady(){ if (document.readyState === "complete") { clearInterval(readyStateCheckInterval); searchAnimations(); } } function getQueryVariable(variable) { var vars = queryString.split('&'); for (var i = 0; i < vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { return decodeURIComponent(pair[1]); } } } var standalone = '__[STANDALONE]__'; var animationData = '__[ANIMATIONDATA]__'; var renderer = ''; if(standalone) { var scripts = document.getElementsByTagName('script'); var index = scripts.length - 1; var myScript = scripts[index]; var queryString = myScript.src.replace(/^[^\?]+\??/,''); renderer = getQueryVariable('renderer'); } var readyStateCheckInterval = setInterval(checkReady, 100); return bodymovinjs; }));  

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = whenProperty;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _SWatcher = __webpack_require__(442);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Resolve a promise when the wanted property on the passed object exist or pass the check function provided
	 *
	 * @name 		whenProperty
	 * @param 		{Object} 					object 				The object on which to monitor the property
	 * @param 		{String} 					property 			The property to monitor
	 * @param 		{Function} 					[checkFn=null] 		An optional function to check the property. The promise is resolved when this function return true
	 * @return 		(Promise) 										The promise that will be resolved when the property exist on the object (and that it passes the checkFn)
	 *
	 * @example 	js
	 * import whenProperty from 'sugarcss/js/utils/objects/whenProperty'
	 *
	 * const myObj = {
	 *  	title : 'Hello'
	 * };
	 *
	 * whenProperty(myObj, 'title').then((value) => {
	 * 		// the object has a title property now
	 * });
	 *
	 * // with a checkFn
	 * whenProperty(myObj, 'title', (newVal, oldVal) => {
	 * 		// when the property is 'Hello World'
	 * 		return newVal === 'Hello World';
	 * }).then((value) => {
	 * 		// do something with your Hello World
	 * });
	 *
	 * setTimeout(() => {
	 * 		// this will resolve the promise
	 * 		myObj.title = 'Hello World';
	 * },1000);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenProperty(object, property) {
	  var checkFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  return new Promise(function (resolve, reject) {

	    var value = (0, _get3.default)(object, property);
	    if (value) {
	      if (checkFn && checkFn(value, value)) {
	        resolve(value);
	        return;
	      } else if (!checkFn) {
	        resolve(value);
	        return;
	      }
	    }

	    var watcher = new _SWatcher2.default();
	    var ok = false;
	    watcher.watch(object, property, function (newVal, oldVal) {
	      if (ok) return;
	      if (checkFn && checkFn(newVal, oldVal)) {
	        ok = true;
	        resolve(newVal);
	        watcher.destroy();
	      } else if (!checkFn) {
	        ok = true;
	        resolve(value);
	        watcher.destroy();
	      }
	    });
	  });
	}

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SITypedComponent = __webpack_require__(452);

	var _SITypedComponent2 = _interopRequireDefault(_SITypedComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SITypedComponent2.default.define('s-i-typed', _SITypedComponent2.default);

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(453);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _ityped = __webpack_require__(478);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SITypedComponent
	 * @extends 	SWebComponent
	 * Webcomponent wrapper around the freaking cool iTyped micro library to create nice typewriter effect.
	 *
	 * @styleguide 	Objects / ITyped
	 * @example 	html
	 * Hello <s-i-typed strings="['Univers']" loop="true">World</s-i-typed>
	 * @see 		https://github.com/luisvinicius167/ityped
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SITypedComponent = function (_SWebComponent) {
		_inherits(SITypedComponent, _SWebComponent);

		function SITypedComponent() {
			_classCallCheck(this, SITypedComponent);

			return _possibleConstructorReturn(this, (SITypedComponent.__proto__ || Object.getPrototypeOf(SITypedComponent)).apply(this, arguments));
		}

		_createClass(SITypedComponent, [{
			key: 'shouldAcceptComponentProp',


			/**
	   * Should component accept prop
	   * @definition 		SWebComponent.shouldComponentAcceptProp
	   * @protected
	   */
			value: function shouldAcceptComponentProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SITypedComponent.prototype.__proto__ || Object.getPrototypeOf(SITypedComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SITypedComponent.prototype.__proto__ || Object.getPrototypeOf(SITypedComponent.prototype), 'componentMount', this).call(this);

				this.props.strings.unshift(this.innerHTML);
				this.innerHTML = '';

				console.log(this.props.loop);

				console.log('this', this);

				// init the iTyped library
				(0, _ityped.init)(this, this.props);
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t@keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@-webkit-keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@-moz-keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t.ityped-cursor {\n\t\t\t\tfont-size: 1em;\n\t\t\t\topacity: 1;\n\t\t\t\t-webkit-animation: s-i-typed-blink 0.3s infinite;\n\t\t\t\t-moz-animation: s-i-typed-blink 0.3s infinite;\n\t\t\t\tanimation: s-i-typed-blink 0.3s infinite;\n\t\t\t\tanimation-direction: alternate;\n\t\t\t}\n\t\t\t' + componentNameDash + ' {\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Accept all the settings of the iTyped library
	     * @type 	{Object}
	     * @prop
	     * @name 	iTyped
	     * @see 	https://github.com/luisvinicius167/ityped
	     */

					/**
	     * Set the strings to pass through
	     * @prop
	     * @type 		{Array}
	     */
					strings: []
				};
			}
		}]);

		return SITypedComponent;
	}(_SWebComponent3.default);

	exports.default = SITypedComponent;

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(454);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SVideoWebComponent = function (_native) {
	  _inherits(SVideoWebComponent, _native);

	  function SVideoWebComponent() {
	    _classCallCheck(this, SVideoWebComponent);

	    return _possibleConstructorReturn(this, (SVideoWebComponent.__proto__ || Object.getPrototypeOf(SVideoWebComponent)).apply(this, arguments));
	  }

	  return SVideoWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SVideoWebComponent;

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	var _mixwith = __webpack_require__(455);

	var _SWebComponentMixin = __webpack_require__(456);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sNativeWebComponent(HTMLElementToExtend) {
		if (typeof HTMLElementToExtend !== 'function') {
			var _HTMLElementToExtend = function _HTMLElementToExtend() {};
			_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
			HTMLElementToExtend = _HTMLElementToExtend;
		}
		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(455);

	var _autoCast = __webpack_require__(457);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(58);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(458);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _upperFirst = __webpack_require__(459);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(460);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(462);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(463);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(470);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _SWatcher = __webpack_require__(471);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	var _propertyProxy = __webpack_require__(473);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(474);
	__webpack_require__(475);
	__webpack_require__(476);

	// require('document-register-element');

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentDidMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- componentWillUpdate
	 * 	- render
	 * 	- componentDidUpdate
	 * 	- componentWillUnmount
	 * 	- componentUnmount
	 * 	- componentDidUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that havwe to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 *
	 * 	\/**
	 * 	 * Render the component
	 * 	 * Here goes the code that reflect the this.props state on the actual html element
	 * 	 * @definition 		SWebComponent.render
	 * 	 * @protected
	 * 	 *\/
	 * 	render() {
	 * 		super.render();
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = Object.getPrototypeOf(window.sugar._webComponentsClasses[this.componentName]);
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					var propsDeps = [].concat(this.props.mountDependencies);
					var finalDeps = [];
					finalDeps = finalDeps.concat(this.props.mountDependencies);
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{SWebComponent} 	component 	The component class
	    * @param 			{Object|String}		ext 		An object or string of base HTMLElement to extend
	    */
				value: function define(name, component) {
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else if (window.customElements) {
						window.customElements.define(name, component, {
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					Object.keys(component).forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							// fastdom.mutate(() => {
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
							// document.head.appendChild(styleElm);
							// });
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2(_) {
				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				return _ret = ((_ = (_temp = (_this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _)), _this), _this.props = {}, _temp)).init(), _), _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// create the "s" namespace
					this.s = {};

					// props
					this.props = {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentDidMount: false,
						componentWillUnmount: false,
						componentUnmount: false,
						componentDidUnmount: false
					};

					// init watcher
					this._sWatcher = new _SWatcher2.default();

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this.props = Object.assign({}, this.defaultProps, this.props);

					// created callback
					this.componentCreated();

					// if ( ! document.body.contains(this)) return;
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// component will mount only if part of the active document
					this.componentWillMount();

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// update attached status
					this._componentAttached = true;

					// stop here if already mounted once
					if (this._lifecycle.componentMount) return;

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback(attribute, oldVal, newVal) {

					// stop if component has not been mounted
					// if ( ! this._lifecycle.componentWillMount) {
					// 	return;
					// }

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldAcceptComponentProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// if the attribute is not already a props, init new prop
					if (this.props[attribute] === undefined) this._initNewProp(attribute, newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if (newVal === undefined && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					var _this4 = this;

					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;

					// dispatch event
					this.onComponentWillMount && this.onComponentWillMount();

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._componentAttached = false;
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					this._initPropsProxy();

					// listen for props updates to handle them
					for (var key in this.props) {
						// initNewProp
						this._initNewProp(key);
					}

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this4.props[prop]) {
							throw 'The "' + _this4.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// dispatch event
					this.onComponentMount && this.onComponentMount();
				}

				/**
	    * Method called after the initial component render
	    *
	    * @example
	    * componentDidMount() {
	    * 		// call parent method
	    * 		super.componentDidMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidMount',
				value: function componentDidMount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidMount = true;
					// dispatch event
					this.onComponentDidMount && this.onComponentDidMount();
					// update lifecycle
					this._lifecycle.componentWillUnmount = false;
					this._lifecycle.componentUnmount = false;
					this._lifecycle.componentDidUnmount = false;
				}

				/**
	    * Method called right before the render when some props have been updated.
	    * This method is not called before the initial render
	    *
	    * @param 		{Object} 		nextProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		nextPropsArray 		An array representation of the nextProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentWillUpdate(nextProps, nextPropsArray) {
	    * 		// call parent method
	    * 		super.componentWillUpdate(nextProps, nextPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUpdate',
				value: function componentWillUpdate(nextProps) {
					// dispatch event
					this.onComponentWillUpdate && this.onComponentWillUpdate(nextProps);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'render',
				value: function render() {
					// dispatch event
					this.onComponentRender && this.onComponentRender();
				}

				/**
	    * Method called right after the render when some props have been updated.
	    * This method is not called after the initial render
	    *
	    * @param 		{Object} 		prevProps 			An object that represent the props that have been updated
	    * @param 		{Array} 		prevPropsArray 		An array representation of the prevProps object [{name:...,value:...}]
	    *
	    * @example
	    * componentDidUpdate(prevProps, prevPropsArray) {
	    * 		// call parent method
	    * 		super.componentDidUpdate(prevProps, prevPropsArray);
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUpdate',
				value: function componentDidUpdate(prevProps, prevPropsArray) {
					// dispatch event
					this.onComponentDidUpdate && this.onComponentDidUpdate(prevProps, prevPropsArray);
				}

				/**
	    * Method called before the component will unmount cause it has been removed from the DOM tree and that the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentWillUnmount() {
	    * 		// call parent method
	    * 		super.componentWillUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					if (this._lifecycle.componentWillUnmount) return;
					// update lifecycle state
					this._lifecycle.componentWillUnmount = true;
					// dispatch event
					this.onComponentWillUnmount && this.onComponentWillUnmount();
				}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// dispatch event
					this.onComponentUnmount && this.onComponentUnmount();
				}

				/**
	    * Method called when the component has been unmounted
	    *
	    * @example
	    * componentDidUnmount() {
	    * 		// call parent method
	    * 		super.componentDidUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentDidUnmount',
				value: function componentDidUnmount() {
					if (this._lifecycle.componentDidMount) return;
					// update lifecycle state
					this._lifecycle.componentDidUnmount = true;
					// destroy things
					this._sWatcher.destroy();
					// dispatch event
					this.onComponentDidUnmount && this.onComponentDidUnmount();
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this5 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this5.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */

			}, {
				key: '_initPropsProxy',
				value: function _initPropsProxy() {
					var _this6 = this;

					var _loop = function _loop(key) {
						if (_this6.hasOwnProperty(key)) {
							console.warn('The component ' + _this6.componentNameDash + ' has already an "' + key + '" property... This property will not reflect the this.props[\'' + key + '\'] value... Try to use a property name that does not already exist on an HTMLElement...');
							return 'continue';
						}
						if (!key in _this6) {
							Object.defineProperty(_this6, key, {
								get: function get() {
									return _this6.props[key];
								},
								set: function set(value) {
									_this6.setProp(key, value);
								},
								enumarable: true
							});
						}
					};

					// loop on each props
					for (var key in this.defaultProps) {
						var _ret2 = _loop(key);

						if (_ret2 === 'continue') continue;
					}
				}

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this7 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this7._componentAttached) return;
						// init
						_this7.componentMount();
						// render
						_this7.render();
						// component did mount
						_this7.componentDidMount();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this8 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {

						// will unmount
						_this8.componentWillUnmount();
						// wait next frame
						_fastdom2.default.clear(_this8._fastdomSetProp);
						_this8._fastdomSetProp = _this8.mutate(function () {
							// unmount only if the component is mounted
							if (!_this8._lifecycle.componentMount) return;
							// unmount
							_this8.componentUnmount();
							// did unmount
							_this8.componentDidUnmount();
							// update lifecycle
							_this8._lifecycle.componentWillMount = false;
							_this8._lifecycle.componentMount = false;
							_this8._lifecycle.componentDidUnmount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					(0, _dispatchEvent2.default)(this, name, data);
					(0, _dispatchEvent2.default)(this, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this.props[prop] = value;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this9 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this9._nextPropsStack) {
							var val = _this9._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this9._handlePhysicalProps(key, val);
						}
						for (var _key in _this9._prevPropsStack) {
							var _val = _this9._prevPropsStack[_key];
							prevPropsArray.push({
								name: _key,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this9.componentWillReceiveProps) {
							_this9.componentWillReceiveProps(_this9._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this9.shouldComponentUpdate && !_this9.shouldComponentUpdate(_this9._nextPropsStack, _this9._prevPropsStack)) return;

						// component will update
						_this9.componentWillUpdate(_this9._nextPropsStack, nextPropsArray);

						// render the component
						_this9.render();

						// component did update
						_this9.componentDidUpdate(_this9._prevPropsStack, prevPropsArray);
					});
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldAcceptComponentProp',
				value: function shouldAcceptComponentProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Watch any data of the component
	    * @param 		{String} 		path 		The path from the component root to watch like "props.myCoolProp"
	    * @param 		{Function}		cb 			The callback to call when the item has changed
	    */

			}, {
				key: 'watch',
				value: function watch(path, cb) {
					this._sWatcher.watch(this, path, cb);
				}

				/**
	    * Initiate a new prop. This will add the propertyProxy on the new prop etc...
	    * @param 			{String} 			prop 			The property name to init
	    */

			}, {
				key: '_initNewProp',
				value: function _initNewProp(prop) {
					var _this10 = this;

					var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					if (value) {
						this.props[prop] = value;
					}
					(0, _propertyProxy2.default)(this.props, prop, {
						set: function set(value) {
							var oldVal = _this10.props[prop];
							// handle new prop value
							_this10._handleNewPropValue(prop, value, oldVal);
							// set the value
							return value;
						},
						enumarable: true
					}, false);
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	    */

			}, {
				key: '_handlePhysicalProps',
				value: function _handlePhysicalProps(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute(prop);
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute(prop, JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute(prop, 'fn');
						} else {
							this.setAttribute(prop, value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldAcceptComponentProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this.props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this.props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProps(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this11 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this11.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this11.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this12 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this12.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this12.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ },
/* 457 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {
		// printed object
		if (string === '[object Object]') return null;
		// boolean values
		if (string === 'false' || string === 'true' || string === 'undefined' || string === 'null' || !isNaN(string)) {
			return eval(string);
		}
		// array
		if (typeof string === 'string' && string.substr(0, 1) === '[') {
			var val = eval(string);
			if (val instanceof Array) return val;
		}
		// parse json
		if (typeof string === 'string' && string.substr(0, 1) === '{') {
			return eval('(' + string + ')');
		}
		// return the string if nothing can be casted
		return string;
	}

/***/ },
/* 458 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ },
/* 459 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(461);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(113);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(463);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport = __webpack_require__(466);

	var _isInViewport2 = _interopRequireDefault(_isInViewport);

	var _throttle = __webpack_require__(467);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(468);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is in the viewport
	 * @return 		(Promise) 								The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenInViewport(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// try to get the closest element that has an overflow
			var scrollContainerElm = document;
			if (!elm._inViewportContainer) {
				var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
				if (overflowContainer) {
					scrollContainerElm = overflowContainer;
					elm._inViewportContainer = overflowContainer;
				}
			} else {
				scrollContainerElm = elm._inViewportContainer;
			}

			var isInViewport = false,
			    isVisible = false,
			    _cb = function _cb() {
				if (isVisible && isInViewport) {
					scrollContainerElm.removeEventListener('scroll', checkViewport);
					window.removeEventListener('resize', checkViewport);
					if (cb) cb(elm);
					resolve(elm);
				}
			};
			var checkViewport = (0, _throttle2.default)(function (e) {
				isInViewport = (0, _isInViewport2.default)(elm, 50);
				_cb();
			}, 100);

			// detect when visible
			(0, _whenVisible2.default)(elm).then(function (elm) {
				isVisible = true;
				_cb();
			});

			// listen for resize
			scrollContainerElm.addEventListener('scroll', checkViewport);
			window.addEventListener('resize', checkViewport);
			setTimeout(function () {
				checkViewport(null);
			});
		});
	}

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(464);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(465);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ },
/* 464 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(464);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ },
/* 466 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  		The element to insert
	 * @param 		{Object} 					offset 		An object of top, right, bottom and left offset used to detect the status
	 * @return 		{Boolean								If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function isInViewport(elm) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

	  var containerHeight = window.innerHeight || document.documentElement.clientHeight;
	  var containerWidth = window.innerWidth || document.documentElement.clientWidth;
	  var rect = elm.getBoundingClientRect();
	  return rect.top - containerHeight - offset <= 0 && rect.bottom + offset >= 0 && rect.left - containerWidth - offset <= 0 && rect.right + offset >= 0;
	}
	window.__isInViewport = isInViewport;

/***/ },
/* 467 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(469);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ },
/* 469 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ },
/* 470 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(472);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(160);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		// static setters = {
		// 	CSSStyleDeclaration : (obj, property, value) => {
		// 		obj.setProperty(property, value);
		// 	}
		// }

		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {}
			// @TODO watcher destroy implementation


			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// check if have a custom setter for this object
					// if (customSetter) {
					// 	customSetter(obj, property, value);
					// 	val = value;
					// }
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// get the setter
				// let customSetter;
				// for (let name in SWatcher.setters) {
				// 	if (__constructorName(obj) === name) {
				// 		customSetter = SWatcher.setters[name];
				// 		break;
				// 	}
				// }

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be a string or an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ },
/* 472 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(125);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
		});

		// return the value
		return val;
	}

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(eOrElm) {
		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
			case 'SELECT':
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === 'checkbox' || field.type === 'radio')) return;
					if (field.value && !field.hasAttribute('has-value')) {
						field.setAttribute('has-value', true);
						field.removeAttribute('empty');
					} else if (!field.value) {
						field.removeAttribute('has-value');
						field.removeAttribute('value');
						if (!field.hasAttribute('empty')) {
							field.setAttribute('empty', true);
						}
					}
					if (!field.hasAttribute('dirty')) {
						field.setAttribute('dirty', true);
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field);
			// stop here if is a submit
			if (e.type === 'submit') return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute('dirty');
			});
		});
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);
	document.addEventListener('reset', handleFormSubmitOrReset);
	document.addEventListener('submit', handleFormSubmitOrReset);

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(110);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(460);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(477);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.body.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true);
	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ },
/* 477 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a};!function(a,b){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"===("undefined"==typeof exports?"undefined":_typeof(exports))?module.exports={init:b.init,destroy:b.destroy}:a.ityped=b}(this,function(a){function b(a){var b=a;return b.strings=a.strings||["Put your string here...","and Enjoy!"],b.typeSpeed=a.typeSpeed||100,b.backSpeed=a.backSpeed||50,b.backDelay=a.backDelay||500,b.startDelay=a.startDelay||500,b.showCursor=a.showCursor,b.loop=a.loop||!1,void 0===b.showCursor&&(b.showCursor=!0),Promise.resolve(b)}function c(a,c){a="string"==typeof a?document.querySelector(a):a,b(c).then(function(b){m=b,a._props=m,m.showCursor&&d(a,m.cursorChar||"|"),e(a)})}function d(a,b){var c=n.cloneNode();a.insertAdjacentElement("afterend",c),c.textContent=b}function e(a){l(a._props.strings,function(b,c,d){var e=a._props.typeSpeed*b.length-1;a._props.backSpeed<a._props.typeSpeed?e-=(a._props.typeSpeed-a._props.backSpeed)*b.length:a._props.backSpeed>a._props.typeSpeed&&(e+=(a._props.backSpeed-a._props.typeSpeed)*b.length);var f=this.async(),g=a._props.strings.length;h(a,b,c,g).then(function(){setTimeout(function(){f()},e)})},function(){a._props.loop&&e(a)})}function f(a,b){return new Promise(function(c,d){for(var e=0,f=0;f<b.length;f++)!function(d){var f=d,h=b.length;setTimeout(function(d){g(a,b.charAt(f)),++e===h-1&&c()},a._props.typeSpeed*d)}(f)})}function g(a,b){a.innerHTML+=b}function h(a,b,c,d){return new Promise(function(e,g){f(a,b).then(function(){setTimeout(function(){j(a,b,c,d).then(function(){setTimeout(function(){e()},a._props.startDelay)})},a._props.backDelay)})})}function i(a,b,c,d){for(var e=c;e>0;e--)!function(e){var f=e,g=c;setTimeout(function(e){a.innerHTML=b.substring(0,c-f),g--,1===f&&d()},a._props.backSpeed*e)}(e)}function j(a,b,c,d){return new Promise(function(e,f){var g=b.length;c+1===d?a._props.loop?a._props.loop&&i(a,b,g,e):(void 0!==a._props.onFinished&&"function"==typeof a._props.onFinished&&a._props.onFinished(),a.innerHTML=b):c+1!==d&&i(a,b,g,e)})}function k(a){a._props.onFinished=function(){}}var l=function(a,b,c){var d=-1,e=a.length>>>0;!function f(g){var h,i=g===!1;do{++d}while(!(d in a)&&d!==e);if(i||d===e)return void(c&&c(!i,a));g=b.call({async:function(){return h=!0,f}},a[d],d,a),h||f(g)}()},m=void 0,n=document.createElement("span");return n.classList.add("ityped-cursor"),n.textContent="|",{init:c,destroy:k}}());

/***/ }
/******/ ]);