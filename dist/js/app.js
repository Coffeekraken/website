/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	// main application entry point
	__webpack_require__(1);
	__webpack_require__(331);
	__webpack_require__(343);
	__webpack_require__(395);
	__webpack_require__(531);
	__webpack_require__(532);
	__webpack_require__(567);

	window.addEventListener('scroll', function (e) {
		var scrollTop = document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;
		if (scrollTop > 300) {
			document.body.classList.add('scrolled');
		} else {
			document.body.classList.remove('scrolled');
		}
	});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	__webpack_require__(2);

	__webpack_require__(327);

	__webpack_require__(328);

	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;

	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}

	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);

	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(51);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(56);
	__webpack_require__(59);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(69);
	__webpack_require__(71);
	__webpack_require__(73);
	__webpack_require__(75);
	__webpack_require__(78);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(84);
	__webpack_require__(86);
	__webpack_require__(88);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(96);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(104);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(108);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(112);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(208);
	__webpack_require__(210);
	__webpack_require__(220);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(294);
	__webpack_require__(295);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(298);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(309);
	__webpack_require__(310);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(316);
	__webpack_require__(317);
	__webpack_require__(318);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(325);
	__webpack_require__(326);
	module.exports = __webpack_require__(9);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(4);
	var has = __webpack_require__(5);
	var DESCRIPTORS = __webpack_require__(6);
	var $export = __webpack_require__(8);
	var redefine = __webpack_require__(18);
	var META = __webpack_require__(22).KEY;
	var $fails = __webpack_require__(7);
	var shared = __webpack_require__(23);
	var setToStringTag = __webpack_require__(25);
	var uid = __webpack_require__(19);
	var wks = __webpack_require__(26);
	var wksExt = __webpack_require__(27);
	var wksDefine = __webpack_require__(28);
	var enumKeys = __webpack_require__(29);
	var isArray = __webpack_require__(44);
	var anObject = __webpack_require__(12);
	var isObject = __webpack_require__(13);
	var toIObject = __webpack_require__(32);
	var toPrimitive = __webpack_require__(16);
	var createDesc = __webpack_require__(17);
	var _create = __webpack_require__(45);
	var gOPNExt = __webpack_require__(48);
	var $GOPD = __webpack_require__(50);
	var $DP = __webpack_require__(11);
	var $keys = __webpack_require__(30);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(49).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(43).f = $propertyIsEnumerable;
	  __webpack_require__(42).f = $getOwnPropertySymbols;

	  if (DESCRIPTORS && !__webpack_require__(24)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var core = __webpack_require__(9);
	var hide = __webpack_require__(10);
	var redefine = __webpack_require__(18);
	var ctx = __webpack_require__(20);
	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.6.1' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(11);
	var createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(12);
	var IE8_DOM_DEFINE = __webpack_require__(14);
	var toPrimitive = __webpack_require__(16);
	var dP = Object.defineProperty;

	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function () {
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	var document = __webpack_require__(4).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var hide = __webpack_require__(10);
	var has = __webpack_require__(5);
	var SRC = __webpack_require__(19)('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	__webpack_require__(9).inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});


/***/ }),
/* 19 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(19)('meta');
	var isObject = __webpack_require__(13);
	var has = __webpack_require__(5);
	var setDesc = __webpack_require__(11).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(9);
	var global = __webpack_require__(4);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: core.version,
	  mode: __webpack_require__(24) ? 'pure' : 'global',
	  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
	});


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	module.exports = false;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f;
	var has = __webpack_require__(5);
	var TAG = __webpack_require__(26)('toStringTag');

	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(23)('wks');
	var uid = __webpack_require__(19);
	var Symbol = __webpack_require__(4).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(26);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var core = __webpack_require__(9);
	var LIBRARY = __webpack_require__(24);
	var wksExt = __webpack_require__(27);
	var defineProperty = __webpack_require__(11).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30);
	var gOPS = __webpack_require__(42);
	var pIE = __webpack_require__(43);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(31);
	var enumBugKeys = __webpack_require__(41);

	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(5);
	var toIObject = __webpack_require__(32);
	var arrayIndexOf = __webpack_require__(36)(false);
	var IE_PROTO = __webpack_require__(40)('IE_PROTO');

	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33);
	var defined = __webpack_require__(35);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32);
	var toLength = __webpack_require__(37);
	var toAbsoluteIndex = __webpack_require__(39);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys');
	var uid = __webpack_require__(19);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(12);
	var dPs = __webpack_require__(46);
	var enumBugKeys = __webpack_require__(41);
	var IE_PROTO = __webpack_require__(40)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(47).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(11);
	var anObject = __webpack_require__(12);
	var getKeys = __webpack_require__(30);

	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(4).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32);
	var gOPN = __webpack_require__(49).f;
	var toString = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(31);
	var hiddenKeys = __webpack_require__(41).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(43);
	var createDesc = __webpack_require__(17);
	var toIObject = __webpack_require__(32);
	var toPrimitive = __webpack_require__(16);
	var has = __webpack_require__(5);
	var IE8_DOM_DEFINE = __webpack_require__(14);
	var gOPD = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(45) });


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperty: __webpack_require__(11).f });


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperties: __webpack_require__(46) });


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(32);
	var $getOwnPropertyDescriptor = __webpack_require__(50).f;

	__webpack_require__(55)('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8);
	var core = __webpack_require__(9);
	var fails = __webpack_require__(7);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(57);
	var $getPrototypeOf = __webpack_require__(58);

	__webpack_require__(55)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(5);
	var toObject = __webpack_require__(57);
	var IE_PROTO = __webpack_require__(40)('IE_PROTO');
	var ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(57);
	var $keys = __webpack_require__(30);

	__webpack_require__(55)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(55)('getOwnPropertyNames', function () {
	  return __webpack_require__(48).f;
	});


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13);
	var meta = __webpack_require__(22).onFreeze;

	__webpack_require__(55)('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13);
	var meta = __webpack_require__(22).onFreeze;

	__webpack_require__(55)('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13);
	var meta = __webpack_require__(22).onFreeze;

	__webpack_require__(55)('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);

	__webpack_require__(55)('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);

	__webpack_require__(55)('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);

	__webpack_require__(55)('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);

	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(68) });


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(30);
	var gOPS = __webpack_require__(42);
	var pIE = __webpack_require__(43);
	var toObject = __webpack_require__(57);
	var IObject = __webpack_require__(33);
	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', { is: __webpack_require__(70) });


/***/ }),
/* 70 */
/***/ (function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(72).set });


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13);
	var anObject = __webpack_require__(12);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(50).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(74);
	var test = {};
	test[__webpack_require__(26)('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  __webpack_require__(18)(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34);
	var TAG = __webpack_require__(26)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);

	$export($export.P, 'Function', { bind: __webpack_require__(76) });


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction = __webpack_require__(21);
	var isObject = __webpack_require__(13);
	var invoke = __webpack_require__(77);
	var arraySlice = [].slice;
	var factories = {};

	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	module.exports = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};


/***/ }),
/* 77 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(11).f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var isObject = __webpack_require__(13);
	var getPrototypeOf = __webpack_require__(58);
	var HAS_INSTANCE = __webpack_require__(26)('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(11).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !isObject(O)) return false;
	  if (!isObject(this.prototype)) return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
	  return false;
	} });


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var $parseInt = __webpack_require__(81);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt;
	var $trim = __webpack_require__(82).trim;
	var ws = __webpack_require__(83);
	var hex = /^[-+]?0[xX]/;

	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var defined = __webpack_require__(35);
	var fails = __webpack_require__(7);
	var spaces = __webpack_require__(83);
	var space = '[' + spaces + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = fails(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	module.exports = exporter;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var $parseFloat = __webpack_require__(85);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat;
	var $trim = __webpack_require__(82).trim;

	module.exports = 1 / $parseFloat(__webpack_require__(83) + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(4);
	var has = __webpack_require__(5);
	var cof = __webpack_require__(34);
	var inheritIfRequired = __webpack_require__(87);
	var toPrimitive = __webpack_require__(16);
	var fails = __webpack_require__(7);
	var gOPN = __webpack_require__(49).f;
	var gOPD = __webpack_require__(50).f;
	var dP = __webpack_require__(11).f;
	var $trim = __webpack_require__(82).trim;
	var NUMBER = 'Number';
	var $Number = global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = cof(__webpack_require__(45)(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++) {
	    if (has(Base, key = keys[j]) && !has($Number, key)) {
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	var setPrototypeOf = __webpack_require__(72).set;
	module.exports = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toInteger = __webpack_require__(38);
	var aNumberValue = __webpack_require__(89);
	var repeat = __webpack_require__(90);
	var $toFixed = 1.0.toFixed;
	var floor = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function (it, msg) {
	  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38);
	var defined = __webpack_require__(35);

	module.exports = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
	  return res;
	};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $fails = __webpack_require__(7);
	var aNumberValue = __webpack_require__(89);
	var $toPrecision = 1.0.toPrecision;

	$export($export.P + $export.F * ($fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);

	$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(8);
	var _isFinite = __webpack_require__(4).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);

	$export($export.S, 'Number', { isInteger: __webpack_require__(95) });


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13);
	var floor = Math.floor;
	module.exports = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);

	$export($export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export = __webpack_require__(8);
	var isInteger = __webpack_require__(95);
	var abs = Math.abs;

	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);

	$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);

	$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var $parseFloat = __webpack_require__(85);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var $parseInt = __webpack_require__(81);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8);
	var log1p = __webpack_require__(103);
	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});


/***/ }),
/* 103 */
/***/ (function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8);
	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8);
	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8);
	var sign = __webpack_require__(107);

	$export($export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});


/***/ }),
/* 107 */
/***/ (function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8);
	var exp = Math.exp;

	$export($export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8);
	var $expm1 = __webpack_require__(111);

	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 111 */
/***/ (function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { fround: __webpack_require__(113) });


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var sign = __webpack_require__(107);
	var pow = Math.pow;
	var EPSILON = pow(2, -52);
	var EPSILON32 = pow(2, -23);
	var MAX32 = pow(2, 127) * (2 - EPSILON32);
	var MIN32 = pow(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	module.exports = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(8);
	var abs = Math.abs;

	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8);
	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { log1p: __webpack_require__(103) });


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { sign: __webpack_require__(107) });


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8);
	var expm1 = __webpack_require__(111);
	var exp = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8);
	var expm1 = __webpack_require__(111);
	var exp = Math.exp;

	$export($export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var toAbsoluteIndex = __webpack_require__(39);
	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var toIObject = __webpack_require__(32);
	var toLength = __webpack_require__(37);

	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(82)('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(127)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(128)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38);
	var defined = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(24);
	var $export = __webpack_require__(8);
	var redefine = __webpack_require__(18);
	var hide = __webpack_require__(10);
	var Iterators = __webpack_require__(129);
	var $iterCreate = __webpack_require__(130);
	var setToStringTag = __webpack_require__(25);
	var getPrototypeOf = __webpack_require__(58);
	var ITERATOR = __webpack_require__(26)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 129 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(45);
	var descriptor = __webpack_require__(17);
	var setToStringTag = __webpack_require__(25);
	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(26)('iterator'), function () { return this; });

	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $at = __webpack_require__(127)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export = __webpack_require__(8);
	var toLength = __webpack_require__(37);
	var context = __webpack_require__(133);
	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	$export($export.P + $export.F * __webpack_require__(135)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(134);
	var defined = __webpack_require__(35);

	module.exports = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13);
	var cof = __webpack_require__(34);
	var MATCH = __webpack_require__(26)('match');
	module.exports = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(26)('match');
	module.exports = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export = __webpack_require__(8);
	var context = __webpack_require__(133);
	var INCLUDES = 'includes';

	$export($export.P + $export.F * __webpack_require__(135)(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);

	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(90)
	});


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export = __webpack_require__(8);
	var toLength = __webpack_require__(37);
	var context = __webpack_require__(133);
	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	$export($export.P + $export.F * __webpack_require__(135)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(140)('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var fails = __webpack_require__(7);
	var defined = __webpack_require__(35);
	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(140)('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(140)('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(140)('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(140)('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(140)('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(140)('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(140)('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(140)('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(140)('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(140)('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(140)('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(140)('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);

	$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8);
	var toISOString = __webpack_require__(156);

	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var fails = __webpack_require__(7);
	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	module.exports = (fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  __webpack_require__(18)(DateProto, TO_STRING, function toString() {
	    var value = getTime.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(26)('toPrimitive');
	var proto = Date.prototype;

	if (!(TO_PRIMITIVE in proto)) __webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(159));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var anObject = __webpack_require__(12);
	var toPrimitive = __webpack_require__(16);
	var NUMBER = 'number';

	module.exports = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);

	$export($export.S, 'Array', { isArray: __webpack_require__(44) });


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ctx = __webpack_require__(20);
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var call = __webpack_require__(162);
	var isArrayIter = __webpack_require__(163);
	var toLength = __webpack_require__(37);
	var createProperty = __webpack_require__(164);
	var getIterFn = __webpack_require__(165);

	$export($export.S + $export.F * !__webpack_require__(166)(function (iter) { Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = getIterFn(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(129);
	var ITERATOR = __webpack_require__(26)('iterator');
	var ArrayProto = Array.prototype;

	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11);
	var createDesc = __webpack_require__(17);

	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(74);
	var ITERATOR = __webpack_require__(26)('iterator');
	var Iterators = __webpack_require__(129);
	module.exports = __webpack_require__(9).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(26)('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }

	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var createProperty = __webpack_require__(164);

	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export = __webpack_require__(8);
	var toIObject = __webpack_require__(32);
	var arrayJoin = [].join;

	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(169)(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var fails = __webpack_require__(7);

	module.exports = function (method, arg) {
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var html = __webpack_require__(47);
	var cof = __webpack_require__(34);
	var toAbsoluteIndex = __webpack_require__(39);
	var toLength = __webpack_require__(37);
	var arraySlice = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function () {
	  if (html) arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice.call(this, begin, end);
	    var start = toAbsoluteIndex(begin, len);
	    var upTo = toAbsoluteIndex(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var aFunction = __webpack_require__(21);
	var toObject = __webpack_require__(57);
	var fails = __webpack_require__(7);
	var $sort = [].sort;
	var test = [1, 2, 3];

	$export($export.P + $export.F * (fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(169)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $forEach = __webpack_require__(173)(0);
	var STRICT = __webpack_require__(169)([].forEach, true);

	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = __webpack_require__(20);
	var IObject = __webpack_require__(33);
	var toObject = __webpack_require__(57);
	var toLength = __webpack_require__(37);
	var asc = __webpack_require__(174);
	module.exports = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(175);

	module.exports = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	var isArray = __webpack_require__(44);
	var SPECIES = __webpack_require__(26)('species');

	module.exports = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $map = __webpack_require__(173)(1);

	$export($export.P + $export.F * !__webpack_require__(169)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $filter = __webpack_require__(173)(2);

	$export($export.P + $export.F * !__webpack_require__(169)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $some = __webpack_require__(173)(3);

	$export($export.P + $export.F * !__webpack_require__(169)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $every = __webpack_require__(173)(4);

	$export($export.P + $export.F * !__webpack_require__(169)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $reduce = __webpack_require__(181);

	$export($export.P + $export.F * !__webpack_require__(169)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21);
	var toObject = __webpack_require__(57);
	var IObject = __webpack_require__(33);
	var toLength = __webpack_require__(37);

	module.exports = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = toObject(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $reduce = __webpack_require__(181);

	$export($export.P + $export.F * !__webpack_require__(169)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $indexOf = __webpack_require__(36)(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toIObject = __webpack_require__(32);
	var toInteger = __webpack_require__(38);
	var toLength = __webpack_require__(37);
	var $native = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);

	$export($export.P, 'Array', { copyWithin: __webpack_require__(186) });

	__webpack_require__(187)('copyWithin');


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(57);
	var toAbsoluteIndex = __webpack_require__(39);
	var toLength = __webpack_require__(37);

	module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(26)('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);

	$export($export.P, 'Array', { fill: __webpack_require__(189) });

	__webpack_require__(187)('fill');


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(57);
	var toAbsoluteIndex = __webpack_require__(39);
	var toLength = __webpack_require__(37);
	module.exports = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8);
	var $find = __webpack_require__(173)(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8);
	var $find = __webpack_require__(173)(6);
	var KEY = 'findIndex';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(193)('Array');


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(4);
	var dP = __webpack_require__(11);
	var DESCRIPTORS = __webpack_require__(6);
	var SPECIES = __webpack_require__(26)('species');

	module.exports = function (KEY) {
	  var C = global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(187);
	var step = __webpack_require__(195);
	var Iterators = __webpack_require__(129);
	var toIObject = __webpack_require__(32);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(128)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 195 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var inheritIfRequired = __webpack_require__(87);
	var dP = __webpack_require__(11).f;
	var gOPN = __webpack_require__(49).f;
	var isRegExp = __webpack_require__(134);
	var $flags = __webpack_require__(197);
	var $RegExp = global.RegExp;
	var Base = $RegExp;
	var proto = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function () {
	  re2[__webpack_require__(26)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(193)('RegExp');


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var regexpExec = __webpack_require__(199);
	__webpack_require__(8)({
	  target: 'RegExp',
	  proto: true,
	  forced: regexpExec !== /./.exec
	}, {
	  exec: regexpExec
	});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var regexpFlags = __webpack_require__(197);

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var LAST_INDEX = 'lastIndex';

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/,
	      re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	})();

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

	    match = nativeExec.call(re, str);

	    if (UPDATES_LAST_INDEX_WRONG && match) {
	      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      // eslint-disable-next-line no-loop-func
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	module.exports = patchedExec;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(201);
	var anObject = __webpack_require__(12);
	var $flags = __webpack_require__(197);
	var DESCRIPTORS = __webpack_require__(6);
	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];

	var define = function (fn) {
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (__webpack_require__(7)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if (__webpack_require__(6) && /./g.flags != 'g') __webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(197)
	});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var anObject = __webpack_require__(12);
	var toLength = __webpack_require__(37);
	var advanceStringIndex = __webpack_require__(203);
	var regExpExec = __webpack_require__(204);

	// @@match logic
	__webpack_require__(205)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[MATCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative($match, regexp, this);
	      if (res.done) return res.value;
	      var rx = anObject(regexp);
	      var S = String(this);
	      if (!rx.global) return regExpExec(rx, S);
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regExpExec(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var at = __webpack_require__(127)(true);

	 // `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	module.exports = function (S, index, unicode) {
	  return index + (unicode ? at(S, index).length : 1);
	};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var classof = __webpack_require__(74);
	var builtinExec = RegExp.prototype.exec;

	 // `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	module.exports = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw new TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }
	  if (classof(R) !== 'RegExp') {
	    throw new TypeError('RegExp#exec called on incompatible receiver');
	  }
	  return builtinExec.call(R, S);
	};


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(198);
	var redefine = __webpack_require__(18);
	var hide = __webpack_require__(10);
	var fails = __webpack_require__(7);
	var defined = __webpack_require__(35);
	var wks = __webpack_require__(26);
	var regexpExec = __webpack_require__(199);

	var SPECIES = wks('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
	  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	})();

	module.exports = function (KEY, length, exec) {
	  var SYMBOL = wks(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;
	    re.exec = function () { execCalled = true; return null; };
	    if (KEY === 'split') {
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES] = function () { return re; };
	    }
	    re[SYMBOL]('');
	    return !execCalled;
	  }) : undefined;

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var fns = exec(
	      defined,
	      SYMBOL,
	      ''[KEY],
	      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	        if (regexp.exec === regexpExec) {
	          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	            // The native String method already delegates to @@method (this
	            // polyfilled function), leasing to infinite recursion.
	            // We avoid it by directly calling the native @@method method.
	            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	          }
	          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	        }
	        return { done: false };
	      }
	    );
	    var strfn = fns[0];
	    var rxfn = fns[1];

	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var anObject = __webpack_require__(12);
	var toObject = __webpack_require__(57);
	var toLength = __webpack_require__(37);
	var toInteger = __webpack_require__(38);
	var advanceStringIndex = __webpack_require__(203);
	var regExpExec = __webpack_require__(204);
	var max = Math.max;
	var min = Math.min;
	var floor = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	__webpack_require__(205)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = defined(this);
	      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return fn !== undefined
	        ? fn.call(searchValue, O, replaceValue)
	        : $replace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      var res = maybeCallNative($replace, regexp, this, replaceValue);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);
	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);
	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regExpExec(rx, S);
	        if (result === null) break;
	        results.push(result);
	        if (!global) break;
	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }
	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];
	        var matched = String(result[0]);
	        var position = max(min(toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	    // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return $replace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return ch;
	          if (n > m) {
	            var f = floor(n / 10);
	            if (f === 0) return ch;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return ch;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var anObject = __webpack_require__(12);
	var sameValue = __webpack_require__(70);
	var regExpExec = __webpack_require__(204);

	// @@search logic
	__webpack_require__(205)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[SEARCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative($search, regexp, this);
	      if (res.done) return res.value;
	      var rx = anObject(regexp);
	      var S = String(this);
	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regExpExec(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var isRegExp = __webpack_require__(134);
	var anObject = __webpack_require__(12);
	var speciesConstructor = __webpack_require__(209);
	var advanceStringIndex = __webpack_require__(203);
	var toLength = __webpack_require__(37);
	var callRegExpExec = __webpack_require__(204);
	var regexpExec = __webpack_require__(199);
	var $min = Math.min;
	var $push = [].push;
	var $SPLIT = 'split';
	var LENGTH = 'length';
	var LAST_INDEX = 'lastIndex';

	// eslint-disable-next-line no-empty
	var SUPPORTS_Y = !!(function () { try { return new RegExp('x', 'y'); } catch (e) {} })();

	// @@split logic
	__webpack_require__(205)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return $split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy[LAST_INDEX];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
	    };
	  } else {
	    internalSplit = $split;
	  }

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = defined(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                    (rx.multiline ? 'm' : '') +
	                    (rx.unicode ? 'u' : '') +
	                    (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? 0xffffffff : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(12);
	var aFunction = __webpack_require__(21);
	var SPECIES = __webpack_require__(26)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(24);
	var global = __webpack_require__(4);
	var ctx = __webpack_require__(20);
	var classof = __webpack_require__(74);
	var $export = __webpack_require__(8);
	var isObject = __webpack_require__(13);
	var aFunction = __webpack_require__(21);
	var anInstance = __webpack_require__(211);
	var forOf = __webpack_require__(212);
	var speciesConstructor = __webpack_require__(209);
	var task = __webpack_require__(213).set;
	var microtask = __webpack_require__(214)();
	var newPromiseCapabilityModule = __webpack_require__(215);
	var perform = __webpack_require__(216);
	var userAgent = __webpack_require__(217);
	var promiseResolve = __webpack_require__(218);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(26)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(219)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(25)($Promise, PROMISE);
	__webpack_require__(193)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(166)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


/***/ }),
/* 211 */
/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(20);
	var call = __webpack_require__(162);
	var isArrayIter = __webpack_require__(163);
	var anObject = __webpack_require__(12);
	var toLength = __webpack_require__(37);
	var getIterFn = __webpack_require__(165);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(20);
	var invoke = __webpack_require__(77);
	var html = __webpack_require__(47);
	var cel = __webpack_require__(15);
	var global = __webpack_require__(4);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(34)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var macrotask = __webpack_require__(213).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(34)(process) == 'process';

	module.exports = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(21);

	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


/***/ }),
/* 216 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var navigator = global.navigator;

	module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(12);
	var isObject = __webpack_require__(13);
	var newPromiseCapability = __webpack_require__(215);

	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function (target, src, safe) {
	  for (var key in src) redefine(target, key, src[key], safe);
	  return target;
	};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(221);
	var validate = __webpack_require__(222);
	var MAP = 'Map';

	// 23.1 Map Objects
	module.exports = __webpack_require__(223)(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var dP = __webpack_require__(11).f;
	var create = __webpack_require__(45);
	var redefineAll = __webpack_require__(219);
	var ctx = __webpack_require__(20);
	var anInstance = __webpack_require__(211);
	var forOf = __webpack_require__(212);
	var $iterDefine = __webpack_require__(128);
	var step = __webpack_require__(195);
	var setSpecies = __webpack_require__(193);
	var DESCRIPTORS = __webpack_require__(6);
	var fastKey = __webpack_require__(22).fastKey;
	var validate = __webpack_require__(222);
	var SIZE = DESCRIPTORS ? '_s' : 'size';

	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (DESCRIPTORS) dP(C.prototype, 'size', {
	      get: function () {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function (it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(4);
	var $export = __webpack_require__(8);
	var redefine = __webpack_require__(18);
	var redefineAll = __webpack_require__(219);
	var meta = __webpack_require__(22);
	var forOf = __webpack_require__(212);
	var anInstance = __webpack_require__(211);
	var isObject = __webpack_require__(13);
	var fails = __webpack_require__(7);
	var $iterDetect = __webpack_require__(166);
	var setToStringTag = __webpack_require__(25);
	var inheritIfRequired = __webpack_require__(87);

	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(221);
	var validate = __webpack_require__(222);
	var SET = 'Set';

	// 23.2 Set Objects
	module.exports = __webpack_require__(223)(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var each = __webpack_require__(173)(0);
	var redefine = __webpack_require__(18);
	var meta = __webpack_require__(22);
	var assign = __webpack_require__(68);
	var weak = __webpack_require__(226);
	var isObject = __webpack_require__(13);
	var fails = __webpack_require__(7);
	var validate = __webpack_require__(222);
	var WEAK_MAP = 'WeakMap';
	var getWeak = meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = weak.ufstore;
	var tmp = {};
	var InternalMap;

	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(validate(this, WEAK_MAP), key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(223)(WEAK_MAP, wrapper, methods, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
	  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll = __webpack_require__(219);
	var getWeak = __webpack_require__(22).getWeak;
	var anObject = __webpack_require__(12);
	var isObject = __webpack_require__(13);
	var anInstance = __webpack_require__(211);
	var forOf = __webpack_require__(212);
	var createArrayMethod = __webpack_require__(173);
	var $has = __webpack_require__(5);
	var validate = __webpack_require__(222);
	var arrayFind = createArrayMethod(5);
	var arrayFindIndex = createArrayMethod(6);
	var id = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(226);
	var validate = __webpack_require__(222);
	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	__webpack_require__(223)(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var $typed = __webpack_require__(229);
	var buffer = __webpack_require__(230);
	var anObject = __webpack_require__(12);
	var toAbsoluteIndex = __webpack_require__(39);
	var toLength = __webpack_require__(37);
	var isObject = __webpack_require__(13);
	var ArrayBuffer = __webpack_require__(4).ArrayBuffer;
	var speciesConstructor = __webpack_require__(209);
	var $ArrayBuffer = buffer.ArrayBuffer;
	var $DataView = buffer.DataView;
	var $isView = $typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW = $typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});

	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, len);
	    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < fin) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	__webpack_require__(193)(ARRAY_BUFFER);


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4);
	var hide = __webpack_require__(10);
	var uid = __webpack_require__(19);
	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(global.ArrayBuffer && global.DataView);
	var CONSTR = ABV;
	var i = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while (i < l) {
	  if (Typed = global[TypedArrayConstructors[i++]]) {
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	module.exports = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(4);
	var DESCRIPTORS = __webpack_require__(6);
	var LIBRARY = __webpack_require__(24);
	var $typed = __webpack_require__(229);
	var hide = __webpack_require__(10);
	var redefineAll = __webpack_require__(219);
	var fails = __webpack_require__(7);
	var anInstance = __webpack_require__(211);
	var toInteger = __webpack_require__(38);
	var toLength = __webpack_require__(37);
	var toIndex = __webpack_require__(231);
	var gOPN = __webpack_require__(49).f;
	var dP = __webpack_require__(11).f;
	var arrayFill = __webpack_require__(189);
	var setToStringTag = __webpack_require__(25);
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = global[ARRAY_BUFFER];
	var $DataView = global[DATA_VIEW];
	var Math = global.Math;
	var RangeError = global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
	var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
	var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}

	if (!$typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    this._b = arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (DESCRIPTORS) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!fails(function () {
	    $ArrayBuffer(1);
	  }) || !fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/ecma262/#sec-toindex
	var toInteger = __webpack_require__(38);
	var toLength = __webpack_require__(37);
	module.exports = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(229).ABV, {
	  DataView: __webpack_require__(230).DataView
	});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	if (__webpack_require__(6)) {
	  var LIBRARY = __webpack_require__(24);
	  var global = __webpack_require__(4);
	  var fails = __webpack_require__(7);
	  var $export = __webpack_require__(8);
	  var $typed = __webpack_require__(229);
	  var $buffer = __webpack_require__(230);
	  var ctx = __webpack_require__(20);
	  var anInstance = __webpack_require__(211);
	  var propertyDesc = __webpack_require__(17);
	  var hide = __webpack_require__(10);
	  var redefineAll = __webpack_require__(219);
	  var toInteger = __webpack_require__(38);
	  var toLength = __webpack_require__(37);
	  var toIndex = __webpack_require__(231);
	  var toAbsoluteIndex = __webpack_require__(39);
	  var toPrimitive = __webpack_require__(16);
	  var has = __webpack_require__(5);
	  var classof = __webpack_require__(74);
	  var isObject = __webpack_require__(13);
	  var toObject = __webpack_require__(57);
	  var isArrayIter = __webpack_require__(163);
	  var create = __webpack_require__(45);
	  var getPrototypeOf = __webpack_require__(58);
	  var gOPN = __webpack_require__(49).f;
	  var getIterFn = __webpack_require__(165);
	  var uid = __webpack_require__(19);
	  var wks = __webpack_require__(26);
	  var createArrayMethod = __webpack_require__(173);
	  var createArrayIncludes = __webpack_require__(36);
	  var speciesConstructor = __webpack_require__(209);
	  var ArrayIterators = __webpack_require__(194);
	  var Iterators = __webpack_require__(129);
	  var $iterDetect = __webpack_require__(166);
	  var setSpecies = __webpack_require__(193);
	  var arrayFill = __webpack_require__(189);
	  var arrayCopyWithin = __webpack_require__(186);
	  var $DP = __webpack_require__(11);
	  var $GOPD = __webpack_require__(50);
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';

	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };

	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });

	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });

	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });

	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });

	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(234)('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(8);
	var aFunction = __webpack_require__(21);
	var anObject = __webpack_require__(12);
	var rApply = (__webpack_require__(4).Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(7)(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export = __webpack_require__(8);
	var create = __webpack_require__(45);
	var aFunction = __webpack_require__(21);
	var anObject = __webpack_require__(12);
	var isObject = __webpack_require__(13);
	var fails = __webpack_require__(7);
	var bind = __webpack_require__(76);
	var rConstruct = (__webpack_require__(4).Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  rConstruct(function () { /* empty */ });
	});

	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP = __webpack_require__(11);
	var $export = __webpack_require__(8);
	var anObject = __webpack_require__(12);
	var toPrimitive = __webpack_require__(16);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export = __webpack_require__(8);
	var gOPD = __webpack_require__(50).f;
	var anObject = __webpack_require__(12);

	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export = __webpack_require__(8);
	var anObject = __webpack_require__(12);
	var Enumerate = function (iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) keys.push(key);
	};
	__webpack_require__(130)(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD = __webpack_require__(50);
	var getPrototypeOf = __webpack_require__(58);
	var has = __webpack_require__(5);
	var $export = __webpack_require__(8);
	var isObject = __webpack_require__(13);
	var anObject = __webpack_require__(12);

	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
	}

	$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD = __webpack_require__(50);
	var $export = __webpack_require__(8);
	var anObject = __webpack_require__(12);

	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export = __webpack_require__(8);
	var getProto = __webpack_require__(58);
	var anObject = __webpack_require__(12);

	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return getProto(anObject(target));
	  }
	});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);

	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export = __webpack_require__(8);
	var anObject = __webpack_require__(12);
	var $isExtensible = Object.isExtensible;

	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);

	$export($export.S, 'Reflect', { ownKeys: __webpack_require__(254) });


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN = __webpack_require__(49);
	var gOPS = __webpack_require__(42);
	var anObject = __webpack_require__(12);
	var Reflect = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export = __webpack_require__(8);
	var anObject = __webpack_require__(12);
	var $preventExtensions = Object.preventExtensions;

	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP = __webpack_require__(11);
	var gOPD = __webpack_require__(50);
	var getPrototypeOf = __webpack_require__(58);
	var has = __webpack_require__(5);
	var $export = __webpack_require__(8);
	var createDesc = __webpack_require__(17);
	var anObject = __webpack_require__(12);
	var isObject = __webpack_require__(13);

	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = gOPD.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = getPrototypeOf(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      dP.f(receiver, propertyKey, existingDescriptor);
	    } else dP.f(receiver, propertyKey, createDesc(0, V));
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export = __webpack_require__(8);
	var setProto = __webpack_require__(72);

	if (setProto) $export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export = __webpack_require__(8);
	var $includes = __webpack_require__(36)(true);

	$export($export.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	__webpack_require__(187)('includes');


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
	var $export = __webpack_require__(8);
	var flattenIntoArray = __webpack_require__(260);
	var toObject = __webpack_require__(57);
	var toLength = __webpack_require__(37);
	var aFunction = __webpack_require__(21);
	var arraySpeciesCreate = __webpack_require__(174);

	$export($export.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	__webpack_require__(187)('flatMap');


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var isArray = __webpack_require__(44);
	var isObject = __webpack_require__(13);
	var toLength = __webpack_require__(37);
	var ctx = __webpack_require__(20);
	var IS_CONCAT_SPREADABLE = __webpack_require__(26)('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}

	module.exports = flattenIntoArray;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
	var $export = __webpack_require__(8);
	var flattenIntoArray = __webpack_require__(260);
	var toObject = __webpack_require__(57);
	var toLength = __webpack_require__(37);
	var toInteger = __webpack_require__(38);
	var arraySpeciesCreate = __webpack_require__(174);

	$export($export.P, 'Array', {
	  flatten: function flatten(/* depthArg = 1 */) {
	    var depthArg = arguments[0];
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	__webpack_require__(187)('flatten');


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8);
	var $at = __webpack_require__(127)(true);

	$export($export.P, 'String', {
	  at: function at(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8);
	var $pad = __webpack_require__(264);
	var userAgent = __webpack_require__(217);

	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37);
	var repeat = __webpack_require__(90);
	var defined = __webpack_require__(35);

	module.exports = function (that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8);
	var $pad = __webpack_require__(264);
	var userAgent = __webpack_require__(217);

	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(82)('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(82)('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export = __webpack_require__(8);
	var defined = __webpack_require__(35);
	var toLength = __webpack_require__(37);
	var isRegExp = __webpack_require__(134);
	var getFlags = __webpack_require__(197);
	var RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function (regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};

	__webpack_require__(130)($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});

	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(28)('asyncIterator');


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(28)('observable');


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export = __webpack_require__(8);
	var ownKeys = __webpack_require__(254);
	var toIObject = __webpack_require__(32);
	var gOPD = __webpack_require__(50);
	var createProperty = __webpack_require__(164);

	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = gOPD.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8);
	var $values = __webpack_require__(273)(false);

	$export($export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys = __webpack_require__(30);
	var toIObject = __webpack_require__(32);
	var isEnum = __webpack_require__(43).f;
	module.exports = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) if (isEnum.call(O, key = keys[i++])) {
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8);
	var $entries = __webpack_require__(273)(true);

	$export($export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var aFunction = __webpack_require__(21);
	var $defineProperty = __webpack_require__(11);

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(276), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(24) || !__webpack_require__(7)(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () { /* empty */ });
	  delete __webpack_require__(4)[K];
	});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var aFunction = __webpack_require__(21);
	var $defineProperty = __webpack_require__(11);

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(276), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var toPrimitive = __webpack_require__(16);
	var getPrototypeOf = __webpack_require__(58);
	var getOwnPropertyDescriptor = __webpack_require__(50).f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(276), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8);
	var toObject = __webpack_require__(57);
	var toPrimitive = __webpack_require__(16);
	var getPrototypeOf = __webpack_require__(58);
	var getOwnPropertyDescriptor = __webpack_require__(50).f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(276), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(8);

	$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(281)('Map') });


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(74);
	var from = __webpack_require__(282);
	module.exports = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(212);

	module.exports = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(8);

	$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(281)('Set') });


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	__webpack_require__(285)('Map');


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(8);

	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { of: function of() {
	    var length = arguments.length;
	    var A = new Array(length);
	    while (length--) A[length] = arguments[length];
	    return new this(A);
	  } });
	};


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	__webpack_require__(285)('Set');


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	__webpack_require__(285)('WeakMap');


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	__webpack_require__(285)('WeakSet');


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	__webpack_require__(290)('Map');


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(8);
	var aFunction = __webpack_require__(21);
	var ctx = __webpack_require__(20);
	var forOf = __webpack_require__(212);

	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	    var mapFn = arguments[1];
	    var mapping, A, n, cb;
	    aFunction(this);
	    mapping = mapFn !== undefined;
	    if (mapping) aFunction(mapFn);
	    if (source == undefined) return new this();
	    A = [];
	    if (mapping) {
	      n = 0;
	      cb = ctx(mapFn, arguments[2], 2);
	      forOf(source, false, function (nextItem) {
	        A.push(cb(nextItem, n++));
	      });
	    } else {
	      forOf(source, false, A.push, A);
	    }
	    return new this(A);
	  } });
	};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	__webpack_require__(290)('Set');


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	__webpack_require__(290)('WeakMap');


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	__webpack_require__(290)('WeakSet');


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(8);

	$export($export.G, { global: __webpack_require__(4) });


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(8);

	$export($export.S, 'System', { global: __webpack_require__(4) });


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8);
	var cof = __webpack_require__(34);

	$export($export.S, 'Error', {
	  isError: function isError(it) {
	    return cof(it) === 'Error';
	  }
	});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);
	var RAD_PER_DEG = 180 / Math.PI;

	$export($export.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);
	var scale = __webpack_require__(301);
	var fround = __webpack_require__(113);

	$export($export.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(scale(x, inLow, inHigh, outLow, outHigh));
	  }
	});


/***/ }),
/* 301 */
/***/ (function(module, exports) {

	// https://rwaldron.github.io/proposal-math-extensions/
	module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      // eslint-disable-next-line no-self-compare
	      || x != x
	      // eslint-disable-next-line no-self-compare
	      || inLow != inLow
	      // eslint-disable-next-line no-self-compare
	      || inHigh != inHigh
	      // eslint-disable-next-line no-self-compare
	      || outLow != outLow
	      // eslint-disable-next-line no-self-compare
	      || outHigh != outHigh
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);
	var DEG_PER_RAD = Math.PI / 180;

	$export($export.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { scale: __webpack_require__(301) });


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	// http://jfbastien.github.io/papers/Math.signbit.html
	var $export = __webpack_require__(8);

	$export($export.S, 'Math', { signbit: function signbit(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	} });


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = __webpack_require__(8);
	var core = __webpack_require__(9);
	var global = __webpack_require__(4);
	var speciesConstructor = __webpack_require__(209);
	var promiseResolve = __webpack_require__(218);

	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(8);
	var newPromiseCapability = __webpack_require__(215);
	var perform = __webpack_require__(216);

	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var toMetaKey = metadata.key;
	var ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	} });


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(220);
	var $export = __webpack_require__(8);
	var shared = __webpack_require__(23)('metadata');
	var store = shared.store || (shared.store = new (__webpack_require__(225))());

	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new Map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map());
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};
	var toMetaKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function (O) {
	  $export($export.S, 'Reflect', O);
	};

	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var toMetaKey = metadata.key;
	var getOrCreateMetadataMap = metadata.map;
	var store = metadata.store;

	metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
	  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	  if (metadataMap.size) return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	} });


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var getPrototypeOf = __webpack_require__(58);
	var ordinaryHasOwnMetadata = metadata.has;
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;

	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(224);
	var from = __webpack_require__(282);
	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var getPrototypeOf = __webpack_require__(58);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;

	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys(O, P);
	  var parent = getPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;

	metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;

	metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var getPrototypeOf = __webpack_require__(58);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;

	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;

	metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	var $metadata = __webpack_require__(313);
	var anObject = __webpack_require__(12);
	var aFunction = __webpack_require__(21);
	var toMetaKey = $metadata.key;
	var ordinaryDefineOwnMetadata = $metadata.set;

	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	  return function decorator(target, targetKey) {
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	} });


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export = __webpack_require__(8);
	var microtask = __webpack_require__(214)();
	var process = __webpack_require__(4).process;
	var isNode = __webpack_require__(34)(process) == 'process';

	$export($export.G, {
	  asap: function asap(fn) {
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export = __webpack_require__(8);
	var global = __webpack_require__(4);
	var core = __webpack_require__(9);
	var microtask = __webpack_require__(214)();
	var OBSERVABLE = __webpack_require__(26)('observable');
	var aFunction = __webpack_require__(21);
	var anObject = __webpack_require__(12);
	var anInstance = __webpack_require__(211);
	var redefineAll = __webpack_require__(219);
	var hide = __webpack_require__(10);
	var forOf = __webpack_require__(212);
	var RETURN = forOf.RETURN;

	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function (subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function (subscription) {
	  return subscription._o === undefined;
	};

	var closeSubscription = function (subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function (observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  } if (subscriptionClosed(this)) cleanupSubscription(this);
	};

	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() { closeSubscription(this); }
	});

	var SubscriptionObserver = function (subscription) {
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (core.Promise || global.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function (value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  }
	});

	hide($Observable.prototype, OBSERVABLE, function () { return this; });

	$export($export.G, { Observable: $Observable });

	__webpack_require__(193)('Observable');


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global = __webpack_require__(4);
	var $export = __webpack_require__(8);
	var userAgent = __webpack_require__(217);
	var slice = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
	var wrap = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout: wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	var $task = __webpack_require__(213);
	$export($export.G + $export.B, {
	  setImmediate: $task.set,
	  clearImmediate: $task.clear
	});


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	var $iterators = __webpack_require__(194);
	var getKeys = __webpack_require__(30);
	var redefine = __webpack_require__(18);
	var global = __webpack_require__(4);
	var hide = __webpack_require__(10);
	var Iterators = __webpack_require__(129);
	var wks = __webpack_require__(26);
	var ITERATOR = wks('iterator');
	var TO_STRING_TAG = wks('toStringTag');
	var ArrayValues = Iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
	  }
	}


/***/ }),
/* 327 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof global.process === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(329);
	module.exports = __webpack_require__(9).RegExp.escape;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8);
	var $re = __webpack_require__(330)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

	$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 330 */
/***/ (function(module, exports) {

	module.exports = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(332);

	__webpack_require__(334);

	__webpack_require__(339);

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _imageLoaded = __webpack_require__(333);

	var _imageLoaded2 = _interopRequireDefault(_imageLoaded);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	document.addEventListener('load', function (e) {
		if (!e.target.tagName) return;
		if (e.target.tagName.toLowerCase() !== 'img') return;
		if (e.target.hasAttribute('loaded')) return;
		e.target.setAttribute('loaded', true);
	}, true); /**
	           * @name 	imagesLoadedAttribute
	           * Add on every images the attribute "loaded" when it has been fully loaded. This is useful
	           * for styling purposes and for others thinks as well.
	           * @example 	js
	           * import 'coffeekraken-sugar/js/features/imagesLoadedAttribute'
	           * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	           */

	[].forEach.call(document.querySelectorAll('img'), function (img) {
		(0, _imageLoaded2.default)(img).then(function (img) {
			if (img.hasAttribute('loaded')) return;
			img.setAttribute('loaded', true);
		});
	});

/***/ }),
/* 333 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = imageLoaded;
	/**
	 * Wait until the passed image is fully loaded
	 *
	 * @name 		imageLoaded
	 * @param 		{HTMLImageElement} 			img  		The image to check the loading state
	 * @param 		{Function}					[cb=null] 	An optional callback to call
	 * @return 		{Promise} 								The promise that will be resolved
	 *
	 * @example  	js
	 * import imageLoaded from 'sugarcss/js/dom/imageLoaded'
	 * imageLoaded(myCoolHTMLImageElement).then((img) => {
	 * 		// do something when the image is loaded
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function imageLoaded(img) {
		var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {
			// check if image is already loaded
			if (img.hasAttribute('src') && img.complete) {
				// resolve promise
				resolve(img);
				// call the callback if exist
				callback && callback(img);
			} else {
				// wait until loaded
				img.addEventListener('load', function (e) {
					// resolve the promise
					resolve(img);
					// callback if exist
					callback && callback(img);
				});
				// listen for error
				img.addEventListener('error', function (e) {
					// reject
					reject(e);
				});
			}
		});
	}

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _fastdom = __webpack_require__(335);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _querySelectorLive = __webpack_require__(336);

	var _querySelectorLive2 = _interopRequireDefault(_querySelectorLive);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @name 	inputAdditionalAttributes
	 * Add some attributes on inputs, textarea and select to help with styling purposes and more.
	 * Here's the attributes added:
	 * - `has-value`: When the input has a value in it
	 * - `empty`: When the input is has no value in it
	 * - `dirty`: When the input has been touched
	 * @example 	js
	 * import 'coffeekraken-sugar/js/features/inputAdditionalAttributes'
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */

	function handleInputAttributes(eOrElm) {
		var setDirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
		var forceDirty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		var field = eOrElm.target ? eOrElm.target : eOrElm;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case "INPUT":
			case "TEXTAREA":
			case "SELECT":
				_fastdom2.default.mutate(function () {
					if (field.type && (field.type === "checkbox" || field.type === "radio")) return;
					if (field.value && !field.hasAttribute("has-value")) {
						field.setAttribute("has-value", true);
						field.removeAttribute("empty");
					} else if (field.value === undefined || field.value === null || field.value === "") {
						field.removeAttribute("has-value");
						field.removeAttribute("value");
						if (!field.hasAttribute("empty")) {
							field.setAttribute("empty", true);
						}
					}
					if (setDirty) {
						if (!field.hasAttribute("dirty") && (field.value || forceDirty)) {
							field.setAttribute("dirty", true);
						}
					}
				});
				break;
		}
	}

	function handleFormSubmitOrReset(e) {
		// loop on each form elements
		[].forEach.call(e.target.elements, function (field) {
			// reset the field attributes
			handleInputAttributes(field, true, true);
			// stop here if is a submit
			if (e.type === "submit") return;
			// remove dirty attribute
			_fastdom2.default.mutate(function () {
				field.removeAttribute("dirty");
			});
		});
	}

	(0, _querySelectorLive2.default)('select, textarea, input:not([type="submit"])', function (elm) {
		handleInputAttributes(elm, false);
	});

	document.addEventListener("change", handleInputAttributes);
	document.addEventListener("keyup", handleInputAttributes);
	document.addEventListener("reset", handleFormSubmitOrReset);
	document.addEventListener("submit", handleFormSubmitOrReset);

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(function(win) {

	/**
	 * FastDom
	 *
	 * Eliminates layout thrashing
	 * by batching DOM read/write
	 * interactions.
	 *
	 * @author Wilson Page <wilsonpage@me.com>
	 * @author Kornel Lesinski <kornel.lesinski@ft.com>
	 */

	'use strict';

	/**
	 * Mini logger
	 *
	 * @return {Function}
	 */
	var debug = 0 ? console.log.bind(console, '[fastdom]') : function() {};

	/**
	 * Normalized rAF
	 *
	 * @type {Function}
	 */
	var raf = win.requestAnimationFrame
	  || win.webkitRequestAnimationFrame
	  || win.mozRequestAnimationFrame
	  || win.msRequestAnimationFrame
	  || function(cb) { return setTimeout(cb, 16); };

	/**
	 * Initialize a `FastDom`.
	 *
	 * @constructor
	 */
	function FastDom() {
	  var self = this;
	  self.reads = [];
	  self.writes = [];
	  self.raf = raf.bind(win); // test hook
	  debug('initialized', self);
	}

	FastDom.prototype = {
	  constructor: FastDom,

	  /**
	   * Adds a job to the read batch and
	   * schedules a new frame if need be.
	   *
	   * @param  {Function} fn
	   * @param  {Object} ctx the context to be bound to `fn` (optional).
	   * @public
	   */
	  measure: function(fn, ctx) {
	    debug('measure');
	    var task = !ctx ? fn : fn.bind(ctx);
	    this.reads.push(task);
	    scheduleFlush(this);
	    return task;
	  },

	  /**
	   * Adds a job to the
	   * write batch and schedules
	   * a new frame if need be.
	   *
	   * @param  {Function} fn
	   * @param  {Object} ctx the context to be bound to `fn` (optional).
	   * @public
	   */
	  mutate: function(fn, ctx) {
	    debug('mutate');
	    var task = !ctx ? fn : fn.bind(ctx);
	    this.writes.push(task);
	    scheduleFlush(this);
	    return task;
	  },

	  /**
	   * Clears a scheduled 'read' or 'write' task.
	   *
	   * @param {Object} task
	   * @return {Boolean} success
	   * @public
	   */
	  clear: function(task) {
	    debug('clear', task);
	    return remove(this.reads, task) || remove(this.writes, task);
	  },

	  /**
	   * Extend this FastDom with some
	   * custom functionality.
	   *
	   * Because fastdom must *always* be a
	   * singleton, we're actually extending
	   * the fastdom instance. This means tasks
	   * scheduled by an extension still enter
	   * fastdom's global task queue.
	   *
	   * The 'super' instance can be accessed
	   * from `this.fastdom`.
	   *
	   * @example
	   *
	   * var myFastdom = fastdom.extend({
	   *   initialize: function() {
	   *     // runs on creation
	   *   },
	   *
	   *   // override a method
	   *   measure: function(fn) {
	   *     // do extra stuff ...
	   *
	   *     // then call the original
	   *     return this.fastdom.measure(fn);
	   *   },
	   *
	   *   ...
	   * });
	   *
	   * @param  {Object} props  properties to mixin
	   * @return {FastDom}
	   */
	  extend: function(props) {
	    debug('extend', props);
	    if (typeof props != 'object') throw new Error('expected object');

	    var child = Object.create(this);
	    mixin(child, props);
	    child.fastdom = this;

	    // run optional creation hook
	    if (child.initialize) child.initialize();

	    return child;
	  },

	  // override this with a function
	  // to prevent Errors in console
	  // when tasks throw
	  catch: null
	};

	/**
	 * Schedules a new read/write
	 * batch if one isn't pending.
	 *
	 * @private
	 */
	function scheduleFlush(fastdom) {
	  if (!fastdom.scheduled) {
	    fastdom.scheduled = true;
	    fastdom.raf(flush.bind(null, fastdom));
	    debug('flush scheduled');
	  }
	}

	/**
	 * Runs queued `read` and `write` tasks.
	 *
	 * Errors are caught and thrown by default.
	 * If a `.catch` function has been defined
	 * it is called instead.
	 *
	 * @private
	 */
	function flush(fastdom) {
	  debug('flush');

	  var writes = fastdom.writes;
	  var reads = fastdom.reads;
	  var error;

	  try {
	    debug('flushing reads', reads.length);
	    runTasks(reads);
	    debug('flushing writes', writes.length);
	    runTasks(writes);
	  } catch (e) { error = e; }

	  fastdom.scheduled = false;

	  // If the batch errored we may still have tasks queued
	  if (reads.length || writes.length) scheduleFlush(fastdom);

	  if (error) {
	    debug('task errored', error.message);
	    if (fastdom.catch) fastdom.catch(error);
	    else throw error;
	  }
	}

	/**
	 * We run this inside a try catch
	 * so that if any jobs error, we
	 * are able to recover and continue
	 * to flush the batch until it's empty.
	 *
	 * @private
	 */
	function runTasks(tasks) {
	  debug('run tasks');
	  var task; while (task = tasks.shift()) task();
	}

	/**
	 * Remove an item from an Array.
	 *
	 * @param  {Array} array
	 * @param  {*} item
	 * @return {Boolean}
	 */
	function remove(array, item) {
	  var index = array.indexOf(item);
	  return !!~index && !!array.splice(index, 1);
	}

	/**
	 * Mixin own properties of source
	 * object into the target.
	 *
	 * @param  {Object} target
	 * @param  {Object} source
	 */
	function mixin(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) target[key] = source[key];
	  }
	}

	// There should never be more than
	// one instance of `FastDom` in an app
	var exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line

	// Expose to CJS & AMD
	if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return exports; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	else if ((typeof module) == 'object') module.exports = exports;

	})( typeof window !== 'undefined' ? window : this);


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = querySelectorLive;

	var _uniqid = __webpack_require__(337);

	var _uniqid2 = _interopRequireDefault(_uniqid);

	var _matches = __webpack_require__(338);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Observe the dom to get all the elements that matches a passed css selector at any point in time.
	 * Be warned that this use the mutation observer API and will monitor all the document for new nodes. Make sure to use it
	 * when you don't have the chance to use the custom elements API instead
	 *
	 * @param	{String} 		selector 		The css selector that we are interested in
	 * @param 	{Function} 		cb 				The function to call with the newly added node
	 * @param 	{Object} 		[settings={}] 	An optional settings object to specify things like the rootNode to monitor, etc...
	 *
	 * @example 	js
	 * import querySelectorLive from 'coffeekraken-sugar/js/dom/querySelectorLive'
	 * querySelectorLive('.my-cool-item', (node) => {
	 * 	// do something here with the detected node
	 * });
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function querySelectorLive(selector, cb) {
		var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		var id = selector + ' - ' + (0, _uniqid2.default)();

		// extend settings
		settings = Object.assign({}, {
			rootNode: document,
			once: true
		}, settings);

		function pushNewNode(node) {
			if (settings.once) {
				if (!node._querySelectorLive) {
					node._querySelectorLive = {};
				}
				if (node._querySelectorLive[id]) return;
				node._querySelectorLive[id] = true;
			}
			cb && cb(node);
		}

		// listen for updates in document
		var mutationObserver = new MutationObserver(function (mutations) {
			mutations.forEach(function (mutation) {
				if (mutation.addedNodes) {
					[].forEach.call(mutation.addedNodes, function (node) {
						if ((0, _matches2.default)(node, selector)) {
							pushNewNode(node);
						}
						// search for new nodes inside the added one
						if (!node.querySelectorAll) return;
						var nestedNodes = node.querySelectorAll(selector);
						[].forEach.call(nestedNodes, function (nestedNode) {
							pushNewNode(nestedNode);
						});
					});
				}
			});
		});
		mutationObserver.observe(settings.rootNode, {
			childList: true,
			subtree: true
		});

		// first search
		[].forEach.call(settings.rootNode.querySelectorAll(selector), function (node) {
			pushNewNode(node);
		});
	}

	/**
	 * @name 	settings.rootNode
	 * The root node used to detect newly added nodes within
	 * @prop
	 * @type 		{HTMLElement}
	 * @default 	document
	 */

	/**
	* @name 	settings.once
	* Specify if want to detect the node only once. Mean that if the node is removed from the dom and added again, it will not be detected again.
	* @prop
	* @type 		{Boolean}
	* @default 	true
	*/

/***/ }),
/* 337 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = uniqid;
	var uniqidIdx = 0;
	if (!window.sugar) window.sugar = {};
	if (!window.sugar._uniqid) window.sugar._uniqid = 0;

	/**
	 * Generate a uniq id
	 * @example    js
	 * import uniqid from 'coffeekraken-sugar/js/utils/uniqid'
	 * uniqid() // s2
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function uniqid() {
	  // update uniqid idx
	  window.sugar._uniqid++;
	  return "s" + window.sugar._uniqid.toString();
	}

/***/ }),
/* 338 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;
	/**
	 * Polyfill for the Element.matches function
	 *
	 * @name 		matches
	 * @param 		{HTMLElement} 			elm  			The element to check
	 * @param 		{String} 				selector 		The selector to check on the element
	 * @return 		{Boolean} 								If the element match the selector or not
	 *
	 * @example  	js
	 * import matches from 'sugarcss/js/dom/matches'
	 * if (matches(myCoolHTMLElement, '.my-cool-css-selector')) {
	 * 		// the element match the selector
	 * }
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/Element/matches
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function matches(el, selector) {
	  if (el.nodeName == '#comment' || el.nodeName == '#text') {
	    return false;
	  }
	  var p = Element.prototype;
	  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
	    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	  };
	  return f.call(el, selector);
	}

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _fastdom = __webpack_require__(335);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(340);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @name 	inputAdditionalEvents
	 * Add some events on some DOM Elements. Here's the list:
	 * **input/textarea**: `onenter`, `onescape`
	 * @example 	js
	 * import 'coffeekraken-sugar/js/features/inputAdditionalEvents'
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */

	function handleInputAttributes(e) {
		var field = e.target ? e.target : e;
		if (!field || !field.tagName) return;
		switch (field.tagName) {
			case 'INPUT':
			case 'TEXTAREA':
				_fastdom2.default.mutate(function () {
					if (e.keyCode) {
						switch (e.keyCode) {
							case 13:
								// enter
								if (field.hasAttribute('onenter')) {
									eval(field.getAttribute('onenter'));
									(0, _dispatchEvent2.default)(field, 'onenter');
								}
								break;
							case 27:
								if (field.hasAttribute('onescape')) {
									eval(field.getAttribute('onescape'));
									(0, _dispatchEvent2.default)(field, 'onescape');
								}
								break;
						}
					}
				});
				break;
		}
	}

	document.addEventListener('change', handleInputAttributes);
	document.addEventListener('keyup', handleInputAttributes);

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dispatchEvent;

	var _SEvent = __webpack_require__(341);

	var _SEvent2 = _interopRequireDefault(_SEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Helper to quickly display an event with some optional data attached to it
	 *
	 * @name 		dispatchEvent
	 * @param 		{HTMLElement} 					target  		The element to dispatch the event from
	 * @param 		{String} 						name 			The event name to dispatch
	 * @param 		{Mixed} 						data 			The data to attache to the event
	 *
	 * @example  	js
	 * import dispatchEvent from 'sugarcss/js/dom/dispatchEvent'
	 * dispatchEvent(myCoolHTMLElement, 'myCoolEventName', {
	 * 		var1 : 'value1'
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function dispatchEvent(target, name) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  // create new event
	  var e = new _SEvent2.default(name, {
	    detail: data,
	    bubbles: true,
	    cancelable: true
	  });
	  target.dispatchEvent(e);
	}

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;

	var _customEvent = __webpack_require__(342);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _customEvent2.default;

	/**
	 * @constructor
	 * @param  		{String} 	name 		The event name
	 * @param 		{Object} 	settings 	The event settings
	 */

	/**
	 * Set if the event is cancelable or not
	 * @setting
	 * @name 		cancelable
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Set if the event will bubble or not
	 * @setting
	 * @name 		bubbles
	 * @type 		{Boolean}
	 * @default 	true
	 */

	/**
	 * Pass an object that will be sent with the event
	 * @setting
	 * @name 		detail
	 * @type 		{Object}
	 * @default 	null
	 */
	/**
	 * @name 		SEvent
	 * Proxy class to create custom events that can be dispatched
	 * through the standard dispatch method on any HTMLElement
	 *
	 * @example 	js
	 * let myEvent = new SEvent('myCoolEvent', {
	 * 		cancelable : true,
	 * 		bubbles : false,
	 * 		detail : {
	 * 			// some datas to send with the event
	 * 		}
	 * });
	 * // dispatch the event from an HTMLElement
	 * myHTMLElement.dispatch(myEvent);
	 *
	 * @see 		https://www.npmjs.com/package/customevent
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */

/***/ }),
/* 342 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;

	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}

	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */

	module.exports = useNative() ? NativeCustomEvent :

	// IE >= 9
	'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :

	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	var _vue = __webpack_require__(344);

	var _vue2 = _interopRequireDefault(_vue);

	var _githubApi = __webpack_require__(348);

	var _githubApi2 = _interopRequireDefault(_githubApi);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// check if we have already some repos in the localstorage
	var localRepos = localStorage.getItem('coffeekraken-repos');
	if (localRepos) {
		localRepos = JSON.parse(localRepos);
		// check time
		if (localRepos.timestamp < new Date().getTime() - 3600 * 24 * 1000) {
			// fetch new repos
			fetchRepos();
		} else {
			// display repos
			displayRepos(localRepos.repos);
		}
	} else {
		fetchRepos();
	}

	function fetchRepos() {
		var token = 'd27c9ea77d47fd90da48720ebe98277a519ba262';
		var github = new _githubApi2.default({
			user: "olivierbossel",
			token: token.split('').reverse().join('')
		});
		var user = github.getUser();
		user.listRepos({}, function (err, repos) {
			if (!repos) return;
			// filter repos
			var coffeeRepos = repos.filter(function (repo) {
				return repo.owner.login === 'Coffeekraken';
			});
			// save into localstorage
			localStorage.setItem('coffeekraken-repos', JSON.stringify({
				timestamp: new Date().getTime(),
				repos: coffeeRepos
			}));
			// display repos
			displayRepos(coffeeRepos);
		}, function () {});
	}

	// display repos
	function displayRepos(repos) {
		// new Vue component
		_vue2.default.component('coffeekraken-repos', {
			template: '\n\t\t\t<ul class="nav nav--pills">\n\t\t\t\t<li class="nav__item" v-for="repo in repos">\n\t\t\t\t\t<a :href="repo.html_url" :title="repo.name" target="_blank">\n\t\t\t\t\t\t<span class="pill" :class="{ \'pill--secondary\' : repo.name.substr(0,2) === \'s-\' }">\n\t\t\t\t\t\t\t{{repo.name}}\n\t\t\t\t\t\t\t<div class="tooltip tooltip--t tf t-center">\n\t\t\t\t\t\t\t\t{{repo.description}}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t',
			data: function data() {
				return {
					repos: repos
				};
			}
		});

		// new Vue
		new _vue2.default({
			el: document.querySelector('[vue-coffeekraken-repos]')
		});
	}

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
	 * Vue.js v2.6.6
	 * (c) 2014-2019 Evan You
	 * Released under the MIT License.
	 */
	!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Vue=t()}(this,function(){"use strict";var e=Object.freeze({});function t(e){return null==e}function n(e){return null!=e}function r(e){return!0===e}function i(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return null!==e&&"object"==typeof e}var a=Object.prototype.toString;function s(e){return"[object Object]"===a.call(e)}function c(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function u(e){return n(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function l(e){return null==e?"":Array.isArray(e)||s(e)&&e.toString===a?JSON.stringify(e,null,2):String(e)}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function p(e,t){for(var n=Object.create(null),r=e.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var d=p("slot,component",!0),v=p("key,ref,slot,slot-scope,is");function h(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var m=Object.prototype.hasOwnProperty;function y(e,t){return m.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var _=/-(\w)/g,b=g(function(e){return e.replace(_,function(e,t){return t?t.toUpperCase():""})}),$=g(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),w=/\B([A-Z])/g,x=g(function(e){return e.replace(w,"-$1").toLowerCase()});var C=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function A(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function k(e,t){for(var n in t)e[n]=t[n];return e}function O(e){for(var t={},n=0;n<e.length;n++)e[n]&&k(t,e[n]);return t}function S(e,t,n){}var T=function(e,t,n){return!1},E=function(e){return e};function j(e,t){if(e===t)return!0;var n=o(e),r=o(t);if(!n||!r)return!n&&!r&&String(e)===String(t);try{var i=Array.isArray(e),a=Array.isArray(t);if(i&&a)return e.length===t.length&&e.every(function(e,n){return j(e,t[n])});if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||a)return!1;var s=Object.keys(e),c=Object.keys(t);return s.length===c.length&&s.every(function(n){return j(e[n],t[n])})}catch(e){return!1}}function N(e,t){for(var n=0;n<e.length;n++)if(j(e[n],t))return n;return-1}function L(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var M="data-server-rendered",I=["component","directive","filter"],D=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],P={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:T,isReservedAttr:T,isUnknownElement:T,getTagNamespace:S,parsePlatformTagName:E,mustUseProp:T,async:!0,_lifecycleHooks:D};function R(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:!!r,writable:!0,configurable:!0})}var F=new RegExp("[^a-zA-Z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd.$_\\d]");var H,B="__proto__"in{},U="undefined"!=typeof window,z="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,V=z&&WXEnvironment.platform.toLowerCase(),K=U&&window.navigator.userAgent.toLowerCase(),J=K&&/msie|trident/.test(K),q=K&&K.indexOf("msie 9.0")>0,W=K&&K.indexOf("edge/")>0,Z=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===V),G=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),X={}.watch,Y=!1;if(U)try{var Q={};Object.defineProperty(Q,"passive",{get:function(){Y=!0}}),window.addEventListener("test-passive",null,Q)}catch(e){}var ee=function(){return void 0===H&&(H=!U&&!z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),H},te=U&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ne(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,ie="undefined"!=typeof Symbol&&ne(Symbol)&&"undefined"!=typeof Reflect&&ne(Reflect.ownKeys);re="undefined"!=typeof Set&&ne(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var oe=S,ae=0,se=function(){this.id=ae++,this.subs=[]};se.prototype.addSub=function(e){this.subs.push(e)},se.prototype.removeSub=function(e){h(this.subs,e)},se.prototype.depend=function(){se.target&&se.target.addDep(this)},se.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},se.target=null;var ce=[];function ue(e){ce.push(e),se.target=e}function le(){ce.pop(),se.target=ce[ce.length-1]}var fe=function(e,t,n,r,i,o,a,s){this.tag=e,this.data=t,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},pe={child:{configurable:!0}};pe.child.get=function(){return this.componentInstance},Object.defineProperties(fe.prototype,pe);var de=function(e){void 0===e&&(e="");var t=new fe;return t.text=e,t.isComment=!0,t};function ve(e){return new fe(void 0,void 0,void 0,String(e))}function he(e){var t=new fe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var me=Array.prototype,ye=Object.create(me);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(e){var t=me[e];R(ye,e,function(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];var i,o=t.apply(this,n),a=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o})});var ge=Object.getOwnPropertyNames(ye),_e=!0;function be(e){_e=e}var $e=function(e){var t;this.value=e,this.dep=new se,this.vmCount=0,R(e,"__ob__",this),Array.isArray(e)?(B?(t=ye,e.__proto__=t):function(e,t,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];R(e,o,t[o])}}(e,ye,ge),this.observeArray(e)):this.walk(e)};function we(e,t){var n;if(o(e)&&!(e instanceof fe))return y(e,"__ob__")&&e.__ob__ instanceof $e?n=e.__ob__:_e&&!ee()&&(Array.isArray(e)||s(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new $e(e)),t&&n&&n.vmCount++,n}function xe(e,t,n,r,i){var o=new se,a=Object.getOwnPropertyDescriptor(e,t);if(!a||!1!==a.configurable){var s=a&&a.get,c=a&&a.set;s&&!c||2!==arguments.length||(n=e[t]);var u=!i&&we(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=s?s.call(e):n;return se.target&&(o.depend(),u&&(u.dep.depend(),Array.isArray(t)&&function e(t){for(var n=void 0,r=0,i=t.length;r<i;r++)(n=t[r])&&n.__ob__&&n.__ob__.dep.depend(),Array.isArray(n)&&e(n)}(t))),t},set:function(t){var r=s?s.call(e):n;t===r||t!=t&&r!=r||s&&!c||(c?c.call(e,t):n=t,u=!i&&we(t),o.notify())}})}}function Ce(e,t,n){if(Array.isArray(e)&&c(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var r=e.__ob__;return e._isVue||r&&r.vmCount?n:r?(xe(r.value,t,n),r.dep.notify(),n):(e[t]=n,n)}function Ae(e,t){if(Array.isArray(e)&&c(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||y(e,t)&&(delete e[t],n&&n.dep.notify())}}$e.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)xe(e,t[n])},$e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)we(e[t])};var ke=P.optionMergeStrategies;function Oe(e,t){if(!t)return e;for(var n,r,i,o=ie?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++)"__ob__"!==(n=o[a])&&(r=e[n],i=t[n],y(e,n)?r!==i&&s(r)&&s(i)&&Oe(r,i):Ce(e,n,i));return e}function Se(e,t,n){return n?function(){var r="function"==typeof t?t.call(n,n):t,i="function"==typeof e?e.call(n,n):e;return r?Oe(r,i):i}:t?e?function(){return Oe("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Te(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function Ee(e,t,n,r){var i=Object.create(e||null);return t?k(i,t):i}ke.data=function(e,t,n){return n?Se(e,t,n):t&&"function"!=typeof t?e:Se(e,t)},D.forEach(function(e){ke[e]=Te}),I.forEach(function(e){ke[e+"s"]=Ee}),ke.watch=function(e,t,n,r){if(e===X&&(e=void 0),t===X&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var o in k(i,e),t){var a=i[o],s=t[o];a&&!Array.isArray(a)&&(a=[a]),i[o]=a?a.concat(s):Array.isArray(s)?s:[s]}return i},ke.props=ke.methods=ke.inject=ke.computed=function(e,t,n,r){if(!e)return t;var i=Object.create(null);return k(i,e),t&&k(i,t),i},ke.provide=Se;var je=function(e,t){return void 0===t?e:t};function Ne(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var r,i,o={};if(Array.isArray(n))for(r=n.length;r--;)"string"==typeof(i=n[r])&&(o[b(i)]={type:null});else if(s(n))for(var a in n)i=n[a],o[b(a)]=s(i)?i:{type:i};e.props=o}}(t),function(e,t){var n=e.inject;if(n){var r=e.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)r[n[i]]={from:n[i]};else if(s(n))for(var o in n){var a=n[o];r[o]=s(a)?k({from:o},a):{from:a}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var r=t[n];"function"==typeof r&&(t[n]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(e=Ne(e,t.extends,n)),t.mixins))for(var r=0,i=t.mixins.length;r<i;r++)e=Ne(e,t.mixins[r],n);var o,a={};for(o in e)c(o);for(o in t)y(e,o)||c(o);function c(r){var i=ke[r]||je;a[r]=i(e[r],t[r],n,r)}return a}function Le(e,t,n,r){if("string"==typeof n){var i=e[t];if(y(i,n))return i[n];var o=b(n);if(y(i,o))return i[o];var a=$(o);return y(i,a)?i[a]:i[n]||i[o]||i[a]}}function Me(e,t,n,r){var i=t[e],o=!y(n,e),a=n[e],s=Pe(Boolean,i.type);if(s>-1)if(o&&!y(i,"default"))a=!1;else if(""===a||a===x(e)){var c=Pe(String,i.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(e,t,n){if(!y(t,"default"))return;var r=t.default;if(e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n])return e._props[n];return"function"==typeof r&&"Function"!==Ie(t.type)?r.call(e):r}(r,i,e);var u=_e;be(!0),we(a),be(u)}return a}function Ie(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:""}function De(e,t){return Ie(e)===Ie(t)}function Pe(e,t){if(!Array.isArray(t))return De(t,e)?0:-1;for(var n=0,r=t.length;n<r;n++)if(De(t[n],e))return n;return-1}function Re(e,t,n){if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,e,t,n))return}catch(e){He(e,r,"errorCaptured hook")}}He(e,t,n)}function Fe(e,t,n,r,i){var o;try{(o=n?e.apply(t,n):e.call(t))&&!o._isVue&&u(o)&&o.catch(function(e){return Re(e,r,i+" (Promise/async)")})}catch(e){Re(e,r,i)}return o}function He(e,t,n){if(P.errorHandler)try{return P.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Be(t,null,"config.errorHandler")}Be(e,t,n)}function Be(e,t,n){if(!U&&!z||"undefined"==typeof console)throw e;console.error(e)}var Ue,ze=!1,Ve=[],Ke=!1;function Je(){Ke=!1;var e=Ve.slice(0);Ve.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&ne(Promise)){var qe=Promise.resolve();Ue=function(){qe.then(Je),Z&&setTimeout(S)},ze=!0}else if(J||"undefined"==typeof MutationObserver||!ne(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ue="undefined"!=typeof setImmediate&&ne(setImmediate)?function(){setImmediate(Je)}:function(){setTimeout(Je,0)};else{var We=1,Ze=new MutationObserver(Je),Ge=document.createTextNode(String(We));Ze.observe(Ge,{characterData:!0}),Ue=function(){We=(We+1)%2,Ge.data=String(We)},ze=!0}function Xe(e,t){var n;if(Ve.push(function(){if(e)try{e.call(t)}catch(e){Re(e,t,"nextTick")}else n&&n(t)}),Ke||(Ke=!0,Ue()),!e&&"undefined"!=typeof Promise)return new Promise(function(e){n=e})}var Ye=new re;function Qe(e){!function e(t,n){var r,i;var a=Array.isArray(t);if(!a&&!o(t)||Object.isFrozen(t)||t instanceof fe)return;if(t.__ob__){var s=t.__ob__.dep.id;if(n.has(s))return;n.add(s)}if(a)for(r=t.length;r--;)e(t[r],n);else for(i=Object.keys(t),r=i.length;r--;)e(t[i[r]],n)}(e,Ye),Ye.clear()}var et=g(function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),r="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=r?e.slice(1):e,once:n,capture:r,passive:t}});function tt(e,t){function n(){var e=arguments,r=n.fns;if(!Array.isArray(r))return Fe(r,null,arguments,t,"v-on handler");for(var i=r.slice(),o=0;o<i.length;o++)Fe(i[o],null,e,t,"v-on handler")}return n.fns=e,n}function nt(e,n,i,o,a,s){var c,u,l,f;for(c in e)u=e[c],l=n[c],f=et(c),t(u)||(t(l)?(t(u.fns)&&(u=e[c]=tt(u,s)),r(f.once)&&(u=e[c]=a(f.name,u,f.capture)),i(f.name,u,f.capture,f.passive,f.params)):u!==l&&(l.fns=u,e[c]=l));for(c in n)t(e[c])&&o((f=et(c)).name,n[c],f.capture)}function rt(e,i,o){var a;e instanceof fe&&(e=e.data.hook||(e.data.hook={}));var s=e[i];function c(){o.apply(this,arguments),h(a.fns,c)}t(s)?a=tt([c]):n(s.fns)&&r(s.merged)?(a=s).fns.push(c):a=tt([s,c]),a.merged=!0,e[i]=a}function it(e,t,r,i,o){if(n(t)){if(y(t,r))return e[r]=t[r],o||delete t[r],!0;if(y(t,i))return e[r]=t[i],o||delete t[i],!0}return!1}function ot(e){return i(e)?[ve(e)]:Array.isArray(e)?function e(o,a){var s=[];var c,u,l,f;for(c=0;c<o.length;c++)t(u=o[c])||"boolean"==typeof u||(l=s.length-1,f=s[l],Array.isArray(u)?u.length>0&&(at((u=e(u,(a||"")+"_"+c))[0])&&at(f)&&(s[l]=ve(f.text+u[0].text),u.shift()),s.push.apply(s,u)):i(u)?at(f)?s[l]=ve(f.text+u):""!==u&&s.push(ve(u)):at(u)&&at(f)?s[l]=ve(f.text+u.text):(r(o._isVList)&&n(u.tag)&&t(u.key)&&n(a)&&(u.key="__vlist"+a+"_"+c+"__"),s.push(u)));return s}(e):void 0}function at(e){return n(e)&&n(e.text)&&!1===e.isComment}function st(e,t){if(e){for(var n=Object.create(null),r=ie?Reflect.ownKeys(e):Object.keys(e),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){for(var a=e[o].from,s=t;s;){if(s._provided&&y(s._provided,a)){n[o]=s._provided[a];break}s=s.$parent}if(!s&&"default"in e[o]){var c=e[o].default;n[o]="function"==typeof c?c.call(t):c}}}return n}}function ct(e,t){if(!e||!e.length)return{};for(var n={},r=0,i=e.length;r<i;r++){var o=e[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==t&&o.fnContext!==t||!a||null==a.slot)(n.default||(n.default=[])).push(o);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var u in n)n[u].every(ut)&&delete n[u];return n}function ut(e){return e.isComment&&!e.asyncFactory||" "===e.text}function lt(t,n,r){var i;if(t){if(t._normalized)return t._normalized;if(t.$stable&&r&&r!==e&&0===Object.keys(n).length)return r;for(var o in i={},t)t[o]&&"$"!==o[0]&&(i[o]=ft(n,o,t[o]))}else i={};for(var a in n)a in i||(i[a]=pt(n,a));return t&&Object.isExtensible(t)&&(t._normalized=i),R(i,"$stable",!t||!!t.$stable),i}function ft(e,t,n){var r=function(){var e=arguments.length?n.apply(null,arguments):n({});return(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:ot(e))&&0===e.length?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function pt(e,t){return function(){return e[t]}}function dt(e,t){var r,i,a,s,c;if(Array.isArray(e)||"string"==typeof e)for(r=new Array(e.length),i=0,a=e.length;i<a;i++)r[i]=t(e[i],i);else if("number"==typeof e)for(r=new Array(e),i=0;i<e;i++)r[i]=t(i+1,i);else if(o(e))if(ie&&e[Symbol.iterator]){r=[];for(var u=e[Symbol.iterator](),l=u.next();!l.done;)r.push(t(l.value,r.length)),l=u.next()}else for(s=Object.keys(e),r=new Array(s.length),i=0,a=s.length;i<a;i++)c=s[i],r[i]=t(e[c],c,i);return n(r)||(r=[]),r._isVList=!0,r}function vt(e,t,n,r){var i,o=this.$scopedSlots[e];o?(n=n||{},r&&(n=k(k({},r),n)),i=o(n)||t):i=this.$slots[e]||t;var a=n&&n.slot;return a?this.$createElement("template",{slot:a},i):i}function ht(e){return Le(this.$options,"filters",e)||E}function mt(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function yt(e,t,n,r,i){var o=P.keyCodes[t]||n;return i&&r&&!P.keyCodes[t]?mt(i,r):o?mt(o,e):r?x(r)!==t:void 0}function gt(e,t,n,r,i){if(n)if(o(n)){var a;Array.isArray(n)&&(n=O(n));var s=function(o){if("class"===o||"style"===o||v(o))a=e;else{var s=e.attrs&&e.attrs.type;a=r||P.mustUseProp(t,s,o)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var c=b(o);o in a||c in a||(a[o]=n[o],i&&((e.on||(e.on={}))["update:"+c]=function(e){n[o]=e}))};for(var c in n)s(c)}else;return e}function _t(e,t){var n=this._staticTrees||(this._staticTrees=[]),r=n[e];return r&&!t?r:($t(r=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),r)}function bt(e,t,n){return $t(e,"__once__"+t+(n?"_"+n:""),!0),e}function $t(e,t,n){if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&wt(e[r],t+"_"+r,n);else wt(e,t,n)}function wt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function xt(e,t){if(t)if(s(t)){var n=e.on=e.on?k({},e.on):{};for(var r in t){var i=n[r],o=t[r];n[r]=i?[].concat(i,o):o}}else;return e}function Ct(e,t,n){n=n||{$stable:!t};for(var r=0;r<e.length;r++){var i=e[r];Array.isArray(i)?Ct(i,t,n):i&&(i.proxy&&(i.fn.proxy=!0),n[i.key]=i.fn)}return n}function At(e,t){for(var n=0;n<t.length;n+=2){var r=t[n];"string"==typeof r&&r&&(e[t[n]]=t[n+1])}return e}function kt(e,t){return"string"==typeof e?t+e:e}function Ot(e){e._o=bt,e._n=f,e._s=l,e._l=dt,e._t=vt,e._q=j,e._i=N,e._m=_t,e._f=ht,e._k=yt,e._b=gt,e._v=ve,e._e=de,e._u=Ct,e._g=xt,e._d=At,e._p=kt}function St(t,n,i,o,a){var s,c=this,u=a.options;y(o,"_uid")?(s=Object.create(o))._original=o:(s=o,o=o._original);var l=r(u._compiled),f=!l;this.data=t,this.props=n,this.children=i,this.parent=o,this.listeners=t.on||e,this.injections=st(u.inject,o),this.slots=function(){return c.$slots||lt(t.scopedSlots,c.$slots=ct(i,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return lt(t.scopedSlots,this.slots())}}),l&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=lt(t.scopedSlots,this.$slots)),u._scopeId?this._c=function(e,t,n,r){var i=Pt(s,e,t,n,r,f);return i&&!Array.isArray(i)&&(i.fnScopeId=u._scopeId,i.fnContext=o),i}:this._c=function(e,t,n,r){return Pt(s,e,t,n,r,f)}}function Tt(e,t,n,r,i){var o=he(e);return o.fnContext=n,o.fnOptions=r,t.slot&&((o.data||(o.data={})).slot=t.slot),o}function Et(e,t){for(var n in t)e[b(n)]=t[n]}Ot(St.prototype);var jt={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var r=e;jt.prepatch(r,r)}else{(e.componentInstance=function(e,t){var r={_isComponent:!0,_parentVnode:e,parent:t},i=e.data.inlineTemplate;n(i)&&(r.render=i.render,r.staticRenderFns=i.staticRenderFns);return new e.componentOptions.Ctor(r)}(e,qt)).$mount(t?e.elm:void 0,t)}},prepatch:function(t,n){var r=n.componentOptions;!function(t,n,r,i,o){var a=!!(i.data.scopedSlots&&!i.data.scopedSlots.$stable||t.$scopedSlots!==e&&!t.$scopedSlots.$stable),s=!!(o||t.$options._renderChildren||a);t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i);if(t.$options._renderChildren=o,t.$attrs=i.data.attrs||e,t.$listeners=r||e,n&&t.$options.props){be(!1);for(var c=t._props,u=t.$options._propKeys||[],l=0;l<u.length;l++){var f=u[l],p=t.$options.props;c[f]=Me(f,p,n,t)}be(!0),t.$options.propsData=n}r=r||e;var d=t.$options._parentListeners;t.$options._parentListeners=r,Jt(t,r,d),s&&(t.$slots=ct(o,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,r.propsData,r.listeners,n,r.children)},insert:function(e){var t,n=e.context,r=e.componentInstance;r._isMounted||(r._isMounted=!0,Xt(r,"mounted")),e.data.keepAlive&&(n._isMounted?((t=r)._inactive=!1,Qt.push(t)):Gt(r,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?function e(t,n){if(n&&(t._directInactive=!0,Zt(t)))return;if(!t._inactive){t._inactive=!0;for(var r=0;r<t.$children.length;r++)e(t.$children[r]);Xt(t,"deactivated")}}(t,!0):t.$destroy())}},Nt=Object.keys(jt);function Lt(i,a,s,c,l){if(!t(i)){var f=s.$options._base;if(o(i)&&(i=f.extend(i)),"function"==typeof i){var p;if(t(i.cid)&&void 0===(i=function(e,i){if(r(e.error)&&n(e.errorComp))return e.errorComp;if(n(e.resolved))return e.resolved;if(r(e.loading)&&n(e.loadingComp))return e.loadingComp;var a=Ft;if(!n(e.owners)){var s=e.owners=[a],c=!0,l=function(e){for(var t=0,n=s.length;t<n;t++)s[t].$forceUpdate();e&&(s.length=0)},f=L(function(t){e.resolved=Ht(t,i),c?s.length=0:l(!0)}),p=L(function(t){n(e.errorComp)&&(e.error=!0,l(!0))}),d=e(f,p);return o(d)&&(u(d)?t(e.resolved)&&d.then(f,p):u(d.component)&&(d.component.then(f,p),n(d.error)&&(e.errorComp=Ht(d.error,i)),n(d.loading)&&(e.loadingComp=Ht(d.loading,i),0===d.delay?e.loading=!0:setTimeout(function(){t(e.resolved)&&t(e.error)&&(e.loading=!0,l(!1))},d.delay||200)),n(d.timeout)&&setTimeout(function(){t(e.resolved)&&p(null)},d.timeout))),c=!1,e.loading?e.loadingComp:e.resolved}e.owners.push(a)}(p=i,f)))return function(e,t,n,r,i){var o=de();return o.asyncFactory=e,o.asyncMeta={data:t,context:n,children:r,tag:i},o}(p,a,s,c,l);a=a||{},_n(i),n(a.model)&&function(e,t){var r=e.model&&e.model.prop||"value",i=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[r]=t.model.value;var o=t.on||(t.on={}),a=o[i],s=t.model.callback;n(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(o[i]=[s].concat(a)):o[i]=s}(i.options,a);var d=function(e,r,i){var o=r.options.props;if(!t(o)){var a={},s=e.attrs,c=e.props;if(n(s)||n(c))for(var u in o){var l=x(u);it(a,c,u,l,!0)||it(a,s,u,l,!1)}return a}}(a,i);if(r(i.options.functional))return function(t,r,i,o,a){var s=t.options,c={},u=s.props;if(n(u))for(var l in u)c[l]=Me(l,u,r||e);else n(i.attrs)&&Et(c,i.attrs),n(i.props)&&Et(c,i.props);var f=new St(i,c,a,o,t),p=s.render.call(null,f._c,f);if(p instanceof fe)return Tt(p,i,f.parent,s);if(Array.isArray(p)){for(var d=ot(p)||[],v=new Array(d.length),h=0;h<d.length;h++)v[h]=Tt(d[h],i,f.parent,s);return v}}(i,d,a,s,c);var v=a.on;if(a.on=a.nativeOn,r(i.options.abstract)){var h=a.slot;a={},h&&(a.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Nt.length;n++){var r=Nt[n],i=t[r],o=jt[r];i===o||i&&i._merged||(t[r]=i?Mt(o,i):o)}}(a);var m=i.options.name||l;return new fe("vue-component-"+i.cid+(m?"-"+m:""),a,void 0,void 0,void 0,s,{Ctor:i,propsData:d,listeners:v,tag:l,children:c},p)}}}function Mt(e,t){var n=function(n,r){e(n,r),t(n,r)};return n._merged=!0,n}var It=1,Dt=2;function Pt(e,a,s,c,u,l){return(Array.isArray(s)||i(s))&&(u=c,c=s,s=void 0),r(l)&&(u=Dt),function(e,i,a,s,c){if(n(a)&&n(a.__ob__))return de();n(a)&&n(a.is)&&(i=a.is);if(!i)return de();Array.isArray(s)&&"function"==typeof s[0]&&((a=a||{}).scopedSlots={default:s[0]},s.length=0);c===Dt?s=ot(s):c===It&&(s=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(s));var u,l;if("string"==typeof i){var f;l=e.$vnode&&e.$vnode.ns||P.getTagNamespace(i),u=P.isReservedTag(i)?new fe(P.parsePlatformTagName(i),a,s,void 0,void 0,e):a&&a.pre||!n(f=Le(e.$options,"components",i))?new fe(i,a,s,void 0,void 0,e):Lt(f,a,e,s,i)}else u=Lt(i,a,e,s);return Array.isArray(u)?u:n(u)?(n(l)&&function e(i,o,a){i.ns=o;"foreignObject"===i.tag&&(o=void 0,a=!0);if(n(i.children))for(var s=0,c=i.children.length;s<c;s++){var u=i.children[s];n(u.tag)&&(t(u.ns)||r(a)&&"svg"!==u.tag)&&e(u,o,a)}}(u,l),n(a)&&function(e){o(e.style)&&Qe(e.style);o(e.class)&&Qe(e.class)}(a),u):de()}(e,a,s,c,u)}var Rt,Ft=null;function Ht(e,t){return(e.__esModule||ie&&"Module"===e[Symbol.toStringTag])&&(e=e.default),o(e)?t.extend(e):e}function Bt(e){return e.isComment&&e.asyncFactory}function Ut(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var r=e[t];if(n(r)&&(n(r.componentOptions)||Bt(r)))return r}}function zt(e,t){Rt.$on(e,t)}function Vt(e,t){Rt.$off(e,t)}function Kt(e,t){var n=Rt;return function r(){null!==t.apply(null,arguments)&&n.$off(e,r)}}function Jt(e,t,n){Rt=e,nt(t,n||{},zt,Vt,Kt,e),Rt=void 0}var qt=null;function Wt(e){var t=qt;return qt=e,function(){qt=t}}function Zt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Gt(e,t){if(t){if(e._directInactive=!1,Zt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Gt(e.$children[n]);Xt(e,"activated")}}function Xt(e,t){ue();var n=e.$options[t],r=t+" hook";if(n)for(var i=0,o=n.length;i<o;i++)Fe(n[i],e,null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),le()}var Yt=[],Qt=[],en={},tn=!1,nn=!1,rn=0;var on=0,an=Date.now;function sn(){var e,t;for(on=an(),nn=!0,Yt.sort(function(e,t){return e.id-t.id}),rn=0;rn<Yt.length;rn++)(e=Yt[rn]).before&&e.before(),t=e.id,en[t]=null,e.run();var n=Qt.slice(),r=Yt.slice();rn=Yt.length=Qt.length=0,en={},tn=nn=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Gt(e[t],!0)}(n),function(e){var t=e.length;for(;t--;){var n=e[t],r=n.vm;r._watcher===n&&r._isMounted&&!r._isDestroyed&&Xt(r,"updated")}}(r),te&&P.devtools&&te.emit("flush")}U&&an()>document.createEvent("Event").timeStamp&&(an=function(){return performance.now()});var cn=0,un=function(e,t,n,r,i){this.vm=e,i&&(e._watcher=this),e._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!F.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=S)),this.value=this.lazy?void 0:this.get()};un.prototype.get=function(){var e;ue(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Re(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&Qe(e),le(),this.cleanupDeps()}return e},un.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},un.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},un.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==en[t]){if(en[t]=!0,nn){for(var n=Yt.length-1;n>rn&&Yt[n].id>e.id;)n--;Yt.splice(n+1,0,e)}else Yt.push(e);tn||(tn=!0,Xe(sn))}}(this)},un.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||o(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){Re(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},un.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},un.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},un.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||h(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var ln={enumerable:!0,configurable:!0,get:S,set:S};function fn(e,t,n){ln.get=function(){return this[t][n]},ln.set=function(e){this[t][n]=e},Object.defineProperty(e,n,ln)}function pn(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},r=e._props={},i=e.$options._propKeys=[];e.$parent&&be(!1);var o=function(o){i.push(o);var a=Me(o,t,n,e);xe(r,o,a),o in e||fn(e,"_props",o)};for(var a in t)o(a);be(!0)}(e,t.props),t.methods&&function(e,t){e.$options.props;for(var n in t)e[n]="function"!=typeof t[n]?S:C(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;s(t=e._data="function"==typeof t?function(e,t){ue();try{return e.call(t,t)}catch(e){return Re(e,t,"data()"),{}}finally{le()}}(t,e):t||{})||(t={});var n=Object.keys(t),r=e.$options.props,i=(e.$options.methods,n.length);for(;i--;){var o=n[i];r&&y(r,o)||(a=void 0,36!==(a=(o+"").charCodeAt(0))&&95!==a&&fn(e,"_data",o))}var a;we(t,!0)}(e):we(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),r=ee();for(var i in t){var o=t[i],a="function"==typeof o?o:o.get;r||(n[i]=new un(e,a||S,S,dn)),i in e||vn(e,i,o)}}(e,t.computed),t.watch&&t.watch!==X&&function(e,t){for(var n in t){var r=t[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)yn(e,n,r[i]);else yn(e,n,r)}}(e,t.watch)}var dn={lazy:!0};function vn(e,t,n){var r=!ee();"function"==typeof n?(ln.get=r?hn(t):mn(n),ln.set=S):(ln.get=n.get?r&&!1!==n.cache?hn(t):mn(n.get):S,ln.set=n.set||S),Object.defineProperty(e,t,ln)}function hn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),se.target&&t.depend(),t.value}}function mn(e){return function(){return e.call(this,this)}}function yn(e,t,n,r){return s(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,r)}var gn=0;function _n(e){var t=e.options;if(e.super){var n=_n(e.super);if(n!==e.superOptions){e.superOptions=n;var r=function(e){var t,n=e.options,r=e.sealedOptions;for(var i in n)n[i]!==r[i]&&(t||(t={}),t[i]=n[i]);return t}(e);r&&k(e.extendOptions,r),(t=e.options=Ne(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function bn(e){this._init(e)}function $n(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,r=n.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=e.name||n.options.name,a=function(e){this._init(e)};return(a.prototype=Object.create(n.prototype)).constructor=a,a.cid=t++,a.options=Ne(n.options,e),a.super=n,a.options.props&&function(e){var t=e.options.props;for(var n in t)fn(e.prototype,"_props",n)}(a),a.options.computed&&function(e){var t=e.options.computed;for(var n in t)vn(e.prototype,n,t[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,I.forEach(function(e){a[e]=n[e]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=e,a.sealedOptions=k({},a.options),i[r]=a,a}}function wn(e){return e&&(e.Ctor.options.name||e.tag)}function xn(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,"[object RegExp]"===a.call(n)&&e.test(t));var n}function Cn(e,t){var n=e.cache,r=e.keys,i=e._vnode;for(var o in n){var a=n[o];if(a){var s=wn(a.componentOptions);s&&!t(s)&&An(n,o,r,i)}}}function An(e,t,n,r){var i=e[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),e[t]=null,h(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=gn++,n._isVue=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),r=t._parentVnode;n.parent=t.parent,n._parentVnode=r;var i=r.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=Ne(_n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&Jt(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,r=t.$vnode=n._parentVnode,i=r&&r.context;t.$slots=ct(n._renderChildren,i),t.$scopedSlots=e,t._c=function(e,n,r,i){return Pt(t,e,n,r,i,!1)},t.$createElement=function(e,n,r,i){return Pt(t,e,n,r,i,!0)};var o=r&&r.data;xe(t,"$attrs",o&&o.attrs||e,null,!0),xe(t,"$listeners",n._parentListeners||e,null,!0)}(n),Xt(n,"beforeCreate"),function(e){var t=st(e.$options.inject,e);t&&(be(!1),Object.keys(t).forEach(function(n){xe(e,n,t[n])}),be(!0))}(n),pn(n),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(n),Xt(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(bn),function(e){var t={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=Ce,e.prototype.$delete=Ae,e.prototype.$watch=function(e,t,n){if(s(t))return yn(this,e,t,n);(n=n||{}).user=!0;var r=new un(this,e,t,n);if(n.immediate)try{t.call(this,r.value)}catch(e){Re(e,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(bn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var r=this;if(Array.isArray(e))for(var i=0,o=e.length;i<o;i++)r.$on(e[i],n);else(r._events[e]||(r._events[e]=[])).push(n),t.test(e)&&(r._hasHookEvent=!0);return r},e.prototype.$once=function(e,t){var n=this;function r(){n.$off(e,r),t.apply(n,arguments)}return r.fn=t,n.$on(e,r),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var r=0,i=e.length;r<i;r++)n.$off(e[r],t);return n}var o,a=n._events[e];if(!a)return n;if(!t)return n._events[e]=null,n;for(var s=a.length;s--;)if((o=a[s])===t||o.fn===t){a.splice(s,1);break}return n},e.prototype.$emit=function(e){var t=this._events[e];if(t){t=t.length>1?A(t):t;for(var n=A(arguments,1),r='event handler for "'+e+'"',i=0,o=t.length;i<o;i++)Fe(t[i],this,n,this,r)}return this}}(bn),function(e){e.prototype._update=function(e,t){var n=this,r=n.$el,i=n._vnode,o=Wt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),o(),r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Xt(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||h(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Xt(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(bn),function(e){Ot(e.prototype),e.prototype.$nextTick=function(e){return Xe(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,r=n.render,i=n._parentVnode;i&&(t.$scopedSlots=lt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Ft=t,e=r.call(t._renderProxy,t.$createElement)}catch(n){Re(n,t,"render"),e=t._vnode}finally{Ft=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof fe||(e=de()),e.parent=i,e}}(bn);var kn=[String,RegExp,Array],On={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:kn,exclude:kn,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)An(this.cache,e,this.keys)},mounted:function(){var e=this;this.$watch("include",function(t){Cn(e,function(e){return xn(t,e)})}),this.$watch("exclude",function(t){Cn(e,function(e){return!xn(t,e)})})},render:function(){var e=this.$slots.default,t=Ut(e),n=t&&t.componentOptions;if(n){var r=wn(n),i=this.include,o=this.exclude;if(i&&(!r||!xn(i,r))||o&&r&&xn(o,r))return t;var a=this.cache,s=this.keys,c=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;a[c]?(t.componentInstance=a[c].componentInstance,h(s,c),s.push(c)):(a[c]=t,s.push(c),this.max&&s.length>parseInt(this.max)&&An(a,s[0],s,this._vnode)),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return P}};Object.defineProperty(e,"config",t),e.util={warn:oe,extend:k,mergeOptions:Ne,defineReactive:xe},e.set=Ce,e.delete=Ae,e.nextTick=Xe,e.observable=function(e){return we(e),e},e.options=Object.create(null),I.forEach(function(t){e.options[t+"s"]=Object.create(null)}),e.options._base=e,k(e.options.components,On),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=A(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Ne(this.options,e),this}}(e),$n(e),function(e){I.forEach(function(t){e[t]=function(e,n){return n?("component"===t&&s(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}})}(e)}(bn),Object.defineProperty(bn.prototype,"$isServer",{get:ee}),Object.defineProperty(bn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(bn,"FunctionalRenderContext",{value:St}),bn.version="2.6.6";var Sn=p("style,class"),Tn=p("input,textarea,option,select,progress"),En=function(e,t,n){return"value"===n&&Tn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},jn=p("contenteditable,draggable,spellcheck"),Nn=p("events,caret,typing,plaintext-only"),Ln=function(e,t){return Rn(t)||"false"===t?"false":"contenteditable"===e&&Nn(t)?t:"true"},Mn=p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),In="http://www.w3.org/1999/xlink",Dn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},Pn=function(e){return Dn(e)?e.slice(6,e.length):""},Rn=function(e){return null==e||!1===e};function Fn(e){for(var t=e.data,r=e,i=e;n(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(t=Hn(i.data,t));for(;n(r=r.parent);)r&&r.data&&(t=Hn(t,r.data));return function(e,t){if(n(e)||n(t))return Bn(e,Un(t));return""}(t.staticClass,t.class)}function Hn(e,t){return{staticClass:Bn(e.staticClass,t.staticClass),class:n(e.class)?[e.class,t.class]:t.class}}function Bn(e,t){return e?t?e+" "+t:e:t||""}function Un(e){return Array.isArray(e)?function(e){for(var t,r="",i=0,o=e.length;i<o;i++)n(t=Un(e[i]))&&""!==t&&(r&&(r+=" "),r+=t);return r}(e):o(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var zn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Vn=p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Kn=p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Jn=function(e){return Vn(e)||Kn(e)};function qn(e){return Kn(e)?"svg":"math"===e?"math":void 0}var Wn=Object.create(null);var Zn=p("text,number,password,search,email,tel,url");function Gn(e){if("string"==typeof e){var t=document.querySelector(e);return t||document.createElement("div")}return e}var Xn=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e?n:(t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)},createElementNS:function(e,t){return document.createElementNS(zn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),Yn={create:function(e,t){Qn(t)},update:function(e,t){e.data.ref!==t.data.ref&&(Qn(e,!0),Qn(t))},destroy:function(e){Qn(e,!0)}};function Qn(e,t){var r=e.data.ref;if(n(r)){var i=e.context,o=e.componentInstance||e.elm,a=i.$refs;t?Array.isArray(a[r])?h(a[r],o):a[r]===o&&(a[r]=void 0):e.data.refInFor?Array.isArray(a[r])?a[r].indexOf(o)<0&&a[r].push(o):a[r]=[o]:a[r]=o}}var er=new fe("",{},[]),tr=["create","activate","update","remove","destroy"];function nr(e,i){return e.key===i.key&&(e.tag===i.tag&&e.isComment===i.isComment&&n(e.data)===n(i.data)&&function(e,t){if("input"!==e.tag)return!0;var r,i=n(r=e.data)&&n(r=r.attrs)&&r.type,o=n(r=t.data)&&n(r=r.attrs)&&r.type;return i===o||Zn(i)&&Zn(o)}(e,i)||r(e.isAsyncPlaceholder)&&e.asyncFactory===i.asyncFactory&&t(i.asyncFactory.error))}function rr(e,t,r){var i,o,a={};for(i=t;i<=r;++i)n(o=e[i].key)&&(a[o]=i);return a}var ir={create:or,update:or,destroy:function(e){or(e,er)}};function or(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,r,i,o=e===er,a=t===er,s=sr(e.data.directives,e.context),c=sr(t.data.directives,t.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,i.oldArg=r.arg,ur(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(ur(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)ur(u[n],"inserted",t,e)};o?rt(t,"insert",f):f()}l.length&&rt(t,"postpatch",function(){for(var n=0;n<l.length;n++)ur(l[n],"componentUpdated",t,e)});if(!o)for(n in s)c[n]||ur(s[n],"unbind",e,e,a)}(e,t)}var ar=Object.create(null);function sr(e,t){var n,r,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(r=e[n]).modifiers||(r.modifiers=ar),i[cr(r)]=r,r.def=Le(t.$options,"directives",r.name);return i}function cr(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function ur(e,t,n,r,i){var o=e.def&&e.def[t];if(o)try{o(n.elm,e,n,r,i)}catch(r){Re(r,n.context,"directive "+e.name+" "+t+" hook")}}var lr=[Yn,ir];function fr(e,r){var i=r.componentOptions;if(!(n(i)&&!1===i.Ctor.options.inheritAttrs||t(e.data.attrs)&&t(r.data.attrs))){var o,a,s=r.elm,c=e.data.attrs||{},u=r.data.attrs||{};for(o in n(u.__ob__)&&(u=r.data.attrs=k({},u)),u)a=u[o],c[o]!==a&&pr(s,o,a);for(o in(J||W)&&u.value!==c.value&&pr(s,"value",u.value),c)t(u[o])&&(Dn(o)?s.removeAttributeNS(In,Pn(o)):jn(o)||s.removeAttribute(o))}}function pr(e,t,n){e.tagName.indexOf("-")>-1?dr(e,t,n):Mn(t)?Rn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):jn(t)?e.setAttribute(t,Ln(t,n)):Dn(t)?Rn(n)?e.removeAttributeNS(In,Pn(t)):e.setAttributeNS(In,t,n):dr(e,t,n)}function dr(e,t,n){if(Rn(n))e.removeAttribute(t);else{if(J&&!q&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var r=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",r)};e.addEventListener("input",r),e.__ieph=!0}e.setAttribute(t,n)}}var vr={create:fr,update:fr};function hr(e,r){var i=r.elm,o=r.data,a=e.data;if(!(t(o.staticClass)&&t(o.class)&&(t(a)||t(a.staticClass)&&t(a.class)))){var s=Fn(r),c=i._transitionClasses;n(c)&&(s=Bn(s,Un(c))),s!==i._prevClass&&(i.setAttribute("class",s),i._prevClass=s)}}var mr,yr,gr,_r,br,$r,wr={create:hr,update:hr},xr=/[\w).+\-_$\]]/;function Cr(e){var t,n,r,i,o,a=!1,s=!1,c=!1,u=!1,l=0,f=0,p=0,d=0;for(r=0;r<e.length;r++)if(n=t,t=e.charCodeAt(r),a)39===t&&92!==n&&(a=!1);else if(s)34===t&&92!==n&&(s=!1);else if(c)96===t&&92!==n&&(c=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(r+1)||124===e.charCodeAt(r-1)||l||f||p){switch(t){case 34:s=!0;break;case 39:a=!0;break;case 96:c=!0;break;case 40:p++;break;case 41:p--;break;case 91:f++;break;case 93:f--;break;case 123:l++;break;case 125:l--}if(47===t){for(var v=r-1,h=void 0;v>=0&&" "===(h=e.charAt(v));v--);h&&xr.test(h)||(u=!0)}}else void 0===i?(d=r+1,i=e.slice(0,r).trim()):m();function m(){(o||(o=[])).push(e.slice(d,r).trim()),d=r+1}if(void 0===i?i=e.slice(0,r).trim():0!==d&&m(),o)for(r=0;r<o.length;r++)i=Ar(i,o[r]);return i}function Ar(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var r=t.slice(0,n),i=t.slice(n+1);return'_f("'+r+'")('+e+(")"!==i?","+i:i)}function kr(e,t){console.error("[Vue compiler]: "+e)}function Or(e,t){return e?e.map(function(e){return e[t]}).filter(function(e){return e}):[]}function Sr(e,t,n,r,i){(e.props||(e.props=[])).push(Pr({name:t,value:n,dynamic:i},r)),e.plain=!1}function Tr(e,t,n,r,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(Pr({name:t,value:n,dynamic:i},r)),e.plain=!1}function Er(e,t,n,r){e.attrsMap[t]=n,e.attrsList.push(Pr({name:t,value:n},r))}function jr(e,t,n,r,i,o,a,s){(e.directives||(e.directives=[])).push(Pr({name:t,rawName:n,value:r,arg:i,isDynamicArg:o,modifiers:a},s)),e.plain=!1}function Nr(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Lr(t,n,r,i,o,a,s,c){var u;(i=i||e).right?c?n="("+n+")==='click'?'contextmenu':("+n+")":"click"===n&&(n="contextmenu",delete i.right):i.middle&&(c?n="("+n+")==='click'?'mouseup':("+n+")":"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=Nr("!",n,c)),i.once&&(delete i.once,n=Nr("~",n,c)),i.passive&&(delete i.passive,n=Nr("&",n,c)),i.native?(delete i.native,u=t.nativeEvents||(t.nativeEvents={})):u=t.events||(t.events={});var l=Pr({value:r.trim(),dynamic:c},s);i!==e&&(l.modifiers=i);var f=u[n];Array.isArray(f)?o?f.unshift(l):f.push(l):u[n]=f?o?[l,f]:[f,l]:l,t.plain=!1}function Mr(e,t,n){var r=Ir(e,":"+t)||Ir(e,"v-bind:"+t);if(null!=r)return Cr(r);if(!1!==n){var i=Ir(e,t);if(null!=i)return JSON.stringify(i)}}function Ir(e,t,n){var r;if(null!=(r=e.attrsMap[t]))for(var i=e.attrsList,o=0,a=i.length;o<a;o++)if(i[o].name===t){i.splice(o,1);break}return n&&delete e.attrsMap[t],r}function Dr(e,t){for(var n=e.attrsList,r=0,i=n.length;r<i;r++){var o=n[r];if(t.test(o.name))return n.splice(r,1),o}}function Pr(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function Rr(e,t,n){var r=n||{},i=r.number,o="$$v";r.trim&&(o="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(o="_n("+o+")");var a=Fr(t,o);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+a+"}"}}function Fr(e,t){var n=function(e){if(e=e.trim(),mr=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<mr-1)return(_r=e.lastIndexOf("."))>-1?{exp:e.slice(0,_r),key:'"'+e.slice(_r+1)+'"'}:{exp:e,key:null};yr=e,_r=br=$r=0;for(;!Br();)Ur(gr=Hr())?Vr(gr):91===gr&&zr(gr);return{exp:e.slice(0,br),key:e.slice(br+1,$r)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function Hr(){return yr.charCodeAt(++_r)}function Br(){return _r>=mr}function Ur(e){return 34===e||39===e}function zr(e){var t=1;for(br=_r;!Br();)if(Ur(e=Hr()))Vr(e);else if(91===e&&t++,93===e&&t--,0===t){$r=_r;break}}function Vr(e){for(var t=e;!Br()&&(e=Hr())!==t;);}var Kr,Jr="__r",qr="__c";function Wr(e,t,n){var r=Kr;return function i(){null!==t.apply(null,arguments)&&Xr(e,i,n,r)}}var Zr=ze&&!(G&&Number(G[1])<=53);function Gr(e,t,n,r){if(Zr){var i=on,o=t;t=o._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||0===e.timeStamp||e.target.ownerDocument!==document)return o.apply(this,arguments)}}Kr.addEventListener(e,t,Y?{capture:n,passive:r}:n)}function Xr(e,t,n,r){(r||Kr).removeEventListener(e,t._wrapper||t,n)}function Yr(e,r){if(!t(e.data.on)||!t(r.data.on)){var i=r.data.on||{},o=e.data.on||{};Kr=r.elm,function(e){if(n(e[Jr])){var t=J?"change":"input";e[t]=[].concat(e[Jr],e[t]||[]),delete e[Jr]}n(e[qr])&&(e.change=[].concat(e[qr],e.change||[]),delete e[qr])}(i),nt(i,o,Gr,Xr,Wr,r.context),Kr=void 0}}var Qr,ei={create:Yr,update:Yr};function ti(e,r){if(!t(e.data.domProps)||!t(r.data.domProps)){var i,o,a=r.elm,s=e.data.domProps||{},c=r.data.domProps||{};for(i in n(c.__ob__)&&(c=r.data.domProps=k({},c)),s)t(c[i])&&(a[i]="");for(i in c){if(o=c[i],"textContent"===i||"innerHTML"===i){if(r.children&&(r.children.length=0),o===s[i])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===i||o!==s[i])if("value"===i){a._value=o;var u=t(o)?"":String(o);ni(a,u)&&(a.value=u)}else if("innerHTML"===i&&Kn(a.tagName)&&t(a.innerHTML)){(Qr=Qr||document.createElement("div")).innerHTML="<svg>"+o+"</svg>";for(var l=Qr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;l.firstChild;)a.appendChild(l.firstChild)}else a[i]=o}}}function ni(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var r=e.value,i=e._vModifiers;if(n(i)){if(i.number)return f(r)!==f(t);if(i.trim)return r.trim()!==t.trim()}return r!==t}(e,t))}var ri={create:ti,update:ti},ii=g(function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach(function(e){if(e){var r=e.split(n);r.length>1&&(t[r[0].trim()]=r[1].trim())}}),t});function oi(e){var t=ai(e.style);return e.staticStyle?k(e.staticStyle,t):t}function ai(e){return Array.isArray(e)?O(e):"string"==typeof e?ii(e):e}var si,ci=/^--/,ui=/\s*!important$/,li=function(e,t,n){if(ci.test(t))e.style.setProperty(t,n);else if(ui.test(n))e.style.setProperty(x(t),n.replace(ui,""),"important");else{var r=pi(t);if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)e.style[r]=n[i];else e.style[r]=n}},fi=["Webkit","Moz","ms"],pi=g(function(e){if(si=si||document.createElement("div").style,"filter"!==(e=b(e))&&e in si)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<fi.length;n++){var r=fi[n]+t;if(r in si)return r}});function di(e,r){var i=r.data,o=e.data;if(!(t(i.staticStyle)&&t(i.style)&&t(o.staticStyle)&&t(o.style))){var a,s,c=r.elm,u=o.staticStyle,l=o.normalizedStyle||o.style||{},f=u||l,p=ai(r.data.style)||{};r.data.normalizedStyle=n(p.__ob__)?k({},p):p;var d=function(e,t){var n,r={};if(t)for(var i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=oi(i.data))&&k(r,n);(n=oi(e.data))&&k(r,n);for(var o=e;o=o.parent;)o.data&&(n=oi(o.data))&&k(r,n);return r}(r,!0);for(s in f)t(d[s])&&li(c,s,"");for(s in d)(a=d[s])!==f[s]&&li(c,s,null==a?"":a)}}var vi={create:di,update:di},hi=/\s+/;function mi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(hi).forEach(function(t){return e.classList.add(t)}):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function yi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(hi).forEach(function(t){return e.classList.remove(t)}):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",r=" "+t+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function gi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&k(t,_i(e.name||"v")),k(t,e),t}return"string"==typeof e?_i(e):void 0}}var _i=g(function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}}),bi=U&&!q,$i="transition",wi="animation",xi="transition",Ci="transitionend",Ai="animation",ki="animationend";bi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(xi="WebkitTransition",Ci="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ai="WebkitAnimation",ki="webkitAnimationEnd"));var Oi=U?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Si(e){Oi(function(){Oi(e)})}function Ti(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),mi(e,t))}function Ei(e,t){e._transitionClasses&&h(e._transitionClasses,t),yi(e,t)}function ji(e,t,n){var r=Li(e,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===$i?Ci:ki,c=0,u=function(){e.removeEventListener(s,l),n()},l=function(t){t.target===e&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),e.addEventListener(s,l)}var Ni=/\b(transform|all)(,|$)/;function Li(e,t){var n,r=window.getComputedStyle(e),i=(r[xi+"Delay"]||"").split(", "),o=(r[xi+"Duration"]||"").split(", "),a=Mi(i,o),s=(r[Ai+"Delay"]||"").split(", "),c=(r[Ai+"Duration"]||"").split(", "),u=Mi(s,c),l=0,f=0;return t===$i?a>0&&(n=$i,l=a,f=o.length):t===wi?u>0&&(n=wi,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?$i:wi:null)?n===$i?o.length:c.length:0,{type:n,timeout:l,propCount:f,hasTransform:n===$i&&Ni.test(r[xi+"Property"])}}function Mi(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map(function(t,n){return Ii(t)+Ii(e[n])}))}function Ii(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Di(e,r){var i=e.elm;n(i._leaveCb)&&(i._leaveCb.cancelled=!0,i._leaveCb());var a=gi(e.data.transition);if(!t(a)&&!n(i._enterCb)&&1===i.nodeType){for(var s=a.css,c=a.type,u=a.enterClass,l=a.enterToClass,p=a.enterActiveClass,d=a.appearClass,v=a.appearToClass,h=a.appearActiveClass,m=a.beforeEnter,y=a.enter,g=a.afterEnter,_=a.enterCancelled,b=a.beforeAppear,$=a.appear,w=a.afterAppear,x=a.appearCancelled,C=a.duration,A=qt,k=qt.$vnode;k&&k.parent;)A=(k=k.parent).context;var O=!A._isMounted||!e.isRootInsert;if(!O||$||""===$){var S=O&&d?d:u,T=O&&h?h:p,E=O&&v?v:l,j=O&&b||m,N=O&&"function"==typeof $?$:y,M=O&&w||g,I=O&&x||_,D=f(o(C)?C.enter:C),P=!1!==s&&!q,R=Fi(N),F=i._enterCb=L(function(){P&&(Ei(i,E),Ei(i,T)),F.cancelled?(P&&Ei(i,S),I&&I(i)):M&&M(i),i._enterCb=null});e.data.show||rt(e,"insert",function(){var t=i.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),N&&N(i,F)}),j&&j(i),P&&(Ti(i,S),Ti(i,T),Si(function(){Ei(i,S),F.cancelled||(Ti(i,E),R||(Ri(D)?setTimeout(F,D):ji(i,c,F)))})),e.data.show&&(r&&r(),N&&N(i,F)),P||R||F()}}}function Pi(e,r){var i=e.elm;n(i._enterCb)&&(i._enterCb.cancelled=!0,i._enterCb());var a=gi(e.data.transition);if(t(a)||1!==i.nodeType)return r();if(!n(i._leaveCb)){var s=a.css,c=a.type,u=a.leaveClass,l=a.leaveToClass,p=a.leaveActiveClass,d=a.beforeLeave,v=a.leave,h=a.afterLeave,m=a.leaveCancelled,y=a.delayLeave,g=a.duration,_=!1!==s&&!q,b=Fi(v),$=f(o(g)?g.leave:g),w=i._leaveCb=L(function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),_&&(Ei(i,l),Ei(i,p)),w.cancelled?(_&&Ei(i,u),m&&m(i)):(r(),h&&h(i)),i._leaveCb=null});y?y(x):x()}function x(){w.cancelled||(!e.data.show&&i.parentNode&&((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),d&&d(i),_&&(Ti(i,u),Ti(i,p),Si(function(){Ei(i,u),w.cancelled||(Ti(i,l),b||(Ri($)?setTimeout(w,$):ji(i,c,w)))})),v&&v(i,w),_||b||w())}}function Ri(e){return"number"==typeof e&&!isNaN(e)}function Fi(e){if(t(e))return!1;var r=e.fns;return n(r)?Fi(Array.isArray(r)?r[0]:r):(e._length||e.length)>1}function Hi(e,t){!0!==t.data.show&&Di(t)}var Bi=function(e){var o,a,s={},c=e.modules,u=e.nodeOps;for(o=0;o<tr.length;++o)for(s[tr[o]]=[],a=0;a<c.length;++a)n(c[a][tr[o]])&&s[tr[o]].push(c[a][tr[o]]);function l(e){var t=u.parentNode(e);n(t)&&u.removeChild(t,e)}function f(e,t,i,o,a,c,l){if(n(e.elm)&&n(c)&&(e=c[l]=he(e)),e.isRootInsert=!a,!function(e,t,i,o){var a=e.data;if(n(a)){var c=n(e.componentInstance)&&a.keepAlive;if(n(a=a.hook)&&n(a=a.init)&&a(e,!1),n(e.componentInstance))return d(e,t),v(i,e.elm,o),r(c)&&function(e,t,r,i){for(var o,a=e;a.componentInstance;)if(a=a.componentInstance._vnode,n(o=a.data)&&n(o=o.transition)){for(o=0;o<s.activate.length;++o)s.activate[o](er,a);t.push(a);break}v(r,e.elm,i)}(e,t,i,o),!0}}(e,t,i,o)){var f=e.data,p=e.children,m=e.tag;n(m)?(e.elm=e.ns?u.createElementNS(e.ns,m):u.createElement(m,e),g(e),h(e,p,t),n(f)&&y(e,t),v(i,e.elm,o)):r(e.isComment)?(e.elm=u.createComment(e.text),v(i,e.elm,o)):(e.elm=u.createTextNode(e.text),v(i,e.elm,o))}}function d(e,t){n(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,m(e)?(y(e,t),g(e)):(Qn(e),t.push(e))}function v(e,t,r){n(e)&&(n(r)?u.parentNode(r)===e&&u.insertBefore(e,t,r):u.appendChild(e,t))}function h(e,t,n){if(Array.isArray(t))for(var r=0;r<t.length;++r)f(t[r],n,e.elm,null,!0,t,r);else i(e.text)&&u.appendChild(e.elm,u.createTextNode(String(e.text)))}function m(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return n(e.tag)}function y(e,t){for(var r=0;r<s.create.length;++r)s.create[r](er,e);n(o=e.data.hook)&&(n(o.create)&&o.create(er,e),n(o.insert)&&t.push(e))}function g(e){var t;if(n(t=e.fnScopeId))u.setStyleScope(e.elm,t);else for(var r=e;r;)n(t=r.context)&&n(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t),r=r.parent;n(t=qt)&&t!==e.context&&t!==e.fnContext&&n(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t)}function _(e,t,n,r,i,o){for(;r<=i;++r)f(n[r],o,e,t,!1,n,r)}function b(e){var t,r,i=e.data;if(n(i))for(n(t=i.hook)&&n(t=t.destroy)&&t(e),t=0;t<s.destroy.length;++t)s.destroy[t](e);if(n(t=e.children))for(r=0;r<e.children.length;++r)b(e.children[r])}function $(e,t,r,i){for(;r<=i;++r){var o=t[r];n(o)&&(n(o.tag)?(w(o),b(o)):l(o.elm))}}function w(e,t){if(n(t)||n(e.data)){var r,i=s.remove.length+1;for(n(t)?t.listeners+=i:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,i),n(r=e.componentInstance)&&n(r=r._vnode)&&n(r.data)&&w(r,t),r=0;r<s.remove.length;++r)s.remove[r](e,t);n(r=e.data.hook)&&n(r=r.remove)?r(e,t):t()}else l(e.elm)}function x(e,t,r,i){for(var o=r;o<i;o++){var a=t[o];if(n(a)&&nr(e,a))return o}}function C(e,i,o,a,c,l){if(e!==i){n(i.elm)&&n(a)&&(i=a[c]=he(i));var p=i.elm=e.elm;if(r(e.isAsyncPlaceholder))n(i.asyncFactory.resolved)?O(e.elm,i,o):i.isAsyncPlaceholder=!0;else if(r(i.isStatic)&&r(e.isStatic)&&i.key===e.key&&(r(i.isCloned)||r(i.isOnce)))i.componentInstance=e.componentInstance;else{var d,v=i.data;n(v)&&n(d=v.hook)&&n(d=d.prepatch)&&d(e,i);var h=e.children,y=i.children;if(n(v)&&m(i)){for(d=0;d<s.update.length;++d)s.update[d](e,i);n(d=v.hook)&&n(d=d.update)&&d(e,i)}t(i.text)?n(h)&&n(y)?h!==y&&function(e,r,i,o,a){for(var s,c,l,p=0,d=0,v=r.length-1,h=r[0],m=r[v],y=i.length-1,g=i[0],b=i[y],w=!a;p<=v&&d<=y;)t(h)?h=r[++p]:t(m)?m=r[--v]:nr(h,g)?(C(h,g,o,i,d),h=r[++p],g=i[++d]):nr(m,b)?(C(m,b,o,i,y),m=r[--v],b=i[--y]):nr(h,b)?(C(h,b,o,i,y),w&&u.insertBefore(e,h.elm,u.nextSibling(m.elm)),h=r[++p],b=i[--y]):nr(m,g)?(C(m,g,o,i,d),w&&u.insertBefore(e,m.elm,h.elm),m=r[--v],g=i[++d]):(t(s)&&(s=rr(r,p,v)),t(c=n(g.key)?s[g.key]:x(g,r,p,v))?f(g,o,e,h.elm,!1,i,d):nr(l=r[c],g)?(C(l,g,o,i,d),r[c]=void 0,w&&u.insertBefore(e,l.elm,h.elm)):f(g,o,e,h.elm,!1,i,d),g=i[++d]);p>v?_(e,t(i[y+1])?null:i[y+1].elm,i,d,y,o):d>y&&$(0,r,p,v)}(p,h,y,o,l):n(y)?(n(e.text)&&u.setTextContent(p,""),_(p,null,y,0,y.length-1,o)):n(h)?$(0,h,0,h.length-1):n(e.text)&&u.setTextContent(p,""):e.text!==i.text&&u.setTextContent(p,i.text),n(v)&&n(d=v.hook)&&n(d=d.postpatch)&&d(e,i)}}}function A(e,t,i){if(r(i)&&n(e.parent))e.parent.data.pendingInsert=t;else for(var o=0;o<t.length;++o)t[o].data.hook.insert(t[o])}var k=p("attrs,class,staticClass,staticStyle,key");function O(e,t,i,o){var a,s=t.tag,c=t.data,u=t.children;if(o=o||c&&c.pre,t.elm=e,r(t.isComment)&&n(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(n(c)&&(n(a=c.hook)&&n(a=a.init)&&a(t,!0),n(a=t.componentInstance)))return d(t,i),!0;if(n(s)){if(n(u))if(e.hasChildNodes())if(n(a=c)&&n(a=a.domProps)&&n(a=a.innerHTML)){if(a!==e.innerHTML)return!1}else{for(var l=!0,f=e.firstChild,p=0;p<u.length;p++){if(!f||!O(f,u[p],i,o)){l=!1;break}f=f.nextSibling}if(!l||f)return!1}else h(t,u,i);if(n(c)){var v=!1;for(var m in c)if(!k(m)){v=!0,y(t,i);break}!v&&c.class&&Qe(c.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,i,o,a){if(!t(i)){var c,l=!1,p=[];if(t(e))l=!0,f(i,p);else{var d=n(e.nodeType);if(!d&&nr(e,i))C(e,i,p,null,null,a);else{if(d){if(1===e.nodeType&&e.hasAttribute(M)&&(e.removeAttribute(M),o=!0),r(o)&&O(e,i,p))return A(i,p,!0),e;c=e,e=new fe(u.tagName(c).toLowerCase(),{},[],void 0,c)}var v=e.elm,h=u.parentNode(v);if(f(i,p,v._leaveCb?null:h,u.nextSibling(v)),n(i.parent))for(var y=i.parent,g=m(i);y;){for(var _=0;_<s.destroy.length;++_)s.destroy[_](y);if(y.elm=i.elm,g){for(var w=0;w<s.create.length;++w)s.create[w](er,y);var x=y.data.hook.insert;if(x.merged)for(var k=1;k<x.fns.length;k++)x.fns[k]()}else Qn(y);y=y.parent}n(h)?$(0,[e],0,0):n(e.tag)&&b(e)}}return A(i,p,l),i.elm}n(e)&&b(e)}}({nodeOps:Xn,modules:[vr,wr,ei,ri,vi,U?{create:Hi,activate:Hi,remove:function(e,t){!0!==e.data.show?Pi(e,t):t()}}:{}].concat(lr)});q&&document.addEventListener("selectionchange",function(){var e=document.activeElement;e&&e.vmodel&&Zi(e,"input")});var Ui={inserted:function(e,t,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?rt(n,"postpatch",function(){Ui.componentUpdated(e,t,n)}):zi(e,t,n.context),e._vOptions=[].map.call(e.options,Ji)):("textarea"===n.tag||Zn(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",qi),e.addEventListener("compositionend",Wi),e.addEventListener("change",Wi),q&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){zi(e,t,n.context);var r=e._vOptions,i=e._vOptions=[].map.call(e.options,Ji);if(i.some(function(e,t){return!j(e,r[t])}))(e.multiple?t.value.some(function(e){return Ki(e,i)}):t.value!==t.oldValue&&Ki(t.value,i))&&Zi(e,"change")}}};function zi(e,t,n){Vi(e,t,n),(J||W)&&setTimeout(function(){Vi(e,t,n)},0)}function Vi(e,t,n){var r=t.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=N(r,Ji(a))>-1,a.selected!==o&&(a.selected=o);else if(j(Ji(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function Ki(e,t){return t.every(function(t){return!j(t,e)})}function Ji(e){return"_value"in e?e._value:e.value}function qi(e){e.target.composing=!0}function Wi(e){e.target.composing&&(e.target.composing=!1,Zi(e.target,"input"))}function Zi(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Gi(e){return!e.componentInstance||e.data&&e.data.transition?e:Gi(e.componentInstance._vnode)}var Xi={model:Ui,show:{bind:function(e,t,n){var r=t.value,i=(n=Gi(n)).data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i?(n.data.show=!0,Di(n,function(){e.style.display=o})):e.style.display=r?o:"none"},update:function(e,t,n){var r=t.value;!r!=!t.oldValue&&((n=Gi(n)).data&&n.data.transition?(n.data.show=!0,r?Di(n,function(){e.style.display=e.__vOriginalDisplay}):Pi(n,function(){e.style.display="none"})):e.style.display=r?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,r,i){i||(e.style.display=e.__vOriginalDisplay)}}},Yi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Qi(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Qi(Ut(t.children)):e}function eo(e){var t={},n=e.$options;for(var r in n.propsData)t[r]=e[r];var i=n._parentListeners;for(var o in i)t[b(o)]=i[o];return t}function to(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var no=function(e){return e.tag||Bt(e)},ro=function(e){return"show"===e.name},io={name:"transition",props:Yi,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(no)).length){var r=this.mode,o=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return o;var a=Qi(o);if(!a)return o;if(this._leaving)return to(e,o);var s="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?s+"comment":s+a.tag:i(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=eo(this),u=this._vnode,l=Qi(u);if(a.data.directives&&a.data.directives.some(ro)&&(a.data.show=!0),l&&l.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(a,l)&&!Bt(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=k({},c);if("out-in"===r)return this._leaving=!0,rt(f,"afterLeave",function(){t._leaving=!1,t.$forceUpdate()}),to(e,o);if("in-out"===r){if(Bt(a))return u;var p,d=function(){p()};rt(c,"afterEnter",d),rt(c,"enterCancelled",d),rt(f,"delayLeave",function(e){p=e})}}return o}}},oo=k({tag:String,moveClass:String},Yi);function ao(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function so(e){e.data.newPos=e.elm.getBoundingClientRect()}function co(e){var t=e.data.pos,n=e.data.newPos,r=t.left-n.left,i=t.top-n.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}delete oo.mode;var uo={Transition:io,TransitionGroup:{props:oo,beforeMount:function(){var e=this,t=this._update;this._update=function(n,r){var i=Wt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,r)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=eo(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=e(t,null,u),this.removed=l}return e(t,null,o)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(ao),e.forEach(so),e.forEach(co),this._reflow=document.body.offsetHeight,e.forEach(function(e){if(e.data.moved){var n=e.elm,r=n.style;Ti(n,t),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Ci,n._moveCb=function e(r){r&&r.target!==n||r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Ci,e),n._moveCb=null,Ei(n,t))})}}))},methods:{hasMove:function(e,t){if(!bi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach(function(e){yi(n,e)}),mi(n,t),n.style.display="none",this.$el.appendChild(n);var r=Li(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}}};bn.config.mustUseProp=En,bn.config.isReservedTag=Jn,bn.config.isReservedAttr=Sn,bn.config.getTagNamespace=qn,bn.config.isUnknownElement=function(e){if(!U)return!0;if(Jn(e))return!1;if(e=e.toLowerCase(),null!=Wn[e])return Wn[e];var t=document.createElement(e);return e.indexOf("-")>-1?Wn[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Wn[e]=/HTMLUnknownElement/.test(t.toString())},k(bn.options.directives,Xi),k(bn.options.components,uo),bn.prototype.__patch__=U?Bi:S,bn.prototype.$mount=function(e,t){return function(e,t,n){var r;return e.$el=t,e.$options.render||(e.$options.render=de),Xt(e,"beforeMount"),r=function(){e._update(e._render(),n)},new un(e,r,S,{before:function(){e._isMounted&&!e._isDestroyed&&Xt(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,Xt(e,"mounted")),e}(this,e=e&&U?Gn(e):void 0,t)},U&&setTimeout(function(){P.devtools&&te&&te.emit("init",bn)},0);var lo=/\{\{((?:.|\r?\n)+?)\}\}/g,fo=/[-.*+?^${}()|[\]\/\\]/g,po=g(function(e){var t=e[0].replace(fo,"\\$&"),n=e[1].replace(fo,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")});var vo={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=Ir(e,"class");n&&(e.staticClass=JSON.stringify(n));var r=Mr(e,"class",!1);r&&(e.classBinding=r)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}};var ho,mo={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=Ir(e,"style");n&&(e.staticStyle=JSON.stringify(ii(n)));var r=Mr(e,"style",!1);r&&(e.styleBinding=r)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},yo=function(e){return(ho=ho||document.createElement("div")).innerHTML=e,ho.textContent},go=p("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),_o=p("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),bo=p("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),$o=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,wo=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,xo="[a-zA-Z_][\\-\\.0-9_a-zA-Za-zA-Z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]*",Co="((?:"+xo+"\\:)?"+xo+")",Ao=new RegExp("^<"+Co),ko=/^\s*(\/?)>/,Oo=new RegExp("^<\\/"+Co+"[^>]*>"),So=/^<!DOCTYPE [^>]+>/i,To=/^<!\--/,Eo=/^<!\[/,jo=p("script,style,textarea",!0),No={},Lo={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Mo=/&(?:lt|gt|quot|amp|#39);/g,Io=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Do=p("pre,textarea",!0),Po=function(e,t){return e&&Do(e)&&"\n"===t[0]};function Ro(e,t){var n=t?Io:Mo;return e.replace(n,function(e){return Lo[e]})}var Fo,Ho,Bo,Uo,zo,Vo,Ko,Jo,qo=/^@|^v-on:/,Wo=/^v-|^@|^:/,Zo=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Go=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Xo=/^\(|\)$/g,Yo=/^\[.*\]$/,Qo=/:(.*)$/,ea=/^:|^\.|^v-bind:/,ta=/\.[^.]+/g,na=/^v-slot(:|$)|^#/,ra=/[\r\n]/,ia=/\s+/g,oa=g(yo),aa="_empty_";function sa(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:va(t),rawAttrsMap:{},parent:n,children:[]}}function ca(e,t){Fo=t.warn||kr,Vo=t.isPreTag||T,Ko=t.mustUseProp||T,Jo=t.getTagNamespace||T;t.isReservedTag;Bo=Or(t.modules,"transformNode"),Uo=Or(t.modules,"preTransformNode"),zo=Or(t.modules,"postTransformNode"),Ho=t.delimiters;var n,r,i=[],o=!1!==t.preserveWhitespace,a=t.whitespace,s=!1,c=!1;function u(e){if(l(e),s||e.processed||(e=ua(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&fa(n,{exp:e.elseif,block:e}),r&&!e.forbidden)if(e.elseif||e.else)a=e,(u=function(e){var t=e.length;for(;t--;){if(1===e[t].type)return e[t];e.pop()}}(r.children))&&u.if&&fa(u,{exp:a.elseif,block:a});else{if(e.slotScope){var o=e.slotTarget||'"default"';(r.scopedSlots||(r.scopedSlots={}))[o]=e}r.children.push(e),e.parent=r}var a,u;e.children=e.children.filter(function(e){return!e.slotScope}),l(e),e.pre&&(s=!1),Vo(e.tag)&&(c=!1);for(var f=0;f<zo.length;f++)zo[f](e,t)}function l(e){if(!c)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,r,i=[],o=t.expectHTML,a=t.isUnaryTag||T,s=t.canBeLeftOpenTag||T,c=0;e;){if(n=e,r&&jo(r)){var u=0,l=r.toLowerCase(),f=No[l]||(No[l]=new RegExp("([\\s\\S]*?)(</"+l+"[^>]*>)","i")),p=e.replace(f,function(e,n,r){return u=r.length,jo(l)||"noscript"===l||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Po(l,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""});c+=e.length-p.length,e=p,k(l,c-u,c)}else{var d=e.indexOf("<");if(0===d){if(To.test(e)){var v=e.indexOf("--\x3e");if(v>=0){t.shouldKeepComment&&t.comment(e.substring(4,v),c,c+v+3),x(v+3);continue}}if(Eo.test(e)){var h=e.indexOf("]>");if(h>=0){x(h+2);continue}}var m=e.match(So);if(m){x(m[0].length);continue}var y=e.match(Oo);if(y){var g=c;x(y[0].length),k(y[1],g,c);continue}var _=C();if(_){A(_),Po(_.tagName,e)&&x(1);continue}}var b=void 0,$=void 0,w=void 0;if(d>=0){for($=e.slice(d);!(Oo.test($)||Ao.test($)||To.test($)||Eo.test($)||(w=$.indexOf("<",1))<0);)d+=w,$=e.slice(d);b=e.substring(0,d)}d<0&&(b=e),b&&x(b.length),t.chars&&b&&t.chars(b,c-b.length,c)}if(e===n){t.chars&&t.chars(e);break}}function x(t){c+=t,e=e.substring(t)}function C(){var t=e.match(Ao);if(t){var n,r,i={tagName:t[1],attrs:[],start:c};for(x(t[0].length);!(n=e.match(ko))&&(r=e.match(wo)||e.match($o));)r.start=c,x(r[0].length),r.end=c,i.attrs.push(r);if(n)return i.unarySlash=n[1],x(n[0].length),i.end=c,i}}function A(e){var n=e.tagName,c=e.unarySlash;o&&("p"===r&&bo(n)&&k(r),s(n)&&r===n&&k(n));for(var u=a(n)||!!c,l=e.attrs.length,f=new Array(l),p=0;p<l;p++){var d=e.attrs[p],v=d[3]||d[4]||d[5]||"",h="a"===n&&"href"===d[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;f[p]={name:d[1],value:Ro(v,h)}}u||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:f,start:e.start,end:e.end}),r=n),t.start&&t.start(n,f,u,e.start,e.end)}function k(e,n,o){var a,s;if(null==n&&(n=c),null==o&&(o=c),e)for(s=e.toLowerCase(),a=i.length-1;a>=0&&i[a].lowerCasedTag!==s;a--);else a=0;if(a>=0){for(var u=i.length-1;u>=a;u--)t.end&&t.end(i[u].tag,n,o);i.length=a,r=a&&i[a-1].tag}else"br"===s?t.start&&t.start(e,[],!0,n,o):"p"===s&&(t.start&&t.start(e,[],!1,n,o),t.end&&t.end(e,n,o))}k()}(e,{warn:Fo,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,o,a,l){var f=r&&r.ns||Jo(e);J&&"svg"===f&&(o=function(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];ha.test(r.name)||(r.name=r.name.replace(ma,""),t.push(r))}return t}(o));var p,d=sa(e,o,r);f&&(d.ns=f),"style"!==(p=d).tag&&("script"!==p.tag||p.attrsMap.type&&"text/javascript"!==p.attrsMap.type)||ee()||(d.forbidden=!0);for(var v=0;v<Uo.length;v++)d=Uo[v](d,t)||d;s||(!function(e){null!=Ir(e,"v-pre")&&(e.pre=!0)}(d),d.pre&&(s=!0)),Vo(d.tag)&&(c=!0),s?function(e){var t=e.attrsList,n=t.length;if(n)for(var r=e.attrs=new Array(n),i=0;i<n;i++)r[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(r[i].start=t[i].start,r[i].end=t[i].end);else e.pre||(e.plain=!0)}(d):d.processed||(la(d),function(e){var t=Ir(e,"v-if");if(t)e.if=t,fa(e,{exp:t,block:e});else{null!=Ir(e,"v-else")&&(e.else=!0);var n=Ir(e,"v-else-if");n&&(e.elseif=n)}}(d),function(e){null!=Ir(e,"v-once")&&(e.once=!0)}(d)),n||(n=d),a?u(d):(r=d,i.push(d))},end:function(e,t,n){var o=i[i.length-1];i.length-=1,r=i[i.length-1],u(o)},chars:function(e,t,n){if(r&&(!J||"textarea"!==r.tag||r.attrsMap.placeholder!==e)){var i,u,l,f=r.children;if(e=c||e.trim()?"script"===(i=r).tag||"style"===i.tag?e:oa(e):f.length?a?"condense"===a&&ra.test(e)?"":" ":o?" ":"":"")"condense"===a&&(e=e.replace(ia," ")),!s&&" "!==e&&(u=function(e,t){var n=t?po(t):lo;if(n.test(e)){for(var r,i,o,a=[],s=[],c=n.lastIndex=0;r=n.exec(e);){(i=r.index)>c&&(s.push(o=e.slice(c,i)),a.push(JSON.stringify(o)));var u=Cr(r[1].trim());a.push("_s("+u+")"),s.push({"@binding":u}),c=i+r[0].length}return c<e.length&&(s.push(o=e.slice(c)),a.push(JSON.stringify(o))),{expression:a.join("+"),tokens:s}}}(e,Ho))?l={type:2,expression:u.expression,tokens:u.tokens,text:e}:" "===e&&f.length&&" "===f[f.length-1].text||(l={type:3,text:e}),l&&f.push(l)}},comment:function(e,t,n){if(r){var i={type:3,text:e,isComment:!0};r.children.push(i)}}}),n}function ua(e,t){var n,r;(r=Mr(n=e,"key"))&&(n.key=r),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Mr(e,"ref");t&&(e.ref=t,e.refInFor=function(e){var t=e;for(;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=Ir(e,"scope"),e.slotScope=t||Ir(e,"slot-scope")):(t=Ir(e,"slot-scope"))&&(e.slotScope=t);var n=Mr(e,"slot");n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Tr(e,"slot",n,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot")));if("template"===e.tag){var r=Dr(e,na);if(r){var i=pa(r),o=i.name,a=i.dynamic;e.slotTarget=o,e.slotTargetDynamic=a,e.slotScope=r.value||aa}}else{var s=Dr(e,na);if(s){var c=e.scopedSlots||(e.scopedSlots={}),u=pa(s),l=u.name,f=u.dynamic,p=c[l]=sa("template",[],e);p.slotTarget=l,p.slotTargetDynamic=f,p.children=e.children.filter(function(e){if(!e.slotScope)return e.parent=p,!0}),p.slotScope=s.value||aa,e.children=[],e.plain=!1}}}(e),function(e){"slot"===e.tag&&(e.slotName=Mr(e,"name"))}(e),function(e){var t;(t=Mr(e,"is"))&&(e.component=t);null!=Ir(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var i=0;i<Bo.length;i++)e=Bo[i](e,t)||e;return function(e){var t,n,r,i,o,a,s,c,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(r=i=u[t].name,o=u[t].value,Wo.test(r))if(e.hasBindings=!0,(a=da(r.replace(Wo,"")))&&(r=r.replace(ta,"")),ea.test(r))r=r.replace(ea,""),o=Cr(o),(c=Yo.test(r))&&(r=r.slice(1,-1)),a&&(a.prop&&!c&&"innerHtml"===(r=b(r))&&(r="innerHTML"),a.camel&&!c&&(r=b(r)),a.sync&&(s=Fr(o,"$event"),c?Lr(e,'"update:"+('+r+")",s,null,!1,0,u[t],!0):(Lr(e,"update:"+b(r),s,null,!1,0,u[t]),x(r)!==b(r)&&Lr(e,"update:"+x(r),s,null,!1,0,u[t])))),a&&a.prop||!e.component&&Ko(e.tag,e.attrsMap.type,r)?Sr(e,r,o,u[t],c):Tr(e,r,o,u[t],c);else if(qo.test(r))r=r.replace(qo,""),(c=Yo.test(r))&&(r=r.slice(1,-1)),Lr(e,r,o,a,!1,0,u[t],c);else{var l=(r=r.replace(Wo,"")).match(Qo),f=l&&l[1];c=!1,f&&(r=r.slice(0,-(f.length+1)),Yo.test(f)&&(f=f.slice(1,-1),c=!0)),jr(e,r,i,o,f,c,a,u[t])}else Tr(e,r,JSON.stringify(o),u[t]),!e.component&&"muted"===r&&Ko(e.tag,e.attrsMap.type,r)&&Sr(e,r,"true",u[t])}(e),e}function la(e){var t;if(t=Ir(e,"v-for")){var n=function(e){var t=e.match(Zo);if(!t)return;var n={};n.for=t[2].trim();var r=t[1].trim().replace(Xo,""),i=r.match(Go);i?(n.alias=r.replace(Go,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=r;return n}(t);n&&k(e,n)}}function fa(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function pa(e){var t=e.name.replace(na,"");return t||"#"!==e.name[0]&&(t="default"),Yo.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function da(e){var t=e.match(ta);if(t){var n={};return t.forEach(function(e){n[e.slice(1)]=!0}),n}}function va(e){for(var t={},n=0,r=e.length;n<r;n++)t[e[n].name]=e[n].value;return t}var ha=/^xmlns:NS\d+/,ma=/^NS\d+:/;function ya(e){return sa(e.tag,e.attrsList.slice(),e.parent)}var ga=[vo,mo,{preTransformNode:function(e,t){if("input"===e.tag){var n,r=e.attrsMap;if(!r["v-model"])return;if((r[":type"]||r["v-bind:type"])&&(n=Mr(e,"type")),r.type||n||!r["v-bind"]||(n="("+r["v-bind"]+").type"),n){var i=Ir(e,"v-if",!0),o=i?"&&("+i+")":"",a=null!=Ir(e,"v-else",!0),s=Ir(e,"v-else-if",!0),c=ya(e);la(c),Er(c,"type","checkbox"),ua(c,t),c.processed=!0,c.if="("+n+")==='checkbox'"+o,fa(c,{exp:c.if,block:c});var u=ya(e);Ir(u,"v-for",!0),Er(u,"type","radio"),ua(u,t),fa(c,{exp:"("+n+")==='radio'"+o,block:u});var l=ya(e);return Ir(l,"v-for",!0),Er(l,":type",n),ua(l,t),fa(c,{exp:i,block:l}),a?c.else=!0:s&&(c.elseif=s),c}}}}];var _a,ba,$a={expectHTML:!0,modules:ga,directives:{model:function(e,t,n){var r=t.value,i=t.modifiers,o=e.tag,a=e.attrsMap.type;if(e.component)return Rr(e,r,i),!1;if("select"===o)!function(e,t,n){var r='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";r=r+" "+Fr(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),Lr(e,"change",r,null,!0)}(e,r,i);else if("input"===o&&"checkbox"===a)!function(e,t,n){var r=n&&n.number,i=Mr(e,"value")||"null",o=Mr(e,"true-value")||"true",a=Mr(e,"false-value")||"false";Sr(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===o?":("+t+")":":_q("+t+","+o+")")),Lr(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Fr(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Fr(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Fr(t,"$$c")+"}",null,!0)}(e,r,i);else if("input"===o&&"radio"===a)!function(e,t,n){var r=n&&n.number,i=Mr(e,"value")||"null";Sr(e,"checked","_q("+t+","+(i=r?"_n("+i+")":i)+")"),Lr(e,"change",Fr(t,i),null,!0)}(e,r,i);else if("input"===o||"textarea"===o)!function(e,t,n){var r=e.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?Jr:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=Fr(t,l);c&&(f="if($event.target.composing)return;"+f),Sr(e,"value","("+t+")"),Lr(e,u,f,null,!0),(s||a)&&Lr(e,"blur","$forceUpdate()")}(e,r,i);else if(!P.isReservedTag(o))return Rr(e,r,i),!1;return!0},text:function(e,t){t.value&&Sr(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Sr(e,"innerHTML","_s("+t.value+")",t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:go,mustUseProp:En,canBeLeftOpenTag:_o,isReservedTag:Jn,getTagNamespace:qn,staticKeys:function(e){return e.reduce(function(e,t){return e.concat(t.staticKeys||[])},[]).join(",")}(ga)},wa=g(function(e){return p("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))});function xa(e,t){e&&(_a=wa(t.staticKeys||""),ba=t.isReservedTag||T,function e(t){t.static=function(e){if(2===e.type)return!1;if(3===e.type)return!0;return!(!e.pre&&(e.hasBindings||e.if||e.for||d(e.tag)||!ba(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(_a)))}(t);if(1===t.type){if(!ba(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var n=0,r=t.children.length;n<r;n++){var i=t.children[n];e(i),i.static||(t.static=!1)}if(t.ifConditions)for(var o=1,a=t.ifConditions.length;o<a;o++){var s=t.ifConditions[o].block;e(s),s.static||(t.static=!1)}}}(e),function e(t,n){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=n),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var r=0,i=t.children.length;r<i;r++)e(t.children[r],n||!!t.for);if(t.ifConditions)for(var o=1,a=t.ifConditions.length;o<a;o++)e(t.ifConditions[o].block,n)}}(e,!1))}var Ca=/^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,Aa=/\([^)]*?\);*$/,ka=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Oa={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Sa={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Ta=function(e){return"if("+e+")return null;"},Ea={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Ta("$event.target !== $event.currentTarget"),ctrl:Ta("!$event.ctrlKey"),shift:Ta("!$event.shiftKey"),alt:Ta("!$event.altKey"),meta:Ta("!$event.metaKey"),left:Ta("'button' in $event && $event.button !== 0"),middle:Ta("'button' in $event && $event.button !== 1"),right:Ta("'button' in $event && $event.button !== 2")};function ja(e,t){var n=t?"nativeOn:":"on:",r="",i="";for(var o in e){var a=Na(e[o]);e[o]&&e[o].dynamic?i+=o+","+a+",":r+='"'+o+'":'+a+","}return r="{"+r.slice(0,-1)+"}",i?n+"_d("+r+",["+i.slice(0,-1)+"])":n+r}function Na(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map(function(e){return Na(e)}).join(",")+"]";var t=ka.test(e.value),n=Ca.test(e.value),r=ka.test(e.value.replace(Aa,""));if(e.modifiers){var i="",o="",a=[];for(var s in e.modifiers)if(Ea[s])o+=Ea[s],Oa[s]&&a.push(s);else if("exact"===s){var c=e.modifiers;o+=Ta(["ctrl","shift","alt","meta"].filter(function(e){return!c[e]}).map(function(e){return"$event."+e+"Key"}).join("||"))}else a.push(s);return a.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(La).join("&&")+")return null;"}(a)),o&&(i+=o),"function($event){"+i+(t?"return "+e.value+"($event)":n?"return ("+e.value+")($event)":r?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(r?"return "+e.value:e.value)+"}"}function La(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Oa[e],r=Sa[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(r)+")"}var Ma={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:S},Ia=function(e){this.options=e,this.warn=e.warn||kr,this.transforms=Or(e.modules,"transformCode"),this.dataGenFns=Or(e.modules,"genData"),this.directives=k(k({},Ma),e.directives);var t=e.isReservedTag||T;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Da(e,t){var n=new Ia(t);return{render:"with(this){return "+(e?Pa(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function Pa(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Ra(e,t);if(e.once&&!e.onceProcessed)return Fa(e,t);if(e.for&&!e.forProcessed)return Ba(e,t);if(e.if&&!e.ifProcessed)return Ha(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',r=Ka(e,t),i="_t("+n+(r?","+r:""),o=e.attrs||e.dynamicAttrs?Wa((e.attrs||[]).concat(e.dynamicAttrs||[]).map(function(e){return{name:b(e.name),value:e.value,dynamic:e.dynamic}})):null,a=e.attrsMap["v-bind"];!o&&!a||r||(i+=",null");o&&(i+=","+o);a&&(i+=(o?"":",null")+","+a);return i+")"}(e,t);var n;if(e.component)n=function(e,t,n){var r=t.inlineTemplate?null:Ka(t,n,!0);return"_c("+e+","+Ua(t,n)+(r?","+r:"")+")"}(e.component,e,t);else{var r;(!e.plain||e.pre&&t.maybeComponent(e))&&(r=Ua(e,t));var i=e.inlineTemplate?null:Ka(e,t,!0);n="_c('"+e.tag+"'"+(r?","+r:"")+(i?","+i:"")+")"}for(var o=0;o<t.transforms.length;o++)n=t.transforms[o](e,n);return n}return Ka(e,t)||"void 0"}function Ra(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+Pa(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function Fa(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Ha(e,t);if(e.staticInFor){for(var n="",r=e.parent;r;){if(r.for){n=r.key;break}r=r.parent}return n?"_o("+Pa(e,t)+","+t.onceId+++","+n+")":Pa(e,t)}return Ra(e,t)}function Ha(e,t,n,r){return e.ifProcessed=!0,function e(t,n,r,i){if(!t.length)return i||"_e()";var o=t.shift();return o.exp?"("+o.exp+")?"+a(o.block)+":"+e(t,n,r,i):""+a(o.block);function a(e){return r?r(e,n):e.once?Fa(e,n):Pa(e,n)}}(e.ifConditions.slice(),t,n,r)}function Ba(e,t,n,r){var i=e.for,o=e.alias,a=e.iterator1?","+e.iterator1:"",s=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(r||"_l")+"(("+i+"),function("+o+a+s+"){return "+(n||Pa)(e,t)+"})"}function Ua(e,t){var n="{",r=function(e,t){var n=e.directives;if(!n)return;var r,i,o,a,s="directives:[",c=!1;for(r=0,i=n.length;r<i;r++){o=n[r],a=!0;var u=t.directives[o.name];u&&(a=!!u(e,o,t.warn)),a&&(c=!0,s+='{name:"'+o.name+'",rawName:"'+o.rawName+'"'+(o.value?",value:("+o.value+"),expression:"+JSON.stringify(o.value):"")+(o.arg?",arg:"+(o.isDynamicArg?o.arg:'"'+o.arg+'"'):"")+(o.modifiers?",modifiers:"+JSON.stringify(o.modifiers):"")+"},")}if(c)return s.slice(0,-1)+"]"}(e,t);r&&(n+=r+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:"+Wa(e.attrs)+","),e.props&&(n+="domProps:"+Wa(e.props)+","),e.events&&(n+=ja(e.events,!1)+","),e.nativeEvents&&(n+=ja(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var r=Object.keys(t).some(function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||za(n)});if(!r)for(var i=e.parent;i;){if(i.slotScope&&i.slotScope!==aa){r=!0;break}i=i.parent}return"scopedSlots:_u(["+Object.keys(t).map(function(e){return Va(t[e],n)}).join(",")+"]"+(r?",true":"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var o=function(e,t){var n=e.children[0];if(n&&1===n.type){var r=Da(n,t.options);return"inlineTemplate:{render:function(){"+r.render+"},staticRenderFns:["+r.staticRenderFns.map(function(e){return"function(){"+e+"}"}).join(",")+"]}"}}(e,t);o&&(n+=o+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+Wa(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function za(e){return 1===e.type&&("slot"===e.tag||e.children.some(za))}function Va(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Ha(e,t,Va,"null");if(e.for&&!e.forProcessed)return Ba(e,t,Va);var r=e.slotScope===aa?"":String(e.slotScope),i="function("+r+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(Ka(e,t)||"undefined")+":undefined":Ka(e,t)||"undefined":Pa(e,t))+"}",o=r?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+i+o+"}"}function Ka(e,t,n,r,i){var o=e.children;if(o.length){var a=o[0];if(1===o.length&&a.for&&"template"!==a.tag&&"slot"!==a.tag){var s=n?t.maybeComponent(a)?",1":",0":"";return""+(r||Pa)(a,t)+s}var c=n?function(e,t){for(var n=0,r=0;r<e.length;r++){var i=e[r];if(1===i.type){if(Ja(i)||i.ifConditions&&i.ifConditions.some(function(e){return Ja(e.block)})){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some(function(e){return t(e.block)}))&&(n=1)}}return n}(o,t.maybeComponent):0,u=i||qa;return"["+o.map(function(e){return u(e,t)}).join(",")+"]"+(c?","+c:"")}}function Ja(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function qa(e,t){return 1===e.type?Pa(e,t):3===e.type&&e.isComment?(r=e,"_e("+JSON.stringify(r.text)+")"):"_v("+(2===(n=e).type?n.expression:Za(JSON.stringify(n.text)))+")";var n,r}function Wa(e){for(var t="",n="",r=0;r<e.length;r++){var i=e[r],o=Za(i.value);i.dynamic?n+=i.name+","+o+",":t+='"'+i.name+'":'+o+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function Za(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b");function Ga(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),S}}function Xa(e){var t=Object.create(null);return function(n,r,i){(r=k({},r)).warn;delete r.warn;var o=r.delimiters?String(r.delimiters)+n:n;if(t[o])return t[o];var a=e(n,r),s={},c=[];return s.render=Ga(a.render,c),s.staticRenderFns=a.staticRenderFns.map(function(e){return Ga(e,c)}),t[o]=s}}var Ya,Qa,es=(Ya=function(e,t){var n=ca(e.trim(),t);!1!==t.optimize&&xa(n,t);var r=Da(n,t);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}},function(e){function t(t,n){var r=Object.create(e),i=[],o=[];if(n)for(var a in n.modules&&(r.modules=(e.modules||[]).concat(n.modules)),n.directives&&(r.directives=k(Object.create(e.directives||null),n.directives)),n)"modules"!==a&&"directives"!==a&&(r[a]=n[a]);r.warn=function(e,t,n){(n?o:i).push(e)};var s=Ya(t.trim(),r);return s.errors=i,s.tips=o,s}return{compile:t,compileToFunctions:Xa(t)}})($a),ts=(es.compile,es.compileToFunctions);function ns(e){return(Qa=Qa||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Qa.innerHTML.indexOf("&#10;")>0}var rs=!!U&&ns(!1),is=!!U&&ns(!0),os=g(function(e){var t=Gn(e);return t&&t.innerHTML}),as=bn.prototype.$mount;return bn.prototype.$mount=function(e,t){if((e=e&&Gn(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=os(r));else{if(!r.nodeType)return this;r=r.innerHTML}else e&&(r=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(r){var i=ts(r,{outputSourceRange:!1,shouldDecodeNewlines:rs,shouldDecodeNewlinesForHref:is,delimiters:n.delimiters,comments:n.comments},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return as.call(this,e,t)},bn.compile=ts,bn});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(345).setImmediate))

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
	            (typeof self !== "undefined" && self) ||
	            window;
	var apply = Function.prototype.apply;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(scope, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// setimmediate attaches itself to the global object
	__webpack_require__(346);
	// On some exotic environments, it's not clear which object `setimmediate` was
	// able to install onto.  Search each possibility in the same order as the
	// `setimmediate` library.
	exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
	                       (typeof global !== "undefined" && global.setImmediate) ||
	                       (this && this.setImmediate);
	exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
	                         (typeof global !== "undefined" && global.clearImmediate) ||
	                         (this && this.clearImmediate);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";

	    if (global.setImmediate) {
	        return;
	    }

	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;

	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }

	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }

	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }

	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }

	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }

	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }

	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };

	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }

	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }

	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };

	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }

	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }

	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }

	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();

	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();

	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();

	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();

	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }

	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(347)))

/***/ }),
/* 347 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	/* eslint valid-jsdoc: ["error", {"requireReturnDescription": false}] */

	var _Gist = __webpack_require__(349);

	var _Gist2 = _interopRequireDefault(_Gist);

	var _User = __webpack_require__(380);

	var _User2 = _interopRequireDefault(_User);

	var _Issue = __webpack_require__(381);

	var _Issue2 = _interopRequireDefault(_Issue);

	var _Search = __webpack_require__(382);

	var _Search2 = _interopRequireDefault(_Search);

	var _RateLimit = __webpack_require__(383);

	var _RateLimit2 = _interopRequireDefault(_RateLimit);

	var _Repository = __webpack_require__(384);

	var _Repository2 = _interopRequireDefault(_Repository);

	var _Organization = __webpack_require__(391);

	var _Organization2 = _interopRequireDefault(_Organization);

	var _Team = __webpack_require__(392);

	var _Team2 = _interopRequireDefault(_Team);

	var _Markdown = __webpack_require__(393);

	var _Markdown2 = _interopRequireDefault(_Markdown);

	var _Project = __webpack_require__(394);

	var _Project2 = _interopRequireDefault(_Project);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * GitHub encapsulates the functionality to create various API wrapper objects.
	 */
	var GitHub = function () {
	  /**
	   * Create a new GitHub.
	   * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is
	   *                                  not provided requests will be made unauthenticated
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function GitHub(auth) {
	    var apiBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'https://api.github.com';

	    _classCallCheck(this, GitHub);

	    this.__apiBase = apiBase;
	    this.__auth = auth || {};
	  }

	  /**
	   * Create a new Gist wrapper
	   * @param {number} [id] - the id for the gist, leave undefined when creating a new gist
	   * @return {Gist}
	   */


	  _createClass(GitHub, [{
	    key: 'getGist',
	    value: function getGist(id) {
	      return new _Gist2.default(id, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new User wrapper
	     * @param {string} [user] - the name of the user to get information about
	     *                        leave undefined for the authenticated user
	     * @return {User}
	     */

	  }, {
	    key: 'getUser',
	    value: function getUser(user) {
	      return new _User2.default(user, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Organization wrapper
	     * @param {string} organization - the name of the organization
	     * @return {Organization}
	     */

	  }, {
	    key: 'getOrganization',
	    value: function getOrganization(organization) {
	      return new _Organization2.default(organization, this.__auth, this.__apiBase);
	    }

	    /**
	     * create a new Team wrapper
	     * @param {string} teamId - the name of the team
	     * @return {team}
	     */

	  }, {
	    key: 'getTeam',
	    value: function getTeam(teamId) {
	      return new _Team2.default(teamId, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Repository wrapper
	     * @param {string} user - the user who owns the respository
	     * @param {string} repo - the name of the repository
	     * @return {Repository}
	     */

	  }, {
	    key: 'getRepo',
	    value: function getRepo(user, repo) {
	      return new _Repository2.default(this._getFullName(user, repo), this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Issue wrapper
	     * @param {string} user - the user who owns the respository
	     * @param {string} repo - the name of the repository
	     * @return {Issue}
	     */

	  }, {
	    key: 'getIssues',
	    value: function getIssues(user, repo) {
	      return new _Issue2.default(this._getFullName(user, repo), this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Search wrapper
	     * @param {string} query - the query to search for
	     * @return {Search}
	     */

	  }, {
	    key: 'search',
	    value: function search(query) {
	      return new _Search2.default(query, this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new RateLimit wrapper
	     * @return {RateLimit}
	     */

	  }, {
	    key: 'getRateLimit',
	    value: function getRateLimit() {
	      return new _RateLimit2.default(this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Markdown wrapper
	     * @return {Markdown}
	     */

	  }, {
	    key: 'getMarkdown',
	    value: function getMarkdown() {
	      return new _Markdown2.default(this.__auth, this.__apiBase);
	    }

	    /**
	     * Create a new Project wrapper
	     * @param {string} id - the id of the project
	     * @return {Markdown}
	     */

	  }, {
	    key: 'getProject',
	    value: function getProject(id) {
	      return new _Project2.default(id, this.__auth, this.__apiBase);
	    }

	    /**
	     * Computes the full repository name
	     * @param {string} user - the username (or the full name)
	     * @param {string} repo - the repository name, must not be passed if `user` is the full name
	     * @return {string} the repository's full name
	     */

	  }, {
	    key: '_getFullName',
	    value: function _getFullName(user, repo) {
	      var fullname = user;

	      if (repo) {
	        fullname = user + '/' + repo;
	      }

	      return fullname;
	    }
	  }]);

	  return GitHub;
	}();

	module.exports = GitHub;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkdpdEh1Yi5qcyJdLCJuYW1lcyI6WyJHaXRIdWIiLCJhdXRoIiwiYXBpQmFzZSIsIl9fYXBpQmFzZSIsIl9fYXV0aCIsImlkIiwidXNlciIsIm9yZ2FuaXphdGlvbiIsInRlYW1JZCIsInJlcG8iLCJfZ2V0RnVsbE5hbWUiLCJxdWVyeSIsImZ1bGxuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7cWpCQUFBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7O0lBR01BLE07QUFDSDs7Ozs7O0FBTUEsa0JBQVlDLElBQVosRUFBc0Q7QUFBQSxRQUFwQ0MsT0FBb0MsdUVBQTFCLHdCQUEwQjs7QUFBQTs7QUFDbkQsU0FBS0MsU0FBTCxHQUFpQkQsT0FBakI7QUFDQSxTQUFLRSxNQUFMLEdBQWNILFFBQVEsRUFBdEI7QUFDRjs7QUFFRDs7Ozs7Ozs7OzRCQUtRSSxFLEVBQUk7QUFDVCxhQUFPLG1CQUFTQSxFQUFULEVBQWEsS0FBS0QsTUFBbEIsRUFBMEIsS0FBS0QsU0FBL0IsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NEJBTVFHLEksRUFBTTtBQUNYLGFBQU8sbUJBQVNBLElBQVQsRUFBZSxLQUFLRixNQUFwQixFQUE0QixLQUFLRCxTQUFqQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O29DQUtnQkksWSxFQUFjO0FBQzNCLGFBQU8sMkJBQWlCQSxZQUFqQixFQUErQixLQUFLSCxNQUFwQyxFQUE0QyxLQUFLRCxTQUFqRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzRCQUtRSyxNLEVBQVE7QUFDYixhQUFPLG1CQUFTQSxNQUFULEVBQWlCLEtBQUtKLE1BQXRCLEVBQThCLEtBQUtELFNBQW5DLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzRCQU1RRyxJLEVBQU1HLEksRUFBTTtBQUNqQixhQUFPLHlCQUFlLEtBQUtDLFlBQUwsQ0FBa0JKLElBQWxCLEVBQXdCRyxJQUF4QixDQUFmLEVBQThDLEtBQUtMLE1BQW5ELEVBQTJELEtBQUtELFNBQWhFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzhCQU1VRyxJLEVBQU1HLEksRUFBTTtBQUNuQixhQUFPLG9CQUFVLEtBQUtDLFlBQUwsQ0FBa0JKLElBQWxCLEVBQXdCRyxJQUF4QixDQUFWLEVBQXlDLEtBQUtMLE1BQTlDLEVBQXNELEtBQUtELFNBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7MkJBS09RLEssRUFBTztBQUNYLGFBQU8scUJBQVdBLEtBQVgsRUFBa0IsS0FBS1AsTUFBdkIsRUFBK0IsS0FBS0QsU0FBcEMsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7O21DQUllO0FBQ1osYUFBTyx3QkFBYyxLQUFLQyxNQUFuQixFQUEyQixLQUFLRCxTQUFoQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7a0NBSWM7QUFDWCxhQUFPLHVCQUFhLEtBQUtDLE1BQWxCLEVBQTBCLEtBQUtELFNBQS9CLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7K0JBS1dFLEUsRUFBSTtBQUNaLGFBQU8sc0JBQVlBLEVBQVosRUFBZ0IsS0FBS0QsTUFBckIsRUFBNkIsS0FBS0QsU0FBbEMsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTWFHLEksRUFBTUcsSSxFQUFNO0FBQ3RCLFVBQUlHLFdBQVdOLElBQWY7O0FBRUEsVUFBSUcsSUFBSixFQUFVO0FBQ1BHLG1CQUFjTixJQUFkLFNBQXNCRyxJQUF0QjtBQUNGOztBQUVELGFBQU9HLFFBQVA7QUFDRjs7Ozs7O0FBR0pDLE9BQU9DLE9BQVAsR0FBaUJkLE1BQWpCIiwiZmlsZSI6IkdpdEh1Yi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cbi8qIGVzbGludCB2YWxpZC1qc2RvYzogW1wiZXJyb3JcIiwge1wicmVxdWlyZVJldHVybkRlc2NyaXB0aW9uXCI6IGZhbHNlfV0gKi9cblxuaW1wb3J0IEdpc3QgZnJvbSAnLi9HaXN0JztcbmltcG9ydCBVc2VyIGZyb20gJy4vVXNlcic7XG5pbXBvcnQgSXNzdWUgZnJvbSAnLi9Jc3N1ZSc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vU2VhcmNoJztcbmltcG9ydCBSYXRlTGltaXQgZnJvbSAnLi9SYXRlTGltaXQnO1xuaW1wb3J0IFJlcG9zaXRvcnkgZnJvbSAnLi9SZXBvc2l0b3J5JztcbmltcG9ydCBPcmdhbml6YXRpb24gZnJvbSAnLi9Pcmdhbml6YXRpb24nO1xuaW1wb3J0IFRlYW0gZnJvbSAnLi9UZWFtJztcbmltcG9ydCBNYXJrZG93biBmcm9tICcuL01hcmtkb3duJztcbmltcG9ydCBQcm9qZWN0IGZyb20gJy4vUHJvamVjdCc7XG5cbi8qKlxuICogR2l0SHViIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBjcmVhdGUgdmFyaW91cyBBUEkgd3JhcHBlciBvYmplY3RzLlxuICovXG5jbGFzcyBHaXRIdWIge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgR2l0SHViLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1Yi4gSWYgYXV0aCBpc1xuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHByb3ZpZGVkIHJlcXVlc3RzIHdpbGwgYmUgbWFkZSB1bmF1dGhlbnRpY2F0ZWRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGF1dGgsIGFwaUJhc2UgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbScpIHtcbiAgICAgIHRoaXMuX19hcGlCYXNlID0gYXBpQmFzZTtcbiAgICAgIHRoaXMuX19hdXRoID0gYXV0aCB8fCB7fTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgR2lzdCB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2lkXSAtIHRoZSBpZCBmb3IgdGhlIGdpc3QsIGxlYXZlIHVuZGVmaW5lZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGdpc3RcbiAgICAqIEByZXR1cm4ge0dpc3R9XG4gICAgKi9cbiAgIGdldEdpc3QoaWQpIHtcbiAgICAgIHJldHVybiBuZXcgR2lzdChpZCwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgVXNlciB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJdIC0gdGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0XG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZlIHVuZGVmaW5lZCBmb3IgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICogQHJldHVybiB7VXNlcn1cbiAgICAqL1xuICAgZ2V0VXNlcih1c2VyKSB7XG4gICAgICByZXR1cm4gbmV3IFVzZXIodXNlciwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgT3JnYW5pemF0aW9uIHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmdhbml6YXRpb24gLSB0aGUgbmFtZSBvZiB0aGUgb3JnYW5pemF0aW9uXG4gICAgKiBAcmV0dXJuIHtPcmdhbml6YXRpb259XG4gICAgKi9cbiAgIGdldE9yZ2FuaXphdGlvbihvcmdhbml6YXRpb24pIHtcbiAgICAgIHJldHVybiBuZXcgT3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbiwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBjcmVhdGUgYSBuZXcgVGVhbSB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkIC0gdGhlIG5hbWUgb2YgdGhlIHRlYW1cbiAgICAqIEByZXR1cm4ge3RlYW19XG4gICAgKi9cbiAgIGdldFRlYW0odGVhbUlkKSB7XG4gICAgICByZXR1cm4gbmV3IFRlYW0odGVhbUlkLCB0aGlzLl9fYXV0aCwgdGhpcy5fX2FwaUJhc2UpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBSZXBvc2l0b3J5IHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIC0gdGhlIHVzZXIgd2hvIG93bnMgdGhlIHJlc3Bvc2l0b3J5XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbyAtIHRoZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcmV0dXJuIHtSZXBvc2l0b3J5fVxuICAgICovXG4gICBnZXRSZXBvKHVzZXIsIHJlcG8pIHtcbiAgICAgIHJldHVybiBuZXcgUmVwb3NpdG9yeSh0aGlzLl9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgSXNzdWUgd3JhcHBlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXIgLSB0aGUgdXNlciB3aG8gb3ducyB0aGUgcmVzcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gdGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEByZXR1cm4ge0lzc3VlfVxuICAgICovXG4gICBnZXRJc3N1ZXModXNlciwgcmVwbykge1xuICAgICAgcmV0dXJuIG5ldyBJc3N1ZSh0aGlzLl9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSwgdGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgU2VhcmNoIHdyYXBwZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIHRoZSBxdWVyeSB0byBzZWFyY2ggZm9yXG4gICAgKiBAcmV0dXJuIHtTZWFyY2h9XG4gICAgKi9cbiAgIHNlYXJjaChxdWVyeSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2gocXVlcnksIHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IFJhdGVMaW1pdCB3cmFwcGVyXG4gICAgKiBAcmV0dXJuIHtSYXRlTGltaXR9XG4gICAgKi9cbiAgIGdldFJhdGVMaW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0KHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IE1hcmtkb3duIHdyYXBwZXJcbiAgICAqIEByZXR1cm4ge01hcmtkb3dufVxuICAgICovXG4gICBnZXRNYXJrZG93bigpIHtcbiAgICAgIHJldHVybiBuZXcgTWFya2Rvd24odGhpcy5fX2F1dGgsIHRoaXMuX19hcGlCYXNlKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgUHJvamVjdCB3cmFwcGVyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHByb2plY3RcbiAgICAqIEByZXR1cm4ge01hcmtkb3dufVxuICAgICovXG4gICBnZXRQcm9qZWN0KGlkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb2plY3QoaWQsIHRoaXMuX19hdXRoLCB0aGlzLl9fYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ29tcHV0ZXMgdGhlIGZ1bGwgcmVwb3NpdG9yeSBuYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlciAtIHRoZSB1c2VybmFtZSAob3IgdGhlIGZ1bGwgbmFtZSlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gdGhlIHJlcG9zaXRvcnkgbmFtZSwgbXVzdCBub3QgYmUgcGFzc2VkIGlmIGB1c2VyYCBpcyB0aGUgZnVsbCBuYW1lXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXBvc2l0b3J5J3MgZnVsbCBuYW1lXG4gICAgKi9cbiAgIF9nZXRGdWxsTmFtZSh1c2VyLCByZXBvKSB7XG4gICAgICBsZXQgZnVsbG5hbWUgPSB1c2VyO1xuXG4gICAgICBpZiAocmVwbykge1xuICAgICAgICAgZnVsbG5hbWUgPSBgJHt1c2VyfS8ke3JlcG99YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bGxuYW1lO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpdEh1YjtcbiJdfQ==
	//# sourceMappingURL=GitHub.js.map


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * A Gist can retrieve and modify gists.
	 */
	var Gist = function (_Requestable) {
	  _inherits(Gist, _Requestable);

	  /**
	   * Create a Gist.
	   * @param {string} id - the id of the gist (not required when creating a gist)
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Gist(id, auth, apiBase) {
	    _classCallCheck(this, Gist);

	    var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase));

	    _this.__id = id;
	    return _this;
	  }

	  /**
	   * Fetch a gist.
	   * @see https://developer.github.com/v3/gists/#get-a-single-gist
	   * @param {Requestable.callback} [cb] - will receive the gist
	   * @return {Promise} - the Promise for the http request
	   */


	  _createClass(Gist, [{
	    key: 'read',
	    value: function read(cb) {
	      return this._request('GET', '/gists/' + this.__id, null, cb);
	    }

	    /**
	     * Create a new gist.
	     * @see https://developer.github.com/v3/gists/#create-a-gist
	     * @param {Object} gist - the data for the new gist
	     * @param {Requestable.callback} [cb] - will receive the new gist upon creation
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'create',
	    value: function create(gist, cb) {
	      var _this2 = this;

	      return this._request('POST', '/gists', gist, cb).then(function (response) {
	        _this2.__id = response.data.id;
	        return response;
	      });
	    }

	    /**
	     * Delete a gist.
	     * @see https://developer.github.com/v3/gists/#delete-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'delete',
	    value: function _delete(cb) {
	      return this._request('DELETE', '/gists/' + this.__id, null, cb);
	    }

	    /**
	     * Fork a gist.
	     * @see https://developer.github.com/v3/gists/#fork-a-gist
	     * @param {Requestable.callback} [cb] - the function that will receive the gist
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'fork',
	    value: function fork(cb) {
	      return this._request('POST', '/gists/' + this.__id + '/forks', null, cb);
	    }

	    /**
	     * Update a gist.
	     * @see https://developer.github.com/v3/gists/#edit-a-gist
	     * @param {Object} gist - the new data for the gist
	     * @param {Requestable.callback} [cb] - the function that receives the API result
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'update',
	    value: function update(gist, cb) {
	      return this._request('PATCH', '/gists/' + this.__id, gist, cb);
	    }

	    /**
	     * Star a gist.
	     * @see https://developer.github.com/v3/gists/#star-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'star',
	    value: function star(cb) {
	      return this._request('PUT', '/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * Unstar a gist.
	     * @see https://developer.github.com/v3/gists/#unstar-a-gist
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'unstar',
	    value: function unstar(cb) {
	      return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * Check if a gist is starred by the user.
	     * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
	     * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'isStarred',
	    value: function isStarred(cb) {
	      return this._request204or404('/gists/' + this.__id + '/star', null, cb);
	    }

	    /**
	     * List the gist's comments
	     * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
	     * @param {Requestable.callback} [cb] - will receive the array of comments
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listComments',
	    value: function listComments(cb) {
	      return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb);
	    }

	    /**
	     * Fetch one of the gist's comments
	     * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment
	     * @param {number} comment - the id of the comment
	     * @param {Requestable.callback} [cb] - will receive the comment
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'getComment',
	    value: function getComment(comment, cb) {
	      return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb);
	    }

	    /**
	     * Comment on a gist
	     * @see https://developer.github.com/v3/gists/comments/#create-a-comment
	     * @param {string} comment - the comment to add
	     * @param {Requestable.callback} [cb] - the function that receives the API result
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'createComment',
	    value: function createComment(comment, cb) {
	      return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb);
	    }

	    /**
	     * Edit a comment on the gist
	     * @see https://developer.github.com/v3/gists/comments/#edit-a-comment
	     * @param {number} comment - the id of the comment
	     * @param {string} body - the new comment
	     * @param {Requestable.callback} [cb] - will receive the modified comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editComment',
	    value: function editComment(comment, body, cb) {
	      return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb);
	    }

	    /**
	     * Delete a comment on the gist.
	     * @see https://developer.github.com/v3/gists/comments/#delete-a-comment
	     * @param {number} comment - the id of the comment
	     * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	     * @return {Promise} - the Promise for the http request
	     */

	  }, {
	    key: 'deleteComment',
	    value: function deleteComment(comment, cb) {
	      return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb);
	    }
	  }]);

	  return Gist;
	}(_Requestable3.default);

	module.exports = Gist;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkdpc3QuanMiXSwibmFtZXMiOlsiR2lzdCIsImlkIiwiYXV0aCIsImFwaUJhc2UiLCJfX2lkIiwiY2IiLCJfcmVxdWVzdCIsImdpc3QiLCJ0aGVuIiwicmVzcG9uc2UiLCJkYXRhIiwiX3JlcXVlc3QyMDRvcjQwNCIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJjb21tZW50IiwiYm9keSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7OztBQVNBOzs7SUFHTUEsSTs7O0FBQ0g7Ozs7OztBQU1BLGdCQUFZQyxFQUFaLEVBQWdCQyxJQUFoQixFQUFzQkMsT0FBdEIsRUFBK0I7QUFBQTs7QUFBQSw0R0FDdEJELElBRHNCLEVBQ2hCQyxPQURnQjs7QUFFNUIsVUFBS0MsSUFBTCxHQUFZSCxFQUFaO0FBRjRCO0FBRzlCOztBQUVEOzs7Ozs7Ozs7O3lCQU1LSSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLEVBQTRDLElBQTVDLEVBQWtEQyxFQUFsRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MkJBT09FLEksRUFBTUYsRSxFQUFJO0FBQUE7O0FBQ2QsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxFQUFzQixRQUF0QixFQUFnQ0MsSUFBaEMsRUFBc0NGLEVBQXRDLEVBQ0hHLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakIsZUFBS0wsSUFBTCxHQUFZSyxTQUFTQyxJQUFULENBQWNULEVBQTFCO0FBQ0EsZUFBT1EsUUFBUDtBQUNGLE9BSkcsQ0FBUDtBQUtGOztBQUVEOzs7Ozs7Ozs7NEJBTU9KLEUsRUFBSTtBQUNSLGFBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS0YsSUFBdkMsRUFBK0MsSUFBL0MsRUFBcURDLEVBQXJELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lCQU1LQSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtGLElBQXJDLGFBQW1ELElBQW5ELEVBQXlEQyxFQUF6RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MkJBT09FLEksRUFBTUYsRSxFQUFJO0FBQ2QsYUFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLRixJQUF0QyxFQUE4Q0csSUFBOUMsRUFBb0RGLEVBQXBELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lCQU1LQSxFLEVBQUk7QUFDTixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLFlBQWlELElBQWpELEVBQXVEQyxFQUF2RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsyQkFNT0EsRSxFQUFJO0FBQ1IsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLRixJQUF2QyxZQUFvRCxJQUFwRCxFQUEwREMsRUFBMUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OEJBTVVBLEUsRUFBSTtBQUNYLGFBQU8sS0FBS00sZ0JBQUwsYUFBZ0MsS0FBS1AsSUFBckMsWUFBa0QsSUFBbEQsRUFBd0RDLEVBQXhELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O2lDQU1hQSxFLEVBQUk7QUFDZCxhQUFPLEtBQUtPLGdCQUFMLGFBQWdDLEtBQUtSLElBQXJDLGdCQUFzRCxJQUF0RCxFQUE0REMsRUFBNUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OytCQU9XUSxPLEVBQVNSLEUsRUFBSTtBQUNyQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLElBQXBDLGtCQUFxRFMsT0FBckQsRUFBZ0UsSUFBaEUsRUFBc0VSLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztrQ0FPY1EsTyxFQUFTUixFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLRixJQUFyQyxnQkFBc0QsRUFBQ1UsTUFBTUQsT0FBUCxFQUF0RCxFQUF1RVIsRUFBdkUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztnQ0FRWVEsTyxFQUFTQyxJLEVBQU1ULEUsRUFBSTtBQUM1QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtGLElBQXRDLGtCQUF1RFMsT0FBdkQsRUFBa0UsRUFBQ0MsTUFBTUEsSUFBUCxFQUFsRSxFQUFnRlQsRUFBaEYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2tDQU9jUSxPLEVBQVNSLEUsRUFBSTtBQUN4QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtGLElBQXZDLGtCQUF3RFMsT0FBeEQsRUFBbUUsSUFBbkUsRUFBeUVSLEVBQXpFLENBQVA7QUFDRjs7Ozs7O0FBR0pVLE9BQU9DLE9BQVAsR0FBaUJoQixJQUFqQiIsImZpbGUiOiJHaXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogQSBHaXN0IGNhbiByZXRyaWV2ZSBhbmQgbW9kaWZ5IGdpc3RzLlxuICovXG5jbGFzcyBHaXN0IGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBHaXN0LlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSBnaXN0IChub3QgcmVxdWlyZWQgd2hlbiBjcmVhdGluZyBhIGdpc3QpXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IFthdXRoXSAtIGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvIGF1dGhlbnRpY2F0ZSB0byBHaXRodWJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGlkLCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX19pZCA9IGlkO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEZldGNoIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jZ2V0LWEtc2luZ2xlLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGdpc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgcmVhZChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvZ2lzdHMvJHt0aGlzLl9faWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNjcmVhdGUtYS1naXN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gZ2lzdCAtIHRoZSBkYXRhIGZvciB0aGUgbmV3IGdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBnaXN0IHVwb24gY3JlYXRpb25cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlKGdpc3QsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsICcvZ2lzdHMnLCBnaXN0LCBjYilcbiAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGdpc3QuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI2RlbGV0ZS1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgUHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGUoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBGb3JrIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jZm9yay1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGdpc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9yayhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9mb3Jrc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBVcGRhdGUgYSBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNlZGl0LWEtZ2lzdFxuICAgICogQHBhcmFtIHtPYmplY3R9IGdpc3QgLSB0aGUgbmV3IGRhdGEgZm9yIHRoZSBnaXN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gdGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIEFQSSByZXN1bHRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlKGdpc3QsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfWAsIGdpc3QsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTdGFyIGEgZ2lzdC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy8jc3Rhci1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9zdGFyYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVuc3RhciBhIGdpc3QuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI3Vuc3Rhci1hLWdpc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVuc3RhcihjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvZ2lzdHMvJHt0aGlzLl9faWR9L3N0YXJgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSBnaXN0IGlzIHN0YXJyZWQgYnkgdGhlIHVzZXIuXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvI2NoZWNrLWlmLWEtZ2lzdC1pcy1zdGFycmVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIGdpc3QgaXMgc3RhcnJlZCBhbmQgZmFsc2UgaWYgdGhlIGdpc3QgaXMgbm90IHN0YXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNTdGFycmVkKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvZ2lzdHMvJHt0aGlzLl9faWR9L3N0YXJgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgZ2lzdCdzIGNvbW1lbnRzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2xpc3QtY29tbWVudHMtb24tYS1naXN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBhcnJheSBvZiBjb21tZW50c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0Q29tbWVudHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9naXN0cy8ke3RoaXMuX19pZH0vY29tbWVudHNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRmV0Y2ggb25lIG9mIHRoZSBnaXN0J3MgY29tbWVudHNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXN0cy9jb21tZW50cy8jZ2V0LWEtc2luZ2xlLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb21tZW50IC0gdGhlIGlkIG9mIHRoZSBjb21tZW50XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb21tZW50XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbW1lbnQoY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50cy8ke2NvbW1lbnR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENvbW1lbnQgb24gYSBnaXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2NyZWF0ZS1hLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50IC0gdGhlIGNvbW1lbnQgdG8gYWRkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gdGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIEFQSSByZXN1bHRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIFByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlQ29tbWVudChjb21tZW50LCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50c2AsIHtib2R5OiBjb21tZW50fSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEVkaXQgYSBjb21tZW50IG9uIHRoZSBnaXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2lzdHMvY29tbWVudHMvI2VkaXQtYS1jb21tZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gY29tbWVudCAtIHRoZSBpZCBvZiB0aGUgY29tbWVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgLSB0aGUgbmV3IGNvbW1lbnRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1vZGlmaWVkIGNvbW1lbnRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdENvbW1lbnQoY29tbWVudCwgYm9keSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvZ2lzdHMvJHt0aGlzLl9faWR9L2NvbW1lbnRzLyR7Y29tbWVudH1gLCB7Ym9keTogYm9keX0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSBjb21tZW50IG9uIHRoZSBnaXN0LlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzL2NvbW1lbnRzLyNkZWxldGUtYS1jb21tZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gY29tbWVudCAtIHRoZSBpZCBvZiB0aGUgY29tbWVudFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBQcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZUNvbW1lbnQoY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL2dpc3RzLyR7dGhpcy5fX2lkfS9jb21tZW50cy8ke2NvbW1lbnR9YCwgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpc3Q7XG4iXX0=
	//# sourceMappingURL=Gist.js.map


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _axios = __webpack_require__(351);

	var _axios2 = _interopRequireDefault(_axios);

	var _debug = __webpack_require__(376);

	var _debug2 = _interopRequireDefault(_debug);

	var _jsBase = __webpack_require__(379);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:request');

	/**
	 * The error structure returned when a network call fails
	 */

	var ResponseError = function (_Error) {
	   _inherits(ResponseError, _Error);

	   /**
	    * Construct a new ResponseError
	    * @param {string} message - an message to return instead of the the default error message
	    * @param {string} path - the requested path
	    * @param {Object} response - the object returned by Axios
	    */
	   function ResponseError(message, path, response) {
	      _classCallCheck(this, ResponseError);

	      var _this = _possibleConstructorReturn(this, (ResponseError.__proto__ || Object.getPrototypeOf(ResponseError)).call(this, message));

	      _this.path = path;
	      _this.request = response.config;
	      _this.response = (response || {}).response || response;
	      _this.status = response.status;
	      return _this;
	   }

	   return ResponseError;
	}(Error);

	/**
	 * Requestable wraps the logic for making http requests to the API
	 */


	var Requestable = function () {
	   /**
	    * Either a username and password or an oauth token for Github
	    * @typedef {Object} Requestable.auth
	    * @prop {string} [username] - the Github username
	    * @prop {string} [password] - the user's password
	    * @prop {token} [token] - an OAuth token
	    */
	   /**
	    * Initialize the http internals.
	    * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is
	    *                                  not provided request will be made unauthenticated
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    * @param {string} [AcceptHeader=v3] - the accept header for the requests
	    */
	   function Requestable(auth, apiBase, AcceptHeader) {
	      _classCallCheck(this, Requestable);

	      this.__apiBase = apiBase || 'https://api.github.com';
	      this.__auth = {
	         token: auth.token,
	         username: auth.username,
	         password: auth.password
	      };
	      this.__AcceptHeader = AcceptHeader || 'v3';

	      if (auth.token) {
	         this.__authorizationHeader = 'token ' + auth.token;
	      } else if (auth.username && auth.password) {
	         this.__authorizationHeader = 'Basic ' + _jsBase.Base64.encode(auth.username + ':' + auth.password);
	      }
	   }

	   /**
	    * Compute the URL to use to make a request.
	    * @private
	    * @param {string} path - either a URL relative to the API base or an absolute URL
	    * @return {string} - the URL to use
	    */


	   _createClass(Requestable, [{
	      key: '__getURL',
	      value: function __getURL(path) {
	         var url = path;

	         if (path.indexOf('//') === -1) {
	            url = this.__apiBase + path;
	         }

	         var newCacheBuster = 'timestamp=' + new Date().getTime();
	         return url.replace(/(timestamp=\d+)/, newCacheBuster);
	      }

	      /**
	       * Compute the headers required for an API request.
	       * @private
	       * @param {boolean} raw - if the request should be treated as JSON or as a raw request
	       * @param {string} AcceptHeader - the accept header for the request
	       * @return {Object} - the headers to use in the request
	       */

	   }, {
	      key: '__getRequestHeaders',
	      value: function __getRequestHeaders(raw, AcceptHeader) {
	         var headers = {
	            'Content-Type': 'application/json;charset=UTF-8',
	            'Accept': 'application/vnd.github.' + (AcceptHeader || this.__AcceptHeader)
	         };

	         if (raw) {
	            headers.Accept += '.raw';
	         }
	         headers.Accept += '+json';

	         if (this.__authorizationHeader) {
	            headers.Authorization = this.__authorizationHeader;
	         }

	         return headers;
	      }

	      /**
	       * Sets the default options for API requests
	       * @protected
	       * @param {Object} [requestOptions={}] - the current options for the request
	       * @return {Object} - the options to pass to the request
	       */

	   }, {
	      key: '_getOptionsWithDefaults',
	      value: function _getOptionsWithDefaults() {
	         var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	         if (!(requestOptions.visibility || requestOptions.affiliation)) {
	            requestOptions.type = requestOptions.type || 'all';
	         }
	         requestOptions.sort = requestOptions.sort || 'updated';
	         requestOptions.per_page = requestOptions.per_page || '100'; // eslint-disable-line

	         return requestOptions;
	      }

	      /**
	       * if a `Date` is passed to this function it will be converted to an ISO string
	       * @param {*} date - the object to attempt to cooerce into an ISO date string
	       * @return {string} - the ISO representation of `date` or whatever was passed in if it was not a date
	       */

	   }, {
	      key: '_dateToISO',
	      value: function _dateToISO(date) {
	         if (date && date instanceof Date) {
	            date = date.toISOString();
	         }

	         return date;
	      }

	      /**
	       * A function that receives the result of the API request.
	       * @callback Requestable.callback
	       * @param {Requestable.Error} error - the error returned by the API or `null`
	       * @param {(Object|true)} result - the data returned by the API or `true` if the API returns `204 No Content`
	       * @param {Object} request - the raw {@linkcode https://github.com/mzabriskie/axios#response-schema Response}
	       */
	      /**
	       * Make a request.
	       * @param {string} method - the method for the request (GET, PUT, POST, DELETE)
	       * @param {string} path - the path for the request
	       * @param {*} [data] - the data to send to the server. For HTTP methods that don't have a body the data
	       *                   will be sent as query parameters
	       * @param {Requestable.callback} [cb] - the callback for the request
	       * @param {boolean} [raw=false] - if the request should be sent as raw. If this is a falsy value then the
	       *                              request will be made as JSON
	       * @return {Promise} - the Promise for the http request
	       */

	   }, {
	      key: '_request',
	      value: function _request(method, path, data, cb, raw) {
	         var url = this.__getURL(path);

	         var AcceptHeader = (data || {}).AcceptHeader;
	         if (AcceptHeader) {
	            delete data.AcceptHeader;
	         }
	         var headers = this.__getRequestHeaders(raw, AcceptHeader);

	         var queryParams = {};

	         var shouldUseDataAsParams = data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && methodHasNoBody(method);
	         if (shouldUseDataAsParams) {
	            queryParams = data;
	            data = undefined;
	         }

	         var config = {
	            url: url,
	            method: method,
	            headers: headers,
	            params: queryParams,
	            data: data,
	            responseType: raw ? 'text' : 'json'
	         };

	         log(config.method + ' to ' + config.url);
	         var requestPromise = (0, _axios2.default)(config).catch(callbackErrorOrThrow(cb, path));

	         if (cb) {
	            requestPromise.then(function (response) {
	               if (response.data && Object.keys(response.data).length > 0) {
	                  // When data has results
	                  cb(null, response.data, response);
	               } else if (config.method !== 'GET' && Object.keys(response.data).length < 1) {
	                  // True when successful submit a request and receive a empty object
	                  cb(null, response.status < 300, response);
	               } else {
	                  cb(null, response.data, response);
	               }
	            });
	         }

	         return requestPromise;
	      }

	      /**
	       * Make a request to an endpoint the returns 204 when true and 404 when false
	       * @param {string} path - the path to request
	       * @param {Object} data - any query parameters for the request
	       * @param {Requestable.callback} cb - the callback that will receive `true` or `false`
	       * @param {method} [method=GET] - HTTP Method to use
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: '_request204or404',
	      value: function _request204or404(path, data, cb) {
	         var method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'GET';

	         return this._request(method, path, data).then(function success(response) {
	            if (cb) {
	               cb(null, true, response);
	            }
	            return true;
	         }, function failure(response) {
	            if (response.response.status === 404) {
	               if (cb) {
	                  cb(null, false, response);
	               }
	               return false;
	            }

	            if (cb) {
	               cb(response);
	            }
	            throw response;
	         });
	      }

	      /**
	       * Make a request and fetch all the available data. Github will paginate responses so for queries
	       * that might span multiple pages this method is preferred to {@link Requestable#request}
	       * @param {string} path - the path to request
	       * @param {Object} options - the query parameters to include
	       * @param {Requestable.callback} [cb] - the function to receive the data. The returned data will always be an array.
	       * @param {Object[]} results - the partial results. This argument is intended for interal use only.
	       * @return {Promise} - a promise which will resolve when all pages have been fetched
	       * @deprecated This will be folded into {@link Requestable#_request} in the 2.0 release.
	       */

	   }, {
	      key: '_requestAllPages',
	      value: function _requestAllPages(path, options, cb, results) {
	         var _this2 = this;

	         results = results || [];

	         return this._request('GET', path, options).then(function (response) {
	            var _results;

	            var thisGroup = void 0;
	            if (response.data instanceof Array) {
	               thisGroup = response.data;
	            } else if (response.data.items instanceof Array) {
	               thisGroup = response.data.items;
	            } else {
	               var message = 'cannot figure out how to append ' + response.data + ' to the result set';
	               throw new ResponseError(message, path, response);
	            }
	            (_results = results).push.apply(_results, _toConsumableArray(thisGroup));

	            var nextUrl = getNextPage(response.headers.link);
	            if (nextUrl) {
	               log('getting next page: ' + nextUrl);
	               return _this2._requestAllPages(nextUrl, options, cb, results);
	            }

	            if (cb) {
	               cb(null, results, response);
	            }

	            response.data = results;
	            return response;
	         }).catch(callbackErrorOrThrow(cb, path));
	      }
	   }]);

	   return Requestable;
	}();

	module.exports = Requestable;

	// ////////////////////////// //
	//  Private helper functions  //
	// ////////////////////////// //
	var METHODS_WITH_NO_BODY = ['GET', 'HEAD', 'DELETE'];
	function methodHasNoBody(method) {
	   return METHODS_WITH_NO_BODY.indexOf(method) !== -1;
	}

	function getNextPage() {
	   var linksHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	   var links = linksHeader.split(/\s*,\s*/); // splits and strips the urls
	   return links.reduce(function (nextUrl, link) {
	      if (link.search(/rel="next"/) !== -1) {
	         return (link.match(/<(.*)>/) || [])[1];
	      }

	      return nextUrl;
	   }, undefined);
	}

	function callbackErrorOrThrow(cb, path) {
	   return function handler(object) {
	      var error = void 0;
	      if (object.hasOwnProperty('config')) {
	         var _object$response = object.response,
	             status = _object$response.status,
	             statusText = _object$response.statusText,
	             _object$config = object.config,
	             method = _object$config.method,
	             url = _object$config.url;

	         var message = status + ' error making request ' + method + ' ' + url + ': "' + statusText + '"';
	         error = new ResponseError(message, path, object);
	         log(message + ' ' + JSON.stringify(object.data));
	      } else {
	         error = object;
	      }
	      if (cb) {
	         log('going to error callback');
	         cb(error);
	      } else {
	         log('throwing error');
	         throw error;
	      }
	   };
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVlc3RhYmxlLmpzIl0sIm5hbWVzIjpbImxvZyIsIlJlc3BvbnNlRXJyb3IiLCJtZXNzYWdlIiwicGF0aCIsInJlc3BvbnNlIiwicmVxdWVzdCIsImNvbmZpZyIsInN0YXR1cyIsIkVycm9yIiwiUmVxdWVzdGFibGUiLCJhdXRoIiwiYXBpQmFzZSIsIkFjY2VwdEhlYWRlciIsIl9fYXBpQmFzZSIsIl9fYXV0aCIsInRva2VuIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIl9fQWNjZXB0SGVhZGVyIiwiX19hdXRob3JpemF0aW9uSGVhZGVyIiwiZW5jb2RlIiwidXJsIiwiaW5kZXhPZiIsIm5ld0NhY2hlQnVzdGVyIiwiRGF0ZSIsImdldFRpbWUiLCJyZXBsYWNlIiwicmF3IiwiaGVhZGVycyIsIkFjY2VwdCIsIkF1dGhvcml6YXRpb24iLCJyZXF1ZXN0T3B0aW9ucyIsInZpc2liaWxpdHkiLCJhZmZpbGlhdGlvbiIsInR5cGUiLCJzb3J0IiwicGVyX3BhZ2UiLCJkYXRlIiwidG9JU09TdHJpbmciLCJtZXRob2QiLCJkYXRhIiwiY2IiLCJfX2dldFVSTCIsIl9fZ2V0UmVxdWVzdEhlYWRlcnMiLCJxdWVyeVBhcmFtcyIsInNob3VsZFVzZURhdGFBc1BhcmFtcyIsIm1ldGhvZEhhc05vQm9keSIsInVuZGVmaW5lZCIsInBhcmFtcyIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RQcm9taXNlIiwiY2F0Y2giLCJjYWxsYmFja0Vycm9yT3JUaHJvdyIsInRoZW4iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiX3JlcXVlc3QiLCJzdWNjZXNzIiwiZmFpbHVyZSIsIm9wdGlvbnMiLCJyZXN1bHRzIiwidGhpc0dyb3VwIiwiQXJyYXkiLCJpdGVtcyIsInB1c2giLCJuZXh0VXJsIiwiZ2V0TmV4dFBhZ2UiLCJsaW5rIiwiX3JlcXVlc3RBbGxQYWdlcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJNRVRIT0RTX1dJVEhfTk9fQk9EWSIsImxpbmtzSGVhZGVyIiwibGlua3MiLCJzcGxpdCIsInJlZHVjZSIsInNlYXJjaCIsIm1hdGNoIiwiaGFuZGxlciIsIm9iamVjdCIsImVycm9yIiwiaGFzT3duUHJvcGVydHkiLCJzdGF0dXNUZXh0IiwiSlNPTiIsInN0cmluZ2lmeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVRBOzs7Ozs7O0FBV0EsSUFBTUEsTUFBTSxxQkFBTSxnQkFBTixDQUFaOztBQUVBOzs7O0lBR01DLGE7OztBQUNIOzs7Ozs7QUFNQSwwQkFBWUMsT0FBWixFQUFxQkMsSUFBckIsRUFBMkJDLFFBQTNCLEVBQXFDO0FBQUE7O0FBQUEsZ0lBQzVCRixPQUQ0Qjs7QUFFbEMsWUFBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsWUFBS0UsT0FBTCxHQUFlRCxTQUFTRSxNQUF4QjtBQUNBLFlBQUtGLFFBQUwsR0FBZ0IsQ0FBQ0EsWUFBWSxFQUFiLEVBQWlCQSxRQUFqQixJQUE2QkEsUUFBN0M7QUFDQSxZQUFLRyxNQUFMLEdBQWNILFNBQVNHLE1BQXZCO0FBTGtDO0FBTXBDOzs7RUFid0JDLEs7O0FBZ0I1Qjs7Ozs7SUFHTUMsVztBQUNIOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQSx3QkFBWUMsSUFBWixFQUFrQkMsT0FBbEIsRUFBMkJDLFlBQTNCLEVBQXlDO0FBQUE7O0FBQ3RDLFdBQUtDLFNBQUwsR0FBaUJGLFdBQVcsd0JBQTVCO0FBQ0EsV0FBS0csTUFBTCxHQUFjO0FBQ1hDLGdCQUFPTCxLQUFLSyxLQUREO0FBRVhDLG1CQUFVTixLQUFLTSxRQUZKO0FBR1hDLG1CQUFVUCxLQUFLTztBQUhKLE9BQWQ7QUFLQSxXQUFLQyxjQUFMLEdBQXNCTixnQkFBZ0IsSUFBdEM7O0FBRUEsVUFBSUYsS0FBS0ssS0FBVCxFQUFnQjtBQUNiLGNBQUtJLHFCQUFMLEdBQTZCLFdBQVdULEtBQUtLLEtBQTdDO0FBQ0YsT0FGRCxNQUVPLElBQUlMLEtBQUtNLFFBQUwsSUFBaUJOLEtBQUtPLFFBQTFCLEVBQW9DO0FBQ3hDLGNBQUtFLHFCQUFMLEdBQTZCLFdBQVcsZUFBT0MsTUFBUCxDQUFjVixLQUFLTSxRQUFMLEdBQWdCLEdBQWhCLEdBQXNCTixLQUFLTyxRQUF6QyxDQUF4QztBQUNGO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7K0JBTVNkLEksRUFBTTtBQUNaLGFBQUlrQixNQUFNbEIsSUFBVjs7QUFFQSxhQUFJQSxLQUFLbUIsT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBQyxDQUE1QixFQUErQjtBQUM1QkQsa0JBQU0sS0FBS1IsU0FBTCxHQUFpQlYsSUFBdkI7QUFDRjs7QUFFRCxhQUFJb0IsaUJBQWlCLGVBQWUsSUFBSUMsSUFBSixHQUFXQyxPQUFYLEVBQXBDO0FBQ0EsZ0JBQU9KLElBQUlLLE9BQUosQ0FBWSxpQkFBWixFQUErQkgsY0FBL0IsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzBDQU9vQkksRyxFQUFLZixZLEVBQWM7QUFDcEMsYUFBSWdCLFVBQVU7QUFDWCw0QkFBZ0IsZ0NBREw7QUFFWCxzQkFBVSw2QkFBNkJoQixnQkFBZ0IsS0FBS00sY0FBbEQ7QUFGQyxVQUFkOztBQUtBLGFBQUlTLEdBQUosRUFBUztBQUNOQyxvQkFBUUMsTUFBUixJQUFrQixNQUFsQjtBQUNGO0FBQ0RELGlCQUFRQyxNQUFSLElBQWtCLE9BQWxCOztBQUVBLGFBQUksS0FBS1YscUJBQVQsRUFBZ0M7QUFDN0JTLG9CQUFRRSxhQUFSLEdBQXdCLEtBQUtYLHFCQUE3QjtBQUNGOztBQUVELGdCQUFPUyxPQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnREFNNkM7QUFBQSxhQUFyQkcsY0FBcUIsdUVBQUosRUFBSTs7QUFDMUMsYUFBSSxFQUFFQSxlQUFlQyxVQUFmLElBQTZCRCxlQUFlRSxXQUE5QyxDQUFKLEVBQWdFO0FBQzdERiwyQkFBZUcsSUFBZixHQUFzQkgsZUFBZUcsSUFBZixJQUF1QixLQUE3QztBQUNGO0FBQ0RILHdCQUFlSSxJQUFmLEdBQXNCSixlQUFlSSxJQUFmLElBQXVCLFNBQTdDO0FBQ0FKLHdCQUFlSyxRQUFmLEdBQTBCTCxlQUFlSyxRQUFmLElBQTJCLEtBQXJELENBTDBDLENBS2tCOztBQUU1RCxnQkFBT0wsY0FBUDtBQUNGOztBQUVEOzs7Ozs7OztpQ0FLV00sSSxFQUFNO0FBQ2QsYUFBSUEsUUFBU0EsZ0JBQWdCYixJQUE3QixFQUFvQztBQUNqQ2EsbUJBQU9BLEtBQUtDLFdBQUwsRUFBUDtBQUNGOztBQUVELGdCQUFPRCxJQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7K0JBV1NFLE0sRUFBUXBDLEksRUFBTXFDLEksRUFBTUMsRSxFQUFJZCxHLEVBQUs7QUFDbkMsYUFBTU4sTUFBTSxLQUFLcUIsUUFBTCxDQUFjdkMsSUFBZCxDQUFaOztBQUVBLGFBQU1TLGVBQWUsQ0FBQzRCLFFBQVEsRUFBVCxFQUFhNUIsWUFBbEM7QUFDQSxhQUFJQSxZQUFKLEVBQWtCO0FBQ2YsbUJBQU80QixLQUFLNUIsWUFBWjtBQUNGO0FBQ0QsYUFBTWdCLFVBQVUsS0FBS2UsbUJBQUwsQ0FBeUJoQixHQUF6QixFQUE4QmYsWUFBOUIsQ0FBaEI7O0FBRUEsYUFBSWdDLGNBQWMsRUFBbEI7O0FBRUEsYUFBTUMsd0JBQXdCTCxRQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBekIsSUFBc0NNLGdCQUFnQlAsTUFBaEIsQ0FBcEU7QUFDQSxhQUFJTSxxQkFBSixFQUEyQjtBQUN4QkQsMEJBQWNKLElBQWQ7QUFDQUEsbUJBQU9PLFNBQVA7QUFDRjs7QUFFRCxhQUFNekMsU0FBUztBQUNaZSxpQkFBS0EsR0FETztBQUVaa0Isb0JBQVFBLE1BRkk7QUFHWlgscUJBQVNBLE9BSEc7QUFJWm9CLG9CQUFRSixXQUpJO0FBS1pKLGtCQUFNQSxJQUxNO0FBTVpTLDBCQUFjdEIsTUFBTSxNQUFOLEdBQWU7QUFOakIsVUFBZjs7QUFTQTNCLGFBQU9NLE9BQU9pQyxNQUFkLFlBQTJCakMsT0FBT2UsR0FBbEM7QUFDQSxhQUFNNkIsaUJBQWlCLHFCQUFNNUMsTUFBTixFQUFjNkMsS0FBZCxDQUFvQkMscUJBQXFCWCxFQUFyQixFQUF5QnRDLElBQXpCLENBQXBCLENBQXZCOztBQUVBLGFBQUlzQyxFQUFKLEVBQVE7QUFDTFMsMkJBQWVHLElBQWYsQ0FBb0IsVUFBQ2pELFFBQUQsRUFBYztBQUMvQixtQkFBSUEsU0FBU29DLElBQVQsSUFBaUJjLE9BQU9DLElBQVAsQ0FBWW5ELFNBQVNvQyxJQUFyQixFQUEyQmdCLE1BQTNCLEdBQW9DLENBQXpELEVBQTREO0FBQ3pEO0FBQ0FmLHFCQUFHLElBQUgsRUFBU3JDLFNBQVNvQyxJQUFsQixFQUF3QnBDLFFBQXhCO0FBQ0YsZ0JBSEQsTUFHTyxJQUFJRSxPQUFPaUMsTUFBUCxLQUFrQixLQUFsQixJQUEyQmUsT0FBT0MsSUFBUCxDQUFZbkQsU0FBU29DLElBQXJCLEVBQTJCZ0IsTUFBM0IsR0FBb0MsQ0FBbkUsRUFBc0U7QUFDMUU7QUFDQWYscUJBQUcsSUFBSCxFQUFVckMsU0FBU0csTUFBVCxHQUFrQixHQUE1QixFQUFrQ0gsUUFBbEM7QUFDRixnQkFITSxNQUdBO0FBQ0pxQyxxQkFBRyxJQUFILEVBQVNyQyxTQUFTb0MsSUFBbEIsRUFBd0JwQyxRQUF4QjtBQUNGO0FBQ0gsYUFWRDtBQVdGOztBQUVELGdCQUFPOEMsY0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRaUIvQyxJLEVBQU1xQyxJLEVBQU1DLEUsRUFBb0I7QUFBQSxhQUFoQkYsTUFBZ0IsdUVBQVAsS0FBTzs7QUFDOUMsZ0JBQU8sS0FBS2tCLFFBQUwsQ0FBY2xCLE1BQWQsRUFBc0JwQyxJQUF0QixFQUE0QnFDLElBQTVCLEVBQ0hhLElBREcsQ0FDRSxTQUFTSyxPQUFULENBQWlCdEQsUUFBakIsRUFBMkI7QUFDOUIsZ0JBQUlxQyxFQUFKLEVBQVE7QUFDTEEsa0JBQUcsSUFBSCxFQUFTLElBQVQsRUFBZXJDLFFBQWY7QUFDRjtBQUNELG1CQUFPLElBQVA7QUFDRixVQU5HLEVBTUQsU0FBU3VELE9BQVQsQ0FBaUJ2RCxRQUFqQixFQUEyQjtBQUMzQixnQkFBSUEsU0FBU0EsUUFBVCxDQUFrQkcsTUFBbEIsS0FBNkIsR0FBakMsRUFBc0M7QUFDbkMsbUJBQUlrQyxFQUFKLEVBQVE7QUFDTEEscUJBQUcsSUFBSCxFQUFTLEtBQVQsRUFBZ0JyQyxRQUFoQjtBQUNGO0FBQ0Qsc0JBQU8sS0FBUDtBQUNGOztBQUVELGdCQUFJcUMsRUFBSixFQUFRO0FBQ0xBLGtCQUFHckMsUUFBSDtBQUNGO0FBQ0Qsa0JBQU1BLFFBQU47QUFDRixVQWxCRyxDQUFQO0FBbUJGOztBQUVEOzs7Ozs7Ozs7Ozs7O3VDQVVpQkQsSSxFQUFNeUQsTyxFQUFTbkIsRSxFQUFJb0IsTyxFQUFTO0FBQUE7O0FBQzFDQSxtQkFBVUEsV0FBVyxFQUFyQjs7QUFFQSxnQkFBTyxLQUFLSixRQUFMLENBQWMsS0FBZCxFQUFxQnRELElBQXJCLEVBQTJCeUQsT0FBM0IsRUFDSFAsSUFERyxDQUNFLFVBQUNqRCxRQUFELEVBQWM7QUFBQTs7QUFDakIsZ0JBQUkwRCxrQkFBSjtBQUNBLGdCQUFJMUQsU0FBU29DLElBQVQsWUFBeUJ1QixLQUE3QixFQUFvQztBQUNqQ0QsMkJBQVkxRCxTQUFTb0MsSUFBckI7QUFDRixhQUZELE1BRU8sSUFBSXBDLFNBQVNvQyxJQUFULENBQWN3QixLQUFkLFlBQStCRCxLQUFuQyxFQUEwQztBQUM5Q0QsMkJBQVkxRCxTQUFTb0MsSUFBVCxDQUFjd0IsS0FBMUI7QUFDRixhQUZNLE1BRUE7QUFDSixtQkFBSTlELCtDQUE2Q0UsU0FBU29DLElBQXRELHVCQUFKO0FBQ0EscUJBQU0sSUFBSXZDLGFBQUosQ0FBa0JDLE9BQWxCLEVBQTJCQyxJQUEzQixFQUFpQ0MsUUFBakMsQ0FBTjtBQUNGO0FBQ0QsaUNBQVE2RCxJQUFSLG9DQUFnQkgsU0FBaEI7O0FBRUEsZ0JBQU1JLFVBQVVDLFlBQVkvRCxTQUFTd0IsT0FBVCxDQUFpQndDLElBQTdCLENBQWhCO0FBQ0EsZ0JBQUlGLE9BQUosRUFBYTtBQUNWbEUsMkNBQTBCa0UsT0FBMUI7QUFDQSxzQkFBTyxPQUFLRyxnQkFBTCxDQUFzQkgsT0FBdEIsRUFBK0JOLE9BQS9CLEVBQXdDbkIsRUFBeEMsRUFBNENvQixPQUE1QyxDQUFQO0FBQ0Y7O0FBRUQsZ0JBQUlwQixFQUFKLEVBQVE7QUFDTEEsa0JBQUcsSUFBSCxFQUFTb0IsT0FBVCxFQUFrQnpELFFBQWxCO0FBQ0Y7O0FBRURBLHFCQUFTb0MsSUFBVCxHQUFnQnFCLE9BQWhCO0FBQ0EsbUJBQU96RCxRQUFQO0FBQ0YsVUF6QkcsRUF5QkQrQyxLQXpCQyxDQXlCS0MscUJBQXFCWCxFQUFyQixFQUF5QnRDLElBQXpCLENBekJMLENBQVA7QUEwQkY7Ozs7OztBQUdKbUUsT0FBT0MsT0FBUCxHQUFpQjlELFdBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQU0rRCx1QkFBdUIsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQixRQUFoQixDQUE3QjtBQUNBLFNBQVMxQixlQUFULENBQXlCUCxNQUF6QixFQUFpQztBQUM5QixVQUFPaUMscUJBQXFCbEQsT0FBckIsQ0FBNkJpQixNQUE3QixNQUF5QyxDQUFDLENBQWpEO0FBQ0Y7O0FBRUQsU0FBUzRCLFdBQVQsR0FBdUM7QUFBQSxPQUFsQk0sV0FBa0IsdUVBQUosRUFBSTs7QUFDcEMsT0FBTUMsUUFBUUQsWUFBWUUsS0FBWixDQUFrQixTQUFsQixDQUFkLENBRG9DLENBQ1E7QUFDNUMsVUFBT0QsTUFBTUUsTUFBTixDQUFhLFVBQVNWLE9BQVQsRUFBa0JFLElBQWxCLEVBQXdCO0FBQ3pDLFVBQUlBLEtBQUtTLE1BQUwsQ0FBWSxZQUFaLE1BQThCLENBQUMsQ0FBbkMsRUFBc0M7QUFDbkMsZ0JBQU8sQ0FBQ1QsS0FBS1UsS0FBTCxDQUFXLFFBQVgsS0FBd0IsRUFBekIsRUFBNkIsQ0FBN0IsQ0FBUDtBQUNGOztBQUVELGFBQU9aLE9BQVA7QUFDRixJQU5NLEVBTUpuQixTQU5JLENBQVA7QUFPRjs7QUFFRCxTQUFTSyxvQkFBVCxDQUE4QlgsRUFBOUIsRUFBa0N0QyxJQUFsQyxFQUF3QztBQUNyQyxVQUFPLFNBQVM0RSxPQUFULENBQWlCQyxNQUFqQixFQUF5QjtBQUM3QixVQUFJQyxjQUFKO0FBQ0EsVUFBSUQsT0FBT0UsY0FBUCxDQUFzQixRQUF0QixDQUFKLEVBQXFDO0FBQUEsZ0NBQzhCRixNQUQ5QixDQUMzQjVFLFFBRDJCO0FBQUEsYUFDaEJHLE1BRGdCLG9CQUNoQkEsTUFEZ0I7QUFBQSxhQUNSNEUsVUFEUSxvQkFDUkEsVUFEUTtBQUFBLDhCQUM4QkgsTUFEOUIsQ0FDSzFFLE1BREw7QUFBQSxhQUNjaUMsTUFEZCxrQkFDY0EsTUFEZDtBQUFBLGFBQ3NCbEIsR0FEdEIsa0JBQ3NCQSxHQUR0Qjs7QUFFbEMsYUFBSW5CLFVBQWNLLE1BQWQsOEJBQTZDZ0MsTUFBN0MsU0FBdURsQixHQUF2RCxXQUFnRThELFVBQWhFLE1BQUo7QUFDQUYsaUJBQVEsSUFBSWhGLGFBQUosQ0FBa0JDLE9BQWxCLEVBQTJCQyxJQUEzQixFQUFpQzZFLE1BQWpDLENBQVI7QUFDQWhGLGFBQU9FLE9BQVAsU0FBa0JrRixLQUFLQyxTQUFMLENBQWVMLE9BQU94QyxJQUF0QixDQUFsQjtBQUNGLE9BTEQsTUFLTztBQUNKeUMsaUJBQVFELE1BQVI7QUFDRjtBQUNELFVBQUl2QyxFQUFKLEVBQVE7QUFDTHpDLGFBQUkseUJBQUo7QUFDQXlDLFlBQUd3QyxLQUFIO0FBQ0YsT0FIRCxNQUdPO0FBQ0pqRixhQUFJLGdCQUFKO0FBQ0EsZUFBTWlGLEtBQU47QUFDRjtBQUNILElBakJEO0FBa0JGIiwiZmlsZSI6IlJlcXVlc3RhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHtCYXNlNjR9IGZyb20gJ2pzLWJhc2U2NCc7XG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdnaXRodWI6cmVxdWVzdCcpO1xuXG4vKipcbiAqIFRoZSBlcnJvciBzdHJ1Y3R1cmUgcmV0dXJuZWQgd2hlbiBhIG5ldHdvcmsgY2FsbCBmYWlsc1xuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgLyoqXG4gICAgKiBDb25zdHJ1Y3QgYSBuZXcgUmVzcG9uc2VFcnJvclxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBhbiBtZXNzYWdlIHRvIHJldHVybiBpbnN0ZWFkIG9mIHRoZSB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSByZXF1ZXN0ZWQgcGF0aFxuICAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gdGhlIG9iamVjdCByZXR1cm5lZCBieSBBeGlvc1xuICAgICovXG4gICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCByZXNwb25zZSkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVzcG9uc2UuY29uZmlnO1xuICAgICAgdGhpcy5yZXNwb25zZSA9IChyZXNwb25zZSB8fCB7fSkucmVzcG9uc2UgfHwgcmVzcG9uc2U7XG4gICAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0YWJsZSB3cmFwcyB0aGUgbG9naWMgZm9yIG1ha2luZyBodHRwIHJlcXVlc3RzIHRvIHRoZSBBUElcbiAqL1xuY2xhc3MgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBFaXRoZXIgYSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgb3IgYW4gb2F1dGggdG9rZW4gZm9yIEdpdGh1YlxuICAgICogQHR5cGVkZWYge09iamVjdH0gUmVxdWVzdGFibGUuYXV0aFxuICAgICogQHByb3Age3N0cmluZ30gW3VzZXJuYW1lXSAtIHRoZSBHaXRodWIgdXNlcm5hbWVcbiAgICAqIEBwcm9wIHtzdHJpbmd9IFtwYXNzd29yZF0gLSB0aGUgdXNlcidzIHBhc3N3b3JkXG4gICAgKiBAcHJvcCB7dG9rZW59IFt0b2tlbl0gLSBhbiBPQXV0aCB0b2tlblxuICAgICovXG4gICAvKipcbiAgICAqIEluaXRpYWxpemUgdGhlIGh0dHAgaW50ZXJuYWxzLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1Yi4gSWYgYXV0aCBpc1xuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHByb3ZpZGVkIHJlcXVlc3Qgd2lsbCBiZSBtYWRlIHVuYXV0aGVudGljYXRlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlPWh0dHBzOi8vYXBpLmdpdGh1Yi5jb21dIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbQWNjZXB0SGVhZGVyPXYzXSAtIHRoZSBhY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdHNcbiAgICAqL1xuICAgY29uc3RydWN0b3IoYXV0aCwgYXBpQmFzZSwgQWNjZXB0SGVhZGVyKSB7XG4gICAgICB0aGlzLl9fYXBpQmFzZSA9IGFwaUJhc2UgfHwgJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xuICAgICAgdGhpcy5fX2F1dGggPSB7XG4gICAgICAgICB0b2tlbjogYXV0aC50b2tlbixcbiAgICAgICAgIHVzZXJuYW1lOiBhdXRoLnVzZXJuYW1lLFxuICAgICAgICAgcGFzc3dvcmQ6IGF1dGgucGFzc3dvcmQsXG4gICAgICB9O1xuICAgICAgdGhpcy5fX0FjY2VwdEhlYWRlciA9IEFjY2VwdEhlYWRlciB8fCAndjMnO1xuXG4gICAgICBpZiAoYXV0aC50b2tlbikge1xuICAgICAgICAgdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXIgPSAndG9rZW4gJyArIGF1dGgudG9rZW47XG4gICAgICB9IGVsc2UgaWYgKGF1dGgudXNlcm5hbWUgJiYgYXV0aC5wYXNzd29yZCkge1xuICAgICAgICAgdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXIgPSAnQmFzaWMgJyArIEJhc2U2NC5lbmNvZGUoYXV0aC51c2VybmFtZSArICc6JyArIGF1dGgucGFzc3dvcmQpO1xuICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIENvbXB1dGUgdGhlIFVSTCB0byB1c2UgdG8gbWFrZSBhIHJlcXVlc3QuXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBlaXRoZXIgYSBVUkwgcmVsYXRpdmUgdG8gdGhlIEFQSSBiYXNlIG9yIGFuIGFic29sdXRlIFVSTFxuICAgICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBVUkwgdG8gdXNlXG4gICAgKi9cbiAgIF9fZ2V0VVJMKHBhdGgpIHtcbiAgICAgIGxldCB1cmwgPSBwYXRoO1xuXG4gICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID09PSAtMSkge1xuICAgICAgICAgdXJsID0gdGhpcy5fX2FwaUJhc2UgKyBwYXRoO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3Q2FjaGVCdXN0ZXIgPSAndGltZXN0YW1wPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvKHRpbWVzdGFtcD1cXGQrKS8sIG5ld0NhY2hlQnVzdGVyKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBoZWFkZXJzIHJlcXVpcmVkIGZvciBhbiBBUEkgcmVxdWVzdC5cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJhdyAtIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSB0cmVhdGVkIGFzIEpTT04gb3IgYXMgYSByYXcgcmVxdWVzdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IEFjY2VwdEhlYWRlciAtIHRoZSBhY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBoZWFkZXJzIHRvIHVzZSBpbiB0aGUgcmVxdWVzdFxuICAgICovXG4gICBfX2dldFJlcXVlc3RIZWFkZXJzKHJhdywgQWNjZXB0SGVhZGVyKSB7XG4gICAgICBsZXQgaGVhZGVycyA9IHtcbiAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi4nICsgKEFjY2VwdEhlYWRlciB8fCB0aGlzLl9fQWNjZXB0SGVhZGVyKSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgIGhlYWRlcnMuQWNjZXB0ICs9ICcucmF3JztcbiAgICAgIH1cbiAgICAgIGhlYWRlcnMuQWNjZXB0ICs9ICcranNvbic7XG5cbiAgICAgIGlmICh0aGlzLl9fYXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gdGhpcy5fX2F1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgQVBJIHJlcXVlc3RzXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RPcHRpb25zPXt9XSAtIHRoZSBjdXJyZW50IG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcmVxdWVzdFxuICAgICovXG4gICBfZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cyhyZXF1ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgICBpZiAoIShyZXF1ZXN0T3B0aW9ucy52aXNpYmlsaXR5IHx8IHJlcXVlc3RPcHRpb25zLmFmZmlsaWF0aW9uKSkge1xuICAgICAgICAgcmVxdWVzdE9wdGlvbnMudHlwZSA9IHJlcXVlc3RPcHRpb25zLnR5cGUgfHwgJ2FsbCc7XG4gICAgICB9XG4gICAgICByZXF1ZXN0T3B0aW9ucy5zb3J0ID0gcmVxdWVzdE9wdGlvbnMuc29ydCB8fCAndXBkYXRlZCc7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5wZXJfcGFnZSA9IHJlcXVlc3RPcHRpb25zLnBlcl9wYWdlIHx8ICcxMDAnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIHJldHVybiByZXF1ZXN0T3B0aW9ucztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBpZiBhIGBEYXRlYCBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBJU08gc3RyaW5nXG4gICAgKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgb2JqZWN0IHRvIGF0dGVtcHQgdG8gY29vZXJjZSBpbnRvIGFuIElTTyBkYXRlIHN0cmluZ1xuICAgICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBJU08gcmVwcmVzZW50YXRpb24gb2YgYGRhdGVgIG9yIHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gaWYgaXQgd2FzIG5vdCBhIGRhdGVcbiAgICAqL1xuICAgX2RhdGVUb0lTTyhkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSAmJiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICBkYXRlID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIHJlc3VsdCBvZiB0aGUgQVBJIHJlcXVlc3QuXG4gICAgKiBAY2FsbGJhY2sgUmVxdWVzdGFibGUuY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuRXJyb3J9IGVycm9yIC0gdGhlIGVycm9yIHJldHVybmVkIGJ5IHRoZSBBUEkgb3IgYG51bGxgXG4gICAgKiBAcGFyYW0geyhPYmplY3R8dHJ1ZSl9IHJlc3VsdCAtIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBBUEkgb3IgYHRydWVgIGlmIHRoZSBBUEkgcmV0dXJucyBgMjA0IE5vIENvbnRlbnRgXG4gICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIHRoZSByYXcge0BsaW5rY29kZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9heGlvcyNyZXNwb25zZS1zY2hlbWEgUmVzcG9uc2V9XG4gICAgKi9cbiAgIC8qKlxuICAgICogTWFrZSBhIHJlcXVlc3QuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0gdGhlIG1ldGhvZCBmb3IgdGhlIHJlcXVlc3QgKEdFVCwgUFVULCBQT1NULCBERUxFVEUpXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGZvciB0aGUgcmVxdWVzdFxuICAgICogQHBhcmFtIHsqfSBbZGF0YV0gLSB0aGUgZGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIEZvciBIVFRQIG1ldGhvZHMgdGhhdCBkb24ndCBoYXZlIGEgYm9keSB0aGUgZGF0YVxuICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzZW50IGFzIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgY2FsbGJhY2sgZm9yIHRoZSByZXF1ZXN0XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyYXc9ZmFsc2VdIC0gaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHNlbnQgYXMgcmF3LiBJZiB0aGlzIGlzIGEgZmFsc3kgdmFsdWUgdGhlbiB0aGVcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCB3aWxsIGJlIG1hZGUgYXMgSlNPTlxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgUHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBfcmVxdWVzdChtZXRob2QsIHBhdGgsIGRhdGEsIGNiLCByYXcpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuX19nZXRVUkwocGF0aCk7XG5cbiAgICAgIGNvbnN0IEFjY2VwdEhlYWRlciA9IChkYXRhIHx8IHt9KS5BY2NlcHRIZWFkZXI7XG4gICAgICBpZiAoQWNjZXB0SGVhZGVyKSB7XG4gICAgICAgICBkZWxldGUgZGF0YS5BY2NlcHRIZWFkZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fX2dldFJlcXVlc3RIZWFkZXJzKHJhdywgQWNjZXB0SGVhZGVyKTtcblxuICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG5cbiAgICAgIGNvbnN0IHNob3VsZFVzZURhdGFBc1BhcmFtcyA9IGRhdGEgJiYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgJiYgbWV0aG9kSGFzTm9Cb2R5KG1ldGhvZCk7XG4gICAgICBpZiAoc2hvdWxkVXNlRGF0YUFzUGFyYW1zKSB7XG4gICAgICAgICBxdWVyeVBhcmFtcyA9IGRhdGE7XG4gICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgIHBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgcmVzcG9uc2VUeXBlOiByYXcgPyAndGV4dCcgOiAnanNvbicsXG4gICAgICB9O1xuXG4gICAgICBsb2coYCR7Y29uZmlnLm1ldGhvZH0gdG8gJHtjb25maWcudXJsfWApO1xuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2UgPSBheGlvcyhjb25maWcpLmNhdGNoKGNhbGxiYWNrRXJyb3JPclRocm93KGNiLCBwYXRoKSk7XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICAgcmVxdWVzdFByb21pc2UudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIE9iamVjdC5rZXlzKHJlc3BvbnNlLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgIC8vIFdoZW4gZGF0YSBoYXMgcmVzdWx0c1xuICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzcG9uc2UuZGF0YSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcubWV0aG9kICE9PSAnR0VUJyAmJiBPYmplY3Qua2V5cyhyZXNwb25zZS5kYXRhKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAvLyBUcnVlIHdoZW4gc3VjY2Vzc2Z1bCBzdWJtaXQgYSByZXF1ZXN0IGFuZCByZWNlaXZlIGEgZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICBjYihudWxsLCAocmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNiKG51bGwsIHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdFByb21pc2U7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTWFrZSBhIHJlcXVlc3QgdG8gYW4gZW5kcG9pbnQgdGhlIHJldHVybnMgMjA0IHdoZW4gdHJ1ZSBhbmQgNDA0IHdoZW4gZmFsc2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gcmVxdWVzdFxuICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBhbnkgcXVlcnkgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGB0cnVlYCBvciBgZmFsc2VgXG4gICAgKiBAcGFyYW0ge21ldGhvZH0gW21ldGhvZD1HRVRdIC0gSFRUUCBNZXRob2QgdG8gdXNlXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIF9yZXF1ZXN0MjA0b3I0MDQocGF0aCwgZGF0YSwgY2IsIG1ldGhvZCA9ICdHRVQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChtZXRob2QsIHBhdGgsIGRhdGEpXG4gICAgICAgICAudGhlbihmdW5jdGlvbiBzdWNjZXNzKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgIGNiKG51bGwsIHRydWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgfSwgZnVuY3Rpb24gZmFpbHVyZShyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZhbHNlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBNYWtlIGEgcmVxdWVzdCBhbmQgZmV0Y2ggYWxsIHRoZSBhdmFpbGFibGUgZGF0YS4gR2l0aHViIHdpbGwgcGFnaW5hdGUgcmVzcG9uc2VzIHNvIGZvciBxdWVyaWVzXG4gICAgKiB0aGF0IG1pZ2h0IHNwYW4gbXVsdGlwbGUgcGFnZXMgdGhpcyBtZXRob2QgaXMgcHJlZmVycmVkIHRvIHtAbGluayBSZXF1ZXN0YWJsZSNyZXF1ZXN0fVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0byByZXF1ZXN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB0aGUgZnVuY3Rpb24gdG8gcmVjZWl2ZSB0aGUgZGF0YS4gVGhlIHJldHVybmVkIGRhdGEgd2lsbCBhbHdheXMgYmUgYW4gYXJyYXkuXG4gICAgKiBAcGFyYW0ge09iamVjdFtdfSByZXN1bHRzIC0gdGhlIHBhcnRpYWwgcmVzdWx0cy4gVGhpcyBhcmd1bWVudCBpcyBpbnRlbmRlZCBmb3IgaW50ZXJhbCB1c2Ugb25seS5cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCBwYWdlcyBoYXZlIGJlZW4gZmV0Y2hlZFxuICAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIGZvbGRlZCBpbnRvIHtAbGluayBSZXF1ZXN0YWJsZSNfcmVxdWVzdH0gaW4gdGhlIDIuMCByZWxlYXNlLlxuICAgICovXG4gICBfcmVxdWVzdEFsbFBhZ2VzKHBhdGgsIG9wdGlvbnMsIGNiLCByZXN1bHRzKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHBhdGgsIG9wdGlvbnMpXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCB0aGlzR3JvdXA7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICB0aGlzR3JvdXAgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhLml0ZW1zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgIHRoaXNHcm91cCA9IHJlc3BvbnNlLmRhdGEuaXRlbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgY2Fubm90IGZpZ3VyZSBvdXQgaG93IHRvIGFwcGVuZCAke3Jlc3BvbnNlLmRhdGF9IHRvIHRoZSByZXN1bHQgc2V0YDtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHBhdGgsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi50aGlzR3JvdXApO1xuXG4gICAgICAgICAgICBjb25zdCBuZXh0VXJsID0gZ2V0TmV4dFBhZ2UocmVzcG9uc2UuaGVhZGVycy5saW5rKTtcbiAgICAgICAgICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgICAgICAgICBsb2coYGdldHRpbmcgbmV4dCBwYWdlOiAke25leHRVcmx9YCk7XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKG5leHRVcmwsIG9wdGlvbnMsIGNiLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICBjYihudWxsLCByZXN1bHRzLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXN1bHRzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgfSkuY2F0Y2goY2FsbGJhY2tFcnJvck9yVGhyb3coY2IsIHBhdGgpKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0YWJsZTtcblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gLy9cbi8vICBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgIC8vXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAvL1xuY29uc3QgTUVUSE9EU19XSVRIX05PX0JPRFkgPSBbJ0dFVCcsICdIRUFEJywgJ0RFTEVURSddO1xuZnVuY3Rpb24gbWV0aG9kSGFzTm9Cb2R5KG1ldGhvZCkge1xuICAgcmV0dXJuIE1FVEhPRFNfV0lUSF9OT19CT0RZLmluZGV4T2YobWV0aG9kKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRQYWdlKGxpbmtzSGVhZGVyID0gJycpIHtcbiAgIGNvbnN0IGxpbmtzID0gbGlua3NIZWFkZXIuc3BsaXQoL1xccyosXFxzKi8pOyAvLyBzcGxpdHMgYW5kIHN0cmlwcyB0aGUgdXJsc1xuICAgcmV0dXJuIGxpbmtzLnJlZHVjZShmdW5jdGlvbihuZXh0VXJsLCBsaW5rKSB7XG4gICAgICBpZiAobGluay5zZWFyY2goL3JlbD1cIm5leHRcIi8pICE9PSAtMSkge1xuICAgICAgICAgcmV0dXJuIChsaW5rLm1hdGNoKC88KC4qKT4vKSB8fCBbXSlbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0VXJsO1xuICAgfSwgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tFcnJvck9yVGhyb3coY2IsIHBhdGgpIHtcbiAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKG9iamVjdCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY29uZmlnJykpIHtcbiAgICAgICAgIGNvbnN0IHtyZXNwb25zZToge3N0YXR1cywgc3RhdHVzVGV4dH0sIGNvbmZpZzoge21ldGhvZCwgdXJsfX0gPSBvYmplY3Q7XG4gICAgICAgICBsZXQgbWVzc2FnZSA9IChgJHtzdGF0dXN9IGVycm9yIG1ha2luZyByZXF1ZXN0ICR7bWV0aG9kfSAke3VybH06IFwiJHtzdGF0dXNUZXh0fVwiYCk7XG4gICAgICAgICBlcnJvciA9IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHBhdGgsIG9iamVjdCk7XG4gICAgICAgICBsb2coYCR7bWVzc2FnZX0gJHtKU09OLnN0cmluZ2lmeShvYmplY3QuZGF0YSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgZXJyb3IgPSBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgIGxvZygnZ29pbmcgdG8gZXJyb3IgY2FsbGJhY2snKTtcbiAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBsb2coJ3Rocm93aW5nIGVycm9yJyk7XG4gICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgIH07XG59XG4iXX0=
	//# sourceMappingURL=Requestable.js.map


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(352);

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);
	var bind = __webpack_require__(354);
	var Axios = __webpack_require__(355);
	var defaults = __webpack_require__(356);

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(373);
	axios.CancelToken = __webpack_require__(374);
	axios.isCancel = __webpack_require__(370);

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(375);

	module.exports = axios;

	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var bind = __webpack_require__(354);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 354 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(356);
	var utils = __webpack_require__(353);
	var InterceptorManager = __webpack_require__(367);
	var dispatchRequest = __webpack_require__(368);
	var isAbsoluteURL = __webpack_require__(371);
	var combineURLs = __webpack_require__(372);

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }

	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	module.exports = Axios;


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(353);
	var normalizeHeaderName = __webpack_require__(357);

	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(358);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(358);
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	module.exports = defaults;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(347)))

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(353);
	var settle = __webpack_require__(359);
	var buildURL = __webpack_require__(362);
	var parseHeaders = __webpack_require__(363);
	var isURLSameOrigin = __webpack_require__(364);
	var createError = __webpack_require__(360);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(365);

	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;

	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(366);

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(347)))

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var createError = __webpack_require__(360);

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response
	    ));
	  }
	};


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var enhanceError = __webpack_require__(361);

	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};


/***/ }),
/* 361 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }

	      if (!utils.isArray(val)) {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;

	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 365 */
/***/ (function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));

	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }

	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }

	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }

	        if (secure === true) {
	          cookie.push('secure');
	        }

	        document.cookie = cookie.join('; ');
	      },

	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },

	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	module.exports = InterceptorManager;


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);
	var transformData = __webpack_require__(369);
	var isCancel = __webpack_require__(370);
	var defaults = __webpack_require__(356);

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(353);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};


/***/ }),
/* 370 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ }),
/* 371 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ }),
/* 372 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};


/***/ }),
/* 373 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	module.exports = Cancel;


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Cancel = __webpack_require__(373);

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	module.exports = CancelToken;


/***/ }),
/* 375 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(377);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return;

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}

	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }

	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(347)))

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(378);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0, i;

	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  return debug;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  exports.names = [];
	  exports.skips = [];

	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ }),
/* 378 */
/***/ (function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*
	 *  base64.js
	 *
	 *  Licensed under the BSD 3-Clause License.
	 *    http://opensource.org/licenses/BSD-3-Clause
	 *
	 *  References:
	 *    http://en.wikipedia.org/wiki/Base64
	 */
	;(function (global, factory) {
	     true
	        ? module.exports = factory(global)
	        : typeof define === 'function' && define.amd
	        ? define(factory) : factory(global)
	}((
	    typeof self !== 'undefined' ? self
	        : typeof window !== 'undefined' ? window
	        : typeof global !== 'undefined' ? global
	: this
	), function(global) {
	    'use strict';
	    // existing version for noConflict()
	    var _Base64 = global.Base64;
	    var version = "2.5.0";
	    // if node.js and NOT React Native, we use Buffer
	    var buffer;
	    if (typeof module !== 'undefined' && module.exports) {
	        try {
	            buffer = eval("require('buffer').Buffer");
	        } catch (err) {
	            buffer = undefined;
	        }
	    }
	    // constants
	    var b64chars
	        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    var b64tab = function(bin) {
	        var t = {};
	        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
	        return t;
	    }(b64chars);
	    var fromCharCode = String.fromCharCode;
	    // encoder stuff
	    var cb_utob = function(c) {
	        if (c.length < 2) {
	            var cc = c.charCodeAt(0);
	            return cc < 0x80 ? c
	                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
	                                + fromCharCode(0x80 | (cc & 0x3f)))
	                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
	                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                   + fromCharCode(0x80 | ( cc         & 0x3f)));
	        } else {
	            var cc = 0x10000
	                + (c.charCodeAt(0) - 0xD800) * 0x400
	                + (c.charCodeAt(1) - 0xDC00);
	            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
	                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
	                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                    + fromCharCode(0x80 | ( cc         & 0x3f)));
	        }
	    };
	    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	    var utob = function(u) {
	        return u.replace(re_utob, cb_utob);
	    };
	    var cb_encode = function(ccc) {
	        var padlen = [0, 2, 1][ccc.length % 3],
	        ord = ccc.charCodeAt(0) << 16
	            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
	            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
	        chars = [
	            b64chars.charAt( ord >>> 18),
	            b64chars.charAt((ord >>> 12) & 63),
	            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	        ];
	        return chars.join('');
	    };
	    var btoa = global.btoa ? function(b) {
	        return global.btoa(b);
	    } : function(b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };
	    var _encode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function (u) {
	            return (u.constructor === buffer.constructor ? u : buffer.from(u))
	                .toString('base64')
	        }
	        :  function (u) {
	            return (u.constructor === buffer.constructor ? u : new  buffer(u))
	                .toString('base64')
	        }
	        : function (u) { return btoa(utob(u)) }
	    ;
	    var encode = function(u, urisafe) {
	        return !urisafe
	            ? _encode(String(u))
	            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
	                return m0 == '+' ? '-' : '_';
	            }).replace(/=/g, '');
	    };
	    var encodeURI = function(u) { return encode(u, true) };
	    // decoder stuff
	    var re_btou = new RegExp([
	        '[\xC0-\xDF][\x80-\xBF]',
	        '[\xE0-\xEF][\x80-\xBF]{2}',
	        '[\xF0-\xF7][\x80-\xBF]{3}'
	    ].join('|'), 'g');
	    var cb_btou = function(cccc) {
	        switch(cccc.length) {
	        case 4:
	            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
	                |    ((0x3f & cccc.charCodeAt(1)) << 12)
	                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
	                |     (0x3f & cccc.charCodeAt(3)),
	            offset = cp - 0x10000;
	            return (fromCharCode((offset  >>> 10) + 0xD800)
	                    + fromCharCode((offset & 0x3FF) + 0xDC00));
	        case 3:
	            return fromCharCode(
	                ((0x0f & cccc.charCodeAt(0)) << 12)
	                    | ((0x3f & cccc.charCodeAt(1)) << 6)
	                    |  (0x3f & cccc.charCodeAt(2))
	            );
	        default:
	            return  fromCharCode(
	                ((0x1f & cccc.charCodeAt(0)) << 6)
	                    |  (0x3f & cccc.charCodeAt(1))
	            );
	        }
	    };
	    var btou = function(b) {
	        return b.replace(re_btou, cb_btou);
	    };
	    var cb_decode = function(cccc) {
	        var len = cccc.length,
	        padlen = len % 4,
	        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
	            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
	            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
	            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
	        chars = [
	            fromCharCode( n >>> 16),
	            fromCharCode((n >>>  8) & 0xff),
	            fromCharCode( n         & 0xff)
	        ];
	        chars.length -= [0, 0, 2, 1][padlen];
	        return chars.join('');
	    };
	    var _atob = global.atob ? function(a) {
	        return global.atob(a);
	    } : function(a){
	        return a.replace(/\S{1,4}/g, cb_decode);
	    };
	    var atob = function(a) {
	        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
	    };
	    var _decode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : buffer.from(a, 'base64')).toString();
	        }
	        : function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : new buffer(a, 'base64')).toString();
	        }
	        : function(a) { return btou(_atob(a)) };
	    var decode = function(a){
	        return _decode(
	            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
	                .replace(/[^A-Za-z0-9\+\/]/g, '')
	        );
	    };
	    var noConflict = function() {
	        var Base64 = global.Base64;
	        global.Base64 = _Base64;
	        return Base64;
	    };
	    // export Base64
	    global.Base64 = {
	        VERSION: version,
	        atob: atob,
	        btoa: btoa,
	        fromBase64: decode,
	        toBase64: encode,
	        utob: utob,
	        encode: encode,
	        encodeURI: encodeURI,
	        btou: btou,
	        decode: decode,
	        noConflict: noConflict,
	        __buffer__: buffer
	    };
	    // if ES5 is available, make Base64.extendString() available
	    if (typeof Object.defineProperty === 'function') {
	        var noEnum = function(v){
	            return {value:v,enumerable:false,writable:true,configurable:true};
	        };
	        global.Base64.extendString = function () {
	            Object.defineProperty(
	                String.prototype, 'fromBase64', noEnum(function () {
	                    return decode(this)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64', noEnum(function (urisafe) {
	                    return encode(this, urisafe)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64URI', noEnum(function () {
	                    return encode(this, true)
	                }));
	        };
	    }
	    //
	    // export Base64 to the namespace
	    //
	    if (global['Meteor']) { // Meteor.js
	        Base64 = global.Base64;
	    }
	    // module.exports and AMD are mutually exclusive.
	    // module.exports has precedence.
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports.Base64 = global.Base64;
	    }
	    else if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return global.Base64 }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // that's it!
	    return {Base64: global.Base64}
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(376);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:user');

	/**
	 * A User allows scoping of API requests to a particular Github user.
	 */

	var User = function (_Requestable) {
	   _inherits(User, _Requestable);

	   /**
	    * Create a User.
	    * @param {string} [username] - the user to use for user-scoped queries
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function User(username, auth, apiBase) {
	      _classCallCheck(this, User);

	      var _this = _possibleConstructorReturn(this, (User.__proto__ || Object.getPrototypeOf(User)).call(this, auth, apiBase));

	      _this.__user = username;
	      return _this;
	   }

	   /**
	    * Get the url for the request. (dependent on if we're requesting for the authenticated user or not)
	    * @private
	    * @param {string} endpoint - the endpoint being requested
	    * @return {string} - the resolved endpoint
	    */


	   _createClass(User, [{
	      key: '__getScopedUrl',
	      value: function __getScopedUrl(endpoint) {
	         if (this.__user) {
	            return endpoint ? '/users/' + this.__user + '/' + endpoint : '/users/' + this.__user;
	         } else {
	            // eslint-disable-line
	            switch (endpoint) {
	               case '':
	                  return '/user';

	               case 'notifications':
	               case 'gists':
	                  return '/' + endpoint;

	               default:
	                  return '/user/' + endpoint;
	            }
	         }
	      }

	      /**
	       * List the user's repositories
	       * @see https://developer.github.com/v3/repos/#list-user-repositories
	       * @param {Object} [options={}] - any options to refine the search
	       * @param {Requestable.callback} [cb] - will receive the list of repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listRepos',
	      value: function listRepos(options, cb) {
	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }

	         options = this._getOptionsWithDefaults(options);

	         log('Fetching repositories with options: ' + JSON.stringify(options));
	         return this._requestAllPages(this.__getScopedUrl('repos'), options, cb);
	      }

	      /**
	       * List the orgs that the user belongs to
	       * @see https://developer.github.com/v3/orgs/#list-user-organizations
	       * @param {Requestable.callback} [cb] - will receive the list of organizations
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listOrgs',
	      value: function listOrgs(cb) {
	         return this._request('GET', this.__getScopedUrl('orgs'), null, cb);
	      }

	      /**
	       * List the user's gists
	       * @see https://developer.github.com/v3/gists/#list-a-users-gists
	       * @param {Requestable.callback} [cb] - will receive the list of gists
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listGists',
	      value: function listGists(cb) {
	         return this._request('GET', this.__getScopedUrl('gists'), null, cb);
	      }

	      /**
	       * List the user's notifications
	       * @see https://developer.github.com/v3/activity/notifications/#list-your-notifications
	       * @param {Object} [options={}] - any options to refine the search
	       * @param {Requestable.callback} [cb] - will receive the list of repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listNotifications',
	      value: function listNotifications(options, cb) {
	         options = options || {};
	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }

	         options.since = this._dateToISO(options.since);
	         options.before = this._dateToISO(options.before);

	         return this._request('GET', this.__getScopedUrl('notifications'), options, cb);
	      }

	      /**
	       * Show the user's profile
	       * @see https://developer.github.com/v3/users/#get-a-single-user
	       * @param {Requestable.callback} [cb] - will receive the user's information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getProfile',
	      value: function getProfile(cb) {
	         return this._request('GET', this.__getScopedUrl(''), null, cb);
	      }

	      /**
	       * Gets the list of starred repositories for the user
	       * @see https://developer.github.com/v3/activity/starring/#list-repositories-being-starred
	       * @param {Requestable.callback} [cb] - will receive the list of starred repositories
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listStarredRepos',
	      value: function listStarredRepos(cb) {
	         var requestOptions = this._getOptionsWithDefaults();
	         return this._requestAllPages(this.__getScopedUrl('starred'), requestOptions, cb);
	      }

	      /**
	       * List email addresses for a user
	       * @see https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
	       * @param {Requestable.callback} [cb] - will receive the list of emails
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getEmails',
	      value: function getEmails(cb) {
	         return this._request('GET', '/user/emails', null, cb);
	      }

	      /**
	       * Have the authenticated user follow this user
	       * @see https://developer.github.com/v3/users/followers/#follow-a-user
	       * @param {string} username - the user to follow
	       * @param {Requestable.callback} [cb] - will receive true if the request succeeds
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'follow',
	      value: function follow(username, cb) {
	         return this._request('PUT', '/user/following/' + this.__user, null, cb);
	      }

	      /**
	       * Have the currently authenticated user unfollow this user
	       * @see https://developer.github.com/v3/users/followers/#follow-a-user
	       * @param {string} username - the user to unfollow
	       * @param {Requestable.callback} [cb] - receives true if the request succeeds
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'unfollow',
	      value: function unfollow(username, cb) {
	         return this._request('DELETE', '/user/following/' + this.__user, null, cb);
	      }

	      /**
	       * Create a new repository for the currently authenticated user
	       * @see https://developer.github.com/v3/repos/#create
	       * @param {object} options - the repository definition
	       * @param {Requestable.callback} [cb] - will receive the API response
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRepo',
	      value: function createRepo(options, cb) {
	         return this._request('POST', '/user/repos', options, cb);
	      }
	   }]);

	   return User;
	}(_Requestable3.default);

	module.exports = User;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlVzZXIuanMiXSwibmFtZXMiOlsibG9nIiwiVXNlciIsInVzZXJuYW1lIiwiYXV0aCIsImFwaUJhc2UiLCJfX3VzZXIiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJjYiIsIl9nZXRPcHRpb25zV2l0aERlZmF1bHRzIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJfX2dldFNjb3BlZFVybCIsIl9yZXF1ZXN0Iiwic2luY2UiLCJfZGF0ZVRvSVNPIiwiYmVmb3JlIiwicmVxdWVzdE9wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7OztBQVNBLElBQU1BLE1BQU0scUJBQU0sYUFBTixDQUFaOztBQUVBOzs7O0lBR01DLEk7OztBQUNIOzs7Ozs7QUFNQSxpQkFBWUMsUUFBWixFQUFzQkMsSUFBdEIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQUE7O0FBQUEsOEdBQzVCRCxJQUQ0QixFQUN0QkMsT0FEc0I7O0FBRWxDLFlBQUtDLE1BQUwsR0FBY0gsUUFBZDtBQUZrQztBQUdwQzs7QUFFRDs7Ozs7Ozs7OztxQ0FNZUksUSxFQUFVO0FBQ3RCLGFBQUksS0FBS0QsTUFBVCxFQUFpQjtBQUNkLG1CQUFPQyx1QkFDTSxLQUFLRCxNQURYLFNBQ3FCQyxRQURyQixlQUVNLEtBQUtELE1BRmxCO0FBS0YsVUFORCxNQU1PO0FBQUU7QUFDTixvQkFBUUMsUUFBUjtBQUNHLG9CQUFLLEVBQUw7QUFDRyx5QkFBTyxPQUFQOztBQUVILG9CQUFLLGVBQUw7QUFDQSxvQkFBSyxPQUFMO0FBQ0csK0JBQVdBLFFBQVg7O0FBRUg7QUFDRyxvQ0FBZ0JBLFFBQWhCO0FBVE47QUFXRjtBQUNIOztBQUVEOzs7Ozs7Ozs7O2dDQU9VQyxPLEVBQVNDLEUsRUFBSTtBQUNwQixhQUFJLE9BQU9ELE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDaENDLGlCQUFLRCxPQUFMO0FBQ0FBLHNCQUFVLEVBQVY7QUFDRjs7QUFFREEsbUJBQVUsS0FBS0UsdUJBQUwsQ0FBNkJGLE9BQTdCLENBQVY7O0FBRUFQLHNEQUEyQ1UsS0FBS0MsU0FBTCxDQUFlSixPQUFmLENBQTNDO0FBQ0EsZ0JBQU8sS0FBS0ssZ0JBQUwsQ0FBc0IsS0FBS0MsY0FBTCxDQUFvQixPQUFwQixDQUF0QixFQUFvRE4sT0FBcEQsRUFBNkRDLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OytCQU1TQSxFLEVBQUk7QUFDVixnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCxFQUFxQixLQUFLRCxjQUFMLENBQW9CLE1BQXBCLENBQXJCLEVBQWtELElBQWxELEVBQXdETCxFQUF4RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS00sUUFBTCxDQUFjLEtBQWQsRUFBcUIsS0FBS0QsY0FBTCxDQUFvQixPQUFwQixDQUFyQixFQUFtRCxJQUFuRCxFQUF5REwsRUFBekQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQkQsTyxFQUFTQyxFLEVBQUk7QUFDNUJELG1CQUFVQSxXQUFXLEVBQXJCO0FBQ0EsYUFBSSxPQUFPQSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2hDQyxpQkFBS0QsT0FBTDtBQUNBQSxzQkFBVSxFQUFWO0FBQ0Y7O0FBRURBLGlCQUFRUSxLQUFSLEdBQWdCLEtBQUtDLFVBQUwsQ0FBZ0JULFFBQVFRLEtBQXhCLENBQWhCO0FBQ0FSLGlCQUFRVSxNQUFSLEdBQWlCLEtBQUtELFVBQUwsQ0FBZ0JULFFBQVFVLE1BQXhCLENBQWpCOztBQUVBLGdCQUFPLEtBQUtILFFBQUwsQ0FBYyxLQUFkLEVBQXFCLEtBQUtELGNBQUwsQ0FBb0IsZUFBcEIsQ0FBckIsRUFBMkROLE9BQTNELEVBQW9FQyxFQUFwRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztpQ0FNV0EsRSxFQUFJO0FBQ1osZ0JBQU8sS0FBS00sUUFBTCxDQUFjLEtBQWQsRUFBcUIsS0FBS0QsY0FBTCxDQUFvQixFQUFwQixDQUFyQixFQUE4QyxJQUE5QyxFQUFvREwsRUFBcEQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7dUNBTWlCQSxFLEVBQUk7QUFDbEIsYUFBSVUsaUJBQWlCLEtBQUtULHVCQUFMLEVBQXJCO0FBQ0EsZ0JBQU8sS0FBS0csZ0JBQUwsQ0FBc0IsS0FBS0MsY0FBTCxDQUFvQixTQUFwQixDQUF0QixFQUFzREssY0FBdEQsRUFBc0VWLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O2dDQU1VQSxFLEVBQUk7QUFDWCxnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCxFQUFxQixjQUFyQixFQUFxQyxJQUFyQyxFQUEyQ04sRUFBM0MsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzZCQU9PTixRLEVBQVVNLEUsRUFBSTtBQUNsQixnQkFBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCx1QkFBd0MsS0FBS1QsTUFBN0MsRUFBdUQsSUFBdkQsRUFBNkRHLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzsrQkFPU04sUSxFQUFVTSxFLEVBQUk7QUFDcEIsZ0JBQU8sS0FBS00sUUFBTCxDQUFjLFFBQWQsdUJBQTJDLEtBQUtULE1BQWhELEVBQTBELElBQTFELEVBQWdFRyxFQUFoRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT1dELE8sRUFBU0MsRSxFQUFJO0FBQ3JCLGdCQUFPLEtBQUtNLFFBQUwsQ0FBYyxNQUFkLEVBQXNCLGFBQXRCLEVBQXFDUCxPQUFyQyxFQUE4Q0MsRUFBOUMsQ0FBUDtBQUNGOzs7Ozs7QUFHSlcsT0FBT0MsT0FBUCxHQUFpQm5CLElBQWpCIiwiZmlsZSI6IlVzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5jb25zdCBsb2cgPSBkZWJ1ZygnZ2l0aHViOnVzZXInKTtcblxuLyoqXG4gKiBBIFVzZXIgYWxsb3dzIHNjb3Bpbmcgb2YgQVBJIHJlcXVlc3RzIHRvIGEgcGFydGljdWxhciBHaXRodWIgdXNlci5cbiAqL1xuY2xhc3MgVXNlciBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgVXNlci5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcm5hbWVdIC0gdGhlIHVzZXIgdG8gdXNlIGZvciB1c2VyLXNjb3BlZCBxdWVyaWVzXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IFthdXRoXSAtIGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvIGF1dGhlbnRpY2F0ZSB0byBHaXRodWJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpQmFzZT1odHRwczovL2FwaS5naXRodWIuY29tXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKHVzZXJuYW1lLCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX191c2VyID0gdXNlcm5hbWU7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSB1cmwgZm9yIHRoZSByZXF1ZXN0LiAoZGVwZW5kZW50IG9uIGlmIHdlJ3JlIHJlcXVlc3RpbmcgZm9yIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgb3Igbm90KVxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIHRoZSBlbmRwb2ludCBiZWluZyByZXF1ZXN0ZWRcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gLSB0aGUgcmVzb2x2ZWQgZW5kcG9pbnRcbiAgICAqL1xuICAgX19nZXRTY29wZWRVcmwoZW5kcG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLl9fdXNlcikge1xuICAgICAgICAgcmV0dXJuIGVuZHBvaW50ID9cbiAgICAgICAgICAgIGAvdXNlcnMvJHt0aGlzLl9fdXNlcn0vJHtlbmRwb2ludH1gIDpcbiAgICAgICAgICAgIGAvdXNlcnMvJHt0aGlzLl9fdXNlcn1gXG4gICAgICAgICAgICA7XG5cbiAgICAgIH0gZWxzZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgIHN3aXRjaCAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICByZXR1cm4gJy91c2VyJztcblxuICAgICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9ucyc6XG4gICAgICAgICAgICBjYXNlICdnaXN0cyc6XG4gICAgICAgICAgICAgICByZXR1cm4gYC8ke2VuZHBvaW50fWA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICByZXR1cm4gYC91c2VyLyR7ZW5kcG9pbnR9YDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSB1c2VyJ3MgcmVwb3NpdG9yaWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2xpc3QtdXNlci1yZXBvc2l0b3JpZXNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBhbnkgb3B0aW9ucyB0byByZWZpbmUgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFJlcG9zKG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG5cbiAgICAgIGxvZyhgRmV0Y2hpbmcgcmVwb3NpdG9yaWVzIHdpdGggb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXModGhpcy5fX2dldFNjb3BlZFVybCgncmVwb3MnKSwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIG9yZ3MgdGhhdCB0aGUgdXNlciBiZWxvbmdzIHRvXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy8jbGlzdC11c2VyLW9yZ2FuaXphdGlvbnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygb3JnYW5pemF0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0T3JncyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHRoaXMuX19nZXRTY29wZWRVcmwoJ29yZ3MnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXIncyBnaXN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpc3RzLyNsaXN0LWEtdXNlcnMtZ2lzdHNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgZ2lzdHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdEdpc3RzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdGhpcy5fX2dldFNjb3BlZFVybCgnZ2lzdHMnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXIncyBub3RpZmljYXRpb25zXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvYWN0aXZpdHkvbm90aWZpY2F0aW9ucy8jbGlzdC15b3VyLW5vdGlmaWNhdGlvbnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBhbnkgb3B0aW9ucyB0byByZWZpbmUgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdE5vdGlmaWNhdGlvbnMob3B0aW9ucywgY2IpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuc2luY2UgPSB0aGlzLl9kYXRlVG9JU08ob3B0aW9ucy5zaW5jZSk7XG4gICAgICBvcHRpb25zLmJlZm9yZSA9IHRoaXMuX2RhdGVUb0lTTyhvcHRpb25zLmJlZm9yZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB0aGlzLl9fZ2V0U2NvcGVkVXJsKCdub3RpZmljYXRpb25zJyksIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTaG93IHRoZSB1c2VyJ3MgcHJvZmlsZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzLyNnZXQtYS1zaW5nbGUtdXNlclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXNlcidzIGluZm9ybWF0aW9uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFByb2ZpbGUoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB0aGlzLl9fZ2V0U2NvcGVkVXJsKCcnKSwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygc3RhcnJlZCByZXBvc2l0b3JpZXMgZm9yIHRoZSB1c2VyXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvYWN0aXZpdHkvc3RhcnJpbmcvI2xpc3QtcmVwb3NpdG9yaWVzLWJlaW5nLXN0YXJyZWRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygc3RhcnJlZCByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFN0YXJyZWRSZXBvcyhjYikge1xuICAgICAgbGV0IHJlcXVlc3RPcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cygpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyh0aGlzLl9fZ2V0U2NvcGVkVXJsKCdzdGFycmVkJyksIHJlcXVlc3RPcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCBlbWFpbCBhZGRyZXNzZXMgZm9yIGEgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzL2VtYWlscy8jbGlzdC1lbWFpbC1hZGRyZXNzZXMtZm9yLWEtdXNlclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBlbWFpbHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0RW1haWxzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgJy91c2VyL2VtYWlscycsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBIYXZlIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgZm9sbG93IHRoaXMgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3VzZXJzL2ZvbGxvd2Vycy8jZm9sbG93LWEtdXNlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIC0gdGhlIHVzZXIgdG8gZm9sbG93XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9sbG93KHVzZXJuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BVVCcsIGAvdXNlci9mb2xsb3dpbmcvJHt0aGlzLl9fdXNlcn1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGF2ZSB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciB1bmZvbGxvdyB0aGlzIHVzZXJcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My91c2Vycy9mb2xsb3dlcnMvI2ZvbGxvdy1hLXVzZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIHRvIHVuZm9sbG93XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gcmVjZWl2ZXMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bmZvbGxvdyh1c2VybmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3VzZXIvZm9sbG93aW5nLyR7dGhpcy5fX3VzZXJ9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyByZXBvc2l0b3J5IGZvciB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNjcmVhdGVcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIHJlcG9zaXRvcnkgZGVmaW5pdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgQVBJIHJlc3BvbnNlXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZVJlcG8ob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgJy91c2VyL3JlcG9zJywgb3B0aW9ucywgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG4iXX0=
	//# sourceMappingURL=User.js.map


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Issue wraps the functionality to get issues for repositories
	 */
	var Issue = function (_Requestable) {
	  _inherits(Issue, _Requestable);

	  /**
	   * Create a new Issue
	   * @param {string} repository - the full name of the repository (`:user/:repo`) to get issues for
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Issue(repository, auth, apiBase) {
	    _classCallCheck(this, Issue);

	    var _this = _possibleConstructorReturn(this, (Issue.__proto__ || Object.getPrototypeOf(Issue)).call(this, auth, apiBase));

	    _this.__repository = repository;
	    return _this;
	  }

	  /**
	   * Create a new issue
	   * @see https://developer.github.com/v3/issues/#create-an-issue
	   * @param {Object} issueData - the issue to create
	   * @param {Requestable.callback} [cb] - will receive the created issue
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Issue, [{
	    key: 'createIssue',
	    value: function createIssue(issueData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/issues', issueData, cb);
	    }

	    /**
	     * List the issues for the repository
	     * @see https://developer.github.com/v3/issues/#list-issues-for-a-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of issues
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssues',
	    value: function listIssues(options, cb) {
	      return this._requestAllPages('/repos/' + this.__repository + '/issues', options, cb);
	    }

	    /**
	     * List the events for an issue
	     * @see https://developer.github.com/v3/issues/events/#list-events-for-an-issue
	     * @param {number} issue - the issue to get events for
	     * @param {Requestable.callback} [cb] - will receive the list of events
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssueEvents',
	    value: function listIssueEvents(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/events', null, cb);
	    }

	    /**
	     * List comments on an issue
	     * @see https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
	     * @param {number} issue - the id of the issue to get comments from
	     * @param {Requestable.callback} [cb] - will receive the comments
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listIssueComments',
	    value: function listIssueComments(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/comments', null, cb);
	    }

	    /**
	     * Get a single comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#get-a-single-comment
	     * @param {number} id - the comment id to get
	     * @param {Requestable.callback} [cb] - will receive the comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getIssueComment',
	    value: function getIssueComment(id, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb);
	    }

	    /**
	     * Comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#create-a-comment
	     * @param {number} issue - the id of the issue to comment on
	     * @param {string} comment - the comment to add
	     * @param {Requestable.callback} [cb] - will receive the created comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createIssueComment',
	    value: function createIssueComment(issue, comment, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/issues/' + issue + '/comments', { body: comment }, cb);
	    }

	    /**
	     * Edit a comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#edit-a-comment
	     * @param {number} id - the comment id to edit
	     * @param {string} comment - the comment to edit
	     * @param {Requestable.callback} [cb] - will receive the edited comment
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editIssueComment',
	    value: function editIssueComment(id, comment, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/issues/comments/' + id, { body: comment }, cb);
	    }

	    /**
	     * Delete a comment on an issue
	     * @see https://developer.github.com/v3/issues/comments/#delete-a-comment
	     * @param {number} id - the comment id to delete
	     * @param {Requestable.callback} [cb] - will receive true if the request is successful
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteIssueComment',
	    value: function deleteIssueComment(id, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb);
	    }

	    /**
	     * Edit an issue
	     * @see https://developer.github.com/v3/issues/#edit-an-issue
	     * @param {number} issue - the issue number to edit
	     * @param {Object} issueData - the new issue data
	     * @param {Requestable.callback} [cb] - will receive the modified issue
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editIssue',
	    value: function editIssue(issue, issueData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/issues/' + issue, issueData, cb);
	    }

	    /**
	     * Get a particular issue
	     * @see https://developer.github.com/v3/issues/#get-a-single-issue
	     * @param {number} issue - the issue number to fetch
	     * @param {Requestable.callback} [cb] - will receive the issue
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getIssue',
	    value: function getIssue(issue, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue, null, cb);
	    }

	    /**
	     * List the milestones for the repository
	     * @see https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of milestones
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMilestones',
	    value: function listMilestones(options, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/milestones', options, cb);
	    }

	    /**
	     * Get a milestone
	     * @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
	     * @param {string} milestone - the id of the milestone to fetch
	     * @param {Requestable.callback} [cb] - will receive the milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getMilestone',
	    value: function getMilestone(milestone, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb);
	    }

	    /**
	     * Create a new milestone
	     * @see https://developer.github.com/v3/issues/milestones/#create-a-milestone
	     * @param {Object} milestoneData - the milestone definition
	     * @param {Requestable.callback} [cb] - will receive the milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createMilestone',
	    value: function createMilestone(milestoneData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/milestones', milestoneData, cb);
	    }

	    /**
	     * Edit a milestone
	     * @see https://developer.github.com/v3/issues/milestones/#update-a-milestone
	     * @param {string} milestone - the id of the milestone to edit
	     * @param {Object} milestoneData - the updates to make to the milestone
	     * @param {Requestable.callback} [cb] - will receive the updated milestone
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editMilestone',
	    value: function editMilestone(milestone, milestoneData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/milestones/' + milestone, milestoneData, cb);
	    }

	    /**
	     * Delete a milestone (this is distinct from closing a milestone)
	     * @see https://developer.github.com/v3/issues/milestones/#delete-a-milestone
	     * @param {string} milestone - the id of the milestone to delete
	     * @param {Requestable.callback} [cb] - will receive the status
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteMilestone',
	    value: function deleteMilestone(milestone, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb);
	    }

	    /**
	     * Create a new label
	     * @see https://developer.github.com/v3/issues/labels/#create-a-label
	     * @param {Object} labelData - the label definition
	     * @param {Requestable.callback} [cb] - will receive the object representing the label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createLabel',
	    value: function createLabel(labelData, cb) {
	      return this._request('POST', '/repos/' + this.__repository + '/labels', labelData, cb);
	    }

	    /**
	     * List the labels for the repository
	     * @see https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
	     * @param {Object} options - filtering options
	     * @param {Requestable.callback} [cb] - will receive the array of labels
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listLabels',
	    value: function listLabels(options, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/labels', options, cb);
	    }

	    /**
	     * Get a label
	     * @see https://developer.github.com/v3/issues/labels/#get-a-single-label
	     * @param {string} label - the name of the label to fetch
	     * @param {Requestable.callback} [cb] - will receive the label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getLabel',
	    value: function getLabel(label, cb) {
	      return this._request('GET', '/repos/' + this.__repository + '/labels/' + label, null, cb);
	    }

	    /**
	     * Edit a label
	     * @see https://developer.github.com/v3/issues/labels/#update-a-label
	     * @param {string} label - the name of the label to edit
	     * @param {Object} labelData - the updates to make to the label
	     * @param {Requestable.callback} [cb] - will receive the updated label
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editLabel',
	    value: function editLabel(label, labelData, cb) {
	      return this._request('PATCH', '/repos/' + this.__repository + '/labels/' + label, labelData, cb);
	    }

	    /**
	     * Delete a label
	     * @see https://developer.github.com/v3/issues/labels/#delete-a-label
	     * @param {string} label - the name of the label to delete
	     * @param {Requestable.callback} [cb] - will receive the status
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteLabel',
	    value: function deleteLabel(label, cb) {
	      return this._request('DELETE', '/repos/' + this.__repository + '/labels/' + label, null, cb);
	    }
	  }]);

	  return Issue;
	}(_Requestable3.default);

	module.exports = Issue;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIklzc3VlLmpzIl0sIm5hbWVzIjpbIklzc3VlIiwicmVwb3NpdG9yeSIsImF1dGgiLCJhcGlCYXNlIiwiX19yZXBvc2l0b3J5IiwiaXNzdWVEYXRhIiwiY2IiLCJfcmVxdWVzdCIsIm9wdGlvbnMiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiaXNzdWUiLCJpZCIsImNvbW1lbnQiLCJib2R5IiwibWlsZXN0b25lIiwibWlsZXN0b25lRGF0YSIsImxhYmVsRGF0YSIsImxhYmVsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BOzs7Ozs7Ozs7OytlQVBBOzs7Ozs7O0FBU0E7OztJQUdNQSxLOzs7QUFDSDs7Ozs7O0FBTUEsaUJBQVlDLFVBQVosRUFBd0JDLElBQXhCLEVBQThCQyxPQUE5QixFQUF1QztBQUFBOztBQUFBLDhHQUM5QkQsSUFEOEIsRUFDeEJDLE9BRHdCOztBQUVwQyxVQUFLQyxZQUFMLEdBQW9CSCxVQUFwQjtBQUZvQztBQUd0Qzs7QUFFRDs7Ozs7Ozs7Ozs7Z0NBT1lJLFMsRUFBV0MsRSxFQUFJO0FBQ3hCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS0gsWUFBckMsY0FBNERDLFNBQTVELEVBQXVFQyxFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7K0JBT1dFLE8sRUFBU0YsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0csZ0JBQUwsYUFBZ0MsS0FBS0wsWUFBckMsY0FBNERJLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7b0NBT2dCSSxLLEVBQU9KLEUsRUFBSTtBQUN4QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtILFlBQXBDLGdCQUEyRE0sS0FBM0QsY0FBMkUsSUFBM0UsRUFBaUZKLEVBQWpGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztzQ0FPa0JJLEssRUFBT0osRSxFQUFJO0FBQzFCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMsZ0JBQTJETSxLQUEzRCxnQkFBNkUsSUFBN0UsRUFBbUZKLEVBQW5GLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JLLEUsRUFBSUwsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMseUJBQW9FTyxFQUFwRSxFQUEwRSxJQUExRSxFQUFnRkwsRUFBaEYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRbUJJLEssRUFBT0UsTyxFQUFTTixFLEVBQUk7QUFDcEMsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLSCxZQUFyQyxnQkFBNERNLEtBQTVELGdCQUE4RSxFQUFDRyxNQUFNRCxPQUFQLEVBQTlFLEVBQStGTixFQUEvRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O3FDQVFpQkssRSxFQUFJQyxPLEVBQVNOLEUsRUFBSTtBQUMvQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtILFlBQXRDLHlCQUFzRU8sRUFBdEUsRUFBNEUsRUFBQ0UsTUFBTUQsT0FBUCxFQUE1RSxFQUE2Rk4sRUFBN0YsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3VDQU9tQkssRSxFQUFJTCxFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLSCxZQUF2Qyx5QkFBdUVPLEVBQXZFLEVBQTZFLElBQTdFLEVBQW1GTCxFQUFuRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzhCQVFVSSxLLEVBQU9MLFMsRUFBV0MsRSxFQUFJO0FBQzdCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS0gsWUFBdEMsZ0JBQTZETSxLQUE3RCxFQUFzRUwsU0FBdEUsRUFBaUZDLEVBQWpGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs2QkFPU0ksSyxFQUFPSixFLEVBQUk7QUFDakIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxnQkFBMkRNLEtBQTNELEVBQW9FLElBQXBFLEVBQTBFSixFQUExRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7bUNBT2VFLE8sRUFBU0YsRSxFQUFJO0FBQ3pCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS0gsWUFBcEMsa0JBQStESSxPQUEvRCxFQUF3RUYsRUFBeEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9hUSxTLEVBQVdSLEUsRUFBSTtBQUN6QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtILFlBQXBDLG9CQUErRFUsU0FBL0QsRUFBNEUsSUFBNUUsRUFBa0ZSLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JTLGEsRUFBZVQsRSxFQUFJO0FBQ2hDLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS0gsWUFBckMsa0JBQWdFVyxhQUFoRSxFQUErRVQsRUFBL0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztrQ0FRY1EsUyxFQUFXQyxhLEVBQWVULEUsRUFBSTtBQUN6QyxhQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtILFlBQXRDLG9CQUFpRVUsU0FBakUsRUFBOEVDLGFBQTlFLEVBQTZGVCxFQUE3RixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7b0NBT2dCUSxTLEVBQVdSLEUsRUFBSTtBQUM1QixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtILFlBQXZDLG9CQUFrRVUsU0FBbEUsRUFBK0UsSUFBL0UsRUFBcUZSLEVBQXJGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPWVUsUyxFQUFXVixFLEVBQUk7QUFDeEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLSCxZQUFyQyxjQUE0RFksU0FBNUQsRUFBdUVWLEVBQXZFLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7OzsrQkFPWUUsTyxFQUFTRixFLEVBQUk7QUFDckIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxjQUEyREksT0FBM0QsRUFBb0VGLEVBQXBFLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7Ozs2QkFPVVcsSyxFQUFPWCxFLEVBQUk7QUFDakIsYUFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLSCxZQUFwQyxnQkFBMkRhLEtBQTNELEVBQW9FLElBQXBFLEVBQTBFWCxFQUExRSxDQUFQO0FBQ0Y7O0FBRUY7Ozs7Ozs7Ozs7OzhCQVFXVyxLLEVBQU9ELFMsRUFBV1YsRSxFQUFJO0FBQzdCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS0gsWUFBdEMsZ0JBQTZEYSxLQUE3RCxFQUFzRUQsU0FBdEUsRUFBaUZWLEVBQWpGLENBQVA7QUFDRjs7QUFFRjs7Ozs7Ozs7OztnQ0FPYVcsSyxFQUFPWCxFLEVBQUk7QUFDcEIsYUFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCxjQUFrQyxLQUFLSCxZQUF2QyxnQkFBOERhLEtBQTlELEVBQXVFLElBQXZFLEVBQTZFWCxFQUE3RSxDQUFQO0FBQ0Y7Ozs7OztBQUdKWSxPQUFPQyxPQUFQLEdBQWlCbkIsS0FBakIiLCJmaWxlIjoiSXNzdWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcblxuLyoqXG4gKiBJc3N1ZSB3cmFwcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBnZXQgaXNzdWVzIGZvciByZXBvc2l0b3JpZXNcbiAqL1xuY2xhc3MgSXNzdWUgZXh0ZW5kcyBSZXF1ZXN0YWJsZSB7XG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBJc3N1ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnkgLSB0aGUgZnVsbCBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IChgOnVzZXIvOnJlcG9gKSB0byBnZXQgaXNzdWVzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihyZXBvc2l0b3J5LCBhdXRoLCBhcGlCYXNlKSB7XG4gICAgICBzdXBlcihhdXRoLCBhcGlCYXNlKTtcbiAgICAgIHRoaXMuX19yZXBvc2l0b3J5ID0gcmVwb3NpdG9yeTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgaXNzdWVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvI2NyZWF0ZS1hbi1pc3N1ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGlzc3VlRGF0YSAtIHRoZSBpc3N1ZSB0byBjcmVhdGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGNyZWF0ZWQgaXNzdWVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlSXNzdWUoaXNzdWVEYXRhLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlc2AsIGlzc3VlRGF0YSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGlzc3VlcyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvI2xpc3QtaXNzdWVzLWZvci1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZmlsdGVyaW5nIG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGFycmF5IG9mIGlzc3Vlc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0SXNzdWVzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGV2ZW50cyBmb3IgYW4gaXNzdWVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvZXZlbnRzLyNsaXN0LWV2ZW50cy1mb3ItYW4taXNzdWVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpc3N1ZSAtIHRoZSBpc3N1ZSB0byBnZXQgZXZlbnRzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBldmVudHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdElzc3VlRXZlbnRzKGlzc3VlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzLyR7aXNzdWV9L2V2ZW50c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IGNvbW1lbnRzIG9uIGFuIGlzc3VlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL2NvbW1lbnRzLyNsaXN0LWNvbW1lbnRzLW9uLWFuLWlzc3VlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaXNzdWUgLSB0aGUgaWQgb2YgdGhlIGlzc3VlIHRvIGdldCBjb21tZW50cyBmcm9tXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb21tZW50c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0SXNzdWVDb21tZW50cyhpc3N1ZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlcy8ke2lzc3VlfS9jb21tZW50c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBzaW5nbGUgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZ2V0LWEtc2luZ2xlLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBjb21tZW50IGlkIHRvIGdldFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWVudFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRJc3N1ZUNvbW1lbnQoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvY29tbWVudHMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jY3JlYXRlLWEtY29tbWVudFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlzc3VlIC0gdGhlIGlkIG9mIHRoZSBpc3N1ZSB0byBjb21tZW50IG9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudCAtIHRoZSBjb21tZW50IHRvIGFkZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgY3JlYXRlZCBjb21tZW50XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUlzc3VlQ29tbWVudChpc3N1ZSwgY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvJHtpc3N1ZX0vY29tbWVudHNgLCB7Ym9keTogY29tbWVudH0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGEgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZWRpdC1hLWNvbW1lbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBjb21tZW50IGlkIHRvIGVkaXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50IC0gdGhlIGNvbW1lbnQgdG8gZWRpdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgZWRpdGVkIGNvbW1lbnRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdElzc3VlQ29tbWVudChpZCwgY29tbWVudCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzL2NvbW1lbnRzLyR7aWR9YCwge2JvZHk6IGNvbW1lbnR9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgY29tbWVudCBvbiBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9jb21tZW50cy8jZGVsZXRlLWEtY29tbWVudFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gdGhlIGNvbW1lbnQgaWQgdG8gZGVsZXRlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVJc3N1ZUNvbW1lbnQoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9pc3N1ZXMvY29tbWVudHMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhbiBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy8jZWRpdC1hbi1pc3N1ZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlzc3VlIC0gdGhlIGlzc3VlIG51bWJlciB0byBlZGl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gaXNzdWVEYXRhIC0gdGhlIG5ldyBpc3N1ZSBkYXRhXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBpc3N1ZVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBlZGl0SXNzdWUoaXNzdWUsIGlzc3VlRGF0YSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vaXNzdWVzLyR7aXNzdWV9YCwgaXNzdWVEYXRhLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgcGFydGljdWxhciBpc3N1ZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy8jZ2V0LWEtc2luZ2xlLWlzc3VlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaXNzdWUgLSB0aGUgaXNzdWUgbnVtYmVyIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBpc3N1ZVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRJc3N1ZShpc3N1ZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2lzc3Vlcy8ke2lzc3VlfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBtaWxlc3RvbmVzIGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9taWxlc3RvbmVzLyNsaXN0LW1pbGVzdG9uZXMtZm9yLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBmaWx0ZXJpbmcgb3B0aW9uc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgYXJyYXkgb2YgbWlsZXN0b25lc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0TWlsZXN0b25lcyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbWlsZXN0b25lc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBtaWxlc3RvbmVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbWlsZXN0b25lcy8jZ2V0LWEtc2luZ2xlLW1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbGVzdG9uZSAtIHRoZSBpZCBvZiB0aGUgbWlsZXN0b25lIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBtaWxlc3RvbmVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0TWlsZXN0b25lKG1pbGVzdG9uZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXMvJHttaWxlc3RvbmV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBtaWxlc3RvbmVcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbWlsZXN0b25lcy8jY3JlYXRlLWEtbWlsZXN0b25lXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbWlsZXN0b25lRGF0YSAtIHRoZSBtaWxlc3RvbmUgZGVmaW5pdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWlsZXN0b25lXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZU1pbGVzdG9uZShtaWxlc3RvbmVEYXRhLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXNgLCBtaWxlc3RvbmVEYXRhLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIG1pbGVzdG9uZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9taWxlc3RvbmVzLyN1cGRhdGUtYS1taWxlc3RvbmVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaWxlc3RvbmUgLSB0aGUgaWQgb2YgdGhlIG1pbGVzdG9uZSB0byBlZGl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gbWlsZXN0b25lRGF0YSAtIHRoZSB1cGRhdGVzIHRvIG1ha2UgdG8gdGhlIG1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCBtaWxlc3RvbmVcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZWRpdE1pbGVzdG9uZShtaWxlc3RvbmUsIG1pbGVzdG9uZURhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L21pbGVzdG9uZXMvJHttaWxlc3RvbmV9YCwgbWlsZXN0b25lRGF0YSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIG1pbGVzdG9uZSAodGhpcyBpcyBkaXN0aW5jdCBmcm9tIGNsb3NpbmcgYSBtaWxlc3RvbmUpXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL21pbGVzdG9uZXMvI2RlbGV0ZS1hLW1pbGVzdG9uZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbGVzdG9uZSAtIHRoZSBpZCBvZiB0aGUgbWlsZXN0b25lIHRvIGRlbGV0ZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgc3RhdHVzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZU1pbGVzdG9uZShtaWxlc3RvbmUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9taWxlc3RvbmVzLyR7bWlsZXN0b25lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgbGFiZWxcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyNjcmVhdGUtYS1sYWJlbFxuICAgICogQHBhcmFtIHtPYmplY3R9IGxhYmVsRGF0YSAtIHRoZSBsYWJlbCBkZWZpbml0aW9uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBsYWJlbFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVMYWJlbChsYWJlbERhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbGFiZWxzYCwgbGFiZWxEYXRhLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIGxhYmVscyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2lzc3Vlcy9sYWJlbHMvI2xpc3QtYWxsLWxhYmVscy1mb3ItdGhpcy1yZXBvc2l0b3J5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZmlsdGVyaW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgYXJyYXkgb2YgbGFiZWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBsaXN0TGFiZWxzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19yZXBvc2l0b3J5fS9sYWJlbHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxhYmVsXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyNnZXQtYS1zaW5nbGUtbGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gdGhlIG5hbWUgb2YgdGhlIGxhYmVsIHRvIGZldGNoXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxhYmVsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBnZXRMYWJlbChsYWJlbCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2xhYmVscy8ke2xhYmVsfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAvKipcbiAgICogRWRpdCBhIGxhYmVsXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9pc3N1ZXMvbGFiZWxzLyN1cGRhdGUtYS1sYWJlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgdG8gZWRpdFxuICAgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxEYXRhIC0gdGhlIHVwZGF0ZXMgdG8gbWFrZSB0byB0aGUgbGFiZWxcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCBsYWJlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgZWRpdExhYmVsKGxhYmVsLCBsYWJlbERhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX3JlcG9zaXRvcnl9L2xhYmVscy8ke2xhYmVsfWAsIGxhYmVsRGF0YSwgY2IpO1xuICAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBsYWJlbFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvaXNzdWVzL2xhYmVscy8jZGVsZXRlLWEtbGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gdGhlIG5hbWUgb2YgdGhlIGxhYmVsIHRvIGRlbGV0ZVxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBzdGF0dXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGRlbGV0ZUxhYmVsKGxhYmVsLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fcmVwb3NpdG9yeX0vbGFiZWxzLyR7bGFiZWx9YCwgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElzc3VlO1xuIl19
	//# sourceMappingURL=Issue.js.map


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(376);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:search');

	/**
	 * Wrap the Search API
	 */

	var Search = function (_Requestable) {
	  _inherits(Search, _Requestable);

	  /**
	   * Create a Search
	   * @param {Object} defaults - defaults for the search
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Search(defaults, auth, apiBase) {
	    _classCallCheck(this, Search);

	    var _this = _possibleConstructorReturn(this, (Search.__proto__ || Object.getPrototypeOf(Search)).call(this, auth, apiBase));

	    _this.__defaults = _this._getOptionsWithDefaults(defaults);
	    return _this;
	  }

	  /**
	   * Available search options
	   * @see https://developer.github.com/v3/search/#parameters
	   * @typedef {Object} Search.Params
	   * @param {string} q - the query to make
	   * @param {string} sort - the sort field, one of `stars`, `forks`, or `updated`.
	   *                      Default is [best match](https://developer.github.com/v3/search/#ranking-search-results)
	   * @param {string} order - the ordering, either `asc` or `desc`
	   */
	  /**
	   * Perform a search on the GitHub API
	   * @private
	   * @param {string} path - the scope of the search
	   * @param {Search.Params} [withOptions] - additional parameters for the search
	   * @param {Requestable.callback} [cb] - will receive the results of the search
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Search, [{
	    key: '_search',
	    value: function _search(path) {
	      var _this2 = this;

	      var withOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

	      var requestOptions = {};
	      Object.keys(this.__defaults).forEach(function (prop) {
	        requestOptions[prop] = _this2.__defaults[prop];
	      });
	      Object.keys(withOptions).forEach(function (prop) {
	        requestOptions[prop] = withOptions[prop];
	      });

	      log('searching ' + path + ' with options:', requestOptions);
	      return this._requestAllPages('/search/' + path, requestOptions, cb);
	    }

	    /**
	     * Search for repositories
	     * @see https://developer.github.com/v3/search/#search-repositories
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forRepositories',
	    value: function forRepositories(options, cb) {
	      return this._search('repositories', options, cb);
	    }

	    /**
	     * Search for code
	     * @see https://developer.github.com/v3/search/#search-code
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forCode',
	    value: function forCode(options, cb) {
	      return this._search('code', options, cb);
	    }

	    /**
	     * Search for issues
	     * @see https://developer.github.com/v3/search/#search-issues
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forIssues',
	    value: function forIssues(options, cb) {
	      return this._search('issues', options, cb);
	    }

	    /**
	     * Search for users
	     * @see https://developer.github.com/v3/search/#search-users
	     * @param {Search.Params} [options] - additional parameters for the search
	     * @param {Requestable.callback} [cb] - will receive the results of the search
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'forUsers',
	    value: function forUsers(options, cb) {
	      return this._search('users', options, cb);
	    }
	  }]);

	  return Search;
	}(_Requestable3.default);

	module.exports = Search;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNlYXJjaC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJTZWFyY2giLCJkZWZhdWx0cyIsImF1dGgiLCJhcGlCYXNlIiwiX19kZWZhdWx0cyIsIl9nZXRPcHRpb25zV2l0aERlZmF1bHRzIiwicGF0aCIsIndpdGhPcHRpb25zIiwiY2IiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0T3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcCIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJvcHRpb25zIiwiX3NlYXJjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7Ozs7O0FBU0EsSUFBTUEsTUFBTSxxQkFBTSxlQUFOLENBQVo7O0FBRUE7Ozs7SUFHTUMsTTs7O0FBQ0g7Ozs7OztBQU1BLGtCQUFZQyxRQUFaLEVBQXNCQyxJQUF0QixFQUE0QkMsT0FBNUIsRUFBcUM7QUFBQTs7QUFBQSxnSEFDNUJELElBRDRCLEVBQ3RCQyxPQURzQjs7QUFFbEMsVUFBS0MsVUFBTCxHQUFrQixNQUFLQyx1QkFBTCxDQUE2QkosUUFBN0IsQ0FBbEI7QUFGa0M7QUFHcEM7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7NEJBUVFLLEksRUFBd0M7QUFBQTs7QUFBQSxVQUFsQ0MsV0FBa0MsdUVBQXBCLEVBQW9CO0FBQUEsVUFBaEJDLEVBQWdCLHVFQUFYQyxTQUFXOztBQUM3QyxVQUFJQyxpQkFBaUIsRUFBckI7QUFDQUMsYUFBT0MsSUFBUCxDQUFZLEtBQUtSLFVBQWpCLEVBQTZCUyxPQUE3QixDQUFxQyxVQUFDQyxJQUFELEVBQVU7QUFDNUNKLHVCQUFlSSxJQUFmLElBQXVCLE9BQUtWLFVBQUwsQ0FBZ0JVLElBQWhCLENBQXZCO0FBQ0YsT0FGRDtBQUdBSCxhQUFPQyxJQUFQLENBQVlMLFdBQVosRUFBeUJNLE9BQXpCLENBQWlDLFVBQUNDLElBQUQsRUFBVTtBQUN4Q0osdUJBQWVJLElBQWYsSUFBdUJQLFlBQVlPLElBQVosQ0FBdkI7QUFDRixPQUZEOztBQUlBZix5QkFBaUJPLElBQWpCLHFCQUF1Q0ksY0FBdkM7QUFDQSxhQUFPLEtBQUtLLGdCQUFMLGNBQWlDVCxJQUFqQyxFQUF5Q0ksY0FBekMsRUFBeURGLEVBQXpELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPZ0JRLE8sRUFBU1IsRSxFQUFJO0FBQzFCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLGNBQWIsRUFBNkJELE9BQTdCLEVBQXNDUixFQUF0QyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7NEJBT1FRLE8sRUFBU1IsRSxFQUFJO0FBQ2xCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLE1BQWIsRUFBcUJELE9BQXJCLEVBQThCUixFQUE5QixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OEJBT1VRLE8sRUFBU1IsRSxFQUFJO0FBQ3BCLGFBQU8sS0FBS1MsT0FBTCxDQUFhLFFBQWIsRUFBdUJELE9BQXZCLEVBQWdDUixFQUFoQyxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7NkJBT1NRLE8sRUFBU1IsRSxFQUFJO0FBQ25CLGFBQU8sS0FBS1MsT0FBTCxDQUFhLE9BQWIsRUFBc0JELE9BQXRCLEVBQStCUixFQUEvQixDQUFQO0FBQ0Y7Ozs7OztBQUdKVSxPQUFPQyxPQUFQLEdBQWlCbkIsTUFBakIiLCJmaWxlIjoiU2VhcmNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuY29uc3QgbG9nID0gZGVidWcoJ2dpdGh1YjpzZWFyY2gnKTtcblxuLyoqXG4gKiBXcmFwIHRoZSBTZWFyY2ggQVBJXG4gKi9cbmNsYXNzIFNlYXJjaCBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgU2VhcmNoXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgLSBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihkZWZhdWx0cywgYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSk7XG4gICAgICB0aGlzLl9fZGVmYXVsdHMgPSB0aGlzLl9nZXRPcHRpb25zV2l0aERlZmF1bHRzKGRlZmF1bHRzKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBdmFpbGFibGUgc2VhcmNoIG9wdGlvbnNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3BhcmFtZXRlcnNcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNlYXJjaC5QYXJhbXNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBxIC0gdGhlIHF1ZXJ5IHRvIG1ha2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0IC0gdGhlIHNvcnQgZmllbGQsIG9uZSBvZiBgc3RhcnNgLCBgZm9ya3NgLCBvciBgdXBkYXRlZGAuXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIFtiZXN0IG1hdGNoXShodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3NlYXJjaC8jcmFua2luZy1zZWFyY2gtcmVzdWx0cylcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlciAtIHRoZSBvcmRlcmluZywgZWl0aGVyIGBhc2NgIG9yIGBkZXNjYFxuICAgICovXG4gICAvKipcbiAgICAqIFBlcmZvcm0gYSBzZWFyY2ggb24gdGhlIEdpdEh1YiBBUElcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoXG4gICAgKiBAcGFyYW0ge1NlYXJjaC5QYXJhbXN9IFt3aXRoT3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBfc2VhcmNoKHBhdGgsIHdpdGhPcHRpb25zID0ge30sIGNiID0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX19kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgcmVxdWVzdE9wdGlvbnNbcHJvcF0gPSB0aGlzLl9fZGVmYXVsdHNbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKHdpdGhPcHRpb25zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICByZXF1ZXN0T3B0aW9uc1twcm9wXSA9IHdpdGhPcHRpb25zW3Byb3BdO1xuICAgICAgfSk7XG5cbiAgICAgIGxvZyhgc2VhcmNoaW5nICR7cGF0aH0gd2l0aCBvcHRpb25zOmAsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9zZWFyY2gvJHtwYXRofWAsIHJlcXVlc3RPcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogU2VhcmNoIGZvciByZXBvc2l0b3JpZXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3NlYXJjaC1yZXBvc2l0b3JpZXNcbiAgICAqIEBwYXJhbSB7U2VhcmNoLlBhcmFtc30gW29wdGlvbnNdIC0gYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc2VhcmNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByZXN1bHRzIG9mIHRoZSBzZWFyY2hcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZm9yUmVwb3NpdG9yaWVzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKCdyZXBvc2l0b3JpZXMnLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogU2VhcmNoIGZvciBjb2RlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvc2VhcmNoLyNzZWFyY2gtY29kZVxuICAgICogQHBhcmFtIHtTZWFyY2guUGFyYW1zfSBbb3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JDb2RlKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKCdjb2RlJywgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNlYXJjaCBmb3IgaXNzdWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvc2VhcmNoLyNzZWFyY2gtaXNzdWVzXG4gICAgKiBAcGFyYW0ge1NlYXJjaC5QYXJhbXN9IFtvcHRpb25zXSAtIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNlYXJjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0cyBvZiB0aGUgc2VhcmNoXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGZvcklzc3VlcyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCgnaXNzdWVzJywgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFNlYXJjaCBmb3IgdXNlcnNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9zZWFyY2gvI3NlYXJjaC11c2Vyc1xuICAgICogQHBhcmFtIHtTZWFyY2guUGFyYW1zfSBbb3B0aW9uc10gLSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JVc2VycyhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCgndXNlcnMnLCBvcHRpb25zLCBjYik7XG4gICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoO1xuIl19
	//# sourceMappingURL=Search.js.map


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * RateLimit allows users to query their rate-limit status
	 */
	var RateLimit = function (_Requestable) {
	  _inherits(RateLimit, _Requestable);

	  /**
	   * construct a RateLimit
	   * @param {Requestable.auth} auth - the credentials to authenticate to GitHub
	   * @param {string} [apiBase] - the base Github API URL
	   * @return {Promise} - the promise for the http request
	   */
	  function RateLimit(auth, apiBase) {
	    _classCallCheck(this, RateLimit);

	    return _possibleConstructorReturn(this, (RateLimit.__proto__ || Object.getPrototypeOf(RateLimit)).call(this, auth, apiBase));
	  }

	  /**
	   * Query the current rate limit
	   * @see https://developer.github.com/v3/rate_limit/
	   * @param {Requestable.callback} [cb] - will receive the rate-limit data
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(RateLimit, [{
	    key: 'getRateLimit',
	    value: function getRateLimit(cb) {
	      return this._request('GET', '/rate_limit', null, cb);
	    }
	  }]);

	  return RateLimit;
	}(_Requestable3.default);

	module.exports = RateLimit;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJhdGVMaW1pdC5qcyJdLCJuYW1lcyI6WyJSYXRlTGltaXQiLCJhdXRoIiwiYXBpQmFzZSIsImNiIiwiX3JlcXVlc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLFM7OztBQUNIOzs7Ozs7QUFNQSxxQkFBWUMsSUFBWixFQUFrQkMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQSxpSEFDbEJELElBRGtCLEVBQ1pDLE9BRFk7QUFFMUI7O0FBRUQ7Ozs7Ozs7Ozs7aUNBTWFDLEUsRUFBSTtBQUNkLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsRUFBcUIsYUFBckIsRUFBb0MsSUFBcEMsRUFBMENELEVBQTFDLENBQVA7QUFDRjs7Ozs7O0FBR0pFLE9BQU9DLE9BQVAsR0FBaUJOLFNBQWpCIiwiZmlsZSI6IlJhdGVMaW1pdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cblxuaW1wb3J0IFJlcXVlc3RhYmxlIGZyb20gJy4vUmVxdWVzdGFibGUnO1xuXG4vKipcbiAqIFJhdGVMaW1pdCBhbGxvd3MgdXNlcnMgdG8gcXVlcnkgdGhlaXIgcmF0ZS1saW1pdCBzdGF0dXNcbiAqL1xuY2xhc3MgUmF0ZUxpbWl0IGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBjb25zdHJ1Y3QgYSBSYXRlTGltaXRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuYXV0aH0gYXV0aCAtIHRoZSBjcmVkZW50aWFscyB0byBhdXRoZW50aWNhdGUgdG8gR2l0SHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2VdIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY29uc3RydWN0b3IoYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogUXVlcnkgdGhlIGN1cnJlbnQgcmF0ZSBsaW1pdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JhdGVfbGltaXQvXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByYXRlLWxpbWl0IGRhdGFcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UmF0ZUxpbWl0KGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgJy9yYXRlX2xpbWl0JywgbnVsbCwgY2IpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhdGVMaW1pdDtcbiJdfQ==
	//# sourceMappingURL=RateLimit.js.map


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _utf = __webpack_require__(389);

	var _utf2 = _interopRequireDefault(_utf);

	var _jsBase = __webpack_require__(379);

	var _debug = __webpack_require__(376);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:repository');

	/**
	 * Respository encapsulates the functionality to create, query, and modify files.
	 */

	var Repository = function (_Requestable) {
	   _inherits(Repository, _Requestable);

	   /**
	    * Create a Repository.
	    * @param {string} fullname - the full name of the repository
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function Repository(fullname, auth, apiBase) {
	      _classCallCheck(this, Repository);

	      var _this = _possibleConstructorReturn(this, (Repository.__proto__ || Object.getPrototypeOf(Repository)).call(this, auth, apiBase));

	      _this.__fullname = fullname;
	      _this.__currentTree = {
	         branch: null,
	         sha: null
	      };
	      return _this;
	   }

	   /**
	    * Get a reference
	    * @see https://developer.github.com/v3/git/refs/#get-a-reference
	    * @param {string} ref - the reference to get
	    * @param {Requestable.callback} [cb] - will receive the reference's refSpec or a list of refSpecs that match `ref`
	    * @return {Promise} - the promise for the http request
	    */


	   _createClass(Repository, [{
	      key: 'getRef',
	      value: function getRef(ref, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb);
	      }

	      /**
	       * Create a reference
	       * @see https://developer.github.com/v3/git/refs/#create-a-reference
	       * @param {Object} options - the object describing the ref
	       * @param {Requestable.callback} [cb] - will receive the ref
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRef',
	      value: function createRef(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/git/refs', options, cb);
	      }

	      /**
	       * Delete a reference
	       * @see https://developer.github.com/v3/git/refs/#delete-a-reference
	       * @param {string} ref - the name of the ref to delte
	       * @param {Requestable.callback} [cb] - will receive true if the request is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRef',
	      value: function deleteRef(ref, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb);
	      }

	      /**
	       * Delete a repository
	       * @see https://developer.github.com/v3/repos/#delete-a-repository
	       * @param {Requestable.callback} [cb] - will receive true if the request is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRepo',
	      value: function deleteRepo(cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname, null, cb);
	      }

	      /**
	       * List the tags on a repository
	       * @see https://developer.github.com/v3/repos/#list-tags
	       * @param {Requestable.callback} [cb] - will receive the tag data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listTags',
	      value: function listTags(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/tags', null, cb);
	      }

	      /**
	       * List the open pull requests on the repository
	       * @see https://developer.github.com/v3/pulls/#list-pull-requests
	       * @param {Object} options - options to filter the search
	       * @param {Requestable.callback} [cb] - will receive the list of PRs
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listPullRequests',
	      value: function listPullRequests(options, cb) {
	         options = options || {};
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls', options, cb);
	      }

	      /**
	       * Get information about a specific pull request
	       * @see https://developer.github.com/v3/pulls/#get-a-single-pull-request
	       * @param {number} number - the PR you wish to fetch
	       * @param {Requestable.callback} [cb] - will receive the PR from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getPullRequest',
	      value: function getPullRequest(number, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number, null, cb);
	      }

	      /**
	       * List the files of a specific pull request
	       * @see https://developer.github.com/v3/pulls/#list-pull-requests-files
	       * @param {number|string} number - the PR you wish to fetch
	       * @param {Requestable.callback} [cb] - will receive the list of files from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listPullRequestFiles',
	      value: function listPullRequestFiles(number, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number + '/files', null, cb);
	      }

	      /**
	       * Compare two branches/commits/repositories
	       * @see https://developer.github.com/v3/repos/commits/#compare-two-commits
	       * @param {string} base - the base commit
	       * @param {string} head - the head commit
	       * @param {Requestable.callback} cb - will receive the comparison
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'compareBranches',
	      value: function compareBranches(base, head, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/compare/' + base + '...' + head, null, cb);
	      }

	      /**
	       * List all the branches for the repository
	       * @see https://developer.github.com/v3/repos/#list-branches
	       * @param {Requestable.callback} cb - will receive the list of branches
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listBranches',
	      value: function listBranches(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/branches', null, cb);
	      }

	      /**
	       * Get a raw blob from the repository
	       * @see https://developer.github.com/v3/git/blobs/#get-a-blob
	       * @param {string} sha - the sha of the blob to fetch
	       * @param {Requestable.callback} cb - will receive the blob from the API
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getBlob',
	      value: function getBlob(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/blobs/' + sha, null, cb, 'raw');
	      }

	      /**
	       * Get a single branch
	       * @see https://developer.github.com/v3/repos/branches/#get-branch
	       * @param {string} branch - the name of the branch to fetch
	       * @param {Requestable.callback} cb - will receive the branch from the API
	       * @returns {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getBranch',
	      value: function getBranch(branch, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/branches/' + branch, null, cb);
	      }

	      /**
	       * Get a commit from the repository
	       * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit
	       * @param {string} sha - the sha for the commit to fetch
	       * @param {Requestable.callback} cb - will receive the commit data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getCommit',
	      value: function getCommit(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/commits/' + sha, null, cb);
	      }

	      /**
	       * List the commits on a repository, optionally filtering by path, author or time range
	       * @see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
	       * @param {Object} [options] - the filtering options for commits
	       * @param {string} [options.sha] - the SHA or branch to start from
	       * @param {string} [options.path] - the path to search on
	       * @param {string} [options.author] - the commit author
	       * @param {(Date|string)} [options.since] - only commits after this date will be returned
	       * @param {(Date|string)} [options.until] - only commits before this date will be returned
	       * @param {Requestable.callback} cb - will receive the list of commits found matching the criteria
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listCommits',
	      value: function listCommits(options, cb) {
	         options = options || {};

	         options.since = this._dateToISO(options.since);
	         options.until = this._dateToISO(options.until);

	         return this._request('GET', '/repos/' + this.__fullname + '/commits', options, cb);
	      }

	      /**
	       * Gets a single commit information for a repository
	       * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit
	       * @param {string} ref - the reference for the commit-ish
	       * @param {Requestable.callback} cb - will receive the commit information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getSingleCommit',
	      value: function getSingleCommit(ref, cb) {
	         ref = ref || '';
	         return this._request('GET', '/repos/' + this.__fullname + '/commits/' + ref, null, cb);
	      }

	      /**
	       * Get tha sha for a particular object in the repository. This is a convenience function
	       * @see https://developer.github.com/v3/repos/contents/#get-contents
	       * @param {string} [branch] - the branch to look in, or the repository's default branch if omitted
	       * @param {string} path - the path of the file or directory
	       * @param {Requestable.callback} cb - will receive a description of the requested object, including a `SHA` property
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getSha',
	      value: function getSha(branch, path, cb) {
	         branch = branch ? '?ref=' + branch : '';
	         return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path + branch, null, cb);
	      }

	      /**
	       * List the commit statuses for a particular sha, branch, or tag
	       * @see https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
	       * @param {string} sha - the sha, branch, or tag to get statuses for
	       * @param {Requestable.callback} cb - will receive the list of statuses
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listStatuses',
	      value: function listStatuses(sha, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/commits/' + sha + '/statuses', null, cb);
	      }

	      /**
	       * Get a description of a git tree
	       * @see https://developer.github.com/v3/git/trees/#get-a-tree
	       * @param {string} treeSHA - the SHA of the tree to fetch
	       * @param {Requestable.callback} cb - will receive the callback data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getTree',
	      value: function getTree(treeSHA, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/git/trees/' + treeSHA, null, cb);
	      }

	      /**
	       * Create a blob
	       * @see https://developer.github.com/v3/git/blobs/#create-a-blob
	       * @param {(string|Buffer|Blob)} content - the content to add to the repository
	       * @param {Requestable.callback} cb - will receive the details of the created blob
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createBlob',
	      value: function createBlob(content, cb) {
	         var postBody = this._getContentObject(content);

	         log('sending content', postBody);
	         return this._request('POST', '/repos/' + this.__fullname + '/git/blobs', postBody, cb);
	      }

	      /**
	       * Get the object that represents the provided content
	       * @param {string|Buffer|Blob} content - the content to send to the server
	       * @return {Object} the representation of `content` for the GitHub API
	       */

	   }, {
	      key: '_getContentObject',
	      value: function _getContentObject(content) {
	         if (typeof content === 'string') {
	            log('contet is a string');
	            return {
	               content: _utf2.default.encode(content),
	               encoding: 'utf-8'
	            };
	         } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
	            log('We appear to be in Node');
	            return {
	               content: content.toString('base64'),
	               encoding: 'base64'
	            };
	         } else if (typeof Blob !== 'undefined' && content instanceof Blob) {
	            log('We appear to be in the browser');
	            return {
	               content: _jsBase.Base64.encode(content),
	               encoding: 'base64'
	            };
	         } else {
	            // eslint-disable-line
	            log('Not sure what this content is: ' + (typeof content === 'undefined' ? 'undefined' : _typeof(content)) + ', ' + JSON.stringify(content));
	            throw new Error('Unknown content passed to postBlob. Must be string or Buffer (node) or Blob (web)');
	         }
	      }

	      /**
	       * Update a tree in Git
	       * @see https://developer.github.com/v3/git/trees/#create-a-tree
	       * @param {string} baseTreeSHA - the SHA of the tree to update
	       * @param {string} path - the path for the new file
	       * @param {string} blobSHA - the SHA for the blob to put at `path`
	       * @param {Requestable.callback} cb - will receive the new tree that is created
	       * @return {Promise} - the promise for the http request
	       * @deprecated use {@link Repository#createTree} instead
	       */

	   }, {
	      key: 'updateTree',
	      value: function updateTree(baseTreeSHA, path, blobSHA, cb) {
	         var newTree = {
	            base_tree: baseTreeSHA, // eslint-disable-line
	            tree: [{
	               path: path,
	               sha: blobSHA,
	               mode: '100644',
	               type: 'blob'
	            }]
	         };

	         return this._request('POST', '/repos/' + this.__fullname + '/git/trees', newTree, cb);
	      }

	      /**
	       * Create a new tree in git
	       * @see https://developer.github.com/v3/git/trees/#create-a-tree
	       * @param {Object} tree - the tree to create
	       * @param {string} baseSHA - the root sha of the tree
	       * @param {Requestable.callback} cb - will receive the new tree that is created
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createTree',
	      value: function createTree(tree, baseSHA, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/git/trees', {
	            tree: tree,
	            base_tree: baseSHA }, cb);
	      }

	      /**
	       * Add a commit to the repository
	       * @see https://developer.github.com/v3/git/commits/#create-a-commit
	       * @param {string} parent - the SHA of the parent commit
	       * @param {string} tree - the SHA of the tree for this commit
	       * @param {string} message - the commit message
	       * @param {Requestable.callback} cb - will receive the commit that is created
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'commit',
	      value: function commit(parent, tree, message, cb) {
	         var _this2 = this;

	         var data = {
	            message: message,
	            tree: tree,
	            parents: [parent]
	         };

	         return this._request('POST', '/repos/' + this.__fullname + '/git/commits', data, cb).then(function (response) {
	            _this2.__currentTree.sha = response.data.sha; // Update latest commit
	            return response;
	         });
	      }

	      /**
	       * Update a ref
	       * @see https://developer.github.com/v3/git/refs/#update-a-reference
	       * @param {string} ref - the ref to update
	       * @param {string} commitSHA - the SHA to point the reference to
	       * @param {boolean} force - indicates whether to force or ensure a fast-forward update
	       * @param {Requestable.callback} cb - will receive the updated ref back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateHead',
	      value: function updateHead(ref, commitSHA, force, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/git/refs/' + ref, {
	            sha: commitSHA,
	            force: force
	         }, cb);
	      }

	      /**
	       * Update commit status
	       * @see https://developer.github.com/v3/repos/statuses/
	       * @param {string} commitSHA - the SHA of the commit that should be updated
	       * @param {object} options - Commit status parameters
	       * @param {string} options.state - The state of the status. Can be one of: pending, success, error, or failure.
	       * @param {string} [options.target_url] - The target URL to associate with this status.
	       * @param {string} [options.description] - A short description of the status.
	       * @param {string} [options.context] - A string label to differentiate this status among CI systems.
	       * @param {Requestable.callback} cb - will receive the updated commit back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateStatus',
	      value: function updateStatus(commitSHA, options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/statuses/' + commitSHA, options, cb);
	      }

	      /**
	       * Update repository information
	       * @see https://developer.github.com/v3/repos/#edit
	       * @param {object} options - New parameters that will be set to the repository
	       * @param {string} options.name - Name of the repository
	       * @param {string} [options.description] - A short description of the repository
	       * @param {string} [options.homepage] - A URL with more information about the repository
	       * @param {boolean} [options.private] - Either true to make the repository private, or false to make it public.
	       * @param {boolean} [options.has_issues] - Either true to enable issues for this repository, false to disable them.
	       * @param {boolean} [options.has_wiki] - Either true to enable the wiki for this repository, false to disable it.
	       * @param {boolean} [options.has_downloads] - Either true to enable downloads, false to disable them.
	       * @param {string} [options.default_branch] - Updates the default branch for this repository.
	       * @param {Requestable.callback} cb - will receive the updated repository back
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateRepository',
	      value: function updateRepository(options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname, options, cb);
	      }

	      /**
	        * Get information about the repository
	        * @see https://developer.github.com/v3/repos/#get
	        * @param {Requestable.callback} cb - will receive the information about the repository
	        * @return {Promise} - the promise for the http request
	        */

	   }, {
	      key: 'getDetails',
	      value: function getDetails(cb) {
	         return this._request('GET', '/repos/' + this.__fullname, null, cb);
	      }

	      /**
	       * List the contributors to the repository
	       * @see https://developer.github.com/v3/repos/#list-contributors
	       * @param {Requestable.callback} cb - will receive the list of contributors
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContributors',
	      value: function getContributors(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/contributors', null, cb);
	      }

	      /**
	       * List the contributor stats to the repository
	       * @see https://developer.github.com/v3/repos/#list-contributors
	       * @param {Requestable.callback} cb - will receive the list of contributors
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContributorStats',
	      value: function getContributorStats(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/stats/contributors', null, cb);
	      }

	      /**
	       * List the users who are collaborators on the repository. The currently authenticated user must have
	       * push access to use this method
	       * @see https://developer.github.com/v3/repos/collaborators/#list-collaborators
	       * @param {Requestable.callback} cb - will receive the list of collaborators
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getCollaborators',
	      value: function getCollaborators(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/collaborators', null, cb);
	      }

	      /**
	       * Check if a user is a collaborator on the repository
	       * @see https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
	       * @param {string} username - the user to check
	       * @param {Requestable.callback} cb - will receive true if the user is a collaborator and false if they are not
	       * @return {Promise} - the promise for the http request {Boolean} [description]
	       */

	   }, {
	      key: 'isCollaborator',
	      value: function isCollaborator(username, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/collaborators/' + username, null, cb);
	      }

	      /**
	       * Get the contents of a repository
	       * @see https://developer.github.com/v3/repos/contents/#get-contents
	       * @param {string} ref - the ref to check
	       * @param {string} path - the path containing the content to fetch
	       * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format
	       * @param {Requestable.callback} cb - will receive the fetched data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getContents',
	      value: function getContents(ref, path, raw, cb) {
	         path = path ? '' + encodeURI(path) : '';
	         return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path, {
	            ref: ref
	         }, cb, raw);
	      }

	      /**
	       * Get the README of a repository
	       * @see https://developer.github.com/v3/repos/contents/#get-the-readme
	       * @param {string} ref - the ref to check
	       * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format
	       * @param {Requestable.callback} cb - will receive the fetched data
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getReadme',
	      value: function getReadme(ref, raw, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/readme', {
	            ref: ref
	         }, cb, raw);
	      }

	      /**
	       * Fork a repository
	       * @see https://developer.github.com/v3/repos/forks/#create-a-fork
	       * @param {Requestable.callback} cb - will receive the information about the newly created fork
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'fork',
	      value: function fork(cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/forks', null, cb);
	      }

	      /**
	       * List a repository's forks
	       * @see https://developer.github.com/v3/repos/forks/#list-forks
	       * @param {Requestable.callback} cb - will receive the list of repositories forked from this one
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listForks',
	      value: function listForks(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/forks', null, cb);
	      }

	      /**
	       * Create a new branch from an existing branch.
	       * @param {string} [oldBranch=master] - the name of the existing branch
	       * @param {string} newBranch - the name of the new branch
	       * @param {Requestable.callback} cb - will receive the commit data for the head of the new branch
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createBranch',
	      value: function createBranch(oldBranch, newBranch, cb) {
	         var _this3 = this;

	         if (typeof newBranch === 'function') {
	            cb = newBranch;
	            newBranch = oldBranch;
	            oldBranch = 'master';
	         }

	         return this.getRef('heads/' + oldBranch).then(function (response) {
	            var sha = response.data.object.sha;
	            return _this3.createRef({
	               sha: sha,
	               ref: 'refs/heads/' + newBranch
	            }, cb);
	         });
	      }

	      /**
	       * Create a new pull request
	       * @see https://developer.github.com/v3/pulls/#create-a-pull-request
	       * @param {Object} options - the pull request description
	       * @param {Requestable.callback} cb - will receive the new pull request
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createPullRequest',
	      value: function createPullRequest(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/pulls', options, cb);
	      }

	      /**
	       * Update a pull request
	       * @see https://developer.github.com/v3/pulls/#update-a-pull-request
	       * @param {number|string} number - the number of the pull request to update
	       * @param {Object} options - the pull request description
	       * @param {Requestable.callback} [cb] - will receive the pull request information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updatePullRequest',
	      value: function updatePullRequest(number, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/pulls/' + number, options, cb);
	      }

	      /**
	       * List the hooks for the repository
	       * @see https://developer.github.com/v3/repos/hooks/#list-hooks
	       * @param {Requestable.callback} cb - will receive the list of hooks
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listHooks',
	      value: function listHooks(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/hooks', null, cb);
	      }

	      /**
	       * Get a hook for the repository
	       * @see https://developer.github.com/v3/repos/hooks/#get-single-hook
	       * @param {number} id - the id of the webook
	       * @param {Requestable.callback} cb - will receive the details of the webook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getHook',
	      value: function getHook(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/hooks/' + id, null, cb);
	      }

	      /**
	       * Add a new hook to the repository
	       * @see https://developer.github.com/v3/repos/hooks/#create-a-hook
	       * @param {Object} options - the configuration describing the new hook
	       * @param {Requestable.callback} cb - will receive the new webhook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createHook',
	      value: function createHook(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/hooks', options, cb);
	      }

	      /**
	       * Edit an existing webhook
	       * @see https://developer.github.com/v3/repos/hooks/#edit-a-hook
	       * @param {number} id - the id of the webhook
	       * @param {Object} options - the new description of the webhook
	       * @param {Requestable.callback} cb - will receive the updated webhook
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateHook',
	      value: function updateHook(id, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/hooks/' + id, options, cb);
	      }

	      /**
	       * Delete a webhook
	       * @see https://developer.github.com/v3/repos/hooks/#delete-a-hook
	       * @param {number} id - the id of the webhook to be deleted
	       * @param {Requestable.callback} cb - will receive true if the call is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteHook',
	      value: function deleteHook(id, cb) {
	         return this._request('DELETE', this.__fullname + '/hooks/' + id, null, cb);
	      }

	      /**
	       * List the deploy keys for the repository
	       * @see https://developer.github.com/v3/repos/keys/#list-deploy-keys
	       * @param {Requestable.callback} cb - will receive the list of deploy keys
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listKeys',
	      value: function listKeys(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/keys', null, cb);
	      }

	      /**
	       * Get a deploy key for the repository
	       * @see https://developer.github.com/v3/repos/keys/#get-a-deploy-key
	       * @param {number} id - the id of the deploy key
	       * @param {Requestable.callback} cb - will receive the details of the deploy key
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getKey',
	      value: function getKey(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/keys/' + id, null, cb);
	      }

	      /**
	       * Add a new deploy key to the repository
	       * @see https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
	       * @param {Object} options - the configuration describing the new deploy key
	       * @param {Requestable.callback} cb - will receive the new deploy key
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createKey',
	      value: function createKey(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/keys', options, cb);
	      }

	      /**
	       * Delete a deploy key
	       * @see https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
	       * @param {number} id - the id of the deploy key to be deleted
	       * @param {Requestable.callback} cb - will receive true if the call is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteKey',
	      value: function deleteKey(id, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/keys/' + id, null, cb);
	      }

	      /**
	       * Delete a file from a branch
	       * @see https://developer.github.com/v3/repos/contents/#delete-a-file
	       * @param {string} branch - the branch to delete from, or the default branch if not specified
	       * @param {string} path - the path of the file to remove
	       * @param {Requestable.callback} cb - will receive the commit in which the delete occurred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteFile',
	      value: function deleteFile(branch, path, cb) {
	         var _this4 = this;

	         return this.getSha(branch, path).then(function (response) {
	            var deleteCommit = {
	               message: 'Delete the file at \'' + path + '\'',
	               sha: response.data.sha,
	               branch: branch
	            };
	            return _this4._request('DELETE', '/repos/' + _this4.__fullname + '/contents/' + path, deleteCommit, cb);
	         });
	      }

	      /**
	       * Change all references in a repo from oldPath to new_path
	       * @param {string} branch - the branch to carry out the reference change, or the default branch if not specified
	       * @param {string} oldPath - original path
	       * @param {string} newPath - new reference path
	       * @param {Requestable.callback} cb - will receive the commit in which the move occurred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'move',
	      value: function move(branch, oldPath, newPath, cb) {
	         var _this5 = this;

	         var oldSha = void 0;
	         return this.getRef('heads/' + branch).then(function (_ref) {
	            var object = _ref.data.object;
	            return _this5.getTree(object.sha + '?recursive=true');
	         }).then(function (_ref2) {
	            var _ref2$data = _ref2.data,
	                tree = _ref2$data.tree,
	                sha = _ref2$data.sha;

	            oldSha = sha;
	            var newTree = tree.map(function (ref) {
	               if (ref.path === oldPath) {
	                  ref.path = newPath;
	               }
	               if (ref.type === 'tree') {
	                  delete ref.sha;
	               }
	               return ref;
	            });
	            return _this5.createTree(newTree);
	         }).then(function (_ref3) {
	            var tree = _ref3.data;
	            return _this5.commit(oldSha, tree.sha, 'Renamed \'' + oldPath + '\' to \'' + newPath + '\'');
	         }).then(function (_ref4) {
	            var commit = _ref4.data;
	            return _this5.updateHead('heads/' + branch, commit.sha, true, cb);
	         });
	      }

	      /**
	       * Write a file to the repository
	       * @see https://developer.github.com/v3/repos/contents/#update-a-file
	       * @param {string} branch - the name of the branch
	       * @param {string} path - the path for the file
	       * @param {string} content - the contents of the file
	       * @param {string} message - the commit message
	       * @param {Object} [options] - commit options
	       * @param {Object} [options.author] - the author of the commit
	       * @param {Object} [options.commiter] - the committer
	       * @param {boolean} [options.encode] - true if the content should be base64 encoded
	       * @param {Requestable.callback} cb - will receive the new commit
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'writeFile',
	      value: function writeFile(branch, path, content, message, options, cb) {
	         var _this6 = this;

	         if (typeof options === 'function') {
	            cb = options;
	            options = {};
	         }
	         var filePath = path ? encodeURI(path) : '';
	         var shouldEncode = options.encode !== false;
	         var commit = {
	            branch: branch,
	            message: message,
	            author: options.author,
	            committer: options.committer,
	            content: shouldEncode ? _jsBase.Base64.encode(content) : content
	         };

	         return this.getSha(branch, filePath).then(function (response) {
	            commit.sha = response.data.sha;
	            return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb);
	         }, function () {
	            return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb);
	         });
	      }

	      /**
	       * Check if a repository is starred by you
	       * @see https://developer.github.com/v3/activity/starring/#check-if-you-are-starring-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is starred and false if the repository
	       *                                  is not starred
	       * @return {Promise} - the promise for the http request {Boolean} [description]
	       */

	   }, {
	      key: 'isStarred',
	      value: function isStarred(cb) {
	         return this._request204or404('/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Star a repository
	       * @see https://developer.github.com/v3/activity/starring/#star-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is starred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'star',
	      value: function star(cb) {
	         return this._request('PUT', '/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Unstar a repository
	       * @see https://developer.github.com/v3/activity/starring/#unstar-a-repository
	       * @param {Requestable.callback} cb - will receive true if the repository is unstarred
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'unstar',
	      value: function unstar(cb) {
	         return this._request('DELETE', '/user/starred/' + this.__fullname, null, cb);
	      }

	      /**
	       * Create a new release
	       * @see https://developer.github.com/v3/repos/releases/#create-a-release
	       * @param {Object} options - the description of the release
	       * @param {Requestable.callback} cb - will receive the newly created release
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createRelease',
	      value: function createRelease(options, cb) {
	         return this._request('POST', '/repos/' + this.__fullname + '/releases', options, cb);
	      }

	      /**
	       * Edit a release
	       * @see https://developer.github.com/v3/repos/releases/#edit-a-release
	       * @param {string} id - the id of the release
	       * @param {Object} options - the description of the release
	       * @param {Requestable.callback} cb - will receive the modified release
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateRelease',
	      value: function updateRelease(id, options, cb) {
	         return this._request('PATCH', '/repos/' + this.__fullname + '/releases/' + id, options, cb);
	      }

	      /**
	       * Get information about all releases
	       * @see https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
	       * @param {Requestable.callback} cb - will receive the release information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listReleases',
	      value: function listReleases(cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/releases', null, cb);
	      }

	      /**
	       * Get information about a release
	       * @see https://developer.github.com/v3/repos/releases/#get-a-single-release
	       * @param {string} id - the id of the release
	       * @param {Requestable.callback} cb - will receive the release information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getRelease',
	      value: function getRelease(id, cb) {
	         return this._request('GET', '/repos/' + this.__fullname + '/releases/' + id, null, cb);
	      }

	      /**
	       * Delete a release
	       * @see https://developer.github.com/v3/repos/releases/#delete-a-release
	       * @param {string} id - the release to be deleted
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteRelease',
	      value: function deleteRelease(id, cb) {
	         return this._request('DELETE', '/repos/' + this.__fullname + '/releases/' + id, null, cb);
	      }

	      /**
	       * Merge a pull request
	       * @see https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
	       * @param {number|string} number - the number of the pull request to merge
	       * @param {Object} options - the merge options for the pull request
	       * @param {Requestable.callback} [cb] - will receive the merge information if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'mergePullRequest',
	      value: function mergePullRequest(number, options, cb) {
	         return this._request('PUT', '/repos/' + this.__fullname + '/pulls/' + number + '/merge', options, cb);
	      }

	      /**
	       * Get information about all projects
	       * @see https://developer.github.com/v3/projects/#list-repository-projects
	       * @param {Requestable.callback} [cb] - will receive the list of projects
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjects',
	      value: function listProjects(cb) {
	         return this._requestAllPages('/repos/' + this.__fullname + '/projects', { AcceptHeader: 'inertia-preview' }, cb);
	      }

	      /**
	       * Create a new project
	       * @see https://developer.github.com/v3/projects/#create-a-repository-project
	       * @param {Object} options - the description of the project
	       * @param {Requestable.callback} cb - will receive the newly created project
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createProject',
	      value: function createProject(options, cb) {
	         options = options || {};
	         options.AcceptHeader = 'inertia-preview';
	         return this._request('POST', '/repos/' + this.__fullname + '/projects', options, cb);
	      }
	   }]);

	   return Repository;
	}(_Requestable3.default);

	module.exports = Repository;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcG9zaXRvcnkuanMiXSwibmFtZXMiOlsibG9nIiwiUmVwb3NpdG9yeSIsImZ1bGxuYW1lIiwiYXV0aCIsImFwaUJhc2UiLCJfX2Z1bGxuYW1lIiwiX19jdXJyZW50VHJlZSIsImJyYW5jaCIsInNoYSIsInJlZiIsImNiIiwiX3JlcXVlc3QiLCJvcHRpb25zIiwibnVtYmVyIiwiYmFzZSIsImhlYWQiLCJzaW5jZSIsIl9kYXRlVG9JU08iLCJ1bnRpbCIsInBhdGgiLCJ0cmVlU0hBIiwiY29udGVudCIsInBvc3RCb2R5IiwiX2dldENvbnRlbnRPYmplY3QiLCJlbmNvZGUiLCJlbmNvZGluZyIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiQmxvYiIsIkpTT04iLCJzdHJpbmdpZnkiLCJFcnJvciIsImJhc2VUcmVlU0hBIiwiYmxvYlNIQSIsIm5ld1RyZWUiLCJiYXNlX3RyZWUiLCJ0cmVlIiwibW9kZSIsInR5cGUiLCJiYXNlU0hBIiwicGFyZW50IiwibWVzc2FnZSIsImRhdGEiLCJwYXJlbnRzIiwidGhlbiIsInJlc3BvbnNlIiwiY29tbWl0U0hBIiwiZm9yY2UiLCJ1c2VybmFtZSIsInJhdyIsImVuY29kZVVSSSIsIm9sZEJyYW5jaCIsIm5ld0JyYW5jaCIsImdldFJlZiIsIm9iamVjdCIsImNyZWF0ZVJlZiIsImlkIiwiZ2V0U2hhIiwiZGVsZXRlQ29tbWl0Iiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRTaGEiLCJnZXRUcmVlIiwibWFwIiwiY3JlYXRlVHJlZSIsImNvbW1pdCIsInVwZGF0ZUhlYWQiLCJmaWxlUGF0aCIsInNob3VsZEVuY29kZSIsImF1dGhvciIsImNvbW1pdHRlciIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiQWNjZXB0SGVhZGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7Ozs7QUFDQTs7OztBQUNBOztBQUdBOzs7Ozs7Ozs7OytlQVpBOzs7Ozs7O0FBYUEsSUFBTUEsTUFBTSxxQkFBTSxtQkFBTixDQUFaOztBQUVBOzs7O0lBR01DLFU7OztBQUNIOzs7Ozs7QUFNQSx1QkFBWUMsUUFBWixFQUFzQkMsSUFBdEIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQUE7O0FBQUEsMEhBQzVCRCxJQUQ0QixFQUN0QkMsT0FEc0I7O0FBRWxDLFlBQUtDLFVBQUwsR0FBa0JILFFBQWxCO0FBQ0EsWUFBS0ksYUFBTCxHQUFxQjtBQUNsQkMsaUJBQVEsSUFEVTtBQUVsQkMsY0FBSztBQUZhLE9BQXJCO0FBSGtDO0FBT3BDOztBQUVEOzs7Ozs7Ozs7Ozs2QkFPT0MsRyxFQUFLQyxFLEVBQUk7QUFDYixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxrQkFBMkRJLEdBQTNELEVBQWtFLElBQWxFLEVBQXdFQyxFQUF4RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VFLE8sRUFBU0YsRSxFQUFJO0FBQ3BCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGdCQUE0RE8sT0FBNUQsRUFBcUVGLEVBQXJFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPVUQsRyxFQUFLQyxFLEVBQUk7QUFDaEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS04sVUFBdkMsa0JBQThESSxHQUE5RCxFQUFxRSxJQUFyRSxFQUEyRUMsRUFBM0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTVdBLEUsRUFBSTtBQUNaLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtOLFVBQXZDLEVBQXFELElBQXJELEVBQTJESyxFQUEzRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNU0EsRSxFQUFJO0FBQ1YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsWUFBdUQsSUFBdkQsRUFBNkRLLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozt1Q0FPaUJFLE8sRUFBU0YsRSxFQUFJO0FBQzNCRSxtQkFBVUEsV0FBVyxFQUFyQjtBQUNBLGdCQUFPLEtBQUtELFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGFBQXdETyxPQUF4RCxFQUFpRUYsRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3FDQU9lRyxNLEVBQVFILEUsRUFBSTtBQUN4QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxlQUF3RFEsTUFBeEQsRUFBa0UsSUFBbEUsRUFBd0VILEVBQXhFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzsyQ0FPcUJHLE0sRUFBUUgsRSxFQUFJO0FBQzlCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGVBQXdEUSxNQUF4RCxhQUF3RSxJQUF4RSxFQUE4RUgsRUFBOUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztzQ0FRZ0JJLEksRUFBTUMsSSxFQUFNTCxFLEVBQUk7QUFDN0IsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsaUJBQTBEUyxJQUExRCxXQUFvRUMsSUFBcEUsRUFBNEUsSUFBNUUsRUFBa0ZMLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O21DQU1hQSxFLEVBQUk7QUFDZCxnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxnQkFBMkQsSUFBM0QsRUFBaUVLLEVBQWpFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs4QkFPUUYsRyxFQUFLRSxFLEVBQUk7QUFDZCxnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxtQkFBNERHLEdBQTVELEVBQW1FLElBQW5FLEVBQXlFRSxFQUF6RSxFQUE2RSxLQUE3RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VILE0sRUFBUUcsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyREUsTUFBM0QsRUFBcUUsSUFBckUsRUFBMkVHLEVBQTNFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztnQ0FPVUYsRyxFQUFLRSxFLEVBQUk7QUFDaEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMscUJBQThERyxHQUE5RCxFQUFxRSxJQUFyRSxFQUEyRUUsRUFBM0UsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7a0NBWVlFLE8sRUFBU0YsRSxFQUFJO0FBQ3RCRSxtQkFBVUEsV0FBVyxFQUFyQjs7QUFFQUEsaUJBQVFJLEtBQVIsR0FBZ0IsS0FBS0MsVUFBTCxDQUFnQkwsUUFBUUksS0FBeEIsQ0FBaEI7QUFDQUosaUJBQVFNLEtBQVIsR0FBZ0IsS0FBS0QsVUFBTCxDQUFnQkwsUUFBUU0sS0FBeEIsQ0FBaEI7O0FBRUEsZ0JBQU8sS0FBS1AsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsZUFBMERPLE9BQTFELEVBQW1FRixFQUFuRSxDQUFQO0FBQ0Y7O0FBRUE7Ozs7Ozs7Ozs7c0NBT2VELEcsRUFBS0MsRSxFQUFJO0FBQ3RCRCxlQUFNQSxPQUFPLEVBQWI7QUFDQSxnQkFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxpQkFBMERJLEdBQTFELEVBQWlFLElBQWpFLEVBQXVFQyxFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzZCQVFPSCxNLEVBQVFZLEksRUFBTVQsRSxFQUFJO0FBQ3RCSCxrQkFBU0EsbUJBQWlCQSxNQUFqQixHQUE0QixFQUFyQztBQUNBLGdCQUFPLEtBQUtJLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRGMsSUFBM0QsR0FBa0VaLE1BQWxFLEVBQTRFLElBQTVFLEVBQWtGRyxFQUFsRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7bUNBT2FGLEcsRUFBS0UsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGlCQUEwREcsR0FBMUQsZ0JBQTBFLElBQTFFLEVBQWdGRSxFQUFoRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OEJBT1FVLE8sRUFBU1YsRSxFQUFJO0FBQ2xCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLG1CQUE0RGUsT0FBNUQsRUFBdUUsSUFBdkUsRUFBNkVWLEVBQTdFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztpQ0FPV1csTyxFQUFTWCxFLEVBQUk7QUFDckIsYUFBSVksV0FBVyxLQUFLQyxpQkFBTCxDQUF1QkYsT0FBdkIsQ0FBZjs7QUFFQXJCLGFBQUksaUJBQUosRUFBdUJzQixRQUF2QjtBQUNBLGdCQUFPLEtBQUtYLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RGlCLFFBQTdELEVBQXVFWixFQUF2RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3dDQUtrQlcsTyxFQUFTO0FBQ3hCLGFBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUM5QnJCLGdCQUFJLG9CQUFKO0FBQ0EsbUJBQU87QUFDSnFCLHdCQUFTLGNBQUtHLE1BQUwsQ0FBWUgsT0FBWixDQURMO0FBRUpJLHlCQUFVO0FBRk4sYUFBUDtBQUtGLFVBUEQsTUFPTyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNMLG1CQUFtQkssTUFBeEQsRUFBZ0U7QUFDcEUxQixnQkFBSSx5QkFBSjtBQUNBLG1CQUFPO0FBQ0pxQix3QkFBU0EsUUFBUU0sUUFBUixDQUFpQixRQUFqQixDQURMO0FBRUpGLHlCQUFVO0FBRk4sYUFBUDtBQUtGLFVBUE0sTUFPQSxJQUFJLE9BQU9HLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JQLG1CQUFtQk8sSUFBdEQsRUFBNEQ7QUFDaEU1QixnQkFBSSxnQ0FBSjtBQUNBLG1CQUFPO0FBQ0pxQix3QkFBUyxlQUFPRyxNQUFQLENBQWNILE9BQWQsQ0FETDtBQUVKSSx5QkFBVTtBQUZOLGFBQVA7QUFLRixVQVBNLE1BT0E7QUFBRTtBQUNOekIsNERBQTZDcUIsT0FBN0MseUNBQTZDQSxPQUE3QyxZQUF5RFEsS0FBS0MsU0FBTCxDQUFlVCxPQUFmLENBQXpEO0FBQ0Esa0JBQU0sSUFBSVUsS0FBSixDQUFVLG1GQUFWLENBQU47QUFDRjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7O2lDQVVXQyxXLEVBQWFiLEksRUFBTWMsTyxFQUFTdkIsRSxFQUFJO0FBQ3hDLGFBQUl3QixVQUFVO0FBQ1hDLHVCQUFXSCxXQURBLEVBQ2E7QUFDeEJJLGtCQUFNLENBQUM7QUFDSmpCLHFCQUFNQSxJQURGO0FBRUpYLG9CQUFLeUIsT0FGRDtBQUdKSSxxQkFBTSxRQUhGO0FBSUpDLHFCQUFNO0FBSkYsYUFBRDtBQUZLLFVBQWQ7O0FBVUEsZ0JBQU8sS0FBSzNCLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RDZCLE9BQTdELEVBQXNFeEIsRUFBdEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRVzBCLEksRUFBTUcsTyxFQUFTN0IsRSxFQUFJO0FBQzNCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGlCQUE2RDtBQUNqRStCLHNCQURpRTtBQUVqRUQsdUJBQVdJLE9BRnNELEVBQTdELEVBR0o3QixFQUhJLENBQVA7QUFJRjs7QUFFRDs7Ozs7Ozs7Ozs7OzZCQVNPOEIsTSxFQUFRSixJLEVBQU1LLE8sRUFBUy9CLEUsRUFBSTtBQUFBOztBQUMvQixhQUFJZ0MsT0FBTztBQUNSRCw0QkFEUTtBQUVSTCxzQkFGUTtBQUdSTyxxQkFBUyxDQUFDSCxNQUFEO0FBSEQsVUFBWDs7QUFNQSxnQkFBTyxLQUFLN0IsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS04sVUFBckMsbUJBQStEcUMsSUFBL0QsRUFBcUVoQyxFQUFyRSxFQUNIa0MsSUFERyxDQUNFLFVBQUNDLFFBQUQsRUFBYztBQUNqQixtQkFBS3ZDLGFBQUwsQ0FBbUJFLEdBQW5CLEdBQXlCcUMsU0FBU0gsSUFBVCxDQUFjbEMsR0FBdkMsQ0FEaUIsQ0FDMkI7QUFDNUMsbUJBQU9xQyxRQUFQO0FBQ0YsVUFKRyxDQUFQO0FBS0Y7O0FBRUQ7Ozs7Ozs7Ozs7OztpQ0FTV3BDLEcsRUFBS3FDLFMsRUFBV0MsSyxFQUFPckMsRSxFQUFJO0FBQ25DLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtOLFVBQXRDLGtCQUE2REksR0FBN0QsRUFBb0U7QUFDeEVELGlCQUFLc0MsU0FEbUU7QUFFeEVDLG1CQUFPQTtBQUZpRSxVQUFwRSxFQUdKckMsRUFISSxDQUFQO0FBSUY7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzttQ0FZYW9DLFMsRUFBV2xDLE8sRUFBU0YsRSxFQUFJO0FBQ2xDLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGtCQUE0RHlDLFNBQTVELEVBQXlFbEMsT0FBekUsRUFBa0ZGLEVBQWxGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQWVpQkUsTyxFQUFTRixFLEVBQUk7QUFDM0IsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS04sVUFBdEMsRUFBb0RPLE9BQXBELEVBQTZERixFQUE3RCxDQUFQO0FBQ0Y7O0FBRUY7Ozs7Ozs7OztpQ0FNWUEsRSxFQUFJO0FBQ1osZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsRUFBa0QsSUFBbEQsRUFBd0RLLEVBQXhELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7O3NDQU1nQkEsRSxFQUFJO0FBQ2pCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLG9CQUErRCxJQUEvRCxFQUFxRUssRUFBckUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7MENBTW9CQSxFLEVBQUk7QUFDckIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsMEJBQXFFLElBQXJFLEVBQTJFSyxFQUEzRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7dUNBT2lCQSxFLEVBQUk7QUFDbEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMscUJBQWdFLElBQWhFLEVBQXNFSyxFQUF0RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7cUNBT2VzQyxRLEVBQVV0QyxFLEVBQUk7QUFDMUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsdUJBQWdFMkMsUUFBaEUsRUFBNEUsSUFBNUUsRUFBa0Z0QyxFQUFsRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OztrQ0FTWUQsRyxFQUFLVSxJLEVBQU04QixHLEVBQUt2QyxFLEVBQUk7QUFDN0JTLGdCQUFPQSxZQUFVK0IsVUFBVS9CLElBQVYsQ0FBVixHQUE4QixFQUFyQztBQUNBLGdCQUFPLEtBQUtSLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRGMsSUFBM0QsRUFBbUU7QUFDdkVWO0FBRHVFLFVBQW5FLEVBRUpDLEVBRkksRUFFQXVDLEdBRkEsQ0FBUDtBQUdGOztBQUVEOzs7Ozs7Ozs7OztnQ0FRVXhDLEcsRUFBS3dDLEcsRUFBS3ZDLEUsRUFBSTtBQUNyQixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLTixVQUFwQyxjQUF5RDtBQUM3REk7QUFENkQsVUFBekQsRUFFSkMsRUFGSSxFQUVBdUMsR0FGQSxDQUFQO0FBR0Y7O0FBRUQ7Ozs7Ozs7OzsyQkFNS3ZDLEUsRUFBSTtBQUNOLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGFBQXlELElBQXpELEVBQStESyxFQUEvRCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsYUFBd0QsSUFBeEQsRUFBOERLLEVBQTlELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzttQ0FPYXlDLFMsRUFBV0MsUyxFQUFXMUMsRSxFQUFJO0FBQUE7O0FBQ3BDLGFBQUksT0FBTzBDLFNBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDbEMxQyxpQkFBSzBDLFNBQUw7QUFDQUEsd0JBQVlELFNBQVo7QUFDQUEsd0JBQVksUUFBWjtBQUNGOztBQUVELGdCQUFPLEtBQUtFLE1BQUwsWUFBcUJGLFNBQXJCLEVBQ0hQLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakIsZ0JBQUlyQyxNQUFNcUMsU0FBU0gsSUFBVCxDQUFjWSxNQUFkLENBQXFCOUMsR0FBL0I7QUFDQSxtQkFBTyxPQUFLK0MsU0FBTCxDQUFlO0FBQ25CL0MsdUJBRG1CO0FBRW5CQyxvQ0FBbUIyQztBQUZBLGFBQWYsRUFHSjFDLEVBSEksQ0FBUDtBQUlGLFVBUEcsQ0FBUDtBQVFGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQkUsTyxFQUFTRixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsY0FBZ0MsS0FBS04sVUFBckMsYUFBeURPLE9BQXpELEVBQWtFRixFQUFsRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O3dDQVFrQkcsTSxFQUFRRCxPLEVBQVNGLEUsRUFBSTtBQUNwQyxnQkFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLTixVQUF0QyxlQUEwRFEsTUFBMUQsRUFBb0VELE9BQXBFLEVBQTZFRixFQUE3RSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNVUEsRSxFQUFJO0FBQ1gsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsYUFBd0QsSUFBeEQsRUFBOERLLEVBQTlELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs4QkFPUThDLEUsRUFBSTlDLEUsRUFBSTtBQUNiLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGVBQXdEbUQsRUFBeEQsRUFBOEQsSUFBOUQsRUFBb0U5QyxFQUFwRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT1dFLE8sRUFBU0YsRSxFQUFJO0FBQ3JCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLGFBQXlETyxPQUF6RCxFQUFrRUYsRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRVzhDLEUsRUFBSTVDLE8sRUFBU0YsRSxFQUFJO0FBQ3pCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxPQUFkLGNBQWlDLEtBQUtOLFVBQXRDLGVBQTBEbUQsRUFBMUQsRUFBZ0U1QyxPQUFoRSxFQUF5RUYsRUFBekUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9XOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLEVBQTJCLEtBQUtOLFVBQWhDLGVBQW9EbUQsRUFBcEQsRUFBMEQsSUFBMUQsRUFBZ0U5QyxFQUFoRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNU0EsRSxFQUFJO0FBQ1YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsWUFBdUQsSUFBdkQsRUFBNkRLLEVBQTdELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs2QkFPTzhDLEUsRUFBSTlDLEUsRUFBSTtBQUNaLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGNBQXVEbUQsRUFBdkQsRUFBNkQsSUFBN0QsRUFBbUU5QyxFQUFuRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT1VFLE8sRUFBU0YsRSxFQUFJO0FBQ3BCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGNBQWdDLEtBQUtOLFVBQXJDLFlBQXdETyxPQUF4RCxFQUFpRUYsRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2dDQU9VOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2YsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQsY0FBa0MsS0FBS04sVUFBdkMsY0FBMERtRCxFQUExRCxFQUFnRSxJQUFoRSxFQUFzRTlDLEVBQXRFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUVdILE0sRUFBUVksSSxFQUFNVCxFLEVBQUk7QUFBQTs7QUFDMUIsZ0JBQU8sS0FBSytDLE1BQUwsQ0FBWWxELE1BQVosRUFBb0JZLElBQXBCLEVBQ0h5QixJQURHLENBQ0UsVUFBQ0MsUUFBRCxFQUFjO0FBQ2pCLGdCQUFNYSxlQUFlO0FBQ2xCakIsa0RBQWdDdEIsSUFBaEMsT0FEa0I7QUFFbEJYLG9CQUFLcUMsU0FBU0gsSUFBVCxDQUFjbEMsR0FGRDtBQUdsQkQ7QUFIa0IsYUFBckI7QUFLQSxtQkFBTyxPQUFLSSxRQUFMLENBQWMsUUFBZCxjQUFrQyxPQUFLTixVQUF2QyxrQkFBOERjLElBQTlELEVBQXNFdUMsWUFBdEUsRUFBb0ZoRCxFQUFwRixDQUFQO0FBQ0YsVUFSRyxDQUFQO0FBU0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFLSCxNLEVBQVFvRCxPLEVBQVNDLE8sRUFBU2xELEUsRUFBSTtBQUFBOztBQUNoQyxhQUFJbUQsZUFBSjtBQUNBLGdCQUFPLEtBQUtSLE1BQUwsWUFBcUI5QyxNQUFyQixFQUNIcUMsSUFERyxDQUNFO0FBQUEsZ0JBQVNVLE1BQVQsUUFBRVosSUFBRixDQUFTWSxNQUFUO0FBQUEsbUJBQXNCLE9BQUtRLE9BQUwsQ0FBZ0JSLE9BQU85QyxHQUF2QixxQkFBdEI7QUFBQSxVQURGLEVBRUhvQyxJQUZHLENBRUUsaUJBQXlCO0FBQUEsbUNBQXZCRixJQUF1QjtBQUFBLGdCQUFoQk4sSUFBZ0IsY0FBaEJBLElBQWdCO0FBQUEsZ0JBQVY1QixHQUFVLGNBQVZBLEdBQVU7O0FBQzVCcUQscUJBQVNyRCxHQUFUO0FBQ0EsZ0JBQUkwQixVQUFVRSxLQUFLMkIsR0FBTCxDQUFTLFVBQUN0RCxHQUFELEVBQVM7QUFDN0IsbUJBQUlBLElBQUlVLElBQUosS0FBYXdDLE9BQWpCLEVBQTBCO0FBQ3ZCbEQsc0JBQUlVLElBQUosR0FBV3lDLE9BQVg7QUFDRjtBQUNELG1CQUFJbkQsSUFBSTZCLElBQUosS0FBYSxNQUFqQixFQUF5QjtBQUN0Qix5QkFBTzdCLElBQUlELEdBQVg7QUFDRjtBQUNELHNCQUFPQyxHQUFQO0FBQ0YsYUFSYSxDQUFkO0FBU0EsbUJBQU8sT0FBS3VELFVBQUwsQ0FBZ0I5QixPQUFoQixDQUFQO0FBQ0YsVUFkRyxFQWVIVSxJQWZHLENBZUU7QUFBQSxnQkFBUVIsSUFBUixTQUFFTSxJQUFGO0FBQUEsbUJBQWtCLE9BQUt1QixNQUFMLENBQVlKLE1BQVosRUFBb0J6QixLQUFLNUIsR0FBekIsaUJBQTBDbUQsT0FBMUMsZ0JBQTBEQyxPQUExRCxRQUFsQjtBQUFBLFVBZkYsRUFnQkhoQixJQWhCRyxDQWdCRTtBQUFBLGdCQUFRcUIsTUFBUixTQUFFdkIsSUFBRjtBQUFBLG1CQUFvQixPQUFLd0IsVUFBTCxZQUF5QjNELE1BQXpCLEVBQW1DMEQsT0FBT3pELEdBQTFDLEVBQStDLElBQS9DLEVBQXFERSxFQUFyRCxDQUFwQjtBQUFBLFVBaEJGLENBQVA7QUFpQkY7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWNVSCxNLEVBQVFZLEksRUFBTUUsTyxFQUFTb0IsTyxFQUFTN0IsTyxFQUFTRixFLEVBQUk7QUFBQTs7QUFDcEQsYUFBSSxPQUFPRSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2hDRixpQkFBS0UsT0FBTDtBQUNBQSxzQkFBVSxFQUFWO0FBQ0Y7QUFDRCxhQUFJdUQsV0FBV2hELE9BQU8rQixVQUFVL0IsSUFBVixDQUFQLEdBQXlCLEVBQXhDO0FBQ0EsYUFBSWlELGVBQWV4RCxRQUFRWSxNQUFSLEtBQW1CLEtBQXRDO0FBQ0EsYUFBSXlDLFNBQVM7QUFDVjFELDBCQURVO0FBRVZrQyw0QkFGVTtBQUdWNEIsb0JBQVF6RCxRQUFReUQsTUFITjtBQUlWQyx1QkFBVzFELFFBQVEwRCxTQUpUO0FBS1ZqRCxxQkFBUytDLGVBQWUsZUFBTzVDLE1BQVAsQ0FBY0gsT0FBZCxDQUFmLEdBQXdDQTtBQUx2QyxVQUFiOztBQVFBLGdCQUFPLEtBQUtvQyxNQUFMLENBQVlsRCxNQUFaLEVBQW9CNEQsUUFBcEIsRUFDSHZCLElBREcsQ0FDRSxVQUFDQyxRQUFELEVBQWM7QUFDakJvQixtQkFBT3pELEdBQVAsR0FBYXFDLFNBQVNILElBQVQsQ0FBY2xDLEdBQTNCO0FBQ0EsbUJBQU8sT0FBS0csUUFBTCxDQUFjLEtBQWQsY0FBK0IsT0FBS04sVUFBcEMsa0JBQTJEOEQsUUFBM0QsRUFBdUVGLE1BQXZFLEVBQStFdkQsRUFBL0UsQ0FBUDtBQUNGLFVBSkcsRUFJRCxZQUFNO0FBQ04sbUJBQU8sT0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsT0FBS04sVUFBcEMsa0JBQTJEOEQsUUFBM0QsRUFBdUVGLE1BQXZFLEVBQStFdkQsRUFBL0UsQ0FBUDtBQUNGLFVBTkcsQ0FBUDtBQU9GOztBQUVEOzs7Ozs7Ozs7O2dDQU9VQSxFLEVBQUk7QUFDWCxnQkFBTyxLQUFLNkQsZ0JBQUwsb0JBQXVDLEtBQUtsRSxVQUE1QyxFQUEwRCxJQUExRCxFQUFnRUssRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7MkJBTUtBLEUsRUFBSTtBQUNOLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLHFCQUFzQyxLQUFLTixVQUEzQyxFQUF5RCxJQUF6RCxFQUErREssRUFBL0QsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NkJBTU9BLEUsRUFBSTtBQUNSLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLHFCQUF5QyxLQUFLTixVQUE5QyxFQUE0RCxJQUE1RCxFQUFrRUssRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jRSxPLEVBQVNGLEUsRUFBSTtBQUN4QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLTixVQUFyQyxnQkFBNERPLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O29DQVFjOEMsRSxFQUFJNUMsTyxFQUFTRixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsY0FBaUMsS0FBS04sVUFBdEMsa0JBQTZEbUQsRUFBN0QsRUFBbUU1QyxPQUFuRSxFQUE0RUYsRUFBNUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7bUNBTWFBLEUsRUFBSTtBQUNkLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGdCQUEyRCxJQUEzRCxFQUFpRUssRUFBakUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2lDQU9XOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ2hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtOLFVBQXBDLGtCQUEyRG1ELEVBQTNELEVBQWlFLElBQWpFLEVBQXVFOUMsRUFBdkUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jOEMsRSxFQUFJOUMsRSxFQUFJO0FBQ25CLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGNBQWtDLEtBQUtOLFVBQXZDLGtCQUE4RG1ELEVBQTlELEVBQW9FLElBQXBFLEVBQTBFOUMsRUFBMUUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRaUJHLE0sRUFBUUQsTyxFQUFTRixFLEVBQUk7QUFDbkMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsY0FBK0IsS0FBS04sVUFBcEMsZUFBd0RRLE1BQXhELGFBQXdFRCxPQUF4RSxFQUFpRkYsRUFBakYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7bUNBTWFBLEUsRUFBSTtBQUNkLGdCQUFPLEtBQUs4RCxnQkFBTCxhQUFnQyxLQUFLbkUsVUFBckMsZ0JBQTRELEVBQUNvRSxjQUFjLGlCQUFmLEVBQTVELEVBQStGL0QsRUFBL0YsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9jRSxPLEVBQVNGLEUsRUFBSTtBQUN4QkUsbUJBQVVBLFdBQVcsRUFBckI7QUFDQUEsaUJBQVE2RCxZQUFSLEdBQXVCLGlCQUF2QjtBQUNBLGdCQUFPLEtBQUs5RCxRQUFMLENBQWMsTUFBZCxjQUFnQyxLQUFLTixVQUFyQyxnQkFBNERPLE9BQTVELEVBQXFFRixFQUFyRSxDQUFQO0FBQ0Y7Ozs7OztBQUlKZ0UsT0FBT0MsT0FBUCxHQUFpQjFFLFVBQWpCIiwiZmlsZSI6IlJlcG9zaXRvcnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlXG4gKiBAY29weXJpZ2h0ICAyMDEzIE1pY2hhZWwgQXVmcmVpdGVyIChEZXZlbG9wbWVudCBTZWVkKSBhbmQgMjAxNiBZYWhvbyBJbmMuXG4gKiBAbGljZW5zZSAgICBMaWNlbnNlZCB1bmRlciB7QGxpbmsgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UtQ2xlYXIuaHRtbCBCU0QtMy1DbGF1c2UtQ2xlYXJ9LlxuICogICAgICAgICAgICAgR2l0aHViLmpzIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlLlxuICovXG5cbmltcG9ydCBSZXF1ZXN0YWJsZSBmcm9tICcuL1JlcXVlc3RhYmxlJztcbmltcG9ydCBVdGY4IGZyb20gJ3V0ZjgnO1xuaW1wb3J0IHtcbiAgIEJhc2U2NCxcbn0gZnJvbSAnanMtYmFzZTY0JztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5jb25zdCBsb2cgPSBkZWJ1ZygnZ2l0aHViOnJlcG9zaXRvcnknKTtcblxuLyoqXG4gKiBSZXNwb3NpdG9yeSBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gY3JlYXRlLCBxdWVyeSwgYW5kIG1vZGlmeSBmaWxlcy5cbiAqL1xuY2xhc3MgUmVwb3NpdG9yeSBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgUmVwb3NpdG9yeS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsbmFtZSAtIHRoZSBmdWxsIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuYXV0aH0gW2F1dGhdIC0gaW5mb3JtYXRpb24gcmVxdWlyZWQgdG8gYXV0aGVudGljYXRlIHRvIEdpdGh1YlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlPWh0dHBzOi8vYXBpLmdpdGh1Yi5jb21dIC0gdGhlIGJhc2UgR2l0aHViIEFQSSBVUkxcbiAgICAqL1xuICAgY29uc3RydWN0b3IoZnVsbG5hbWUsIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX2Z1bGxuYW1lID0gZnVsbG5hbWU7XG4gICAgICB0aGlzLl9fY3VycmVudFRyZWUgPSB7XG4gICAgICAgICBicmFuY2g6IG51bGwsXG4gICAgICAgICBzaGE6IG51bGwsXG4gICAgICB9O1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhIHJlZmVyZW5jZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyNnZXQtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmZXJlbmNlIHRvIGdldFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVmZXJlbmNlJ3MgcmVmU3BlYyBvciBhIGxpc3Qgb2YgcmVmU3BlY3MgdGhhdCBtYXRjaCBgcmVmYFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRSZWYocmVmLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzLyR7cmVmfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSByZWZlcmVuY2VcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXQvcmVmcy8jY3JlYXRlLWEtcmVmZXJlbmNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBvYmplY3QgZGVzY3JpYmluZyB0aGUgcmVmXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSByZWZcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUmVmKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIHJlZmVyZW5jZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyNkZWxldGUtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgbmFtZSBvZiB0aGUgcmVmIHRvIGRlbHRlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVSZWYocmVmLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9yZWZzLyR7cmVmfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2RlbGV0ZS1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZVJlcG8oY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSB0YWdzIG9uIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LXRhZ3NcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHRhZyBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RUYWdzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vdGFnc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBvcGVuIHB1bGwgcmVxdWVzdHMgb24gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wdWxscy8jbGlzdC1wdWxsLXJlcXVlc3RzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gZmlsdGVyIHRoZSBzZWFyY2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgUFJzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RQdWxsUmVxdWVzdHMob3B0aW9ucywgY2IpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3B1bGxzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNnZXQtYS1zaW5nbGUtcHVsbC1yZXF1ZXN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIC0gdGhlIFBSIHlvdSB3aXNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBQUiBmcm9tIHRoZSBBUElcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UHVsbFJlcXVlc3QobnVtYmVyLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3B1bGxzLyR7bnVtYmVyfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBmaWxlcyBvZiBhIHNwZWNpZmljIHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNsaXN0LXB1bGwtcmVxdWVzdHMtZmlsZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIC0gdGhlIFBSIHlvdSB3aXNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGZpbGVzIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UHVsbFJlcXVlc3RGaWxlcyhudW1iZXIsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcHVsbHMvJHtudW1iZXJ9L2ZpbGVzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENvbXBhcmUgdHdvIGJyYW5jaGVzL2NvbW1pdHMvcmVwb3NpdG9yaWVzXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29tbWl0cy8jY29tcGFyZS10d28tY29tbWl0c1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgLSB0aGUgYmFzZSBjb21taXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkIC0gdGhlIGhlYWQgY29tbWl0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tcGFyaXNvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjb21wYXJlQnJhbmNoZXMoYmFzZSwgaGVhZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb21wYXJlLyR7YmFzZX0uLi4ke2hlYWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgYWxsIHRoZSBicmFuY2hlcyBmb3IgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jbGlzdC1icmFuY2hlc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgYnJhbmNoZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdEJyYW5jaGVzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vYnJhbmNoZXNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgcmF3IGJsb2IgZnJvbSB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9ibG9icy8jZ2V0LWEtYmxvYlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYSAtIHRoZSBzaGEgb2YgdGhlIGJsb2IgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBibG9iIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRCbG9iKHNoYSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvYmxvYnMvJHtzaGF9YCwgbnVsbCwgY2IsICdyYXcnKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBzaW5nbGUgYnJhbmNoXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvYnJhbmNoZXMvI2dldC1icmFuY2hcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggLSB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIHRvIGZldGNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgYnJhbmNoIGZyb20gdGhlIEFQSVxuICAgICogQHJldHVybnMge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0QnJhbmNoKGJyYW5jaCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9icmFuY2hlcy8ke2JyYW5jaH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGEgY29tbWl0IGZyb20gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb21taXRzLyNnZXQtYS1zaW5nbGUtY29tbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhIC0gdGhlIHNoYSBmb3IgdGhlIGNvbW1pdCB0byBmZXRjaFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbW1pdCBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbW1pdChzaGEsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L2NvbW1pdHMvJHtzaGF9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGNvbW1pdHMgb24gYSByZXBvc2l0b3J5LCBvcHRpb25hbGx5IGZpbHRlcmluZyBieSBwYXRoLCBhdXRob3Igb3IgdGltZSByYW5nZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbW1pdHMvI2xpc3QtY29tbWl0cy1vbi1hLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSB0aGUgZmlsdGVyaW5nIG9wdGlvbnMgZm9yIGNvbW1pdHNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zaGFdIC0gdGhlIFNIQSBvciBicmFuY2ggdG8gc3RhcnQgZnJvbVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhdGhdIC0gdGhlIHBhdGggdG8gc2VhcmNoIG9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXV0aG9yXSAtIHRoZSBjb21taXQgYXV0aG9yXG4gICAgKiBAcGFyYW0geyhEYXRlfHN0cmluZyl9IFtvcHRpb25zLnNpbmNlXSAtIG9ubHkgY29tbWl0cyBhZnRlciB0aGlzIGRhdGUgd2lsbCBiZSByZXR1cm5lZFxuICAgICogQHBhcmFtIHsoRGF0ZXxzdHJpbmcpfSBbb3B0aW9ucy51bnRpbF0gLSBvbmx5IGNvbW1pdHMgYmVmb3JlIHRoaXMgZGF0ZSB3aWxsIGJlIHJldHVybmVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjb21taXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBjcml0ZXJpYVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0Q29tbWl0cyhvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIG9wdGlvbnMuc2luY2UgPSB0aGlzLl9kYXRlVG9JU08ob3B0aW9ucy5zaW5jZSk7XG4gICAgICBvcHRpb25zLnVudGlsID0gdGhpcy5fZGF0ZVRvSVNPKG9wdGlvbnMudW50aWwpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29tbWl0c2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzaW5nbGUgY29tbWl0IGluZm9ybWF0aW9uIGZvciBhIHJlcG9zaXRvcnlcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29tbWl0cy8jZ2V0LWEtc2luZ2xlLWNvbW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmZXJlbmNlIGZvciB0aGUgY29tbWl0LWlzaFxuICAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjb21taXQgaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgICovXG4gICBnZXRTaW5nbGVDb21taXQocmVmLCBjYikge1xuICAgICAgcmVmID0gcmVmIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbW1pdHMvJHtyZWZ9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCB0aGEgc2hhIGZvciBhIHBhcnRpY3VsYXIgb2JqZWN0IGluIHRoZSByZXBvc2l0b3J5LiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb250ZW50cy8jZ2V0LWNvbnRlbnRzXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2JyYW5jaF0gLSB0aGUgYnJhbmNoIHRvIGxvb2sgaW4sIG9yIHRoZSByZXBvc2l0b3J5J3MgZGVmYXVsdCBicmFuY2ggaWYgb21pdHRlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIGEgZGVzY3JpcHRpb24gb2YgdGhlIHJlcXVlc3RlZCBvYmplY3QsIGluY2x1ZGluZyBhIGBTSEFgIHByb3BlcnR5XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFNoYShicmFuY2gsIHBhdGgsIGNiKSB7XG4gICAgICBicmFuY2ggPSBicmFuY2ggPyBgP3JlZj0ke2JyYW5jaH1gIDogJyc7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29udGVudHMvJHtwYXRofSR7YnJhbmNofWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBjb21taXQgc3RhdHVzZXMgZm9yIGEgcGFydGljdWxhciBzaGEsIGJyYW5jaCwgb3IgdGFnXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3Mvc3RhdHVzZXMvI2xpc3Qtc3RhdHVzZXMtZm9yLWEtc3BlY2lmaWMtcmVmXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhIC0gdGhlIHNoYSwgYnJhbmNoLCBvciB0YWcgdG8gZ2V0IHN0YXR1c2VzIGZvclxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2Ygc3RhdHVzZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFN0YXR1c2VzKHNoYSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb21taXRzLyR7c2hhfS9zdGF0dXNlc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBkZXNjcmlwdGlvbiBvZiBhIGdpdCB0cmVlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L3RyZWVzLyNnZXQtYS10cmVlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdHJlZVNIQSAtIHRoZSBTSEEgb2YgdGhlIHRyZWUgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjYWxsYmFjayBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFRyZWUodHJlZVNIQSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvdHJlZXMvJHt0cmVlU0hBfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBibG9iXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L2Jsb2JzLyNjcmVhdGUtYS1ibG9iXG4gICAgKiBAcGFyYW0geyhzdHJpbmd8QnVmZmVyfEJsb2IpfSBjb250ZW50IC0gdGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgZGV0YWlscyBvZiB0aGUgY3JlYXRlZCBibG9iXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUJsb2IoY29udGVudCwgY2IpIHtcbiAgICAgIGxldCBwb3N0Qm9keSA9IHRoaXMuX2dldENvbnRlbnRPYmplY3QoY29udGVudCk7XG5cbiAgICAgIGxvZygnc2VuZGluZyBjb250ZW50JywgcG9zdEJvZHkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9naXQvYmxvYnNgLCBwb3N0Qm9keSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCB0aGUgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvdmlkZWQgY29udGVudFxuICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfEJsb2J9IGNvbnRlbnQgLSB0aGUgY29udGVudCB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBjb250ZW50YCBmb3IgdGhlIEdpdEh1YiBBUElcbiAgICAqL1xuICAgX2dldENvbnRlbnRPYmplY3QoY29udGVudCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgbG9nKCdjb250ZXQgaXMgYSBzdHJpbmcnKTtcbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBVdGY4LmVuY29kZShjb250ZW50KSxcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZW50IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICBsb2coJ1dlIGFwcGVhciB0byBiZSBpbiBOb2RlJyk7XG4gICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudC50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgICB9O1xuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZW50IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgbG9nKCdXZSBhcHBlYXIgdG8gYmUgaW4gdGhlIGJyb3dzZXInKTtcbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBCYXNlNjQuZW5jb2RlKGNvbnRlbnQpLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgbG9nKGBOb3Qgc3VyZSB3aGF0IHRoaXMgY29udGVudCBpczogJHt0eXBlb2YgY29udGVudH0sICR7SlNPTi5zdHJpbmdpZnkoY29udGVudCl9YCk7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29udGVudCBwYXNzZWQgdG8gcG9zdEJsb2IuIE11c3QgYmUgc3RyaW5nIG9yIEJ1ZmZlciAobm9kZSkgb3IgQmxvYiAod2ViKScpO1xuICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSBhIHRyZWUgaW4gR2l0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvZ2l0L3RyZWVzLyNjcmVhdGUtYS10cmVlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVRyZWVTSEEgLSB0aGUgU0hBIG9mIHRoZSB0cmVlIHRvIHVwZGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCBmb3IgdGhlIG5ldyBmaWxlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvYlNIQSAtIHRoZSBTSEEgZm9yIHRoZSBibG9iIHRvIHB1dCBhdCBgcGF0aGBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXcgdHJlZSB0aGF0IGlzIGNyZWF0ZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgUmVwb3NpdG9yeSNjcmVhdGVUcmVlfSBpbnN0ZWFkXG4gICAgKi9cbiAgIHVwZGF0ZVRyZWUoYmFzZVRyZWVTSEEsIHBhdGgsIGJsb2JTSEEsIGNiKSB7XG4gICAgICBsZXQgbmV3VHJlZSA9IHtcbiAgICAgICAgIGJhc2VfdHJlZTogYmFzZVRyZWVTSEEsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgIHRyZWU6IFt7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgc2hhOiBibG9iU0hBLFxuICAgICAgICAgICAgbW9kZTogJzEwMDY0NCcsXG4gICAgICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgICB9XSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3RyZWVzYCwgbmV3VHJlZSwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyB0cmVlIGluIGdpdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC90cmVlcy8jY3JlYXRlLWEtdHJlZVxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWUgLSB0aGUgdHJlZSB0byBjcmVhdGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlU0hBIC0gdGhlIHJvb3Qgc2hhIG9mIHRoZSB0cmVlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3IHRyZWUgdGhhdCBpcyBjcmVhdGVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZVRyZWUodHJlZSwgYmFzZVNIQSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3RyZWVzYCwge1xuICAgICAgICAgdHJlZSxcbiAgICAgICAgIGJhc2VfdHJlZTogYmFzZVNIQSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH0sIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBjb21taXQgdG8gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9naXQvY29tbWl0cy8jY3JlYXRlLWEtY29tbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50IC0gdGhlIFNIQSBvZiB0aGUgcGFyZW50IGNvbW1pdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRyZWUgLSB0aGUgU0hBIG9mIHRoZSB0cmVlIGZvciB0aGlzIGNvbW1pdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSB0aGUgY29tbWl0IG1lc3NhZ2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBjb21taXQgdGhhdCBpcyBjcmVhdGVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNvbW1pdChwYXJlbnQsIHRyZWUsIG1lc3NhZ2UsIGNiKSB7XG4gICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICB0cmVlLFxuICAgICAgICAgcGFyZW50czogW3BhcmVudF0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2dpdC9jb21taXRzYCwgZGF0YSwgY2IpXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50VHJlZS5zaGEgPSByZXNwb25zZS5kYXRhLnNoYTsgLy8gVXBkYXRlIGxhdGVzdCBjb21taXRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSBhIHJlZlxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2dpdC9yZWZzLyN1cGRhdGUtYS1yZWZlcmVuY2VcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmIHRvIHVwZGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1pdFNIQSAtIHRoZSBTSEEgdG8gcG9pbnQgdGhlIHJlZmVyZW5jZSB0b1xuICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGluZGljYXRlcyB3aGV0aGVyIHRvIGZvcmNlIG9yIGVuc3VyZSBhIGZhc3QtZm9yd2FyZCB1cGRhdGVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSB1cGRhdGVkIHJlZiBiYWNrXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZUhlYWQocmVmLCBjb21taXRTSEEsIGZvcmNlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BBVENIJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vZ2l0L3JlZnMvJHtyZWZ9YCwge1xuICAgICAgICAgc2hhOiBjb21taXRTSEEsXG4gICAgICAgICBmb3JjZTogZm9yY2UsXG4gICAgICB9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVXBkYXRlIGNvbW1pdCBzdGF0dXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9zdGF0dXNlcy9cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21taXRTSEEgLSB0aGUgU0hBIG9mIHRoZSBjb21taXQgdGhhdCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBDb21taXQgc3RhdHVzIHBhcmFtZXRlcnNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN0YXRlIC0gVGhlIHN0YXRlIG9mIHRoZSBzdGF0dXMuIENhbiBiZSBvbmUgb2Y6IHBlbmRpbmcsIHN1Y2Nlc3MsIGVycm9yLCBvciBmYWlsdXJlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRhcmdldF91cmxdIC0gVGhlIHRhcmdldCBVUkwgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBzdGF0dXMuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIC0gQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhdHVzLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRleHRdIC0gQSBzdHJpbmcgbGFiZWwgdG8gZGlmZmVyZW50aWF0ZSB0aGlzIHN0YXR1cyBhbW9uZyBDSSBzeXN0ZW1zLlxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIHVwZGF0ZWQgY29tbWl0IGJhY2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlU3RhdHVzKGNvbW1pdFNIQSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vc3RhdHVzZXMvJHtjb21taXRTSEF9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZSByZXBvc2l0b3J5IGluZm9ybWF0aW9uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2VkaXRcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gTmV3IHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNldCB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl0gLSBBIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaG9tZXBhZ2VdIC0gQSBVUkwgd2l0aCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByaXZhdGVdIC0gRWl0aGVyIHRydWUgdG8gbWFrZSB0aGUgcmVwb3NpdG9yeSBwcml2YXRlLCBvciBmYWxzZSB0byBtYWtlIGl0IHB1YmxpYy5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzX2lzc3Vlc10gLSBFaXRoZXIgdHJ1ZSB0byBlbmFibGUgaXNzdWVzIGZvciB0aGlzIHJlcG9zaXRvcnksIGZhbHNlIHRvIGRpc2FibGUgdGhlbS5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzX3dpa2ldIC0gRWl0aGVyIHRydWUgdG8gZW5hYmxlIHRoZSB3aWtpIGZvciB0aGlzIHJlcG9zaXRvcnksIGZhbHNlIHRvIGRpc2FibGUgaXQuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhhc19kb3dubG9hZHNdIC0gRWl0aGVyIHRydWUgdG8gZW5hYmxlIGRvd25sb2FkcywgZmFsc2UgdG8gZGlzYWJsZSB0aGVtLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRfYnJhbmNoXSAtIFVwZGF0ZXMgdGhlIGRlZmF1bHQgYnJhbmNoIGZvciB0aGlzIHJlcG9zaXRvcnkuXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCByZXBvc2l0b3J5IGJhY2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlUmVwb3NpdG9yeShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BBVENIJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgLyoqXG4gICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jZ2V0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcG9zaXRvcnlcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0RGV0YWlscyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGNvbnRyaWJ1dG9ycyB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LWNvbnRyaWJ1dG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29udHJpYnV0b3JzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbnRyaWJ1dG9ycyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbnRyaWJ1dG9yc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSBjb250cmlidXRvciBzdGF0cyB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zLyNsaXN0LWNvbnRyaWJ1dG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29udHJpYnV0b3JzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldENvbnRyaWJ1dG9yU3RhdHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9zdGF0cy9jb250cmlidXRvcnNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgdXNlcnMgd2hvIGFyZSBjb2xsYWJvcmF0b3JzIG9uIHRoZSByZXBvc2l0b3J5LiBUaGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBtdXN0IGhhdmVcbiAgICAqIHB1c2ggYWNjZXNzIHRvIHVzZSB0aGlzIG1ldGhvZFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbGxhYm9yYXRvcnMvI2xpc3QtY29sbGFib3JhdG9yc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY29sbGFib3JhdG9yc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRDb2xsYWJvcmF0b3JzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29sbGFib3JhdG9yc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHVzZXIgaXMgYSBjb2xsYWJvcmF0b3Igb24gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9jb2xsYWJvcmF0b3JzLyNjaGVjay1pZi1hLXVzZXItaXMtYS1jb2xsYWJvcmF0b3JcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIHRvIGNoZWNrXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSB1c2VyIGlzIGEgY29sbGFib3JhdG9yIGFuZCBmYWxzZSBpZiB0aGV5IGFyZSBub3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3Qge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAqL1xuICAgaXNDb2xsYWJvcmF0b3IodXNlcm5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29sbGFib3JhdG9ycy8ke3VzZXJuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbnRlbnRzLyNnZXQtY29udGVudHNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSB0aGUgcmVmIHRvIGNoZWNrXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdG8gZmV0Y2hcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmF3IC0gYHRydWVgIGlmIHRoZSByZXN1bHRzIHNob3VsZCBiZSByZXR1cm5lZCByYXcgaW5zdGVhZCBvZiBHaXRIdWIncyBub3JtYWxpemVkIGZvcm1hdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGZldGNoZWQgZGF0YVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRDb250ZW50cyhyZWYsIHBhdGgsIHJhdywgY2IpIHtcbiAgICAgIHBhdGggPSBwYXRoID8gYCR7ZW5jb2RlVVJJKHBhdGgpfWAgOiAnJztcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb250ZW50cy8ke3BhdGh9YCwge1xuICAgICAgICAgcmVmLFxuICAgICAgfSwgY2IsIHJhdyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSBSRUFETUUgb2YgYSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29udGVudHMvI2dldC10aGUtcmVhZG1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIC0gdGhlIHJlZiB0byBjaGVja1xuICAgICogQHBhcmFtIHtib29sZWFufSByYXcgLSBgdHJ1ZWAgaWYgdGhlIHJlc3VsdHMgc2hvdWxkIGJlIHJldHVybmVkIHJhdyBpbnN0ZWFkIG9mIEdpdEh1YidzIG5vcm1hbGl6ZWQgZm9ybWF0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgZmV0Y2hlZCBkYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFJlYWRtZShyZWYsIHJhdywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWFkbWVgLCB7XG4gICAgICAgICByZWYsXG4gICAgICB9LCBjYiwgcmF3KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBGb3JrIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2ZvcmtzLyNjcmVhdGUtYS1mb3JrXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ld2x5IGNyZWF0ZWQgZm9ya1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBmb3JrKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2ZvcmtzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgYSByZXBvc2l0b3J5J3MgZm9ya3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9mb3Jrcy8jbGlzdC1mb3Jrc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgcmVwb3NpdG9yaWVzIGZvcmtlZCBmcm9tIHRoaXMgb25lXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RGb3JrcyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2ZvcmtzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyBicmFuY2ggZnJvbSBhbiBleGlzdGluZyBicmFuY2guXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29sZEJyYW5jaD1tYXN0ZXJdIC0gdGhlIG5hbWUgb2YgdGhlIGV4aXN0aW5nIGJyYW5jaFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0JyYW5jaCAtIHRoZSBuYW1lIG9mIHRoZSBuZXcgYnJhbmNoXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWl0IGRhdGEgZm9yIHRoZSBoZWFkIG9mIHRoZSBuZXcgYnJhbmNoXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUJyYW5jaChvbGRCcmFuY2gsIG5ld0JyYW5jaCwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3QnJhbmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICBjYiA9IG5ld0JyYW5jaDtcbiAgICAgICAgIG5ld0JyYW5jaCA9IG9sZEJyYW5jaDtcbiAgICAgICAgIG9sZEJyYW5jaCA9ICdtYXN0ZXInO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRSZWYoYGhlYWRzLyR7b2xkQnJhbmNofWApXG4gICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCBzaGEgPSByZXNwb25zZS5kYXRhLm9iamVjdC5zaGE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZWYoe1xuICAgICAgICAgICAgICAgc2hhLFxuICAgICAgICAgICAgICAgcmVmOiBgcmVmcy9oZWFkcy8ke25ld0JyYW5jaH1gLFxuICAgICAgICAgICAgfSwgY2IpO1xuICAgICAgICAgfSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHB1bGwgcmVxdWVzdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3B1bGxzLyNjcmVhdGUtYS1wdWxsLXJlcXVlc3RcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIHB1bGwgcmVxdWVzdCBkZXNjcmlwdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBwdWxsIHJlcXVlc3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUHVsbFJlcXVlc3Qob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcHVsbHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVXBkYXRlIGEgcHVsbCByZXF1ZXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHVsbHMvI3VwZGF0ZS1hLXB1bGwtcmVxdWVzdFxuICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSBwdWxsIHJlcXVlc3QgdG8gdXBkYXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBwdWxsIHJlcXVlc3QgZGVzY3JpcHRpb25cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIHB1bGwgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1cGRhdGVQdWxsUmVxdWVzdChudW1iZXIsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9wdWxscy8ke251bWJlcn1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgaG9va3MgZm9yIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2xpc3QtaG9va3NcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGhvb2tzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RIb29rcyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2hvb2tzYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhIGhvb2sgZm9yIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2dldC1zaW5nbGUtaG9va1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gdGhlIGlkIG9mIHRoZSB3ZWJvb2tcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBkZXRhaWxzIG9mIHRoZSB3ZWJvb2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0SG9vayhpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rcy8ke2lkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBuZXcgaG9vayB0byB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2hvb2tzLyNjcmVhdGUtYS1ob29rXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBjb25maWd1cmF0aW9uIGRlc2NyaWJpbmcgdGhlIG5ldyBob29rXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3IHdlYmhvb2tcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlSG9vayhvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGFuIGV4aXN0aW5nIHdlYmhvb2tcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9ob29rcy8jZWRpdC1hLWhvb2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgd2ViaG9va1xuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGRlc2NyaXB0aW9uIG9mIHRoZSB3ZWJob29rXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCB3ZWJob29rXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZUhvb2soaWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9ob29rcy8ke2lkfWAsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvaG9va3MvI2RlbGV0ZS1hLWhvb2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgd2ViaG9vayB0byBiZSBkZWxldGVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBjYWxsIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlSG9vayhpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgJHt0aGlzLl9fZnVsbG5hbWV9L2hvb2tzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIGRlcGxveSBrZXlzIGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2tleXMvI2xpc3QtZGVwbG95LWtleXNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIGRlcGxveSBrZXlzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RLZXlzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0va2V5c2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYSBkZXBsb3kga2V5IGZvciB0aGUgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2tleXMvI2dldC1hLWRlcGxveS1rZXlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHRoZSBpZCBvZiB0aGUgZGVwbG95IGtleVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGRldGFpbHMgb2YgdGhlIGRlcGxveSBrZXlcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0S2V5KGlkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2tleXMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQWRkIGEgbmV3IGRlcGxveSBrZXkgdG8gdGhlIHJlcG9zaXRvcnlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9rZXlzLyNhZGQtYS1uZXctZGVwbG95LWtleVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgY29uZmlndXJhdGlvbiBkZXNjcmliaW5nIHRoZSBuZXcgZGVwbG95IGtleVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ldyBkZXBsb3kga2V5XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNyZWF0ZUtleShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9rZXlzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGRlcGxveSBrZXlcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9rZXlzLyNyZW1vdmUtYS1kZXBsb3kta2V5XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSB0aGUgaWQgb2YgdGhlIGRlcGxveSBrZXkgdG8gYmUgZGVsZXRlZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgY2FsbCBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGRlbGV0ZUtleShpZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9rZXlzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIGZpbGUgZnJvbSBhIGJyYW5jaFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL2NvbnRlbnRzLyNkZWxldGUtYS1maWxlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoIC0gdGhlIGJyYW5jaCB0byBkZWxldGUgZnJvbSwgb3IgdGhlIGRlZmF1bHQgYnJhbmNoIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gcmVtb3ZlXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgY29tbWl0IGluIHdoaWNoIHRoZSBkZWxldGUgb2NjdXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlRmlsZShicmFuY2gsIHBhdGgsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTaGEoYnJhbmNoLCBwYXRoKVxuICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVDb21taXQgPSB7XG4gICAgICAgICAgICAgICBtZXNzYWdlOiBgRGVsZXRlIHRoZSBmaWxlIGF0ICcke3BhdGh9J2AsXG4gICAgICAgICAgICAgICBzaGE6IHJlc3BvbnNlLmRhdGEuc2hhLFxuICAgICAgICAgICAgICAgYnJhbmNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9jb250ZW50cy8ke3BhdGh9YCwgZGVsZXRlQ29tbWl0LCBjYik7XG4gICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2UgYWxsIHJlZmVyZW5jZXMgaW4gYSByZXBvIGZyb20gb2xkUGF0aCB0byBuZXdfcGF0aFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJyYW5jaCAtIHRoZSBicmFuY2ggdG8gY2Fycnkgb3V0IHRoZSByZWZlcmVuY2UgY2hhbmdlLCBvciB0aGUgZGVmYXVsdCBicmFuY2ggaWYgbm90IHNwZWNpZmllZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhdGggLSBvcmlnaW5hbCBwYXRoXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGF0aCAtIG5ldyByZWZlcmVuY2UgcGF0aFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbW1pdCBpbiB3aGljaCB0aGUgbW92ZSBvY2N1cnJlZFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtb3ZlKGJyYW5jaCwgb2xkUGF0aCwgbmV3UGF0aCwgY2IpIHtcbiAgICAgIGxldCBvbGRTaGE7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSZWYoYGhlYWRzLyR7YnJhbmNofWApXG4gICAgICAgICAudGhlbigoe2RhdGE6IHtvYmplY3R9fSkgPT4gdGhpcy5nZXRUcmVlKGAke29iamVjdC5zaGF9P3JlY3Vyc2l2ZT10cnVlYCkpXG4gICAgICAgICAudGhlbigoe2RhdGE6IHt0cmVlLCBzaGF9fSkgPT4ge1xuICAgICAgICAgICAgb2xkU2hhID0gc2hhO1xuICAgICAgICAgICAgbGV0IG5ld1RyZWUgPSB0cmVlLm1hcCgocmVmKSA9PiB7XG4gICAgICAgICAgICAgICBpZiAocmVmLnBhdGggPT09IG9sZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlZi5wYXRoID0gbmV3UGF0aDtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChyZWYudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcmVmLnNoYTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRyZWUobmV3VHJlZSk7XG4gICAgICAgICB9KVxuICAgICAgICAgLnRoZW4oKHtkYXRhOiB0cmVlfSkgPT4gdGhpcy5jb21taXQob2xkU2hhLCB0cmVlLnNoYSwgYFJlbmFtZWQgJyR7b2xkUGF0aH0nIHRvICcke25ld1BhdGh9J2ApKVxuICAgICAgICAgLnRoZW4oKHtkYXRhOiBjb21taXR9KSA9PiB0aGlzLnVwZGF0ZUhlYWQoYGhlYWRzLyR7YnJhbmNofWAsIGNvbW1pdC5zaGEsIHRydWUsIGNiKSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogV3JpdGUgYSBmaWxlIHRvIHRoZSByZXBvc2l0b3J5XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvY29udGVudHMvI3VwZGF0ZS1hLWZpbGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggLSB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIGZvciB0aGUgZmlsZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSB0aGUgY29udGVudHMgb2YgdGhlIGZpbGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gdGhlIGNvbW1pdCBtZXNzYWdlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gY29tbWl0IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hdXRob3JdIC0gdGhlIGF1dGhvciBvZiB0aGUgY29tbWl0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29tbWl0ZXJdIC0gdGhlIGNvbW1pdHRlclxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmNvZGVdIC0gdHJ1ZSBpZiB0aGUgY29udGVudCBzaG91bGQgYmUgYmFzZTY0IGVuY29kZWRcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXcgY29tbWl0XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHdyaXRlRmlsZShicmFuY2gsIHBhdGgsIGNvbnRlbnQsIG1lc3NhZ2UsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWxlUGF0aCA9IHBhdGggPyBlbmNvZGVVUkkocGF0aCkgOiAnJztcbiAgICAgIGxldCBzaG91bGRFbmNvZGUgPSBvcHRpb25zLmVuY29kZSAhPT0gZmFsc2U7XG4gICAgICBsZXQgY29tbWl0ID0ge1xuICAgICAgICAgYnJhbmNoLFxuICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgIGF1dGhvcjogb3B0aW9ucy5hdXRob3IsXG4gICAgICAgICBjb21taXR0ZXI6IG9wdGlvbnMuY29tbWl0dGVyLFxuICAgICAgICAgY29udGVudDogc2hvdWxkRW5jb2RlID8gQmFzZTY0LmVuY29kZShjb250ZW50KSA6IGNvbnRlbnQsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5nZXRTaGEoYnJhbmNoLCBmaWxlUGF0aClcbiAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29tbWl0LnNoYSA9IHJlc3BvbnNlLmRhdGEuc2hhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BVVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L2NvbnRlbnRzLyR7ZmlsZVBhdGh9YCwgY29tbWl0LCBjYik7XG4gICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUFVUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vY29udGVudHMvJHtmaWxlUGF0aH1gLCBjb21taXQsIGNiKTtcbiAgICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgcmVwb3NpdG9yeSBpcyBzdGFycmVkIGJ5IHlvdVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyNjaGVjay1pZi15b3UtYXJlLXN0YXJyaW5nLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVwb3NpdG9yeSBpcyBzdGFycmVkIGFuZCBmYWxzZSBpZiB0aGUgcmVwb3NpdG9yeVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IHN0YXJyZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3Qge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAqL1xuICAgaXNTdGFycmVkKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvdXNlci9zdGFycmVkLyR7dGhpcy5fX2Z1bGxuYW1lfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTdGFyIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyNzdGFyLWEtcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgcmVwb3NpdG9yeSBpcyBzdGFycmVkXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3VzZXIvc3RhcnJlZC8ke3RoaXMuX19mdWxsbmFtZX1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVW5zdGFyIGEgcmVwb3NpdG9yeVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL2FjdGl2aXR5L3N0YXJyaW5nLyN1bnN0YXItYS1yZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSByZXBvc2l0b3J5IGlzIHVuc3RhcnJlZFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bnN0YXIoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3VzZXIvc3RhcnJlZC8ke3RoaXMuX19mdWxsbmFtZX1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHJlbGVhc2VcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9yZWxlYXNlcy8jY3JlYXRlLWEtcmVsZWFzZVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJlbGVhc2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIHJlbGVhc2VcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUmVsZWFzZShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWxlYXNlc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBFZGl0IGEgcmVsZWFzZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL3JlbGVhc2VzLyNlZGl0LWEtcmVsZWFzZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSByZWxlYXNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcmVsZWFzZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG1vZGlmaWVkIHJlbGVhc2VcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgdXBkYXRlUmVsZWFzZShpZCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3JlbGVhc2VzLyR7aWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgcmVsZWFzZXNcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9yZWxlYXNlcy8jbGlzdC1yZWxlYXNlcy1mb3ItYS1yZXBvc2l0b3J5XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgcmVsZWFzZSBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UmVsZWFzZXMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9yZWxlYXNlc2AsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSByZWxlYXNlXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvcmVsZWFzZXMvI2dldC1hLXNpbmdsZS1yZWxlYXNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHJlbGVhc2VcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSByZWxlYXNlIGluZm9ybWF0aW9uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFJlbGVhc2UoaWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9yZXBvcy8ke3RoaXMuX19mdWxsbmFtZX0vcmVsZWFzZXMvJHtpZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgcmVsZWFzZVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL3JlbGVhc2VzLyNkZWxldGUtYS1yZWxlYXNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgcmVsZWFzZSB0byBiZSBkZWxldGVkXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBkZWxldGVSZWxlYXNlKGlkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3JlbGVhc2VzLyR7aWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIE1lcmdlIGEgcHVsbCByZXF1ZXN0XG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHVsbHMvI21lcmdlLWEtcHVsbC1yZXF1ZXN0LW1lcmdlLWJ1dHRvblxuICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSBwdWxsIHJlcXVlc3QgdG8gbWVyZ2VcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIG1lcmdlIG9wdGlvbnMgZm9yIHRoZSBwdWxsIHJlcXVlc3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lcmdlIGluZm9ybWF0aW9uIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtZXJnZVB1bGxSZXF1ZXN0KG51bWJlciwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3JlcG9zLyR7dGhpcy5fX2Z1bGxuYW1lfS9wdWxscy8ke251bWJlcn0vbWVyZ2VgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCBwcm9qZWN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNsaXN0LXJlcG9zaXRvcnktcHJvamVjdHNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgcHJvamVjdHNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFByb2plY3RzKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3Byb2plY3RzYCwge0FjY2VwdEhlYWRlcjogJ2luZXJ0aWEtcHJldmlldyd9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jY3JlYXRlLWEtcmVwb3NpdG9yeS1wcm9qZWN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvamVjdFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVQcm9qZWN0KG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMuQWNjZXB0SGVhZGVyID0gJ2luZXJ0aWEtcHJldmlldyc7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcmVwb3MvJHt0aGlzLl9fZnVsbG5hbWV9L3Byb2plY3RzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVwb3NpdG9yeTtcbiJdfQ==
	//# sourceMappingURL=Repository.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(385).Buffer))

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(386)
	var ieee754 = __webpack_require__(387)
	var isArray = __webpack_require__(388)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 386 */
/***/ (function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function getLens (b64) {
	  var len = b64.length

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

	  var curByte = 0

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen

	  for (var i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(
	      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
	    ))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }

	  return parts.join('')
	}


/***/ }),
/* 387 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 388 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.1.2 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.1.2',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(390)(module), (function() { return this; }())))

/***/ }),
/* 390 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Organization encapsulates the functionality to create repositories in organizations
	 */
	var Organization = function (_Requestable) {
	  _inherits(Organization, _Requestable);

	  /**
	   * Create a new Organization
	   * @param {string} organization - the name of the organization
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Organization(organization, auth, apiBase) {
	    _classCallCheck(this, Organization);

	    var _this = _possibleConstructorReturn(this, (Organization.__proto__ || Object.getPrototypeOf(Organization)).call(this, auth, apiBase));

	    _this.__name = organization;
	    return _this;
	  }

	  /**
	   * Create a repository in an organization
	   * @see https://developer.github.com/v3/repos/#create
	   * @param {Object} options - the repository definition
	   * @param {Requestable.callback} [cb] - will receive the created repository
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Organization, [{
	    key: 'createRepo',
	    value: function createRepo(options, cb) {
	      return this._request('POST', '/orgs/' + this.__name + '/repos', options, cb);
	    }

	    /**
	     * List the repositories in an organization
	     * @see https://developer.github.com/v3/repos/#list-organization-repositories
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getRepos',
	    value: function getRepos(cb) {
	      var requestOptions = this._getOptionsWithDefaults({ direction: 'desc' });

	      return this._requestAllPages('/orgs/' + this.__name + '/repos', requestOptions, cb);
	    }

	    /**
	     * Query if the user is a member or not
	     * @param {string} username - the user in question
	     * @param {Requestable.callback} [cb] - will receive true if the user is a member
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'isMember',
	    value: function isMember(username, cb) {
	      return this._request204or404('/orgs/' + this.__name + '/members/' + username, null, cb);
	    }

	    /**
	     * List the users who are members of the company
	     * @see https://developer.github.com/v3/orgs/members/#members-list
	     * @param {object} options - filtering options
	     * @param {string} [options.filter=all] - can be either `2fa_disabled` or `all`
	     * @param {string} [options.role=all] - can be one of: `all`, `admin`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the list of users
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMembers',
	    value: function listMembers(options, cb) {
	      return this._request('GET', '/orgs/' + this.__name + '/members', options, cb);
	    }

	    /**
	     * List the Teams in the Organization
	     * @see https://developer.github.com/v3/orgs/teams/#list-teams
	     * @param {Requestable.callback} [cb] - will receive the list of teams
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getTeams',
	    value: function getTeams(cb) {
	      return this._requestAllPages('/orgs/' + this.__name + '/teams', undefined, cb);
	    }

	    /**
	     * Create a team
	     * @see https://developer.github.com/v3/orgs/teams/#create-team
	     * @param {object} options - Team creation parameters
	     * @param {string} options.name - The name of the team
	     * @param {string} [options.description] - Team description
	     * @param {string} [options.repo_names] - Repos to add the team to
	     * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one
	     * of: `secret`, or `closed`
	     * @param {Requestable.callback} [cb] - will receive the created team
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createTeam',
	    value: function createTeam(options, cb) {
	      return this._request('POST', '/orgs/' + this.__name + '/teams', options, cb);
	    }

	    /**
	     * Get information about all projects
	     * @see https://developer.github.com/v3/projects/#list-organization-projects
	     * @param {Requestable.callback} [cb] - will receive the list of projects
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listProjects',
	    value: function listProjects(cb) {
	      return this._requestAllPages('/orgs/' + this.__name + '/projects', { AcceptHeader: 'inertia-preview' }, cb);
	    }

	    /**
	     * Create a new project
	     * @see https://developer.github.com/v3/repos/projects/#create-a-project
	     * @param {Object} options - the description of the project
	     * @param {Requestable.callback} cb - will receive the newly created project
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'createProject',
	    value: function createProject(options, cb) {
	      options = options || {};
	      options.AcceptHeader = 'inertia-preview';
	      return this._request('POST', '/orgs/' + this.__name + '/projects', options, cb);
	    }
	  }]);

	  return Organization;
	}(_Requestable3.default);

	module.exports = Organization;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9yZ2FuaXphdGlvbi5qcyJdLCJuYW1lcyI6WyJPcmdhbml6YXRpb24iLCJvcmdhbml6YXRpb24iLCJhdXRoIiwiYXBpQmFzZSIsIl9fbmFtZSIsIm9wdGlvbnMiLCJjYiIsIl9yZXF1ZXN0IiwicmVxdWVzdE9wdGlvbnMiLCJfZ2V0T3B0aW9uc1dpdGhEZWZhdWx0cyIsImRpcmVjdGlvbiIsIl9yZXF1ZXN0QWxsUGFnZXMiLCJ1c2VybmFtZSIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJ1bmRlZmluZWQiLCJBY2NlcHRIZWFkZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLFk7OztBQUNIOzs7Ozs7QUFNQSx3QkFBWUMsWUFBWixFQUEwQkMsSUFBMUIsRUFBZ0NDLE9BQWhDLEVBQXlDO0FBQUE7O0FBQUEsNEhBQ2hDRCxJQURnQyxFQUMxQkMsT0FEMEI7O0FBRXRDLFVBQUtDLE1BQUwsR0FBY0gsWUFBZDtBQUZzQztBQUd4Qzs7QUFFRDs7Ozs7Ozs7Ozs7K0JBT1dJLE8sRUFBU0MsRSxFQUFJO0FBQ3JCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsYUFBK0IsS0FBS0gsTUFBcEMsYUFBb0RDLE9BQXBELEVBQTZEQyxFQUE3RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs2QkFNU0EsRSxFQUFJO0FBQ1YsVUFBSUUsaUJBQWlCLEtBQUtDLHVCQUFMLENBQTZCLEVBQUNDLFdBQVcsTUFBWixFQUE3QixDQUFyQjs7QUFFQSxhQUFPLEtBQUtDLGdCQUFMLFlBQStCLEtBQUtQLE1BQXBDLGFBQW9ESSxjQUFwRCxFQUFvRUYsRUFBcEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7NkJBTVNNLFEsRUFBVU4sRSxFQUFJO0FBQ3BCLGFBQU8sS0FBS08sZ0JBQUwsWUFBK0IsS0FBS1QsTUFBcEMsaUJBQXNEUSxRQUF0RCxFQUFrRSxJQUFsRSxFQUF3RU4sRUFBeEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Z0NBU1lELE8sRUFBU0MsRSxFQUFJO0FBQ3RCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLEtBQWQsYUFBOEIsS0FBS0gsTUFBbkMsZUFBcURDLE9BQXJELEVBQThEQyxFQUE5RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs2QkFNU0EsRSxFQUFJO0FBQ1YsYUFBTyxLQUFLSyxnQkFBTCxZQUErQixLQUFLUCxNQUFwQyxhQUFvRFUsU0FBcEQsRUFBK0RSLEVBQS9ELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OytCQVlXRCxPLEVBQVNDLEUsRUFBSTtBQUNyQixhQUFPLEtBQUtDLFFBQUwsQ0FBYyxNQUFkLGFBQStCLEtBQUtILE1BQXBDLGFBQW9EQyxPQUFwRCxFQUE2REMsRUFBN0QsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTWFBLEUsRUFBSTtBQUNkLGFBQU8sS0FBS0ssZ0JBQUwsWUFBK0IsS0FBS1AsTUFBcEMsZ0JBQXVELEVBQUNXLGNBQWMsaUJBQWYsRUFBdkQsRUFBMEZULEVBQTFGLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztrQ0FPY0QsTyxFQUFTQyxFLEVBQUk7QUFDeEJELGdCQUFVQSxXQUFXLEVBQXJCO0FBQ0FBLGNBQVFVLFlBQVIsR0FBdUIsaUJBQXZCO0FBQ0EsYUFBTyxLQUFLUixRQUFMLENBQWMsTUFBZCxhQUErQixLQUFLSCxNQUFwQyxnQkFBdURDLE9BQXZELEVBQWdFQyxFQUFoRSxDQUFQO0FBQ0Y7Ozs7OztBQUdKVSxPQUFPQyxPQUFQLEdBQWlCakIsWUFBakIiLCJmaWxlIjoiT3JnYW5pemF0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogT3JnYW5pemF0aW9uIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBjcmVhdGUgcmVwb3NpdG9yaWVzIGluIG9yZ2FuaXphdGlvbnNcbiAqL1xuY2xhc3MgT3JnYW5pemF0aW9uIGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgT3JnYW5pemF0aW9uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3JnYW5pemF0aW9uIC0gdGhlIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3Rvcihvcmdhbml6YXRpb24sIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX25hbWUgPSBvcmdhbml6YXRpb247XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBpbiBhbiBvcmdhbml6YXRpb25cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy8jY3JlYXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSByZXBvc2l0b3J5IGRlZmluaXRpb25cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGNyZWF0ZWQgcmVwb3NpdG9yeVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVSZXBvKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvb3Jncy8ke3RoaXMuX19uYW1lfS9yZXBvc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMaXN0IHRoZSByZXBvc2l0b3JpZXMgaW4gYW4gb3JnYW5pemF0aW9uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3MvI2xpc3Qtb3JnYW5pemF0aW9uLXJlcG9zaXRvcmllc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0UmVwb3MoY2IpIHtcbiAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNXaXRoRGVmYXVsdHMoe2RpcmVjdGlvbjogJ2Rlc2MnfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3JlcG9zYCwgcmVxdWVzdE9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBRdWVyeSBpZiB0aGUgdXNlciBpcyBhIG1lbWJlciBvciBub3RcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VyIGluIHF1ZXN0aW9uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIHVzZXIgaXMgYSBtZW1iZXJcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNNZW1iZXIodXNlcm5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvb3Jncy8ke3RoaXMuX19uYW1lfS9tZW1iZXJzLyR7dXNlcm5hbWV9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIExpc3QgdGhlIHVzZXJzIHdobyBhcmUgbWVtYmVycyBvZiB0aGUgY29tcGFueVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvbWVtYmVycy8jbWVtYmVycy1saXN0XG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGZpbHRlcmluZyBvcHRpb25zXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsdGVyPWFsbF0gLSBjYW4gYmUgZWl0aGVyIGAyZmFfZGlzYWJsZWRgIG9yIGBhbGxgXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm9sZT1hbGxdIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBhZG1pbmAsIG9yIGBtZW1iZXJgXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBsaXN0IG9mIHVzZXJzXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RNZW1iZXJzKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9vcmdzLyR7dGhpcy5fX25hbWV9L21lbWJlcnNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgVGVhbXMgaW4gdGhlIE9yZ2FuaXphdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2xpc3QtdGVhbXNcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgdGVhbXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZ2V0VGVhbXMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3RlYW1zYCwgdW5kZWZpbmVkLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgdGVhbVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2NyZWF0ZS10ZWFtXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRlYW0gY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0ZWFtXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIC0gVGVhbSBkZXNjcmlwdGlvblxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlcG9fbmFtZXNdIC0gUmVwb3MgdG8gYWRkIHRoZSB0ZWFtIHRvXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJpdmFjeT1zZWNyZXRdIC0gVGhlIGxldmVsIG9mIHByaXZhY3kgdGhlIHRlYW0gc2hvdWxkIGhhdmUuIENhbiBiZSBlaXRoZXIgb25lXG4gICAgKiBvZjogYHNlY3JldGAsIG9yIGBjbG9zZWRgXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjcmVhdGVkIHRlYW1cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlVGVhbShvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL29yZ3MvJHt0aGlzLl9fbmFtZX0vdGVhbXNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCBwcm9qZWN0c1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNsaXN0LW9yZ2FuaXphdGlvbi1wcm9qZWN0c1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBwcm9qZWN0c1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBsaXN0UHJvamVjdHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0QWxsUGFnZXMoYC9vcmdzLyR7dGhpcy5fX25hbWV9L3Byb2plY3RzYCwge0FjY2VwdEhlYWRlcjogJ2luZXJ0aWEtcHJldmlldyd9LCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9yZXBvcy9wcm9qZWN0cy8jY3JlYXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIHByb2plY3RcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgY3JlYXRlUHJvamVjdChvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLkFjY2VwdEhlYWRlciA9ICdpbmVydGlhLXByZXZpZXcnO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCBgL29yZ3MvJHt0aGlzLl9fbmFtZX0vcHJvamVjdHNgLCBvcHRpb25zLCBjYik7XG4gICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3JnYW5pemF0aW9uO1xuIl19
	//# sourceMappingURL=Organization.js.map


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	var _debug = __webpack_require__(376);

	var _debug2 = _interopRequireDefault(_debug);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2016 Matt Smith (Development Seed)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var log = (0, _debug2.default)('github:team');

	/**
	 * A Team allows scoping of API requests to a particular Github Organization Team.
	 */

	var Team = function (_Requestable) {
	  _inherits(Team, _Requestable);

	  /**
	   * Create a Team.
	   * @param {string} [teamId] - the id for the team
	   * @param {Requestable.auth} [auth] - information required to authenticate to Github
	   * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	   */
	  function Team(teamId, auth, apiBase) {
	    _classCallCheck(this, Team);

	    var _this = _possibleConstructorReturn(this, (Team.__proto__ || Object.getPrototypeOf(Team)).call(this, auth, apiBase));

	    _this.__teamId = teamId;
	    return _this;
	  }

	  /**
	   * Get Team information
	   * @see https://developer.github.com/v3/orgs/teams/#get-team
	   * @param {Requestable.callback} [cb] - will receive the team
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Team, [{
	    key: 'getTeam',
	    value: function getTeam(cb) {
	      log('Fetching Team ' + this.__teamId);
	      return this._request('Get', '/teams/' + this.__teamId, undefined, cb);
	    }

	    /**
	     * List the Team's repositories
	     * @see https://developer.github.com/v3/orgs/teams/#list-team-repos
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listRepos',
	    value: function listRepos(cb) {
	      log('Fetching repositories for Team ' + this.__teamId);
	      return this._requestAllPages('/teams/' + this.__teamId + '/repos', undefined, cb);
	    }

	    /**
	     * Edit Team information
	     * @see https://developer.github.com/v3/orgs/teams/#edit-team
	     * @param {object} options - Parameters for team edit
	     * @param {string} options.name - The name of the team
	     * @param {string} [options.description] - Team description
	     * @param {string} [options.repo_names] - Repos to add the team to
	     * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one
	     * of: `secret`, or `closed`
	     * @param {Requestable.callback} [cb] - will receive the updated team
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'editTeam',
	    value: function editTeam(options, cb) {
	      log('Editing Team ' + this.__teamId);
	      return this._request('PATCH', '/teams/' + this.__teamId, options, cb);
	    }

	    /**
	     * List the users who are members of the Team
	     * @see https://developer.github.com/v3/orgs/teams/#list-team-members
	     * @param {object} options - Parameters for listing team users
	     * @param {string} [options.role=all] - can be one of: `all`, `maintainer`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the list of users
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'listMembers',
	    value: function listMembers(options, cb) {
	      log('Getting members of Team ' + this.__teamId);
	      return this._requestAllPages('/teams/' + this.__teamId + '/members', options, cb);
	    }

	    /**
	     * Get Team membership status for a user
	     * @see https://developer.github.com/v3/orgs/teams/#get-team-membership
	     * @param {string} username - can be one of: `all`, `maintainer`, or `member`
	     * @param {Requestable.callback} [cb] - will receive the membership status of a user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'getMembership',
	    value: function getMembership(username, cb) {
	      log('Getting membership of user ' + username + ' in Team ' + this.__teamId);
	      return this._request('GET', '/teams/' + this.__teamId + '/memberships/' + username, undefined, cb);
	    }

	    /**
	     * Add a member to the Team
	     * @see https://developer.github.com/v3/orgs/teams/#add-team-membership
	     * @param {string} username - can be one of: `all`, `maintainer`, or `member`
	     * @param {object} options - Parameters for adding a team member
	     * @param {string} [options.role=member] - The role that this user should have in the team. Can be one
	     * of: `member`, or `maintainer`
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'addMembership',
	    value: function addMembership(username, options, cb) {
	      log('Adding user ' + username + ' to Team ' + this.__teamId);
	      return this._request('PUT', '/teams/' + this.__teamId + '/memberships/' + username, options, cb);
	    }

	    /**
	     * Get repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#remove-team-membership
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'isManagedRepo',
	    value: function isManagedRepo(owner, repo, cb) {
	      log('Getting repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, undefined, cb);
	    }

	    /**
	     * Add or Update repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#add-or-update-team-repository
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {object} options - Parameters for adding or updating repo management for the team
	     * @param {string} [options.permission] - The permission to grant the team on this repository. Can be one
	     * of: `pull`, `push`, or `admin`
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'manageRepo',
	    value: function manageRepo(owner, repo, options, cb) {
	      log('Adding or Updating repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, options, cb, 'PUT');
	    }

	    /**
	     * Remove repo management status for team
	     * @see https://developer.github.com/v3/orgs/teams/#remove-team-repository
	     * @param {string} owner - Organization name
	     * @param {string} repo - Repo name
	     * @param {Requestable.callback} [cb] - will receive the membership status of added user
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'unmanageRepo',
	    value: function unmanageRepo(owner, repo, cb) {
	      log('Remove repo management by Team ' + this.__teamId + ' for repo ' + owner + '/' + repo);
	      return this._request204or404('/teams/' + this.__teamId + '/repos/' + owner + '/' + repo, undefined, cb, 'DELETE');
	    }

	    /**
	     * Delete Team
	     * @see https://developer.github.com/v3/orgs/teams/#delete-team
	     * @param {Requestable.callback} [cb] - will receive the list of repositories
	     * @return {Promise} - the promise for the http request
	     */

	  }, {
	    key: 'deleteTeam',
	    value: function deleteTeam(cb) {
	      log('Deleting Team ' + this.__teamId);
	      return this._request204or404('/teams/' + this.__teamId, undefined, cb, 'DELETE');
	    }
	  }]);

	  return Team;
	}(_Requestable3.default);

	module.exports = Team;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlRlYW0uanMiXSwibmFtZXMiOlsibG9nIiwiVGVhbSIsInRlYW1JZCIsImF1dGgiLCJhcGlCYXNlIiwiX190ZWFtSWQiLCJjYiIsIl9yZXF1ZXN0IiwidW5kZWZpbmVkIiwiX3JlcXVlc3RBbGxQYWdlcyIsIm9wdGlvbnMiLCJ1c2VybmFtZSIsIm93bmVyIiwicmVwbyIsIl9yZXF1ZXN0MjA0b3I0MDQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBT0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7OztBQVNBLElBQU1BLE1BQU0scUJBQU0sYUFBTixDQUFaOztBQUVBOzs7O0lBR01DLEk7OztBQUNIOzs7Ozs7QUFNQSxnQkFBWUMsTUFBWixFQUFvQkMsSUFBcEIsRUFBMEJDLE9BQTFCLEVBQW1DO0FBQUE7O0FBQUEsNEdBQzFCRCxJQUQwQixFQUNwQkMsT0FEb0I7O0FBRWhDLFVBQUtDLFFBQUwsR0FBZ0JILE1BQWhCO0FBRmdDO0FBR2xDOztBQUVEOzs7Ozs7Ozs7OzRCQU1RSSxFLEVBQUk7QUFDVE4sNkJBQXFCLEtBQUtLLFFBQTFCO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLRixRQUFwQyxFQUFnREcsU0FBaEQsRUFBMkRGLEVBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OzhCQU1VQSxFLEVBQUk7QUFDWE4sOENBQXNDLEtBQUtLLFFBQTNDO0FBQ0EsYUFBTyxLQUFLSSxnQkFBTCxhQUFnQyxLQUFLSixRQUFyQyxhQUF1REcsU0FBdkQsRUFBa0VGLEVBQWxFLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OzZCQVlTSSxPLEVBQVNKLEUsRUFBSTtBQUNuQk4sNEJBQW9CLEtBQUtLLFFBQXpCO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsT0FBZCxjQUFpQyxLQUFLRixRQUF0QyxFQUFrREssT0FBbEQsRUFBMkRKLEVBQTNELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Z0NBUVlJLE8sRUFBU0osRSxFQUFJO0FBQ3RCTix1Q0FBK0IsS0FBS0ssUUFBcEM7QUFDQSxhQUFPLEtBQUtJLGdCQUFMLGFBQWdDLEtBQUtKLFFBQXJDLGVBQXlESyxPQUF6RCxFQUFrRUosRUFBbEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O2tDQU9jSyxRLEVBQVVMLEUsRUFBSTtBQUN6Qk4sMENBQWtDVyxRQUFsQyxpQkFBc0QsS0FBS04sUUFBM0Q7QUFDQSxhQUFPLEtBQUtFLFFBQUwsQ0FBYyxLQUFkLGNBQStCLEtBQUtGLFFBQXBDLHFCQUE0RE0sUUFBNUQsRUFBd0VILFNBQXhFLEVBQW1GRixFQUFuRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7a0NBVWNLLFEsRUFBVUQsTyxFQUFTSixFLEVBQUk7QUFDbENOLDJCQUFtQlcsUUFBbkIsaUJBQXVDLEtBQUtOLFFBQTVDO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWMsS0FBZCxjQUErQixLQUFLRixRQUFwQyxxQkFBNERNLFFBQTVELEVBQXdFRCxPQUF4RSxFQUFpRkosRUFBakYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztrQ0FRY00sSyxFQUFPQyxJLEVBQU1QLEUsRUFBSTtBQUM1Qk4sK0NBQXVDLEtBQUtLLFFBQTVDLGtCQUFpRU8sS0FBakUsU0FBMEVDLElBQTFFO0FBQ0EsYUFBTyxLQUFLQyxnQkFBTCxhQUFnQyxLQUFLVCxRQUFyQyxlQUF1RE8sS0FBdkQsU0FBZ0VDLElBQWhFLEVBQXdFTCxTQUF4RSxFQUFtRkYsRUFBbkYsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7OzsrQkFXV00sSyxFQUFPQyxJLEVBQU1ILE8sRUFBU0osRSxFQUFJO0FBQ2xDTiwwREFBa0QsS0FBS0ssUUFBdkQsa0JBQTRFTyxLQUE1RSxTQUFxRkMsSUFBckY7QUFDQSxhQUFPLEtBQUtDLGdCQUFMLGFBQWdDLEtBQUtULFFBQXJDLGVBQXVETyxLQUF2RCxTQUFnRUMsSUFBaEUsRUFBd0VILE9BQXhFLEVBQWlGSixFQUFqRixFQUFxRixLQUFyRixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFhTSxLLEVBQU9DLEksRUFBTVAsRSxFQUFJO0FBQzNCTiw4Q0FBc0MsS0FBS0ssUUFBM0Msa0JBQWdFTyxLQUFoRSxTQUF5RUMsSUFBekU7QUFDQSxhQUFPLEtBQUtDLGdCQUFMLGFBQWdDLEtBQUtULFFBQXJDLGVBQXVETyxLQUF2RCxTQUFnRUMsSUFBaEUsRUFBd0VMLFNBQXhFLEVBQW1GRixFQUFuRixFQUF1RixRQUF2RixDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsrQkFNV0EsRSxFQUFJO0FBQ1pOLDZCQUFxQixLQUFLSyxRQUExQjtBQUNBLGFBQU8sS0FBS1MsZ0JBQUwsYUFBZ0MsS0FBS1QsUUFBckMsRUFBaURHLFNBQWpELEVBQTRERixFQUE1RCxFQUFnRSxRQUFoRSxDQUFQO0FBQ0Y7Ozs7OztBQUdKUyxPQUFPQyxPQUFQLEdBQWlCZixJQUFqQiIsImZpbGUiOiJUZWFtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxNiBNYXR0IFNtaXRoIChEZXZlbG9wbWVudCBTZWVkKVxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuY29uc3QgbG9nID0gZGVidWcoJ2dpdGh1Yjp0ZWFtJyk7XG5cbi8qKlxuICogQSBUZWFtIGFsbG93cyBzY29waW5nIG9mIEFQSSByZXF1ZXN0cyB0byBhIHBhcnRpY3VsYXIgR2l0aHViIE9yZ2FuaXphdGlvbiBUZWFtLlxuICovXG5jbGFzcyBUZWFtIGV4dGVuZHMgUmVxdWVzdGFibGUge1xuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBUZWFtLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZWFtSWRdIC0gdGhlIGlkIGZvciB0aGUgdGVhbVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3Rvcih0ZWFtSWQsIGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgICAgdGhpcy5fX3RlYW1JZCA9IHRlYW1JZDtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgVGVhbSBpbmZvcm1hdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2dldC10ZWFtXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSB0ZWFtXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGdldFRlYW0oY2IpIHtcbiAgICAgIGxvZyhgRmV0Y2hpbmcgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR2V0JywgYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9YCwgdW5kZWZpbmVkLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgVGVhbSdzIHJlcG9zaXRvcmllc1xuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2xpc3QtdGVhbS1yZXBvc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdFJlcG9zKGNiKSB7XG4gICAgICBsb2coYEZldGNoaW5nIHJlcG9zaXRvcmllcyBmb3IgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEFsbFBhZ2VzKGAvdGVhbXMvJHt0aGlzLl9fdGVhbUlkfS9yZXBvc2AsIHVuZGVmaW5lZCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEVkaXQgVGVhbSBpbmZvcm1hdGlvblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI2VkaXQtdGVhbVxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIGZvciB0ZWFtIGVkaXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGVhbVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSAtIFRlYW0gZGVzY3JpcHRpb25cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXBvX25hbWVzXSAtIFJlcG9zIHRvIGFkZCB0aGUgdGVhbSB0b1xuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByaXZhY3k9c2VjcmV0XSAtIFRoZSBsZXZlbCBvZiBwcml2YWN5IHRoZSB0ZWFtIHNob3VsZCBoYXZlLiBDYW4gYmUgZWl0aGVyIG9uZVxuICAgICogb2Y6IGBzZWNyZXRgLCBvciBgY2xvc2VkYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCB0ZWFtXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGVkaXRUZWFtKG9wdGlvbnMsIGNiKSB7XG4gICAgICBsb2coYEVkaXRpbmcgVGVhbSAke3RoaXMuX190ZWFtSWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTGlzdCB0aGUgdXNlcnMgd2hvIGFyZSBtZW1iZXJzIG9mIHRoZSBUZWFtXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy90ZWFtcy8jbGlzdC10ZWFtLW1lbWJlcnNcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gUGFyYW1ldGVycyBmb3IgbGlzdGluZyB0ZWFtIHVzZXJzXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm9sZT1hbGxdIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBtYWludGFpbmVyYCwgb3IgYG1lbWJlcmBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgdXNlcnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgbGlzdE1lbWJlcnMob3B0aW9ucywgY2IpIHtcbiAgICAgIGxvZyhgR2V0dGluZyBtZW1iZXJzIG9mIFRlYW0gJHt0aGlzLl9fdGVhbUlkfWApO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2AsIG9wdGlvbnMsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgVGVhbSBtZW1iZXJzaGlwIHN0YXR1cyBmb3IgYSB1c2VyXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvb3Jncy90ZWFtcy8jZ2V0LXRlYW0tbWVtYmVyc2hpcFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIC0gY2FuIGJlIG9uZSBvZjogYGFsbGAsIGBtYWludGFpbmVyYCwgb3IgYG1lbWJlcmBcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lbWJlcnNoaXAgc3RhdHVzIG9mIGEgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRNZW1iZXJzaGlwKHVzZXJuYW1lLCBjYikge1xuICAgICAgbG9nKGBHZXR0aW5nIG1lbWJlcnNoaXAgb2YgdXNlciAke3VzZXJuYW1lfSBpbiBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2hpcHMvJHt1c2VybmFtZX1gLCB1bmRlZmluZWQsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgYSBtZW1iZXIgdG8gdGhlIFRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNhZGQtdGVhbS1tZW1iZXJzaGlwXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgLSBjYW4gYmUgb25lIG9mOiBgYWxsYCwgYG1haW50YWluZXJgLCBvciBgbWVtYmVyYFxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIGZvciBhZGRpbmcgYSB0ZWFtIG1lbWJlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJvbGU9bWVtYmVyXSAtIFRoZSByb2xlIHRoYXQgdGhpcyB1c2VyIHNob3VsZCBoYXZlIGluIHRoZSB0ZWFtLiBDYW4gYmUgb25lXG4gICAgKiBvZjogYG1lbWJlcmAsIG9yIGBtYWludGFpbmVyYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBhZGRNZW1iZXJzaGlwKHVzZXJuYW1lLCBvcHRpb25zLCBjYikge1xuICAgICAgbG9nKGBBZGRpbmcgdXNlciAke3VzZXJuYW1lfSB0byBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQVVQnLCBgL3RlYW1zLyR7dGhpcy5fX3RlYW1JZH0vbWVtYmVyc2hpcHMvJHt1c2VybmFtZX1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IHJlcG8gbWFuYWdlbWVudCBzdGF0dXMgZm9yIHRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNyZW1vdmUtdGVhbS1tZW1iZXJzaGlwXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXIgLSBPcmdhbml6YXRpb24gbmFtZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcG8gLSBSZXBvIG5hbWVcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIG1lbWJlcnNoaXAgc3RhdHVzIG9mIGFkZGVkIHVzZXJcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgaXNNYW5hZ2VkUmVwbyhvd25lciwgcmVwbywgY2IpIHtcbiAgICAgIGxvZyhgR2V0dGluZyByZXBvIG1hbmFnZW1lbnQgYnkgVGVhbSAke3RoaXMuX190ZWFtSWR9IGZvciByZXBvICR7b3duZXJ9LyR7cmVwb31gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9L3JlcG9zLyR7b3duZXJ9LyR7cmVwb31gLCB1bmRlZmluZWQsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBZGQgb3IgVXBkYXRlIHJlcG8gbWFuYWdlbWVudCBzdGF0dXMgZm9yIHRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNhZGQtb3ItdXBkYXRlLXRlYW0tcmVwb3NpdG9yeVxuICAgICogQHBhcmFtIHtzdHJpbmd9IG93bmVyIC0gT3JnYW5pemF0aW9uIG5hbWVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvIC0gUmVwbyBuYW1lXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgZm9yIGFkZGluZyBvciB1cGRhdGluZyByZXBvIG1hbmFnZW1lbnQgZm9yIHRoZSB0ZWFtXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVybWlzc2lvbl0gLSBUaGUgcGVybWlzc2lvbiB0byBncmFudCB0aGUgdGVhbSBvbiB0aGlzIHJlcG9zaXRvcnkuIENhbiBiZSBvbmVcbiAgICAqIG9mOiBgcHVsbGAsIGBwdXNoYCwgb3IgYGFkbWluYFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBtYW5hZ2VSZXBvKG93bmVyLCByZXBvLCBvcHRpb25zLCBjYikge1xuICAgICAgbG9nKGBBZGRpbmcgb3IgVXBkYXRpbmcgcmVwbyBtYW5hZ2VtZW50IGJ5IFRlYW0gJHt0aGlzLl9fdGVhbUlkfSBmb3IgcmVwbyAke293bmVyfS8ke3JlcG99YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDIwNG9yNDA0KGAvdGVhbXMvJHt0aGlzLl9fdGVhbUlkfS9yZXBvcy8ke293bmVyfS8ke3JlcG99YCwgb3B0aW9ucywgY2IsICdQVVQnKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBSZW1vdmUgcmVwbyBtYW5hZ2VtZW50IHN0YXR1cyBmb3IgdGVhbVxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL29yZ3MvdGVhbXMvI3JlbW92ZS10ZWFtLXJlcG9zaXRvcnlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lciAtIE9yZ2FuaXphdGlvbiBuYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbyAtIFJlcG8gbmFtZVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbWVtYmVyc2hpcCBzdGF0dXMgb2YgYWRkZWQgdXNlclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICB1bm1hbmFnZVJlcG8ob3duZXIsIHJlcG8sIGNiKSB7XG4gICAgICBsb2coYFJlbW92ZSByZXBvIG1hbmFnZW1lbnQgYnkgVGVhbSAke3RoaXMuX190ZWFtSWR9IGZvciByZXBvICR7b3duZXJ9LyR7cmVwb31gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9L3JlcG9zLyR7b3duZXJ9LyR7cmVwb31gLCB1bmRlZmluZWQsIGNiLCAnREVMRVRFJyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIFRlYW1cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vcmdzL3RlYW1zLyNkZWxldGUtdGVhbVxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiByZXBvc2l0b3JpZXNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlVGVhbShjYikge1xuICAgICAgbG9nKGBEZWxldGluZyBUZWFtICR7dGhpcy5fX3RlYW1JZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0MjA0b3I0MDQoYC90ZWFtcy8ke3RoaXMuX190ZWFtSWR9YCwgdW5kZWZpbmVkLCBjYiwgJ0RFTEVURScpO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlYW07XG4iXX0=
	//# sourceMappingURL=Team.js.map


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Renders html from Markdown text
	 */
	var Markdown = function (_Requestable) {
	  _inherits(Markdown, _Requestable);

	  /**
	   * construct a Markdown
	   * @param {Requestable.auth} auth - the credentials to authenticate to GitHub
	   * @param {string} [apiBase] - the base Github API URL
	   * @return {Promise} - the promise for the http request
	   */
	  function Markdown(auth, apiBase) {
	    _classCallCheck(this, Markdown);

	    return _possibleConstructorReturn(this, (Markdown.__proto__ || Object.getPrototypeOf(Markdown)).call(this, auth, apiBase));
	  }

	  /**
	   * Render html from Markdown text.
	   * @see https://developer.github.com/v3/markdown/#render-an-arbitrary-markdown-document
	   * @param {Object} options - conversion options
	   * @param {string} [options.text] - the markdown text to convert
	   * @param {string} [options.mode=markdown] - can be either `markdown` or `gfm`
	   * @param {string} [options.context] - repository name if mode is gfm
	   * @param {Requestable.callback} [cb] - will receive the converted html
	   * @return {Promise} - the promise for the http request
	   */


	  _createClass(Markdown, [{
	    key: 'render',
	    value: function render(options, cb) {
	      return this._request('POST', '/markdown', options, cb);
	    }
	  }]);

	  return Markdown;
	}(_Requestable3.default);

	module.exports = Markdown;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1hcmtkb3duLmpzIl0sIm5hbWVzIjpbIk1hcmtkb3duIiwiYXV0aCIsImFwaUJhc2UiLCJvcHRpb25zIiwiY2IiLCJfcmVxdWVzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFPQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7OztBQVNBOzs7SUFHTUEsUTs7O0FBQ0g7Ozs7OztBQU1BLG9CQUFZQyxJQUFaLEVBQWtCQyxPQUFsQixFQUEyQjtBQUFBOztBQUFBLCtHQUNsQkQsSUFEa0IsRUFDWkMsT0FEWTtBQUUxQjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7MkJBVU9DLE8sRUFBU0MsRSxFQUFJO0FBQ2pCLGFBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQsRUFBc0IsV0FBdEIsRUFBbUNGLE9BQW5DLEVBQTRDQyxFQUE1QyxDQUFQO0FBQ0Y7Ozs7OztBQUdKRSxPQUFPQyxPQUFQLEdBQWlCUCxRQUFqQiIsImZpbGUiOiJNYXJrZG93bi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVcbiAqIEBjb3B5cmlnaHQgIDIwMTMgTWljaGFlbCBBdWZyZWl0ZXIgKERldmVsb3BtZW50IFNlZWQpIGFuZCAyMDE2IFlhaG9vIEluYy5cbiAqIEBsaWNlbnNlICAgIExpY2Vuc2VkIHVuZGVyIHtAbGluayBodHRwczovL3NwZHgub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZS1DbGVhci5odG1sIEJTRC0zLUNsYXVzZS1DbGVhcn0uXG4gKiAgICAgICAgICAgICBHaXRodWIuanMgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUuXG4gKi9cblxuaW1wb3J0IFJlcXVlc3RhYmxlIGZyb20gJy4vUmVxdWVzdGFibGUnO1xuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCBmcm9tIE1hcmtkb3duIHRleHRcbiAqL1xuY2xhc3MgTWFya2Rvd24gZXh0ZW5kcyBSZXF1ZXN0YWJsZSB7XG4gICAvKipcbiAgICAqIGNvbnN0cnVjdCBhIE1hcmtkb3duXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmF1dGh9IGF1dGggLSB0aGUgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRlIHRvIEdpdEh1YlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlCYXNlXSAtIHRoZSBiYXNlIEdpdGh1YiBBUEkgVVJMXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGNvbnN0cnVjdG9yKGF1dGgsIGFwaUJhc2UpIHtcbiAgICAgIHN1cGVyKGF1dGgsIGFwaUJhc2UpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFJlbmRlciBodG1sIGZyb20gTWFya2Rvd24gdGV4dC5cbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9tYXJrZG93bi8jcmVuZGVyLWFuLWFyYml0cmFyeS1tYXJrZG93bi1kb2N1bWVudFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb252ZXJzaW9uIG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0XSAtIHRoZSBtYXJrZG93biB0ZXh0IHRvIGNvbnZlcnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tb2RlPW1hcmtkb3duXSAtIGNhbiBiZSBlaXRoZXIgYG1hcmtkb3duYCBvciBgZ2ZtYFxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRleHRdIC0gcmVwb3NpdG9yeSBuYW1lIGlmIG1vZGUgaXMgZ2ZtXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBbY2JdIC0gd2lsbCByZWNlaXZlIHRoZSBjb252ZXJ0ZWQgaHRtbFxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICByZW5kZXIob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgJy9tYXJrZG93bicsIG9wdGlvbnMsIGNiKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcbiJdfQ==
	//# sourceMappingURL=Markdown.js.map


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Requestable2 = __webpack_require__(350);

	var _Requestable3 = _interopRequireDefault(_Requestable2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *             Github.js is freely distributable.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/**
	 * Project encapsulates the functionality to create, query, and modify cards and columns.
	 */
	var Project = function (_Requestable) {
	   _inherits(Project, _Requestable);

	   /**
	    * Create a Project.
	    * @param {string} id - the id of the project
	    * @param {Requestable.auth} [auth] - information required to authenticate to Github
	    * @param {string} [apiBase=https://api.github.com] - the base Github API URL
	    */
	   function Project(id, auth, apiBase) {
	      _classCallCheck(this, Project);

	      var _this = _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).call(this, auth, apiBase, 'inertia-preview'));

	      _this.__id = id;
	      return _this;
	   }

	   /**
	    * Get information about a project
	    * @see https://developer.github.com/v3/projects/#get-a-project
	    * @param {Requestable.callback} cb - will receive the project information
	    * @return {Promise} - the promise for the http request
	    */


	   _createClass(Project, [{
	      key: 'getProject',
	      value: function getProject(cb) {
	         return this._request('GET', '/projects/' + this.__id, null, cb);
	      }

	      /**
	       * Edit a project
	       * @see https://developer.github.com/v3/projects/#update-a-project
	       * @param {Object} options - the description of the project
	       * @param {Requestable.callback} cb - will receive the modified project
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateProject',
	      value: function updateProject(options, cb) {
	         return this._request('PATCH', '/projects/' + this.__id, options, cb);
	      }

	      /**
	       * Delete a project
	       * @see https://developer.github.com/v3/projects/#delete-a-project
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteProject',
	      value: function deleteProject(cb) {
	         return this._request('DELETE', '/projects/' + this.__id, null, cb);
	      }

	      /**
	       * Get information about all columns of a project
	       * @see https://developer.github.com/v3/projects/columns/#list-project-columns
	       * @param {Requestable.callback} [cb] - will receive the list of columns
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjectColumns',
	      value: function listProjectColumns(cb) {
	         return this._requestAllPages('/projects/' + this.__id + '/columns', null, cb);
	      }

	      /**
	       * Get information about a column
	       * @see https://developer.github.com/v3/projects/columns/#get-a-project-column
	       * @param {string} colId - the id of the column
	       * @param {Requestable.callback} cb - will receive the column information
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'getProjectColumn',
	      value: function getProjectColumn(colId, cb) {
	         return this._request('GET', '/projects/columns/' + colId, null, cb);
	      }

	      /**
	       * Create a new column
	       * @see https://developer.github.com/v3/projects/columns/#create-a-project-column
	       * @param {Object} options - the description of the column
	       * @param {Requestable.callback} cb - will receive the newly created column
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'createProjectColumn',
	      value: function createProjectColumn(options, cb) {
	         return this._request('POST', '/projects/' + this.__id + '/columns', options, cb);
	      }

	      /**
	       * Edit a column
	       * @see https://developer.github.com/v3/projects/columns/#update-a-project-column
	       * @param {string} colId - the column id
	       * @param {Object} options - the description of the column
	       * @param {Requestable.callback} cb - will receive the modified column
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'updateProjectColumn',
	      value: function updateProjectColumn(colId, options, cb) {
	         return this._request('PATCH', '/projects/columns/' + colId, options, cb);
	      }

	      /**
	       * Delete a column
	       * @see https://developer.github.com/v3/projects/columns/#delete-a-project-column
	       * @param {string} colId - the column to be deleted
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'deleteProjectColumn',
	      value: function deleteProjectColumn(colId, cb) {
	         return this._request('DELETE', '/projects/columns/' + colId, null, cb);
	      }

	      /**
	       * Move a column
	       * @see https://developer.github.com/v3/projects/columns/#move-a-project-column
	       * @param {string} colId - the column to be moved
	       * @param {string} position - can be one of first, last, or after:<column-id>,
	       * where <column-id> is the id value of a column in the same project.
	       * @param {Requestable.callback} cb - will receive true if the operation is successful
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'moveProjectColumn',
	      value: function moveProjectColumn(colId, position, cb) {
	         return this._request('POST', '/projects/columns/' + colId + '/moves', { position: position }, cb);
	      }

	      /**
	       * Get information about all cards of a project
	       * @see https://developer.github.com/v3/projects/cards/#list-project-cards
	       * @param {Requestable.callback} [cb] - will receive the list of cards
	       * @return {Promise} - the promise for the http request
	       */

	   }, {
	      key: 'listProjectCards',
	      value: function listProjectCards(cb) {
	         var _this2 = this;

	         return this.listProjectColumns().then(function (_ref) {
	            var data = _ref.data;

	            return Promise.all(data.map(function (column) {
	               return _this2._requestAllPages('/projects/columns/' + column.id + '/cards', null);
	            }));
	         }).then(function (cardsInColumns) {
	            var cards = cardsInColumns.reduce(function (prev, _ref2) {
	               var data = _ref2.data;

	               prev.push.apply(prev, _toConsumableArray(data));
	               return prev;
	            }, []);
	            if (cb) {
	               cb(null, cards);
	            }
	            return cards;
	         }).catch(function (err) {
	            if (cb) {
	               cb(err);
	               return;
	            }
	            throw err;
	         });
	      }

	      /**
	      * Get information about all cards of a column
	      * @see https://developer.github.com/v3/projects/cards/#list-project-cards
	      * @param {string} colId - the id of the column
	      * @param {Requestable.callback} [cb] - will receive the list of cards
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'listColumnCards',
	      value: function listColumnCards(colId, cb) {
	         return this._requestAllPages('/projects/columns/' + colId + '/cards', null, cb);
	      }

	      /**
	      * Get information about a card
	      * @see https://developer.github.com/v3/projects/cards/#get-a-project-card
	      * @param {string} cardId - the id of the card
	      * @param {Requestable.callback} cb - will receive the card information
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'getProjectCard',
	      value: function getProjectCard(cardId, cb) {
	         return this._request('GET', '/projects/columns/cards/' + cardId, null, cb);
	      }

	      /**
	      * Create a new card
	      * @see https://developer.github.com/v3/projects/cards/#create-a-project-card
	      * @param {string} colId - the column id
	      * @param {Object} options - the description of the card
	      * @param {Requestable.callback} cb - will receive the newly created card
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'createProjectCard',
	      value: function createProjectCard(colId, options, cb) {
	         return this._request('POST', '/projects/columns/' + colId + '/cards', options, cb);
	      }

	      /**
	      * Edit a card
	      * @see https://developer.github.com/v3/projects/cards/#update-a-project-card
	      * @param {string} cardId - the card id
	      * @param {Object} options - the description of the card
	      * @param {Requestable.callback} cb - will receive the modified card
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'updateProjectCard',
	      value: function updateProjectCard(cardId, options, cb) {
	         return this._request('PATCH', '/projects/columns/cards/' + cardId, options, cb);
	      }

	      /**
	      * Delete a card
	      * @see https://developer.github.com/v3/projects/cards/#delete-a-project-card
	      * @param {string} cardId - the card to be deleted
	      * @param {Requestable.callback} cb - will receive true if the operation is successful
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'deleteProjectCard',
	      value: function deleteProjectCard(cardId, cb) {
	         return this._request('DELETE', '/projects/columns/cards/' + cardId, null, cb);
	      }

	      /**
	      * Move a card
	      * @see https://developer.github.com/v3/projects/cards/#move-a-project-card
	      * @param {string} cardId - the card to be moved
	      * @param {string} position - can be one of top, bottom, or after:<card-id>,
	      * where <card-id> is the id value of a card in the same project.
	      * @param {string} colId - the id value of a column in the same project.
	      * @param {Requestable.callback} cb - will receive true if the operation is successful
	      * @return {Promise} - the promise for the http request
	      */

	   }, {
	      key: 'moveProjectCard',
	      value: function moveProjectCard(cardId, position, colId, cb) {
	         return this._request('POST', '/projects/columns/cards/' + cardId + '/moves', { position: position, column_id: colId }, // eslint-disable-line camelcase
	         cb);
	      }
	   }]);

	   return Project;
	}(_Requestable3.default);

	module.exports = Project;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlByb2plY3QuanMiXSwibmFtZXMiOlsiUHJvamVjdCIsImlkIiwiYXV0aCIsImFwaUJhc2UiLCJfX2lkIiwiY2IiLCJfcmVxdWVzdCIsIm9wdGlvbnMiLCJfcmVxdWVzdEFsbFBhZ2VzIiwiY29sSWQiLCJwb3NpdGlvbiIsImxpc3RQcm9qZWN0Q29sdW1ucyIsInRoZW4iLCJkYXRhIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNvbHVtbiIsImNhcmRzSW5Db2x1bW5zIiwiY2FyZHMiLCJyZWR1Y2UiLCJwcmV2IiwicHVzaCIsImNhdGNoIiwiZXJyIiwiY2FyZElkIiwiY29sdW1uX2lkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BOzs7Ozs7Ozs7Ozs7K2VBUEE7Ozs7Ozs7QUFTQTs7O0lBR01BLE87OztBQUNIOzs7Ozs7QUFNQSxvQkFBWUMsRUFBWixFQUFnQkMsSUFBaEIsRUFBc0JDLE9BQXRCLEVBQStCO0FBQUE7O0FBQUEsb0hBQ3RCRCxJQURzQixFQUNoQkMsT0FEZ0IsRUFDUCxpQkFETzs7QUFFNUIsWUFBS0MsSUFBTCxHQUFZSCxFQUFaO0FBRjRCO0FBRzlCOztBQUVEOzs7Ozs7Ozs7O2lDQU1XSSxFLEVBQUk7QUFDWixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCxpQkFBa0MsS0FBS0YsSUFBdkMsRUFBK0MsSUFBL0MsRUFBcURDLEVBQXJELENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7OztvQ0FPY0UsTyxFQUFTRixFLEVBQUk7QUFDeEIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsaUJBQW9DLEtBQUtGLElBQXpDLEVBQWlERyxPQUFqRCxFQUEwREYsRUFBMUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7b0NBTWNBLEUsRUFBSTtBQUNmLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxRQUFkLGlCQUFxQyxLQUFLRixJQUExQyxFQUFrRCxJQUFsRCxFQUF3REMsRUFBeEQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7eUNBTW1CQSxFLEVBQUk7QUFDcEIsZ0JBQU8sS0FBS0csZ0JBQUwsZ0JBQW1DLEtBQUtKLElBQXhDLGVBQXdELElBQXhELEVBQThEQyxFQUE5RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7dUNBT2lCSSxLLEVBQU9KLEUsRUFBSTtBQUN6QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsS0FBZCx5QkFBMENHLEtBQTFDLEVBQW1ELElBQW5ELEVBQXlESixFQUF6RCxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7MENBT29CRSxPLEVBQVNGLEUsRUFBSTtBQUM5QixnQkFBTyxLQUFLQyxRQUFMLENBQWMsTUFBZCxpQkFBbUMsS0FBS0YsSUFBeEMsZUFBd0RHLE9BQXhELEVBQWlFRixFQUFqRSxDQUFQO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OzBDQVFvQkksSyxFQUFPRixPLEVBQVNGLEUsRUFBSTtBQUNyQyxnQkFBTyxLQUFLQyxRQUFMLENBQWMsT0FBZCx5QkFBNENHLEtBQTVDLEVBQXFERixPQUFyRCxFQUE4REYsRUFBOUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzBDQU9vQkksSyxFQUFPSixFLEVBQUk7QUFDNUIsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLFFBQWQseUJBQTZDRyxLQUE3QyxFQUFzRCxJQUF0RCxFQUE0REosRUFBNUQsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7d0NBU2tCSSxLLEVBQU9DLFEsRUFBVUwsRSxFQUFJO0FBQ3BDLGdCQUFPLEtBQUtDLFFBQUwsQ0FDSixNQURJLHlCQUVpQkcsS0FGakIsYUFHSixFQUFDQyxVQUFVQSxRQUFYLEVBSEksRUFJSkwsRUFKSSxDQUFQO0FBTUY7O0FBRUY7Ozs7Ozs7Ozt1Q0FNa0JBLEUsRUFBSTtBQUFBOztBQUNsQixnQkFBTyxLQUFLTSxrQkFBTCxHQUNKQyxJQURJLENBQ0MsZ0JBQVk7QUFBQSxnQkFBVkMsSUFBVSxRQUFWQSxJQUFVOztBQUNmLG1CQUFPQyxRQUFRQyxHQUFSLENBQVlGLEtBQUtHLEdBQUwsQ0FBUyxVQUFDQyxNQUFELEVBQVk7QUFDckMsc0JBQU8sT0FBS1QsZ0JBQUwsd0JBQTJDUyxPQUFPaEIsRUFBbEQsYUFBOEQsSUFBOUQsQ0FBUDtBQUNGLGFBRmtCLENBQVosQ0FBUDtBQUdGLFVBTEksRUFLRlcsSUFMRSxDQUtHLFVBQUNNLGNBQUQsRUFBb0I7QUFDekIsZ0JBQU1DLFFBQVFELGVBQWVFLE1BQWYsQ0FBc0IsVUFBQ0MsSUFBRCxTQUFrQjtBQUFBLG1CQUFWUixJQUFVLFNBQVZBLElBQVU7O0FBQ25EUSxvQkFBS0MsSUFBTCxnQ0FBYVQsSUFBYjtBQUNBLHNCQUFPUSxJQUFQO0FBQ0YsYUFIYSxFQUdYLEVBSFcsQ0FBZDtBQUlBLGdCQUFJaEIsRUFBSixFQUFRO0FBQ0xBLGtCQUFHLElBQUgsRUFBU2MsS0FBVDtBQUNGO0FBQ0QsbUJBQU9BLEtBQVA7QUFDRixVQWRJLEVBY0ZJLEtBZEUsQ0FjSSxVQUFDQyxHQUFELEVBQVM7QUFDZixnQkFBSW5CLEVBQUosRUFBUTtBQUNMQSxrQkFBR21CLEdBQUg7QUFDQTtBQUNGO0FBQ0Qsa0JBQU1BLEdBQU47QUFDRixVQXBCSSxDQUFQO0FBcUJGOztBQUVEOzs7Ozs7Ozs7O3NDQU9nQmYsSyxFQUFPSixFLEVBQUk7QUFDeEIsZ0JBQU8sS0FBS0csZ0JBQUwsd0JBQTJDQyxLQUEzQyxhQUEwRCxJQUExRCxFQUFnRUosRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3FDQU9lb0IsTSxFQUFRcEIsRSxFQUFJO0FBQ3hCLGdCQUFPLEtBQUtDLFFBQUwsQ0FBYyxLQUFkLCtCQUFnRG1CLE1BQWhELEVBQTBELElBQTFELEVBQWdFcEIsRUFBaEUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozt3Q0FRa0JJLEssRUFBT0YsTyxFQUFTRixFLEVBQUk7QUFDbkMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE1BQWQseUJBQTJDRyxLQUEzQyxhQUEwREYsT0FBMUQsRUFBbUVGLEVBQW5FLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7d0NBUWtCb0IsTSxFQUFRbEIsTyxFQUFTRixFLEVBQUk7QUFDcEMsZ0JBQU8sS0FBS0MsUUFBTCxDQUFjLE9BQWQsK0JBQWtEbUIsTUFBbEQsRUFBNERsQixPQUE1RCxFQUFxRUYsRUFBckUsQ0FBUDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3dDQU9rQm9CLE0sRUFBUXBCLEUsRUFBSTtBQUMzQixnQkFBTyxLQUFLQyxRQUFMLENBQWMsUUFBZCwrQkFBbURtQixNQUFuRCxFQUE2RCxJQUE3RCxFQUFtRXBCLEVBQW5FLENBQVA7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OztzQ0FVZ0JvQixNLEVBQVFmLFEsRUFBVUQsSyxFQUFPSixFLEVBQUk7QUFDMUMsZ0JBQU8sS0FBS0MsUUFBTCxDQUNKLE1BREksK0JBRXVCbUIsTUFGdkIsYUFHSixFQUFDZixVQUFVQSxRQUFYLEVBQXFCZ0IsV0FBV2pCLEtBQWhDLEVBSEksRUFHb0M7QUFDeENKLFdBSkksQ0FBUDtBQU1GOzs7Ozs7QUFHSnNCLE9BQU9DLE9BQVAsR0FBaUI1QixPQUFqQiIsImZpbGUiOiJQcm9qZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZVxuICogQGNvcHlyaWdodCAgMjAxMyBNaWNoYWVsIEF1ZnJlaXRlciAoRGV2ZWxvcG1lbnQgU2VlZCkgYW5kIDIwMTYgWWFob28gSW5jLlxuICogQGxpY2Vuc2UgICAgTGljZW5zZWQgdW5kZXIge0BsaW5rIGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlLUNsZWFyLmh0bWwgQlNELTMtQ2xhdXNlLUNsZWFyfS5cbiAqICAgICAgICAgICAgIEdpdGh1Yi5qcyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZS5cbiAqL1xuXG5pbXBvcnQgUmVxdWVzdGFibGUgZnJvbSAnLi9SZXF1ZXN0YWJsZSc7XG5cbi8qKlxuICogUHJvamVjdCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gY3JlYXRlLCBxdWVyeSwgYW5kIG1vZGlmeSBjYXJkcyBhbmQgY29sdW1ucy5cbiAqL1xuY2xhc3MgUHJvamVjdCBleHRlbmRzIFJlcXVlc3RhYmxlIHtcbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgUHJvamVjdC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5hdXRofSBbYXV0aF0gLSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBhdXRoZW50aWNhdGUgdG8gR2l0aHViXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwaUJhc2U9aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbV0gLSB0aGUgYmFzZSBHaXRodWIgQVBJIFVSTFxuICAgICovXG4gICBjb25zdHJ1Y3RvcihpZCwgYXV0aCwgYXBpQmFzZSkge1xuICAgICAgc3VwZXIoYXV0aCwgYXBpQmFzZSwgJ2luZXJ0aWEtcHJldmlldycpO1xuICAgICAgdGhpcy5fX2lkID0gaWQ7XG4gICB9XG5cbiAgIC8qKlxuICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvamVjdFxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzLyNnZXQtYS1wcm9qZWN0XG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgcHJvamVjdCBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRQcm9qZWN0KGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgYC9wcm9qZWN0cy8ke3RoaXMuX19pZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jdXBkYXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBwcm9qZWN0XG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZVByb2plY3Qob3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQQVRDSCcsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy8jZGVsZXRlLWEtcHJvamVjdFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlUHJvamVjdChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY29sdW1ucyBvZiBhIHByb2plY3RcbiAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jb2x1bW5zLyNsaXN0LXByb2plY3QtY29sdW1uc1xuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjb2x1bW5zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIGxpc3RQcm9qZWN0Q29sdW1ucyhjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzLyR7dGhpcy5fX2lkfS9jb2x1bW5zYCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI2dldC1hLXByb2plY3QtY29sdW1uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29sSWQgLSB0aGUgaWQgb2YgdGhlIGNvbHVtblxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNvbHVtbiBpbmZvcm1hdGlvblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBnZXRQcm9qZWN0Q29sdW1uKGNvbElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIGAvcHJvamVjdHMvY29sdW1ucy8ke2NvbElkfWAsIG51bGwsIGNiKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgY29sdW1uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY29sdW1ucy8jY3JlYXRlLWEtcHJvamVjdC1jb2x1bW5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjb2x1bW5cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBuZXdseSBjcmVhdGVkIGNvbHVtblxuICAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgICovXG4gICBjcmVhdGVQcm9qZWN0Q29sdW1uKG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsIGAvcHJvamVjdHMvJHt0aGlzLl9faWR9L2NvbHVtbnNgLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRWRpdCBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI3VwZGF0ZS1hLXByb2plY3QtY29sdW1uXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29sSWQgLSB0aGUgY29sdW1uIGlkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29sdW1uXG4gICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbW9kaWZpZWQgY29sdW1uXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIHVwZGF0ZVByb2plY3RDb2x1bW4oY29sSWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH1gLCBvcHRpb25zLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogRGVsZXRlIGEgY29sdW1uXG4gICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY29sdW1ucy8jZGVsZXRlLWEtcHJvamVjdC1jb2x1bW5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xJZCAtIHRoZSBjb2x1bW4gdG8gYmUgZGVsZXRlZFxuICAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWxcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICAqL1xuICAgZGVsZXRlUHJvamVjdENvbHVtbihjb2xJZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCBgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogTW92ZSBhIGNvbHVtblxuICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NvbHVtbnMvI21vdmUtYS1wcm9qZWN0LWNvbHVtblxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGNvbHVtbiB0byBiZSBtb3ZlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIC0gY2FuIGJlIG9uZSBvZiBmaXJzdCwgbGFzdCwgb3IgYWZ0ZXI6PGNvbHVtbi1pZD4sXG4gICAgKiB3aGVyZSA8Y29sdW1uLWlkPiBpcyB0aGUgaWQgdmFsdWUgb2YgYSBjb2x1bW4gaW4gdGhlIHNhbWUgcHJvamVjdC5cbiAgICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAgKi9cbiAgIG1vdmVQcm9qZWN0Q29sdW1uKGNvbElkLCBwb3NpdGlvbiwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KFxuICAgICAgICAgJ1BPU1QnLFxuICAgICAgICAgYC9wcm9qZWN0cy9jb2x1bW5zLyR7Y29sSWR9L21vdmVzYCxcbiAgICAgICAgIHtwb3NpdGlvbjogcG9zaXRpb259LFxuICAgICAgICAgY2JcbiAgICAgICk7XG4gICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2FyZHMgb2YgYSBwcm9qZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jYXJkcy8jbGlzdC1wcm9qZWN0LWNhcmRzXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IFtjYl0gLSB3aWxsIHJlY2VpdmUgdGhlIGxpc3Qgb2YgY2FyZHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGxpc3RQcm9qZWN0Q2FyZHMoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RQcm9qZWN0Q29sdW1ucygpXG4gICAgICAgIC50aGVuKCh7ZGF0YX0pID0+IHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGRhdGEubWFwKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2x1bW4uaWR9L2NhcmRzYCwgbnVsbCk7XG4gICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkudGhlbigoY2FyZHNJbkNvbHVtbnMpID0+IHtcbiAgICAgICAgICAgY29uc3QgY2FyZHMgPSBjYXJkc0luQ29sdW1ucy5yZWR1Y2UoKHByZXYsIHtkYXRhfSkgPT4ge1xuICAgICAgICAgICAgICBwcmV2LnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihudWxsLCBjYXJkcyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIGNhcmRzO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2FyZHMgb2YgYSBjb2x1bW5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyNsaXN0LXByb2plY3QtY2FyZHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGlkIG9mIHRoZSBjb2x1bW5cbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gW2NiXSAtIHdpbGwgcmVjZWl2ZSB0aGUgbGlzdCBvZiBjYXJkc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgbGlzdENvbHVtbkNhcmRzKGNvbElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RBbGxQYWdlcyhgL3Byb2plY3RzL2NvbHVtbnMvJHtjb2xJZH0vY2FyZHNgLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSBjYXJkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9wcm9qZWN0cy9jYXJkcy8jZ2V0LWEtcHJvamVjdC1jYXJkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXJkSWQgLSB0aGUgaWQgb2YgdGhlIGNhcmRcbiAgICogQHBhcmFtIHtSZXF1ZXN0YWJsZS5jYWxsYmFja30gY2IgLSB3aWxsIHJlY2VpdmUgdGhlIGNhcmQgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgcHJvbWlzZSBmb3IgdGhlIGh0dHAgcmVxdWVzdFxuICAgKi9cbiAgIGdldFByb2plY3RDYXJkKGNhcmRJZCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMvJHtjYXJkSWR9YCwgbnVsbCwgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNhcmRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyNjcmVhdGUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGNvbHVtbiBpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY2FyZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0aGUgbmV3bHkgY3JlYXRlZCBjYXJkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBjcmVhdGVQcm9qZWN0Q2FyZChjb2xJZCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdQT1NUJywgYC9wcm9qZWN0cy9jb2x1bW5zLyR7Y29sSWR9L2NhcmRzYCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogRWRpdCBhIGNhcmRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3Byb2plY3RzL2NhcmRzLyN1cGRhdGUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhcmRJZCAtIHRoZSBjYXJkIGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjYXJkXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBjYXJkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICB1cGRhdGVQcm9qZWN0Q2FyZChjYXJkSWQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLCBgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMvJHtjYXJkSWR9YCwgb3B0aW9ucywgY2IpO1xuICAgfVxuXG4gICAvKipcbiAgICogRGVsZXRlIGEgY2FyZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY2FyZHMvI2RlbGV0ZS1hLXByb2plY3QtY2FyZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FyZElkIC0gdGhlIGNhcmQgdG8gYmUgZGVsZXRlZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RhYmxlLmNhbGxiYWNrfSBjYiAtIHdpbGwgcmVjZWl2ZSB0cnVlIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBwcm9taXNlIGZvciB0aGUgaHR0cCByZXF1ZXN0XG4gICAqL1xuICAgZGVsZXRlUHJvamVjdENhcmQoY2FyZElkLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0RFTEVURScsIGAvcHJvamVjdHMvY29sdW1ucy9jYXJkcy8ke2NhcmRJZH1gLCBudWxsLCBjYik7XG4gICB9XG5cbiAgIC8qKlxuICAgKiBNb3ZlIGEgY2FyZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcHJvamVjdHMvY2FyZHMvI21vdmUtYS1wcm9qZWN0LWNhcmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhcmRJZCAtIHRoZSBjYXJkIHRvIGJlIG1vdmVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAtIGNhbiBiZSBvbmUgb2YgdG9wLCBib3R0b20sIG9yIGFmdGVyOjxjYXJkLWlkPixcbiAgICogd2hlcmUgPGNhcmQtaWQ+IGlzIHRoZSBpZCB2YWx1ZSBvZiBhIGNhcmQgaW4gdGhlIHNhbWUgcHJvamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbElkIC0gdGhlIGlkIHZhbHVlIG9mIGEgY29sdW1uIGluIHRoZSBzYW1lIHByb2plY3QuXG4gICAqIEBwYXJhbSB7UmVxdWVzdGFibGUuY2FsbGJhY2t9IGNiIC0gd2lsbCByZWNlaXZlIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIHByb21pc2UgZm9yIHRoZSBodHRwIHJlcXVlc3RcbiAgICovXG4gICBtb3ZlUHJvamVjdENhcmQoY2FyZElkLCBwb3NpdGlvbiwgY29sSWQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChcbiAgICAgICAgICdQT1NUJyxcbiAgICAgICAgIGAvcHJvamVjdHMvY29sdW1ucy9jYXJkcy8ke2NhcmRJZH0vbW92ZXNgLFxuICAgICAgICAge3Bvc2l0aW9uOiBwb3NpdGlvbiwgY29sdW1uX2lkOiBjb2xJZH0sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICBjYlxuICAgICAgKTtcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xuIl19
	//# sourceMappingURL=Project.js.map


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	var _animLettersInReveal = __webpack_require__(396);

	var _animLettersInReveal2 = _interopRequireDefault(_animLettersInReveal);

	var _animSlideIn = __webpack_require__(526);

	var _animSlideIn2 = _interopRequireDefault(_animSlideIn);

	var _mobile = __webpack_require__(527);

	var _mobile2 = _interopRequireDefault(_mobile);

	var _phone = __webpack_require__(530);

	var _phone2 = _interopRequireDefault(_phone);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	if (!(0, _mobile2.default)()) {
		// init listeners
		(0, _animLettersInReveal2.default)(0, 500);
		(0, _animSlideIn2.default)(0, 500);
	}

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = animLettersInReveal;

	var _splitLetters = __webpack_require__(397);

	var _splitLetters2 = _interopRequireDefault(_splitLetters);

	var _whenInViewport = __webpack_require__(519);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _querySelectorLive = __webpack_require__(336);

	var _querySelectorLive2 = _interopRequireDefault(_querySelectorLive);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Init the listener for the "letters-in-reveal" animation to work
	 *
	 * @param    {Integer}    [offset=-window.innerHeight*.2]    An offset that represent the distance before entering the viewport for the detection
	 * @param    {Integer}    [delay=300]    The delay after the detection to trigger the animation
	 *
	 * @example
	 * \@import 	animLettersInReveal from 'coffeekraken-s-animation-component/dist/animLettersInReveal'
	 * animLettersInReveal(); // init listeners
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function animLettersInReveal() {
	  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -window.innerHeight * .2;
	  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

	  (0, _querySelectorLive2.default)('[anim="letters-in-reveal"]', function (elm) {
	    (0, _splitLetters2.default)(elm);
	    (0, _whenInViewport2.default)(elm, offset).then(function (elm) {
	      setTimeout(function () {
	        elm.classList.add('active');
	      }, delay);
	    });
	  });
	}

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = splitLetters;

	var _map2 = __webpack_require__(398);

	var _map3 = _interopRequireDefault(_map2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _decodeHtml(html) {
	  var txt = document.createElement("textarea");
	  txt.innerHTML = html;
	  return txt.value;
	}

	/**
	 * Split each letters inside an HTMLElement by scoping them inside multiple tags.
	 * Here's an result sample for : Hello World
	 * ```html
	 * <span style="white-space:nowrap">
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">H</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">e</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">l</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">l</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">o</span>
	 * 	</span>
	 * </span>
	 * <span class="split-letters">
	 * 	<span class="split-letters__letter">&nbsp;</span>
	 * </span>
	 * <span style="white-space:nowrap">
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">W</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">o</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">r</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">l</span>
	 * 	</span>
	 * 	<span class="split-letters">
	 * 		<span class="split-letters__letter">d</span>
	 * 	</span>
	 * </span>
	 * ```
	 *
	 * @example 	js
	 * import __splitLetters from 'coffeekraken-sugar/js/dom/splitLetters'
	 * const myCoolElement = document.querySelector('.my-cool-element');
	 * __splitLetters(myCoolElement);
	 *
	 * @param 	{HTMLElement} 		elm 		 	The HTMLElement to split letters in
	 * @param 	{String} 			[tag="span"] 	The tag to use to split the letters
	 * @param 	{String} 			[tagClass="s-split-letters"] 		The class to apply on the tags
	 * @return 	{HTMLElement} 						The HTMLElement processed
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function splitLetters(elm) {
	  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
	  var tagClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'split-letters';


	  var string = elm._splitLettersOriginalString;
	  if (!string) {
	    string = elm.innerHTML;
	    elm._splitLettersOriginalString = string;
	  }

	  elm.classList.add(tagClass);

	  // wrap each characters inside two spans
	  var words = string.match(/<\s*(\w+\b)(?:(?!<\s*\/\s*\1\b)[\s\S])*<\s*\/\s*\1\s*>|\S+/g);

	  // split words
	  words = (0, _map3.default)(words, function (word) {
	    return '<' + tag + ' style="white-space:nowrap">' + word + '</' + tag + '>';
	  }).join(' ');

	  var letters = _decodeHtml(words).split('');

	  var hasTagOpened = false;
	  letters = (0, _map3.default)(letters, function (letter) {
	    // check if a tag has started
	    if (letter === '<') hasTagOpened = true;else if (letter === '>') {
	      hasTagOpened = false;
	      return letter;
	    }
	    if (hasTagOpened) return letter;
	    if (letter === ' ') letter = '&nbsp;';
	    return '<' + tag + ' class="' + tagClass + '__letter-container"><' + tag + ' class="' + tagClass + '__letter">' + letter + '</' + tag + '></' + tag + '>';
	  });

	  elm.innerHTML = letters.join('');

	  return elm;
	}

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(399),
	    baseIteratee = __webpack_require__(400),
	    baseMap = __webpack_require__(513),
	    isArray = __webpack_require__(463);

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	module.exports = map;


/***/ }),
/* 399 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(401),
	    baseMatchesProperty = __webpack_require__(494),
	    identity = __webpack_require__(509),
	    isArray = __webpack_require__(463),
	    property = __webpack_require__(510);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(402),
	    getMatchData = __webpack_require__(491),
	    matchesStrictComparable = __webpack_require__(493);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(403),
	    baseIsEqual = __webpack_require__(447);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(404),
	    stackClear = __webpack_require__(412),
	    stackDelete = __webpack_require__(413),
	    stackGet = __webpack_require__(414),
	    stackHas = __webpack_require__(415),
	    stackSet = __webpack_require__(416);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(405),
	    listCacheDelete = __webpack_require__(406),
	    listCacheGet = __webpack_require__(409),
	    listCacheHas = __webpack_require__(410),
	    listCacheSet = __webpack_require__(411);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ }),
/* 405 */
/***/ (function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(407);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(408);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ }),
/* 408 */
/***/ (function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(407);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(407);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(407);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(404);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ }),
/* 413 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ }),
/* 414 */
/***/ (function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ }),
/* 415 */
/***/ (function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(404),
	    Map = __webpack_require__(417),
	    MapCache = __webpack_require__(432);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418),
	    root = __webpack_require__(423);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(419),
	    getValue = __webpack_require__(431);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(420),
	    isMasked = __webpack_require__(428),
	    isObject = __webpack_require__(427),
	    toSource = __webpack_require__(430);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(421),
	    isObject = __webpack_require__(427);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(422),
	    getRawTag = __webpack_require__(425),
	    objectToString = __webpack_require__(426);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(423);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(424);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ }),
/* 424 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(422);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ }),
/* 426 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ }),
/* 427 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(429);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(423);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ }),
/* 430 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ }),
/* 431 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(433),
	    mapCacheDelete = __webpack_require__(441),
	    mapCacheGet = __webpack_require__(444),
	    mapCacheHas = __webpack_require__(445),
	    mapCacheSet = __webpack_require__(446);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(434),
	    ListCache = __webpack_require__(404),
	    Map = __webpack_require__(417);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(435),
	    hashDelete = __webpack_require__(437),
	    hashGet = __webpack_require__(438),
	    hashHas = __webpack_require__(439),
	    hashSet = __webpack_require__(440);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(436);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ }),
/* 437 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(436);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(436);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(436);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(442);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(443);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ }),
/* 443 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(442);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(442);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(442);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(448),
	    isObjectLike = __webpack_require__(472);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(403),
	    equalArrays = __webpack_require__(449),
	    equalByTag = __webpack_require__(455),
	    equalObjects = __webpack_require__(459),
	    getTag = __webpack_require__(486),
	    isArray = __webpack_require__(463),
	    isBuffer = __webpack_require__(473),
	    isTypedArray = __webpack_require__(476);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(450),
	    arraySome = __webpack_require__(453),
	    cacheHas = __webpack_require__(454);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(432),
	    setCacheAdd = __webpack_require__(451),
	    setCacheHas = __webpack_require__(452);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ }),
/* 451 */
/***/ (function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ }),
/* 452 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ }),
/* 453 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ }),
/* 454 */
/***/ (function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(422),
	    Uint8Array = __webpack_require__(456),
	    eq = __webpack_require__(408),
	    equalArrays = __webpack_require__(449),
	    mapToArray = __webpack_require__(457),
	    setToArray = __webpack_require__(458);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(423);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ }),
/* 457 */
/***/ (function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ }),
/* 458 */
/***/ (function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(460);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(461),
	    getSymbols = __webpack_require__(464),
	    keys = __webpack_require__(467);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(462),
	    isArray = __webpack_require__(463);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ }),
/* 462 */
/***/ (function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ }),
/* 463 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(465),
	    stubArray = __webpack_require__(466);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ }),
/* 465 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ }),
/* 466 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(468),
	    baseKeys = __webpack_require__(481),
	    isArrayLike = __webpack_require__(485);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(469),
	    isArguments = __webpack_require__(470),
	    isArray = __webpack_require__(463),
	    isBuffer = __webpack_require__(473),
	    isIndex = __webpack_require__(475),
	    isTypedArray = __webpack_require__(476);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ }),
/* 469 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(471),
	    isObjectLike = __webpack_require__(472);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(421),
	    isObjectLike = __webpack_require__(472);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ }),
/* 472 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(423),
	    stubFalse = __webpack_require__(474);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(390)(module)))

/***/ }),
/* 474 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 475 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(477),
	    baseUnary = __webpack_require__(479),
	    nodeUtil = __webpack_require__(480);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(421),
	    isLength = __webpack_require__(478),
	    isObjectLike = __webpack_require__(472);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ }),
/* 478 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ }),
/* 479 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(424);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(390)(module)))

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(482),
	    nativeKeys = __webpack_require__(483);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ }),
/* 482 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(484);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 484 */
/***/ (function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(420),
	    isLength = __webpack_require__(478);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(487),
	    Map = __webpack_require__(417),
	    Promise = __webpack_require__(488),
	    Set = __webpack_require__(489),
	    WeakMap = __webpack_require__(490),
	    baseGetTag = __webpack_require__(421),
	    toSource = __webpack_require__(430);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418),
	    root = __webpack_require__(423);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418),
	    root = __webpack_require__(423);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418),
	    root = __webpack_require__(423);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418),
	    root = __webpack_require__(423);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(492),
	    keys = __webpack_require__(467);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(427);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ }),
/* 493 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(447),
	    get = __webpack_require__(495),
	    hasIn = __webpack_require__(506),
	    isKey = __webpack_require__(498),
	    isStrictComparable = __webpack_require__(492),
	    matchesStrictComparable = __webpack_require__(493),
	    toKey = __webpack_require__(505);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(496);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(497),
	    toKey = __webpack_require__(505);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(463),
	    isKey = __webpack_require__(498),
	    stringToPath = __webpack_require__(500),
	    toString = __webpack_require__(503);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(463),
	    isSymbol = __webpack_require__(499);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(421),
	    isObjectLike = __webpack_require__(472);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(501);

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(502);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(432);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(504);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(422),
	    arrayMap = __webpack_require__(399),
	    isArray = __webpack_require__(463),
	    isSymbol = __webpack_require__(499);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(499);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(507),
	    hasPath = __webpack_require__(508);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ }),
/* 507 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(497),
	    isArguments = __webpack_require__(470),
	    isArray = __webpack_require__(463),
	    isIndex = __webpack_require__(475),
	    isLength = __webpack_require__(478),
	    toKey = __webpack_require__(505);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ }),
/* 509 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(511),
	    basePropertyDeep = __webpack_require__(512),
	    isKey = __webpack_require__(498),
	    toKey = __webpack_require__(505);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ }),
/* 511 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(496);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(514),
	    isArrayLike = __webpack_require__(485);

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	module.exports = baseMap;


/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(515),
	    createBaseEach = __webpack_require__(518);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(516),
	    keys = __webpack_require__(467);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(517);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ }),
/* 517 */
/***/ (function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(485);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenInViewport;

	var _whenVisible = __webpack_require__(520);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _isInViewport2 = __webpack_require__(523);

	var _isInViewport3 = _interopRequireDefault(_isInViewport2);

	var _throttle = __webpack_require__(524);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _closest = __webpack_require__(525);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is in the viewport
	 *
	 * @name 		whenInViewport
	 * @param 		{HTMLElement} 				elm 					The element to monitor
	 * @param 		{Number} 					[offset=50] 			An offset that represent the distance before entering the viewport for the detection
	 * @return 		(Promise) 											The promise that will be resolved when the element is in the viewport
	 *
	 * @example 	js
	 * import whenInViewport from 'sugarcss/js/dom/whenInViewport'
	 * whenInViewport(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that has entered the viewport...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function whenInViewport(elm) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

		return new Promise(function (resolve, reject) {

			if (window.IntersectionObserver) {

				var isInViewport = false,
				    isVisible = false,
				    _cb = function _cb() {
					if (isVisible && isInViewport) {
						observer.disconnect();
						resolve(elm);
					}
				};

				var observer = new IntersectionObserver(function (entries, observer) {
					if (!entries.length) return;
					var entry = entries[0];
					if (entry.intersectionRatio > 0) {
						isInViewport = true;
					} else {
						isInViewport = false;
					}
					_cb();
				}, {
					root: null, // viewport
					rootMargin: offset + 'px',
					threshold: [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]
				});

				observer.observe(elm);

				// detect when visible
				(0, _whenVisible2.default)(elm).then(function (elm) {
					isVisible = true;
					_cb();
				});
			} else {

				// try to get the closest element that has an overflow
				var scrollContainerElm = document;
				if (!elm._inViewportContainer) {
					var overflowContainer = (0, _closest2.default)(elm, '[data-in-viewport-container]');
					if (overflowContainer) {
						scrollContainerElm = overflowContainer;
						elm._inViewportContainer = overflowContainer;
					}
				} else {
					scrollContainerElm = elm._inViewportContainer;
				}

				var _isInViewport = false,
				    _isVisible = false,
				    _cb2 = function _cb2() {
					if (_isVisible && _isInViewport) {
						scrollContainerElm.removeEventListener('scroll', checkViewport);
						window.removeEventListener('resize', checkViewport);
						resolve(elm);
					}
				};
				var checkViewport = (0, _throttle2.default)(function (e) {
					_isInViewport = (0, _isInViewport3.default)(elm, offset);
					_cb2();
				}, 100);

				// detect when visible
				(0, _whenVisible2.default)(elm).then(function (elm) {
					_isVisible = true;
					_cb2();
				});

				// listen for resize
				scrollContainerElm.addEventListener('scroll', checkViewport);
				window.addEventListener('resize', checkViewport);
				setTimeout(function () {
					checkViewport(null);
				});
			}
		});
	}

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenVisible;

	var _isVisible = __webpack_require__(521);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	var _closestNotVisible = __webpack_require__(522);

	var _closestNotVisible2 = _interopRequireDefault(_closestNotVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Monitor an HTMLElement to be notified when it is visible
	 *
	 * @name 		whenVisible
	 * @param 		{HTMLElement} 				elm 		The element to monitor
	 * @param 		{Function} 					[cb=null] 	An optional callback to call when the element is visible
	 * @return 		(Promise) 								The promise that will be resolved when the element is visible
	 *
	 * @example 	js
	 * import whenVisible from 'sugarcss/js/dom/whenVisible'
	 * whenVisible(myCoolHTMLElement).then((elm) => {
	 * 		// do something with your element that is now visible
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function whenVisible(elm) {
		var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		return new Promise(function (resolve, reject) {

			// variables
			var isSelfVisible = false,
			    areParentsVisible = false,
			    closestNotVisible = null,
			    selfObserver = null,
			    parentObserver = null;

			var _cb = function _cb() {
				if (isSelfVisible && areParentsVisible) {
					// process callbacks
					if (cb) cb(elm);
					resolve(elm);
					// remove the event listeners
					elm.removeEventListener('transitionend', _eventCb);
					elm.removeEventListener('animationstart', _eventCb);
					elm.removeEventListener('animationend', _eventCb);
					// remove the event listeners
					if (closestNotVisible) {
						closestNotVisible.removeEventListener('transitionend', _eventCb);
						closestNotVisible.removeEventListener('animationstart', _eventCb);
						closestNotVisible.removeEventListener('animationend', _eventCb);
					}
				}
			};

			// function called on each transitionend, start, etc...
			var _eventCb = function _eventCb(e) {
				// wait just a little time to check again
				setTimeout(function () {
					if (e.target === elm) {
						if ((0, _isVisible2.default)(elm)) {
							isSelfVisible = true;
							if (selfObserver && selfObserver.disconnect) {
								selfObserver.disconnect();
							}
							// remove the event listeners
							elm.removeEventListener('transitionend', _eventCb);
							elm.removeEventListener('animationstart', _eventCb);
							elm.removeEventListener('animationend', _eventCb);
						}
					} else if (e.target === closestNotVisible) {
						if ((0, _isVisible2.default)(closestNotVisible)) {
							areParentsVisible = true;
							if (parentObserver && parentObserver.disconnect) {
								parentObserver.disconnect();
							}
							// remove the event listeners
							closestNotVisible.removeEventListener('transitionend', _eventCb);
							closestNotVisible.removeEventListener('animationstart', _eventCb);
							closestNotVisible.removeEventListener('animationend', _eventCb);
						}
					}
					// callback
					_cb();
				});
			};

			// check if element itself is not visible
			if (!(0, _isVisible2.default)(elm)) {
				selfObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								isSelfVisible = true;
								// callback
								_cb();
								// stop observe
								selfObserver.disconnect();
							}
						}
					});
				});
				selfObserver.observe(elm, { attributes: true });

				// listen for animationstart to check if the element is visible
				elm.addEventListener('animationstart', _eventCb);
				elm.addEventListener('animationend', _eventCb);
				elm.addEventListener('transitionend', _eventCb);
			} else {
				isSelfVisible = true;
			}

			// get the closest not visible element
			// if found, we monitor it to check when it is visible
			closestNotVisible = (0, _closestNotVisible2.default)(elm);
			if (closestNotVisible) {
				parentObserver = new MutationObserver(function (mutations) {
					mutations.forEach(function (mutation) {
						// check that is the style whos changed
						if (mutation.attributeName === 'style' || mutation.attributeName === 'class') {
							// check if is visible
							if ((0, _isVisible2.default)(mutation.target)) {
								// update
								areParentsVisible = true;
								// callback
								_cb();
								// stop observe
								parentObserver.disconnect();
							}
						}
					});
				});
				parentObserver.observe(closestNotVisible, { attributes: true });

				// listen for animationstart to check if the element is visible
				closestNotVisible.addEventListener('animationstart', _eventCb);
				closestNotVisible.addEventListener('animationend', _eventCb);
				closestNotVisible.addEventListener('transitionend', _eventCb);
			} else {
				areParentsVisible = true;
			}

			// callback
			_cb();
		});
	}

/***/ }),
/* 521 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVisible;
	/**
	 * Check if the passed HTMLElement is visible or not.
	 * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none
	 *
	 * @name 		isVisible
	 * @param 		{HTMLElement} 				elm  		The element to check
	 * @return 		{Boolean								If the element is visible or not
	 *
	 * @example  	js
	 * import isVisible from 'sugarcss/js/dom/isVisible'
	 * if (isVisible(myCoolHTMLElement) {
	 * 		// i'm visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isVisible(elm) {

	  // assume that the script tag is always visible
	  if (elm.nodeName.toLowerCase() === 'script') return true;

	  // if no offset parent
	  // mean that the element is not visible
	  // if (elm.offsetParent === null) return false;

	  // get style
	  var style = window.getComputedStyle(elm, null),
	      opacity = style['opacity'],
	      visibility = style['visibility'],
	      display = style['display'];
	  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;
	}
	window.__isVisible = isVisible;

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closestNotVisible;

	var _isVisible = __webpack_require__(521);

	var _isVisible2 = _interopRequireDefault(_isVisible);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that is not visible.
	 * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none
	 *
	 * @name 		closestNotVisible
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'
	 * const closestElm = closest(myCoolElement);
	 * if (closestElm) {
	 * 		// we have found en element is not visible
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function closestNotVisible(elm) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (!(0, _isVisible2.default)(elm)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return false;
	}
	window.__closestNotVisible = closestNotVisible;

/***/ }),
/* 523 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = isInViewport;
	/**
	 * Check if the passed HTMLElement is in the viewport or not
	 *
	 * @name 		isInViewport
	 * @param 		{HTMLElement} 				elm  			The element to insert
	 * @param 		{Object} 					[offset=50] 	An object of top, right, bottom and left offset used to detect the status or an object with top, right, bottom and left offsets
	 * @return 		{Boolean									If the element is in the viewport or not
	 *
	 * @example  	js
	 * import isInViewport from 'sugarcss/js/dom/isInViewport'
	 * if (isInViewport(myCoolHTMLElement) {
	 * 		// i'm in the viewport
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isInViewport(elm) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;

		// handle offset
		var offsetTop = offset;
		var offsetRight = offset;
		var offsetBottom = offset;
		var offsetLeft = offset;
		if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
			offsetTop = offset.top || 0;
			offsetRight = offset.right || 0;
			offsetBottom = offset.bottom || 0;
			offsetLeft = offset.left || 0;
		}
		var containerHeight = window.innerHeight || document.documentElement.clientHeight;
		var containerWidth = window.innerWidth || document.documentElement.clientWidth;
		var rect = elm.getBoundingClientRect();
		var isTopIn = rect.top - containerHeight - offsetBottom <= 0;
		var isBottomIn = rect.bottom - offsetTop >= 0;
		var isLeftIn = rect.left - containerWidth - offsetRight <= 0;
		var isRightIn = rect.right - offsetLeft >= 0;
		return isTopIn && isBottomIn && isLeftIn && isRightIn;
	}

/***/ }),
/* 524 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = throttle;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called once each threshhold time
	 *
	 * @name 			throttle
	 * @example 		js
	 * const myThrottledFn = throttle(() => {
	 * 		// my function content that will be
	 * 		// executed only once each second
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my throttled function
	 * 		myThrottledFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function throttle(fn, threshhold) {
	    threshhold || (threshhold = 250);
	    var last, deferTimer;
	    return function () {
	        var context = this;

	        var now = +new Date(),
	            args = arguments;
	        if (last && now < last + threshhold) {
	            // hold on to it
	            clearTimeout(deferTimer);
	            deferTimer = setTimeout(function () {
	                last = now;
	                fn.apply(context, args);
	            }, threshhold);
	        } else {
	            last = now;
	            fn.apply(context, args);
	        }
	    };
	}

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = closest;

	var _matches = __webpack_require__(338);

	var _matches2 = _interopRequireDefault(_matches);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Go up the dom three to find the first element that matches the passed selector
	 *
	 * @name 		closest
	 * @param 		{HTMLElement} 					elm  		The element to start on
	 * @param 		{String|Function} 				selector 	A css selector to search for or a check function that will be used
	 * @return 		{HTMLElement} 								The element found or null
	 *
	 * @example  	js
	 * import closest from 'sugarcss/js/dom/closest'
	 * const closestElm = closest(myCoolElement, '.my-cool-class');
	 * if (closestElm) {
	 * 		// we have found en element that matches the selector
	 * }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function closest(elm, selector) {
	  elm = elm.parentNode;
	  while (elm && elm != document) {
	    if (typeof selector === 'function') {
	      if (selector(elm)) return elm;
	    } else if (typeof selector === 'string' && (0, _matches2.default)(elm, selector)) {
	      return elm;
	    }
	    elm = elm.parentNode;
	  }
	  return null;
	}
	window.__closest = closest;

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = animSlideIn;

	var _whenInViewport = __webpack_require__(519);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _querySelectorLive = __webpack_require__(336);

	var _querySelectorLive2 = _interopRequireDefault(_querySelectorLive);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Init the listener for the "slide-in-" animation to work
	 * Supported slides animation directions
	 * - up
	 * - right
	 * - left
	 * - down
	 *
	 * @param    {Integer}    [offset=-window.innerHeight*.2]    An offset that represent the distance before entering the viewport for the detection
	 * @param    {Integer}    [delay=300]    The delay after the detection to trigger the animation
	 *
	 * @example
	 * \@import 	animSlideIn from 'coffeekraken-s-animation-component/dist/animSlideIn'
	 * animSlideIn(); // init listeners
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */
	function animSlideIn() {
	  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -window.innerHeight * .2;
	  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

	  (0, _querySelectorLive2.default)('[anim^="slide-in-"]', function (elm) {
	    (0, _whenInViewport2.default)(elm, offset).then(function (elm) {
	      setTimeout(function () {
	        elm.classList.add('active');
	      }, delay);
	    });
	  });
	}

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isMobile;

	var _mobileDetect = __webpack_require__(528);

	var _mobileDetect2 = _interopRequireDefault(_mobileDetect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Detect if is a mobile device (phone or tablet)
	 * @return    {Boolean}    true if is a mobile, false if not
	 * @example 	js
	 * import isMobile from 'coffeekraken-sugar/js/utils/is/mobile'
	 * if (isMobile()) {
	 *   // do something cool...
	 * }
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isMobile() {
	  var md = new _mobileDetect2.default(window.navigator.userAgent);
	  return md.mobile() !== null;
	}

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

	// THIS FILE IS GENERATED - DO NOT EDIT!
	/*!mobile-detect v1.4.3 2018-09-08*/
	/*global module:false, define:false*/
	/*jshint latedef:false*/
	/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
	(function (define, undefined) {
	define(function () {
	    'use strict';

	    var impl = {};

	    impl.mobileDetectRules = {
	    "phones": {
	        "iPhone": "\\biPhone\\b|\\biPod\\b",
	        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+",
	        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
	        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
	        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
	        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
	        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
	        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)",
	        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
	        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
	        "NokiaLumia": "Lumia [0-9]{3,4}",
	        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
	        "Palm": "PalmSource|Palm",
	        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
	        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
	        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
	        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
	        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
	        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
	        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
	        "Alcatel": "Alcatel",
	        "Nintendo": "Nintendo (3DS|Switch)",
	        "Amoi": "Amoi",
	        "INQ": "INQ",
	        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
	    },
	    "tablets": {
	        "iPad": "iPad|iPad.*Mobile",
	        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
	        "GoogleTablet": "Android.*Pixel C",
	        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835",
	        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
	        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
	        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
	        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
	        "BlackBerryTablet": "PlayBook|RIM Tablet",
	        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
	        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
	        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
	        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
	        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
	        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
	        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
	        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
	        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304F|TB-X304L|TB-8703F|Tab2A7-10F|TB2-X30L",
	        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
	        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
	        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
	        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
	        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
	        "IRUTablet": "M702pro",
	        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
	        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
	        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
	        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
	        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
	        "NokiaLumiaTablet": "Lumia 2520",
	        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
	        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
	        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
	        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
	        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
	        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
	        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
	        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
	        "FlyTablet": "IQ310|Fly Vision",
	        "bqTablet": "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))|Maxwell.*Lite|Maxwell.*Plus",
	        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09",
	        "NecTablet": "\\bN-06D|\\bN-08D",
	        "PantechTablet": "Pantech.*P4100",
	        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
	        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
	        "ZyncTablet": "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
	        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
	        "NabiTablet": "Android.*\\bNabi",
	        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
	        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
	        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
	        "PlaystationTablet": "Playstation.*(Portable|Vita)",
	        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
	        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
	        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
	        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
	        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
	        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
	        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
	        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
	        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
	        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
	        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
	        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
	        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
	        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
	        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
	        "DPSTablet": "DPS Dream 9|DPS Dual 7",
	        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
	        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
	        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
	        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
	        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
	        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
	        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
	        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
	        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
	        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497",
	        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
	        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
	        "iMobileTablet": "i-mobile i-note",
	        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
	        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
	        "AMPETablet": "Android.* A78 ",
	        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
	        "TecnoTablet": "TECNO P9|TECNO DP8D",
	        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
	        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
	        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
	        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
	        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
	        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
	        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
	        "CaptivaTablet": "CAPTIVA PAD",
	        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
	        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
	        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
	        "JaytechTablet": "TPC-PA762",
	        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
	        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
	        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
	        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
	        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
	        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
	        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
	        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
	        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
	        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
	        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
	        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
	        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
	        "UbislateTablet": "UbiSlate[\\s]?7C",
	        "PocketBookTablet": "Pocketbook",
	        "KocasoTablet": "\\b(TB-1207)\\b",
	        "HisenseTablet": "\\b(F5281|E2371)\\b",
	        "Hudl": "Hudl HT7S3|Hudl 2",
	        "TelstraTablet": "T-Hub2",
	        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
	    },
	    "oss": {
	        "AndroidOS": "Android",
	        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
	        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
	        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
	        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
	        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
	        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
	        "MeeGoOS": "MeeGo",
	        "MaemoOS": "Maemo",
	        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
	        "webOS": "webOS|hpwOS",
	        "badaOS": "\\bBada\\b",
	        "BREWOS": "BREW"
	    },
	    "uas": {
	        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
	        "Dolfin": "\\bDolfin\\b",
	        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
	        "Skyfire": "Skyfire",
	        "Edge": "Mobile Safari\/[.0-9]* Edge",
	        "IE": "IEMobile|MSIEMobile",
	        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
	        "Bolt": "bolt",
	        "TeaShark": "teashark",
	        "Blazer": "Blazer",
	        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
	        "WeChat": "\\bMicroMessenger\\b",
	        "UCBrowser": "UC.*Browser|UCWEB",
	        "baiduboxapp": "baiduboxapp",
	        "baidubrowser": "baidubrowser",
	        "DiigoBrowser": "DiigoBrowser",
	        "Puffin": "Puffin",
	        "Mercury": "\\bMercury\\b",
	        "ObigoBrowser": "Obigo",
	        "NetFront": "NF-Browser",
	        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
	        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
	    },
	    "props": {
	        "Mobile": "Mobile\/[VER]",
	        "Build": "Build\/[VER]",
	        "Version": "Version\/[VER]",
	        "VendorID": "VendorID\/[VER]",
	        "iPad": "iPad.*CPU[a-z ]+[VER]",
	        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
	        "iPod": "iPod.*CPU[a-z ]+[VER]",
	        "Kindle": "Kindle\/[VER]",
	        "Chrome": [
	            "Chrome\/[VER]",
	            "CriOS\/[VER]",
	            "CrMo\/[VER]"
	        ],
	        "Coast": [
	            "Coast\/[VER]"
	        ],
	        "Dolfin": "Dolfin\/[VER]",
	        "Firefox": [
	            "Firefox\/[VER]",
	            "FxiOS\/[VER]"
	        ],
	        "Fennec": "Fennec\/[VER]",
	        "Edge": "Edge\/[VER]",
	        "IE": [
	            "IEMobile\/[VER];",
	            "IEMobile [VER]",
	            "MSIE [VER];",
	            "Trident\/[0-9.]+;.*rv:[VER]"
	        ],
	        "NetFront": "NetFront\/[VER]",
	        "NokiaBrowser": "NokiaBrowser\/[VER]",
	        "Opera": [
	            " OPR\/[VER]",
	            "Opera Mini\/[VER]",
	            "Version\/[VER]"
	        ],
	        "Opera Mini": "Opera Mini\/[VER]",
	        "Opera Mobi": "Version\/[VER]",
	        "UCBrowser": [
	            "UCWEB[VER]",
	            "UC.*Browser\/[VER]"
	        ],
	        "MQQBrowser": "MQQBrowser\/[VER]",
	        "MicroMessenger": "MicroMessenger\/[VER]",
	        "baiduboxapp": "baiduboxapp\/[VER]",
	        "baidubrowser": "baidubrowser\/[VER]",
	        "SamsungBrowser": "SamsungBrowser\/[VER]",
	        "Iron": "Iron\/[VER]",
	        "Safari": [
	            "Version\/[VER]",
	            "Safari\/[VER]"
	        ],
	        "Skyfire": "Skyfire\/[VER]",
	        "Tizen": "Tizen\/[VER]",
	        "Webkit": "webkit[ \/][VER]",
	        "PaleMoon": "PaleMoon\/[VER]",
	        "Gecko": "Gecko\/[VER]",
	        "Trident": "Trident\/[VER]",
	        "Presto": "Presto\/[VER]",
	        "Goanna": "Goanna\/[VER]",
	        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
	        "Android": "Android [VER]",
	        "BlackBerry": [
	            "BlackBerry[\\w]+\/[VER]",
	            "BlackBerry.*Version\/[VER]",
	            "Version\/[VER]"
	        ],
	        "BREW": "BREW [VER]",
	        "Java": "Java\/[VER]",
	        "Windows Phone OS": [
	            "Windows Phone OS [VER]",
	            "Windows Phone [VER]"
	        ],
	        "Windows Phone": "Windows Phone [VER]",
	        "Windows CE": "Windows CE\/[VER]",
	        "Windows NT": "Windows NT [VER]",
	        "Symbian": [
	            "SymbianOS\/[VER]",
	            "Symbian\/[VER]"
	        ],
	        "webOS": [
	            "webOS\/[VER]",
	            "hpwOS\/[VER];"
	        ]
	    },
	    "utils": {
	        "Bot": "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
	        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
	        "DesktopMode": "WPDesktop",
	        "TV": "SonyDTV|HbbTV",
	        "WebKit": "(webkit)[ \/]([\\w.]+)",
	        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
	        "Watch": "SM-V700"
	    }
	};

	    // following patterns come from http://detectmobilebrowsers.com/
	    impl.detectMobileBrowsers = {
	        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
	        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
	        tabletPattern: /android|ipad|playbook|silk/i
	    };

	    var hasOwnProp = Object.prototype.hasOwnProperty,
	        isArray;

	    impl.FALLBACK_PHONE = 'UnknownPhone';
	    impl.FALLBACK_TABLET = 'UnknownTablet';
	    impl.FALLBACK_MOBILE = 'UnknownMobile';

	    isArray = ('isArray' in Array) ?
	        Array.isArray : function (value) { return Object.prototype.toString.call(value) === '[object Array]'; };

	    function equalIC(a, b) {
	        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
	    }

	    function containsIC(array, value) {
	        var valueLC, i, len = array.length;
	        if (!len || !value) {
	            return false;
	        }
	        valueLC = value.toLowerCase();
	        for (i = 0; i < len; ++i) {
	            if (valueLC === array[i].toLowerCase()) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function convertPropsToRegExp(object) {
	        for (var key in object) {
	            if (hasOwnProp.call(object, key)) {
	                object[key] = new RegExp(object[key], 'i');
	            }
	        }
	    }

	    function prepareUserAgent(userAgent) {
	        return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
	    }

	    (function init() {
	        var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
	        for (key in mobileDetectRules.props) {
	            if (hasOwnProp.call(mobileDetectRules.props, key)) {
	                values = mobileDetectRules.props[key];
	                if (!isArray(values)) {
	                    values = [values];
	                }
	                len = values.length;
	                for (i = 0; i < len; ++i) {
	                    value = values[i];
	                    verPos = value.indexOf('[VER]');
	                    if (verPos >= 0) {
	                        value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
	                    }
	                    values[i] = new RegExp(value, 'i');
	                }
	                mobileDetectRules.props[key] = values;
	            }
	        }
	        convertPropsToRegExp(mobileDetectRules.oss);
	        convertPropsToRegExp(mobileDetectRules.phones);
	        convertPropsToRegExp(mobileDetectRules.tablets);
	        convertPropsToRegExp(mobileDetectRules.uas);
	        convertPropsToRegExp(mobileDetectRules.utils);

	        // copy some patterns to oss0 which are tested first (see issue#15)
	        mobileDetectRules.oss0 = {
	            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
	            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
	        };
	    }());

	    /**
	     * Test userAgent string against a set of rules and find the first matched key.
	     * @param {Object} rules (key is String, value is RegExp)
	     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
	     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
	     * @private
	     */
	    impl.findMatch = function(rules, userAgent) {
	        for (var key in rules) {
	            if (hasOwnProp.call(rules, key)) {
	                if (rules[key].test(userAgent)) {
	                    return key;
	                }
	            }
	        }
	        return null;
	    };

	    /**
	     * Test userAgent string against a set of rules and return an array of matched keys.
	     * @param {Object} rules (key is String, value is RegExp)
	     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
	     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
	     * @private
	     */
	    impl.findMatches = function(rules, userAgent) {
	        var result = [];
	        for (var key in rules) {
	            if (hasOwnProp.call(rules, key)) {
	                if (rules[key].test(userAgent)) {
	                    result.push(key);
	                }
	            }
	        }
	        return result;
	    };

	    /**
	     * Check the version of the given property in the User-Agent.
	     *
	     * @param {String} propertyName
	     * @param {String} userAgent
	     * @return {String} version or <tt>null</tt> if version not found
	     * @private
	     */
	    impl.getVersionStr = function (propertyName, userAgent) {
	        var props = impl.mobileDetectRules.props, patterns, i, len, match;
	        if (hasOwnProp.call(props, propertyName)) {
	            patterns = props[propertyName];
	            len = patterns.length;
	            for (i = 0; i < len; ++i) {
	                match = patterns[i].exec(userAgent);
	                if (match !== null) {
	                    return match[1];
	                }
	            }
	        }
	        return null;
	    };

	    /**
	     * Check the version of the given property in the User-Agent.
	     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
	     *
	     * @param {String} propertyName
	     * @param {String} userAgent
	     * @return {Number} version or <tt>NaN</tt> if version not found
	     * @private
	     */
	    impl.getVersion = function (propertyName, userAgent) {
	        var version = impl.getVersionStr(propertyName, userAgent);
	        return version ? impl.prepareVersionNo(version) : NaN;
	    };

	    /**
	     * Prepare the version number.
	     *
	     * @param {String} version
	     * @return {Number} the version number as a floating number
	     * @private
	     */
	    impl.prepareVersionNo = function (version) {
	        var numbers;

	        numbers = version.split(/[a-z._ \/\-]/i);
	        if (numbers.length === 1) {
	            version = numbers[0];
	        }
	        if (numbers.length > 1) {
	            version = numbers[0] + '.';
	            numbers.shift();
	            version += numbers.join('');
	        }
	        return Number(version);
	    };

	    impl.isMobileFallback = function (userAgent) {
	        return impl.detectMobileBrowsers.fullPattern.test(userAgent) ||
	            impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0,4));
	    };

	    impl.isTabletFallback = function (userAgent) {
	        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
	    };

	    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
	        if (cache.mobile !== undefined) {
	            return;
	        }
	        var phone, tablet, phoneSized;

	        // first check for stronger tablet rules, then phone (see issue#5)
	        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
	        if (tablet) {
	            cache.mobile = cache.tablet = tablet;
	            cache.phone = null;
	            return; // unambiguously identified as tablet
	        }

	        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
	        if (phone) {
	            cache.mobile = cache.phone = phone;
	            cache.tablet = null;
	            return; // unambiguously identified as phone
	        }

	        // our rules haven't found a match -> try more general fallback rules
	        if (impl.isMobileFallback(userAgent)) {
	            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
	            if (phoneSized === undefined) {
	                cache.mobile = impl.FALLBACK_MOBILE;
	                cache.tablet = cache.phone = null;
	            } else if (phoneSized) {
	                cache.mobile = cache.phone = impl.FALLBACK_PHONE;
	                cache.tablet = null;
	            } else {
	                cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
	                cache.phone = null;
	            }
	        } else if (impl.isTabletFallback(userAgent)) {
	            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
	            cache.phone = null;
	        } else {
	            // not mobile at all!
	            cache.mobile = cache.tablet = cache.phone = null;
	        }
	    };

	    // t is a reference to a MobileDetect instance
	    impl.mobileGrade = function (t) {
	        // impl note:
	        // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
	        // When changes are made in Mobile_Detect.php, copy this method and replace:
	        //     $this-> / t.
	        //     self::MOBILE_GRADE_(.) / '$1'
	        //     , self::VERSION_TYPE_FLOAT / (nothing)
	        //     isIOS() / os('iOS')
	        //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
	        var $isMobile = t.mobile() !== null;

	        if (
	            // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
	            t.os('iOS') && t.version('iPad')>=4.3 ||
	            t.os('iOS') && t.version('iPhone')>=3.1 ||
	            t.os('iOS') && t.version('iPod')>=3.1 ||

	            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
	            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
	            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
	            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
	            ( t.version('Android')>2.1 && t.is('Webkit') ) ||

	            // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
	            t.version('Windows Phone OS')>=7.0 ||

	            // Blackberry 7 - Tested on BlackBerry Torch 9810
	            // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
	            t.is('BlackBerry') && t.version('BlackBerry')>=6.0 ||
	            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
	            t.match('Playbook.*Tablet') ||

	            // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
	            ( t.version('webOS')>=1.4 && t.match('Palm|Pre|Pixi') ) ||
	            // Palm WebOS 3.0  - Tested on HP TouchPad
	            t.match('hp.*TouchPad') ||

	            // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
	            ( t.is('Firefox') && t.version('Firefox')>=12 ) ||

	            // Chrome for Android - Tested on Android 4.0, 4.1 device
	            ( t.is('Chrome') && t.is('AndroidOS') && t.version('Android')>=4.0 ) ||

	            // Skyfire 4.1 - Tested on Android 2.3 device
	            ( t.is('Skyfire') && t.version('Skyfire')>=4.1 && t.is('AndroidOS') && t.version('Android')>=2.3 ) ||

	            // Opera Mobile 11.5-12: Tested on Android 2.3
	            ( t.is('Opera') && t.version('Opera Mobi')>11 && t.is('AndroidOS') ) ||

	            // Meego 1.2 - Tested on Nokia 950 and N9
	            t.is('MeeGoOS') ||

	            // Tizen (pre-release) - Tested on early hardware
	            t.is('Tizen') ||

	            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
	            // @todo: more tests here!
	            t.is('Dolfin') && t.version('Bada')>=2.0 ||

	            // UC Browser - Tested on Android 2.3 device
	            ( (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android')>=2.3 ) ||

	            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
	            ( t.match('Kindle Fire') ||
	                t.is('Kindle') && t.version('Kindle')>=3.0 ) ||

	            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
	            t.is('AndroidOS') && t.is('NookTablet') ||

	            // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
	            t.version('Chrome')>=11 && !$isMobile ||

	            // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
	            t.version('Safari')>=5.0 && !$isMobile ||

	            // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
	            t.version('Firefox')>=4.0 && !$isMobile ||

	            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
	            t.version('MSIE')>=7.0 && !$isMobile ||

	            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
	            // @reference: http://my.opera.com/community/openweb/idopera/
	            t.version('Opera')>=10 && !$isMobile

	            ){
	            return 'A';
	        }

	        if (
	            t.os('iOS') && t.version('iPad')<4.3 ||
	            t.os('iOS') && t.version('iPhone')<3.1 ||
	            t.os('iOS') && t.version('iPod')<3.1 ||

	            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
	            t.is('Blackberry') && t.version('BlackBerry')>=5 && t.version('BlackBerry')<6 ||

	            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
	            ( t.version('Opera Mini')>=5.0 && t.version('Opera Mini')<=6.5 &&
	                (t.version('Android')>=2.3 || t.is('iOS')) ) ||

	            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
	            t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

	            // @todo: report this (tested on Nokia N71)
	            t.version('Opera Mobi')>=11 && t.is('SymbianOS')
	            ){
	            return 'B';
	        }

	        if (
	        // Blackberry 4.x - Tested on the Curve 8330
	            t.version('BlackBerry')<5.0 ||
	            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
	            t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile')<=5.2

	            ){
	            return 'C';
	        }

	        //All older smartphone platforms and featurephones - Any device that doesn't support media queries
	        //will receive the basic, C grade experience.
	        return 'C';
	    };

	    impl.detectOS = function (ua) {
	        return impl.findMatch(impl.mobileDetectRules.oss0, ua) ||
	            impl.findMatch(impl.mobileDetectRules.oss, ua);
	    };

	    impl.getDeviceSmallerSide = function () {
	        return window.screen.width < window.screen.height ?
	            window.screen.width :
	            window.screen.height;
	    };

	    /**
	     * Constructor for MobileDetect object.
	     * <br>
	     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
	     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
	     *     <strong>Find information how to download and install:</strong>
	     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
	     * </div>
	     *
	     * @example <pre>
	     *     var md = new MobileDetect(window.navigator.userAgent);
	     *     if (md.mobile()) {
	     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
	     *     }
	     * </pre>
	     *
	     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
	     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
	     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
	     *        as phone.
	     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
	     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
	     *        for Android</a>.<br>
	     *        If you provide a value < 0, then this "fuzzy" check is disabled.
	     * @constructor
	     * @global
	     */
	    function MobileDetect(userAgent, maxPhoneWidth) {
	        this.ua = prepareUserAgent(userAgent);
	        this._cache = {};
	        //600dp is typical 7" tablet minimum width
	        this.maxPhoneWidth = maxPhoneWidth || 600;
	    }

	    MobileDetect.prototype = {
	        constructor: MobileDetect,

	        /**
	         * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
	         * <br>
	         * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
	         * <br>
	         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
	         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
	         * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
	         * <code>UnknownMobile</code> is returned.<br>
	         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
	         * <br>
	         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
	         * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
	         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
	         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
	         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
	         * <br>
	         * In most cases you will use the return value just as a boolean.
	         *
	         * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
	         * @function MobileDetect#mobile
	         */
	        mobile: function () {
	            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	            return this._cache.mobile;
	        },

	        /**
	         * Returns the detected phone type/family string or <tt>null</tt>.
	         * <br>
	         * The returned tablet (family or producer) is one of following keys:<br>
	         * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
	         * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
	         * Wolfgang, Alcatel, Nintendo, Amoi, INQ, GenericPhone</tt><br>
	         * <br>
	         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
	         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
	         * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
	         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
	         * <br>
	         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
	         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
	         * will return <code>UnknownMobile</code>.<br>
	         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
	         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
	         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
	         * <br>
	         * In most cases you will use the return value just as a boolean.
	         *
	         * @returns {String} the key of the phone family or producer, e.g. "iPhone"
	         * @function MobileDetect#phone
	         */
	        phone: function () {
	            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	            return this._cache.phone;
	        },

	        /**
	         * Returns the detected tablet type/family string or <tt>null</tt>.
	         * <br>
	         * The returned tablet (family or producer) is one of following keys:<br>
	         * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
	         * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
	         * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
	         * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
	         * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
	         * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
	         * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
	         * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
	         * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
	         * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
	         * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
	         * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
	         * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
	         * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
	         * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
	         * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
	         * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
	         * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
	         * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
	         * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
	         * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
	         * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
	         * GenericTablet</tt><br>
	         * <br>
	         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
	         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
	         * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
	         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
	         * <br>
	         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
	         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
	         * will return <code>UnknownMobile</code>.<br>
	         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
	         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
	         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
	         * <br>
	         * In most cases you will use the return value just as a boolean.
	         *
	         * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
	         * @function MobileDetect#tablet
	         */
	        tablet: function () {
	            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	            return this._cache.tablet;
	        },

	        /**
	         * Returns the (first) detected user-agent string or <tt>null</tt>.
	         * <br>
	         * The returned user-agent is one of following keys:<br>
	         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
	         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin,
	         * Mercury, ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
	         * <br>
	         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
	         * cases where a mobile device pretends to be more than one particular browser. You can get the
	         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
	         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
	         *
	         * @returns {String} the key for the detected user-agent or <tt>null</tt>
	         * @function MobileDetect#userAgent
	         */
	        userAgent: function () {
	            if (this._cache.userAgent === undefined) {
	                this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
	            }
	            return this._cache.userAgent;
	        },

	        /**
	         * Returns all detected user-agent strings.
	         * <br>
	         * The array is empty or contains one or more of following keys:<br>
	         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
	         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin,
	         * Mercury, ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
	         * <br>
	         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
	         * cases where a mobile device pretends to be more than one particular browser. You can get the
	         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
	         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
	         *
	         * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
	         * @function MobileDetect#userAgents
	         */
	        userAgents: function () {
	            if (this._cache.userAgents === undefined) {
	                this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
	            }
	            return this._cache.userAgents;
	        },

	        /**
	         * Returns the detected operating system string or <tt>null</tt>.
	         * <br>
	         * The operating system is one of following keys:<br>
	         * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
	         * iOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
	         *
	         * @returns {String} the key for the detected operating system.
	         * @function MobileDetect#os
	         */
	        os: function () {
	            if (this._cache.os === undefined) {
	                this._cache.os = impl.detectOS(this.ua);
	            }
	            return this._cache.os;
	        },

	        /**
	         * Get the version (as Number) of the given property in the User-Agent.
	         * <br>
	         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
	         *
	         * @param {String} key a key defining a thing which has a version.<br>
	         *        You can use one of following keys:<br>
	         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
	         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
	         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
	         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
	         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
	         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
	         *
	         * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
	         *          Be careful when comparing this value with '==' operator!
	         * @function MobileDetect#version
	         */
	        version: function (key) {
	            return impl.getVersion(key, this.ua);
	        },

	        /**
	         * Get the version (as String) of the given property in the User-Agent.
	         * <br>
	         *
	         * @param {String} key a key defining a thing which has a version.<br>
	         *        You can use one of following keys:<br>
	         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
	         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
	         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
	         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
	         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
	         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
	         *
	         * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
	         *
	         * @function MobileDetect#versionStr
	         */
	        versionStr: function (key) {
	            return impl.getVersionStr(key, this.ua);
	        },

	        /**
	         * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
	         *
	         * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
	         *        tablet family.<br>
	         *        For a complete list of possible values, see {@link MobileDetect#userAgent},
	         *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
	         *        Additionally you have following keys:<br>
	         * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
	         *
	         * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
	         *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
	         * @function MobileDetect#is
	         */
	        is: function (key) {
	            return containsIC(this.userAgents(), key) ||
	                   equalIC(key, this.os()) ||
	                   equalIC(key, this.phone()) ||
	                   equalIC(key, this.tablet()) ||
	                   containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
	        },

	        /**
	         * Do a quick test against navigator::userAgent.
	         *
	         * @param {String|RegExp} pattern the pattern, either as String or RegExp
	         *                        (a string will be converted to a case-insensitive RegExp).
	         * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
	         * @function MobileDetect#match
	         */
	        match: function (pattern) {
	            if (!(pattern instanceof RegExp)) {
	                pattern = new RegExp(pattern, 'i');
	            }
	            return pattern.test(this.ua);
	        },

	        /**
	         * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
	         * <br>
	         * Obviously this method makes sense in browser environments only (not for Node.js)!
	         * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
	         *        The argument is optional and if not present or falsy, the value of the constructor is taken.
	         * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
	         *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
	         *          Will always return <code>undefined</code> server-side.
	         */
	        isPhoneSized: function (maxPhoneWidth) {
	            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
	        },

	        /**
	         * Returns the mobile grade ('A', 'B', 'C').
	         *
	         * @returns {String} one of the mobile grades ('A', 'B', 'C').
	         * @function MobileDetect#mobileGrade
	         */
	        mobileGrade: function () {
	            if (this._cache.grade === undefined) {
	                this._cache.grade = impl.mobileGrade(this);
	            }
	            return this._cache.grade;
	        }
	    };

	    // environment-dependent
	    if (typeof window !== 'undefined' && window.screen) {
	        MobileDetect.isPhoneSized = function (maxPhoneWidth) {
	            return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
	        };
	    } else {
	        MobileDetect.isPhoneSized = function () {};
	    }

	    // should not be replaced by a completely new object - just overwrite existing methods
	    MobileDetect._impl = impl;
	    
	    MobileDetect.version = '1.4.3 2018-09-08';

	    return MobileDetect;
	}); // end of call of define()
	})((function (undefined) {
	    if (typeof module !== 'undefined' && module.exports) {
	        return function (factory) { module.exports = factory(); };
	    } else if (true) {
	        return __webpack_require__(529);
	    } else if (typeof window !== 'undefined') {
	        return function (factory) { window.MobileDetect = factory(); };
	    } else {
	        // please file a bug if you get this error!
	        throw new Error('unknown environment');
	    }
	})());

/***/ }),
/* 529 */
/***/ (function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isPhone;

	var _mobileDetect = __webpack_require__(528);

	var _mobileDetect2 = _interopRequireDefault(_mobileDetect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Detect if is a phone device
	 * @return    {Boolean}    true if is a phone, false if not
	 * @example 	js
	 * import isPhone from 'coffeekraken-sugar/js/utils/is/phone'
	 * if (isPhone()) {
	 *   // do something cool...
	 * }
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isPhone() {
	  var md = new _mobileDetect2.default(window.navigator.userAgent);
	  return md.phone() !== null;
	}

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

	var _whenInViewport = __webpack_require__(519);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _querySelectorLive = __webpack_require__(336);

	var _querySelectorLive2 = _interopRequireDefault(_querySelectorLive);

	var _closest = __webpack_require__(525);

	var _closest2 = _interopRequireDefault(_closest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _querySelectorLive2.default)('s-layers-transition', function ($elm) {
		(0, _whenInViewport2.default)($elm).then(function () {
			setTimeout(function () {
				$elm.animateIn(function () {
					(0, _closest2.default)($elm, 'section').classList.add('active');

					$elm.animateOut();
				});
			}, 1000);
		});
	});

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

	var _SWebComponent = __webpack_require__(533);

	var _SWebComponent2 = _interopRequireDefault(_SWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_SWebComponent2.default.setDefaultProps({
		widths: [{
			width: 300,
			name: 'extra-small'
		}, {
			width: 600,
			name: 'small'
		}, {
			width: 800,
			name: 'medium'
		}, {
			width: 1280,
			name: 'large'
		}],
		computeSrc: function computeSrc(src, widthObj) {
			return src + '?w={width}&auto=compress';
		}
	}, 's-responsive-img');

	_SWebComponent2.default.setDefaultProps({
		apiKey: 'AIzaSyDCD2MPJFbXBkc5hNB5p8v21XcpeIo_5Mw'
	}, ['s-google-map', 's-google-map-marker']);

	_SWebComponent2.default.setDefaultProps({
		mountWhen: 'isInViewport'
	}, ['s-bodymovin', 's-responsive-img']);

	_SWebComponent2.default.setDefaultProps({
		driver: 'fontawesome'
	}, 's-icon');

	_SWebComponent2.default.setDefaultProps({
		timeout: 2000,
		characters: '#',
		duration: 200
	}, 's-characters-slideshow');

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(534);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SWebComponent = function (_native) {
	  _inherits(SWebComponent, _native);

	  function SWebComponent() {
	    _classCallCheck(this, SWebComponent);

	    return _possibleConstructorReturn(this, (SWebComponent.__proto__ || Object.getPrototypeOf(SWebComponent)).apply(this, arguments));
	  }

	  return SWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLElement));

	exports.default = SWebComponent;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = sNativeWebComponent;

	__webpack_require__(535);

	__webpack_require__(536);

	var _safari = __webpack_require__(537);

	var _safari2 = _interopRequireDefault(_safari);

	var _mixwith = __webpack_require__(538);

	var _SWebComponentMixin = __webpack_require__(539);

	var _SWebComponentMixin2 = _interopRequireDefault(_SWebComponentMixin);

	var _samsungBrowser = __webpack_require__(565);

	var _samsungBrowser2 = _interopRequireDefault(_samsungBrowser);

	var _ucBrowser = __webpack_require__(566);

	var _ucBrowser2 = _interopRequireDefault(_ucBrowser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var extendsStack = {};
	function sNativeWebComponent(HTMLElementToExtend) {
		if (!(0, _safari2.default)() && !(0, _samsungBrowser2.default)() && !(0, _ucBrowser2.default)()) {
			HTMLElementToExtend = function (OriginalHTMLElement) {
				if (!window[OriginalHTMLElement.name]) return OriginalHTMLElement;
				if (extendsStack[OriginalHTMLElement.name]) return extendsStack[OriginalHTMLElement.name];
				function BabelHTMLElement() {
					if (typeof Reflect == "undefined" || typeof Reflect.construct != "function" || typeof customElements == "undefined") {
						// Use your favorite polyfill.
					}
					var newTarget = this.__proto__.constructor;
					return Reflect.construct(OriginalHTMLElement, [], newTarget);
				}
				Object.setPrototypeOf(BabelHTMLElement, OriginalHTMLElement);
				Object.setPrototypeOf(BabelHTMLElement.prototype, OriginalHTMLElement.prototype);
				extendsStack[HTMLElementToExtend.name] = BabelHTMLElement;
				return BabelHTMLElement;
			}(HTMLElementToExtend);
		}

		// if (typeof HTMLElementToExtend !== "function") {
		// 	var _HTMLElementToExtend = function() {};
		// 	_HTMLElementToExtend.prototype = HTMLElementToExtend.prototype;
		// 	HTMLElementToExtend = _HTMLElementToExtend;
		// }

		return (0, _mixwith.mix)(HTMLElementToExtend).with(_SWebComponentMixin2.default);
	}

/***/ }),
/* 535 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	ISC License

	Copyright (c) 2014-2018, Andrea Giammarchi, @WebReflection

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
	OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.

	*/
	// global window Object
	// optional polyfill info
	//    'auto' used by default, everything is feature detected
	//    'force' use the polyfill even if not fully needed
	function installCustomElements(window, polyfill) {'use strict';

	  // DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK
	  // THIS IS A PROJECT BASED ON A BUILD SYSTEM
	  // THIS FILE IS JUST WRAPPED UP RESULTING IN
	  // build/document-register-element.node.js

	  var
	    document = window.document,
	    Object = window.Object
	  ;

	  var htmlClass = (function (info) {
	    // (C) Andrea Giammarchi - @WebReflection - MIT Style
	    var
	      catchClass = /^[A-Z]+[a-z]/,
	      filterBy = function (re) {
	        var arr = [], tag;
	        for (tag in register) {
	          if (re.test(tag)) arr.push(tag);
	        }
	        return arr;
	      },
	      add = function (Class, tag) {
	        tag = tag.toLowerCase();
	        if (!(tag in register)) {
	          register[Class] = (register[Class] || []).concat(tag);
	          register[tag] = (register[tag.toUpperCase()] = Class);
	        }
	      },
	      register = (Object.create || Object)(null),
	      htmlClass = {},
	      i, section, tags, Class
	    ;
	    for (section in info) {
	      for (Class in info[section]) {
	        tags = info[section][Class];
	        register[Class] = tags;
	        for (i = 0; i < tags.length; i++) {
	          register[tags[i].toLowerCase()] =
	          register[tags[i].toUpperCase()] = Class;
	        }
	      }
	    }
	    htmlClass.get = function get(tagOrClass) {
	      return typeof tagOrClass === 'string' ?
	        (register[tagOrClass] || (catchClass.test(tagOrClass) ? [] : '')) :
	        filterBy(tagOrClass);
	    };
	    htmlClass.set = function set(tag, Class) {
	      return (catchClass.test(tag) ?
	        add(tag, Class) :
	        add(Class, tag)
	      ), htmlClass;
	    };
	    return htmlClass;
	  }({
	    "collections": {
	      "HTMLAllCollection": [
	        "all"
	      ],
	      "HTMLCollection": [
	        "forms"
	      ],
	      "HTMLFormControlsCollection": [
	        "elements"
	      ],
	      "HTMLOptionsCollection": [
	        "options"
	      ]
	    },
	    "elements": {
	      "Element": [
	        "element"
	      ],
	      "HTMLAnchorElement": [
	        "a"
	      ],
	      "HTMLAppletElement": [
	        "applet"
	      ],
	      "HTMLAreaElement": [
	        "area"
	      ],
	      "HTMLAttachmentElement": [
	        "attachment"
	      ],
	      "HTMLAudioElement": [
	        "audio"
	      ],
	      "HTMLBRElement": [
	        "br"
	      ],
	      "HTMLBaseElement": [
	        "base"
	      ],
	      "HTMLBodyElement": [
	        "body"
	      ],
	      "HTMLButtonElement": [
	        "button"
	      ],
	      "HTMLCanvasElement": [
	        "canvas"
	      ],
	      "HTMLContentElement": [
	        "content"
	      ],
	      "HTMLDListElement": [
	        "dl"
	      ],
	      "HTMLDataElement": [
	        "data"
	      ],
	      "HTMLDataListElement": [
	        "datalist"
	      ],
	      "HTMLDetailsElement": [
	        "details"
	      ],
	      "HTMLDialogElement": [
	        "dialog"
	      ],
	      "HTMLDirectoryElement": [
	        "dir"
	      ],
	      "HTMLDivElement": [
	        "div"
	      ],
	      "HTMLDocument": [
	        "document"
	      ],
	      "HTMLElement": [
	        "element",
	        "abbr",
	        "address",
	        "article",
	        "aside",
	        "b",
	        "bdi",
	        "bdo",
	        "cite",
	        "code",
	        "command",
	        "dd",
	        "dfn",
	        "dt",
	        "em",
	        "figcaption",
	        "figure",
	        "footer",
	        "header",
	        "i",
	        "kbd",
	        "mark",
	        "nav",
	        "noscript",
	        "rp",
	        "rt",
	        "ruby",
	        "s",
	        "samp",
	        "section",
	        "small",
	        "strong",
	        "sub",
	        "summary",
	        "sup",
	        "u",
	        "var",
	        "wbr"
	      ],
	      "HTMLEmbedElement": [
	        "embed"
	      ],
	      "HTMLFieldSetElement": [
	        "fieldset"
	      ],
	      "HTMLFontElement": [
	        "font"
	      ],
	      "HTMLFormElement": [
	        "form"
	      ],
	      "HTMLFrameElement": [
	        "frame"
	      ],
	      "HTMLFrameSetElement": [
	        "frameset"
	      ],
	      "HTMLHRElement": [
	        "hr"
	      ],
	      "HTMLHeadElement": [
	        "head"
	      ],
	      "HTMLHeadingElement": [
	        "h1",
	        "h2",
	        "h3",
	        "h4",
	        "h5",
	        "h6"
	      ],
	      "HTMLHtmlElement": [
	        "html"
	      ],
	      "HTMLIFrameElement": [
	        "iframe"
	      ],
	      "HTMLImageElement": [
	        "img"
	      ],
	      "HTMLInputElement": [
	        "input"
	      ],
	      "HTMLKeygenElement": [
	        "keygen"
	      ],
	      "HTMLLIElement": [
	        "li"
	      ],
	      "HTMLLabelElement": [
	        "label"
	      ],
	      "HTMLLegendElement": [
	        "legend"
	      ],
	      "HTMLLinkElement": [
	        "link"
	      ],
	      "HTMLMapElement": [
	        "map"
	      ],
	      "HTMLMarqueeElement": [
	        "marquee"
	      ],
	      "HTMLMediaElement": [
	        "media"
	      ],
	      "HTMLMenuElement": [
	        "menu"
	      ],
	      "HTMLMenuItemElement": [
	        "menuitem"
	      ],
	      "HTMLMetaElement": [
	        "meta"
	      ],
	      "HTMLMeterElement": [
	        "meter"
	      ],
	      "HTMLModElement": [
	        "del",
	        "ins"
	      ],
	      "HTMLOListElement": [
	        "ol"
	      ],
	      "HTMLObjectElement": [
	        "object"
	      ],
	      "HTMLOptGroupElement": [
	        "optgroup"
	      ],
	      "HTMLOptionElement": [
	        "option"
	      ],
	      "HTMLOutputElement": [
	        "output"
	      ],
	      "HTMLParagraphElement": [
	        "p"
	      ],
	      "HTMLParamElement": [
	        "param"
	      ],
	      "HTMLPictureElement": [
	        "picture"
	      ],
	      "HTMLPreElement": [
	        "pre"
	      ],
	      "HTMLProgressElement": [
	        "progress"
	      ],
	      "HTMLQuoteElement": [
	        "blockquote",
	        "q",
	        "quote"
	      ],
	      "HTMLScriptElement": [
	        "script"
	      ],
	      "HTMLSelectElement": [
	        "select"
	      ],
	      "HTMLShadowElement": [
	        "shadow"
	      ],
	      "HTMLSlotElement": [
	        "slot"
	      ],
	      "HTMLSourceElement": [
	        "source"
	      ],
	      "HTMLSpanElement": [
	        "span"
	      ],
	      "HTMLStyleElement": [
	        "style"
	      ],
	      "HTMLTableCaptionElement": [
	        "caption"
	      ],
	      "HTMLTableCellElement": [
	        "td",
	        "th"
	      ],
	      "HTMLTableColElement": [
	        "col",
	        "colgroup"
	      ],
	      "HTMLTableElement": [
	        "table"
	      ],
	      "HTMLTableRowElement": [
	        "tr"
	      ],
	      "HTMLTableSectionElement": [
	        "thead",
	        "tbody",
	        "tfoot"
	      ],
	      "HTMLTemplateElement": [
	        "template"
	      ],
	      "HTMLTextAreaElement": [
	        "textarea"
	      ],
	      "HTMLTimeElement": [
	        "time"
	      ],
	      "HTMLTitleElement": [
	        "title"
	      ],
	      "HTMLTrackElement": [
	        "track"
	      ],
	      "HTMLUListElement": [
	        "ul"
	      ],
	      "HTMLUnknownElement": [
	        "unknown",
	        "vhgroupv",
	        "vkeygen"
	      ],
	      "HTMLVideoElement": [
	        "video"
	      ]
	    },
	    "nodes": {
	      "Attr": [
	        "node"
	      ],
	      "Audio": [
	        "audio"
	      ],
	      "CDATASection": [
	        "node"
	      ],
	      "CharacterData": [
	        "node"
	      ],
	      "Comment": [
	        "#comment"
	      ],
	      "Document": [
	        "#document"
	      ],
	      "DocumentFragment": [
	        "#document-fragment"
	      ],
	      "DocumentType": [
	        "node"
	      ],
	      "HTMLDocument": [
	        "#document"
	      ],
	      "Image": [
	        "img"
	      ],
	      "Option": [
	        "option"
	      ],
	      "ProcessingInstruction": [
	        "node"
	      ],
	      "ShadowRoot": [
	        "#shadow-root"
	      ],
	      "Text": [
	        "#text"
	      ],
	      "XMLDocument": [
	        "xml"
	      ]
	    }
	  }));
	  
	  
	    
	  // passed at runtime, configurable via nodejs module
	  if (typeof polyfill !== 'object') polyfill = {type: polyfill || 'auto'};
	  
	  var
	    // V0 polyfill entry
	    REGISTER_ELEMENT = 'registerElement',
	  
	    // IE < 11 only + old WebKit for attributes + feature detection
	    EXPANDO_UID = '__' + REGISTER_ELEMENT + (window.Math.random() * 10e4 >> 0),
	  
	    // shortcuts and costants
	    ADD_EVENT_LISTENER = 'addEventListener',
	    ATTACHED = 'attached',
	    CALLBACK = 'Callback',
	    DETACHED = 'detached',
	    EXTENDS = 'extends',
	  
	    ATTRIBUTE_CHANGED_CALLBACK = 'attributeChanged' + CALLBACK,
	    ATTACHED_CALLBACK = ATTACHED + CALLBACK,
	    CONNECTED_CALLBACK = 'connected' + CALLBACK,
	    DISCONNECTED_CALLBACK = 'disconnected' + CALLBACK,
	    CREATED_CALLBACK = 'created' + CALLBACK,
	    DETACHED_CALLBACK = DETACHED + CALLBACK,
	  
	    ADDITION = 'ADDITION',
	    MODIFICATION = 'MODIFICATION',
	    REMOVAL = 'REMOVAL',
	  
	    DOM_ATTR_MODIFIED = 'DOMAttrModified',
	    DOM_CONTENT_LOADED = 'DOMContentLoaded',
	    DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',
	  
	    PREFIX_TAG = '<',
	    PREFIX_IS = '=',
	  
	    // valid and invalid node names
	    validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
	    invalidNames = [
	      'ANNOTATION-XML',
	      'COLOR-PROFILE',
	      'FONT-FACE',
	      'FONT-FACE-SRC',
	      'FONT-FACE-URI',
	      'FONT-FACE-FORMAT',
	      'FONT-FACE-NAME',
	      'MISSING-GLYPH'
	    ],
	  
	    // registered types and their prototypes
	    types = [],
	    protos = [],
	  
	    // to query subnodes
	    query = '',
	  
	    // html shortcut used to feature detect
	    documentElement = document.documentElement,
	  
	    // ES5 inline helpers || basic patches
	    indexOf = types.indexOf || function (v) {
	      for(var i = this.length; i-- && this[i] !== v;){}
	      return i;
	    },
	  
	    // other helpers / shortcuts
	    OP = Object.prototype,
	    hOP = OP.hasOwnProperty,
	    iPO = OP.isPrototypeOf,
	  
	    defineProperty = Object.defineProperty,
	    empty = [],
	    gOPD = Object.getOwnPropertyDescriptor,
	    gOPN = Object.getOwnPropertyNames,
	    gPO = Object.getPrototypeOf,
	    sPO = Object.setPrototypeOf,
	  
	    // jshint proto: true
	    hasProto = !!Object.__proto__,
	  
	    // V1 helpers
	    fixGetClass = false,
	    DRECEV1 = '__dreCEv1',
	    customElements = window.customElements,
	    usableCustomElements = !/^force/.test(polyfill.type) && !!(
	      customElements &&
	      customElements.define &&
	      customElements.get &&
	      customElements.whenDefined
	    ),
	    Dict = Object.create || Object,
	    Map = window.Map || function Map() {
	      var K = [], V = [], i;
	      return {
	        get: function (k) {
	          return V[indexOf.call(K, k)];
	        },
	        set: function (k, v) {
	          i = indexOf.call(K, k);
	          if (i < 0) V[K.push(k) - 1] = v;
	          else V[i] = v;
	        }
	      };
	    },
	    Promise = window.Promise || function (fn) {
	      var
	        notify = [],
	        done = false,
	        p = {
	          'catch': function () {
	            return p;
	          },
	          'then': function (cb) {
	            notify.push(cb);
	            if (done) setTimeout(resolve, 1);
	            return p;
	          }
	        }
	      ;
	      function resolve(value) {
	        done = true;
	        while (notify.length) notify.shift()(value);
	      }
	      fn(resolve);
	      return p;
	    },
	    justCreated = false,
	    constructors = Dict(null),
	    waitingList = Dict(null),
	    nodeNames = new Map(),
	    secondArgument = function (is) {
	      return is.toLowerCase();
	    },
	  
	    // used to create unique instances
	    create = Object.create || function Bridge(proto) {
	      // silly broken polyfill probably ever used but short enough to work
	      return proto ? ((Bridge.prototype = proto), new Bridge()) : this;
	    },
	  
	    // will set the prototype if possible
	    // or copy over all properties
	    setPrototype = sPO || (
	      hasProto ?
	        function (o, p) {
	          o.__proto__ = p;
	          return o;
	        } : (
	      (gOPN && gOPD) ?
	        (function(){
	          function setProperties(o, p) {
	            for (var
	              key,
	              names = gOPN(p),
	              i = 0, length = names.length;
	              i < length; i++
	            ) {
	              key = names[i];
	              if (!hOP.call(o, key)) {
	                defineProperty(o, key, gOPD(p, key));
	              }
	            }
	          }
	          return function (o, p) {
	            do {
	              setProperties(o, p);
	            } while ((p = gPO(p)) && !iPO.call(p, o));
	            return o;
	          };
	        }()) :
	        function (o, p) {
	          for (var key in p) {
	            o[key] = p[key];
	          }
	          return o;
	        }
	    )),
	  
	    // DOM shortcuts and helpers, if any
	  
	    MutationObserver = window.MutationObserver ||
	                       window.WebKitMutationObserver,
	  
	    HTMLAnchorElement = window.HTMLAnchorElement,
	  
	    HTMLElementPrototype = (
	      window.HTMLElement ||
	      window.Element ||
	      window.Node
	    ).prototype,
	  
	    IE8 = !iPO.call(HTMLElementPrototype, documentElement),
	  
	    safeProperty = IE8 ? function (o, k, d) {
	      o[k] = d.value;
	      return o;
	    } : defineProperty,
	  
	    isValidNode = IE8 ?
	      function (node) {
	        return node.nodeType === 1;
	      } :
	      function (node) {
	        return iPO.call(HTMLElementPrototype, node);
	      },
	  
	    targets = IE8 && [],
	  
	    attachShadow = HTMLElementPrototype.attachShadow,
	    cloneNode = HTMLElementPrototype.cloneNode,
	    dispatchEvent = HTMLElementPrototype.dispatchEvent,
	    getAttribute = HTMLElementPrototype.getAttribute,
	    hasAttribute = HTMLElementPrototype.hasAttribute,
	    removeAttribute = HTMLElementPrototype.removeAttribute,
	    setAttribute = HTMLElementPrototype.setAttribute,
	  
	    // replaced later on
	    createElement = document.createElement,
	    importNode = document.importNode,
	    patchedCreateElement = createElement,
	  
	    // shared observer for all attributes
	    attributesObserver = MutationObserver && {
	      attributes: true,
	      characterData: true,
	      attributeOldValue: true
	    },
	  
	    // useful to detect only if there's no MutationObserver
	    DOMAttrModified = MutationObserver || function(e) {
	      doesNotSupportDOMAttrModified = false;
	      documentElement.removeEventListener(
	        DOM_ATTR_MODIFIED,
	        DOMAttrModified
	      );
	    },
	  
	    // will both be used to make DOMNodeInserted asynchronous
	    asapQueue,
	    asapTimer = 0,
	  
	    // internal flags
	    V0 = REGISTER_ELEMENT in document &&
	         !/^force-all/.test(polyfill.type),
	    setListener = true,
	    justSetup = false,
	    doesNotSupportDOMAttrModified = true,
	    dropDomContentLoaded = true,
	  
	    // needed for the innerHTML helper
	    notFromInnerHTMLHelper = true,
	  
	    // optionally defined later on
	    onSubtreeModified,
	    callDOMAttrModified,
	    getAttributesMirror,
	    observer,
	    observe,
	  
	    // based on setting prototype capability
	    // will check proto or the expando attribute
	    // in order to setup the node once
	    patchIfNotAlready,
	    patch,
	  
	    // used for tests
	    tmp
	  ;
	  
	  // IE11 disconnectedCallback issue #
	  // to be tested before any createElement patch
	  if (MutationObserver) {
	    // original fix:
	    // https://github.com/javan/mutation-observer-inner-html-shim
	    tmp = document.createElement('div');
	    tmp.innerHTML = '<div><div></div></div>';
	    new MutationObserver(function (mutations, observer) {
	      if (
	        mutations[0] &&
	        mutations[0].type == 'childList' &&
	        !mutations[0].removedNodes[0].childNodes.length
	      ) {
	        tmp = gOPD(HTMLElementPrototype, 'innerHTML');
	        var set = tmp && tmp.set;
	        if (set)
	          defineProperty(HTMLElementPrototype, 'innerHTML', {
	            set: function (value) {
	              while (this.lastChild)
	                this.removeChild(this.lastChild);
	              set.call(this, value);
	            }
	          });
	      }
	      observer.disconnect();
	      tmp = null;
	    }).observe(tmp, {childList: true, subtree: true});
	    tmp.innerHTML = "";
	  }
	  
	  // only if needed
	  if (!V0) {
	  
	    if (sPO || hasProto) {
	        patchIfNotAlready = function (node, proto) {
	          if (!iPO.call(proto, node)) {
	            setupNode(node, proto);
	          }
	        };
	        patch = setupNode;
	    } else {
	        patchIfNotAlready = function (node, proto) {
	          if (!node[EXPANDO_UID]) {
	            node[EXPANDO_UID] = Object(true);
	            setupNode(node, proto);
	          }
	        };
	        patch = patchIfNotAlready;
	    }
	  
	    if (IE8) {
	      doesNotSupportDOMAttrModified = false;
	      (function (){
	        var
	          descriptor = gOPD(HTMLElementPrototype, ADD_EVENT_LISTENER),
	          addEventListener = descriptor.value,
	          patchedRemoveAttribute = function (name) {
	            var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
	            e.attrName = name;
	            e.prevValue = getAttribute.call(this, name);
	            e.newValue = null;
	            e[REMOVAL] = e.attrChange = 2;
	            removeAttribute.call(this, name);
	            dispatchEvent.call(this, e);
	          },
	          patchedSetAttribute = function (name, value) {
	            var
	              had = hasAttribute.call(this, name),
	              old = had && getAttribute.call(this, name),
	              e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})
	            ;
	            setAttribute.call(this, name, value);
	            e.attrName = name;
	            e.prevValue = had ? old : null;
	            e.newValue = value;
	            if (had) {
	              e[MODIFICATION] = e.attrChange = 1;
	            } else {
	              e[ADDITION] = e.attrChange = 0;
	            }
	            dispatchEvent.call(this, e);
	          },
	          onPropertyChange = function (e) {
	            // jshint eqnull:true
	            var
	              node = e.currentTarget,
	              superSecret = node[EXPANDO_UID],
	              propertyName = e.propertyName,
	              event
	            ;
	            if (superSecret.hasOwnProperty(propertyName)) {
	              superSecret = superSecret[propertyName];
	              event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
	              event.attrName = superSecret.name;
	              event.prevValue = superSecret.value || null;
	              event.newValue = (superSecret.value = node[propertyName] || null);
	              if (event.prevValue == null) {
	                event[ADDITION] = event.attrChange = 0;
	              } else {
	                event[MODIFICATION] = event.attrChange = 1;
	              }
	              dispatchEvent.call(node, event);
	            }
	          }
	        ;
	        descriptor.value = function (type, handler, capture) {
	          if (
	            type === DOM_ATTR_MODIFIED &&
	            this[ATTRIBUTE_CHANGED_CALLBACK] &&
	            this.setAttribute !== patchedSetAttribute
	          ) {
	            this[EXPANDO_UID] = {
	              className: {
	                name: 'class',
	                value: this.className
	              }
	            };
	            this.setAttribute = patchedSetAttribute;
	            this.removeAttribute = patchedRemoveAttribute;
	            addEventListener.call(this, 'propertychange', onPropertyChange);
	          }
	          addEventListener.call(this, type, handler, capture);
	        };
	        defineProperty(HTMLElementPrototype, ADD_EVENT_LISTENER, descriptor);
	      }());
	    } else if (!MutationObserver) {
	      documentElement[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, DOMAttrModified);
	      documentElement.setAttribute(EXPANDO_UID, 1);
	      documentElement.removeAttribute(EXPANDO_UID);
	      if (doesNotSupportDOMAttrModified) {
	        onSubtreeModified = function (e) {
	          var
	            node = this,
	            oldAttributes,
	            newAttributes,
	            key
	          ;
	          if (node === e.target) {
	            oldAttributes = node[EXPANDO_UID];
	            node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));
	            for (key in newAttributes) {
	              if (!(key in oldAttributes)) {
	                // attribute was added
	                return callDOMAttrModified(
	                  0,
	                  node,
	                  key,
	                  oldAttributes[key],
	                  newAttributes[key],
	                  ADDITION
	                );
	              } else if (newAttributes[key] !== oldAttributes[key]) {
	                // attribute was changed
	                return callDOMAttrModified(
	                  1,
	                  node,
	                  key,
	                  oldAttributes[key],
	                  newAttributes[key],
	                  MODIFICATION
	                );
	              }
	            }
	            // checking if it has been removed
	            for (key in oldAttributes) {
	              if (!(key in newAttributes)) {
	                // attribute removed
	                return callDOMAttrModified(
	                  2,
	                  node,
	                  key,
	                  oldAttributes[key],
	                  newAttributes[key],
	                  REMOVAL
	                );
	              }
	            }
	          }
	        };
	        callDOMAttrModified = function (
	          attrChange,
	          currentTarget,
	          attrName,
	          prevValue,
	          newValue,
	          action
	        ) {
	          var e = {
	            attrChange: attrChange,
	            currentTarget: currentTarget,
	            attrName: attrName,
	            prevValue: prevValue,
	            newValue: newValue
	          };
	          e[action] = attrChange;
	          onDOMAttrModified(e);
	        };
	        getAttributesMirror = function (node) {
	          for (var
	            attr, name,
	            result = {},
	            attributes = node.attributes,
	            i = 0, length = attributes.length;
	            i < length; i++
	          ) {
	            attr = attributes[i];
	            name = attr.name;
	            if (name !== 'setAttribute') {
	              result[name] = attr.value;
	            }
	          }
	          return result;
	        };
	      }
	    }
	  
	    // set as enumerable, writable and configurable
	    document[REGISTER_ELEMENT] = function registerElement(type, options) {
	      upperType = type.toUpperCase();
	      if (setListener) {
	        // only first time document.registerElement is used
	        // we need to set this listener
	        // setting it by default might slow down for no reason
	        setListener = false;
	        if (MutationObserver) {
	          observer = (function(attached, detached){
	            function checkEmAll(list, callback) {
	              for (var i = 0, length = list.length; i < length; callback(list[i++])){}
	            }
	            return new MutationObserver(function (records) {
	              for (var
	                current, node, newValue,
	                i = 0, length = records.length; i < length; i++
	              ) {
	                current = records[i];
	                if (current.type === 'childList') {
	                  checkEmAll(current.addedNodes, attached);
	                  checkEmAll(current.removedNodes, detached);
	                } else {
	                  node = current.target;
	                  if (notFromInnerHTMLHelper &&
	                      node[ATTRIBUTE_CHANGED_CALLBACK] &&
	                      current.attributeName !== 'style') {
	                    newValue = getAttribute.call(node, current.attributeName);
	                    if (newValue !== current.oldValue) {
	                      node[ATTRIBUTE_CHANGED_CALLBACK](
	                        current.attributeName,
	                        current.oldValue,
	                        newValue
	                      );
	                    }
	                  }
	                }
	              }
	            });
	          }(executeAction(ATTACHED), executeAction(DETACHED)));
	          observe = function (node) {
	            observer.observe(
	              node,
	              {
	                childList: true,
	                subtree: true
	              }
	            );
	            return node;
	          };
	          observe(document);
	          if (attachShadow) {
	            HTMLElementPrototype.attachShadow = function () {
	              return observe(attachShadow.apply(this, arguments));
	            };
	          }
	        } else {
	          asapQueue = [];
	          document[ADD_EVENT_LISTENER]('DOMNodeInserted', onDOMNode(ATTACHED));
	          document[ADD_EVENT_LISTENER]('DOMNodeRemoved', onDOMNode(DETACHED));
	        }
	  
	        document[ADD_EVENT_LISTENER](DOM_CONTENT_LOADED, onReadyStateChange);
	        document[ADD_EVENT_LISTENER]('readystatechange', onReadyStateChange);
	  
	        document.importNode = function (node, deep) {
	          switch (node.nodeType) {
	            case 1:
	              return setupAll(document, importNode, [node, !!deep]);
	            case 11:
	              for (var
	                fragment = document.createDocumentFragment(),
	                childNodes = node.childNodes,
	                length = childNodes.length,
	                i = 0; i < length; i++
	              )
	                fragment.appendChild(document.importNode(childNodes[i], !!deep));
	              return fragment;
	            default:
	              return cloneNode.call(node, !!deep);
	          }
	        };
	  
	        HTMLElementPrototype.cloneNode = function (deep) {
	          return setupAll(this, cloneNode, [!!deep]);
	        };
	      }
	  
	      if (justSetup) return (justSetup = false);
	  
	      if (-2 < (
	        indexOf.call(types, PREFIX_IS + upperType) +
	        indexOf.call(types, PREFIX_TAG + upperType)
	      )) {
	        throwTypeError(type);
	      }
	  
	      if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {
	        throw new Error('The type ' + type + ' is invalid');
	      }
	  
	      var
	        constructor = function () {
	          return extending ?
	            document.createElement(nodeName, upperType) :
	            document.createElement(nodeName);
	        },
	        opt = options || OP,
	        extending = hOP.call(opt, EXTENDS),
	        nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,
	        upperType,
	        i
	      ;
	  
	      if (extending && -1 < (
	        indexOf.call(types, PREFIX_TAG + nodeName)
	      )) {
	        throwTypeError(nodeName);
	      }
	  
	      i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;
	  
	      query = query.concat(
	        query.length ? ',' : '',
	        extending ? nodeName + '[is="' + type.toLowerCase() + '"]' : nodeName
	      );
	  
	      constructor.prototype = (
	        protos[i] = hOP.call(opt, 'prototype') ?
	          opt.prototype :
	          create(HTMLElementPrototype)
	      );
	  
	      if (query.length) loopAndVerify(
	        document.querySelectorAll(query),
	        ATTACHED
	      );
	  
	      return constructor;
	    };
	  
	    document.createElement = (patchedCreateElement = function (localName, typeExtension) {
	      var
	        is = getIs(typeExtension),
	        node = is ?
	          createElement.call(document, localName, secondArgument(is)) :
	          createElement.call(document, localName),
	        name = '' + localName,
	        i = indexOf.call(
	          types,
	          (is ? PREFIX_IS : PREFIX_TAG) +
	          (is || name).toUpperCase()
	        ),
	        setup = -1 < i
	      ;
	      if (is) {
	        node.setAttribute('is', is = is.toLowerCase());
	        if (setup) {
	          setup = isInQSA(name.toUpperCase(), is);
	        }
	      }
	      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;
	      if (setup) patch(node, protos[i]);
	      return node;
	    });
	  
	  }
	  
	  function ASAP() {
	    var queue = asapQueue.splice(0, asapQueue.length);
	    asapTimer = 0;
	    while (queue.length) {
	      queue.shift().call(
	        null, queue.shift()
	      );
	    }
	  }
	  
	  function loopAndVerify(list, action) {
	    for (var i = 0, length = list.length; i < length; i++) {
	      verifyAndSetupAndAction(list[i], action);
	    }
	  }
	  
	  function loopAndSetup(list) {
	    for (var i = 0, length = list.length, node; i < length; i++) {
	      node = list[i];
	      patch(node, protos[getTypeIndex(node)]);
	    }
	  }
	  
	  function executeAction(action) {
	    return function (node) {
	      if (isValidNode(node)) {
	        verifyAndSetupAndAction(node, action);
	        if (query.length) loopAndVerify(
	          node.querySelectorAll(query),
	          action
	        );
	      }
	    };
	  }
	  
	  function getTypeIndex(target) {
	    var
	      is = getAttribute.call(target, 'is'),
	      nodeName = target.nodeName.toUpperCase(),
	      i = indexOf.call(
	        types,
	        is ?
	            PREFIX_IS + is.toUpperCase() :
	            PREFIX_TAG + nodeName
	      )
	    ;
	    return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;
	  }
	  
	  function isInQSA(name, type) {
	    return -1 < query.indexOf(name + '[is="' + type + '"]');
	  }
	  
	  function onDOMAttrModified(e) {
	    var
	      node = e.currentTarget,
	      attrChange = e.attrChange,
	      attrName = e.attrName,
	      target = e.target,
	      addition = e[ADDITION] || 2,
	      removal = e[REMOVAL] || 3
	    ;
	    if (notFromInnerHTMLHelper &&
	        (!target || target === node) &&
	        node[ATTRIBUTE_CHANGED_CALLBACK] &&
	        attrName !== 'style' && (
	          e.prevValue !== e.newValue ||
	          // IE9, IE10, and Opera 12 gotcha
	          e.newValue === '' && (
	            attrChange === addition ||
	            attrChange === removal
	          )
	    )) {
	      node[ATTRIBUTE_CHANGED_CALLBACK](
	        attrName,
	        attrChange === addition ? null : e.prevValue,
	        attrChange === removal ? null : e.newValue
	      );
	    }
	  }
	  
	  function onDOMNode(action) {
	    var executor = executeAction(action);
	    return function (e) {
	      asapQueue.push(executor, e.target);
	      if (asapTimer) clearTimeout(asapTimer);
	      asapTimer = setTimeout(ASAP, 1);
	    };
	  }
	  
	  function onReadyStateChange(e) {
	    if (dropDomContentLoaded) {
	      dropDomContentLoaded = false;
	      e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
	    }
	    if (query.length) loopAndVerify(
	      (e.target || document).querySelectorAll(query),
	      e.detail === DETACHED ? DETACHED : ATTACHED
	    );
	    if (IE8) purge();
	  }
	  
	  function patchedSetAttribute(name, value) {
	    // jshint validthis:true
	    var self = this;
	    setAttribute.call(self, name, value);
	    onSubtreeModified.call(self, {target: self});
	  }
	  
	  function setupAll(context, callback, args) {
	    var
	      node = callback.apply(context, args),
	      i = getTypeIndex(node)
	    ;
	    if (-1 < i) patch(node, protos[i]);
	    if (args.pop() && query.length)
	      loopAndSetup(node.querySelectorAll(query));
	    return node;
	  }
	  
	  function setupNode(node, proto) {
	    setPrototype(node, proto);
	    if (observer) {
	      observer.observe(node, attributesObserver);
	    } else {
	      if (doesNotSupportDOMAttrModified) {
	        node.setAttribute = patchedSetAttribute;
	        node[EXPANDO_UID] = getAttributesMirror(node);
	        node[ADD_EVENT_LISTENER](DOM_SUBTREE_MODIFIED, onSubtreeModified);
	      }
	      node[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, onDOMAttrModified);
	    }
	    if (node[CREATED_CALLBACK] && notFromInnerHTMLHelper) {
	      node.created = true;
	      node[CREATED_CALLBACK]();
	      node.created = false;
	    }
	  }
	  
	  function purge() {
	    for (var
	      node,
	      i = 0,
	      length = targets.length;
	      i < length; i++
	    ) {
	      node = targets[i];
	      if (!documentElement.contains(node)) {
	        length--;
	        targets.splice(i--, 1);
	        verifyAndSetupAndAction(node, DETACHED);
	      }
	    }
	  }
	  
	  function throwTypeError(type) {
	    throw new Error('A ' + type + ' type is already registered');
	  }
	  
	  function verifyAndSetupAndAction(node, action) {
	    var
	      fn,
	      i = getTypeIndex(node),
	      counterAction
	    ;
	    if (-1 < i) {
	      patchIfNotAlready(node, protos[i]);
	      i = 0;
	      if (action === ATTACHED && !node[ATTACHED]) {
	        node[DETACHED] = false;
	        node[ATTACHED] = true;
	        counterAction = 'connected';
	        i = 1;
	        if (IE8 && indexOf.call(targets, node) < 0) {
	          targets.push(node);
	        }
	      } else if (action === DETACHED && !node[DETACHED]) {
	        node[ATTACHED] = false;
	        node[DETACHED] = true;
	        counterAction = 'disconnected';
	        i = 1;
	      }
	      if (i && (fn = (
	        node[action + CALLBACK] ||
	        node[counterAction + CALLBACK]
	      ))) fn.call(node);
	    }
	  }
	  
	  
	  
	  // V1 in da House!
	  function CustomElementRegistry() {}
	  
	  CustomElementRegistry.prototype = {
	    constructor: CustomElementRegistry,
	    // a workaround for the stubborn WebKit
	    define: usableCustomElements ?
	      function (name, Class, options) {
	        if (options) {
	          CERDefine(name, Class, options);
	        } else {
	          var NAME = name.toUpperCase();
	          constructors[NAME] = {
	            constructor: Class,
	            create: [NAME]
	          };
	          nodeNames.set(Class, NAME);
	          customElements.define(name, Class);
	        }
	      } :
	      CERDefine,
	    get: usableCustomElements ?
	      function (name) {
	        return customElements.get(name) || get(name);
	      } :
	      get,
	    whenDefined: usableCustomElements ?
	      function (name) {
	        return Promise.race([
	          customElements.whenDefined(name),
	          whenDefined(name)
	        ]);
	      } :
	      whenDefined
	  };
	  
	  function CERDefine(name, Class, options) {
	    var
	      is = options && options[EXTENDS] || '',
	      CProto = Class.prototype,
	      proto = create(CProto),
	      attributes = Class.observedAttributes || empty,
	      definition = {prototype: proto}
	    ;
	    // TODO: is this needed at all since it's inherited?
	    // defineProperty(proto, 'constructor', {value: Class});
	    safeProperty(proto, CREATED_CALLBACK, {
	        value: function () {
	          if (justCreated) justCreated = false;
	          else if (!this[DRECEV1]) {
	            this[DRECEV1] = true;
	            new Class(this);
	            if (CProto[CREATED_CALLBACK])
	              CProto[CREATED_CALLBACK].call(this);
	            var info = constructors[nodeNames.get(Class)];
	            if (!usableCustomElements || info.create.length > 1) {
	              notifyAttributes(this);
	            }
	          }
	      }
	    });
	    safeProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {
	      value: function (name) {
	        if (-1 < indexOf.call(attributes, name)) {
	          if (CProto[ATTRIBUTE_CHANGED_CALLBACK])
	            CProto[ATTRIBUTE_CHANGED_CALLBACK].apply(this, arguments);
	        }
	      }
	    });
	    if (CProto[CONNECTED_CALLBACK]) {
	      safeProperty(proto, ATTACHED_CALLBACK, {
	        value: CProto[CONNECTED_CALLBACK]
	      });
	    }
	    if (CProto[DISCONNECTED_CALLBACK]) {
	      safeProperty(proto, DETACHED_CALLBACK, {
	        value: CProto[DISCONNECTED_CALLBACK]
	      });
	    }
	    if (is) definition[EXTENDS] = is;
	    name = name.toUpperCase();
	    constructors[name] = {
	      constructor: Class,
	      create: is ? [is, secondArgument(name)] : [name]
	    };
	    nodeNames.set(Class, name);
	    document[REGISTER_ELEMENT](name.toLowerCase(), definition);
	    whenDefined(name);
	    waitingList[name].r();
	  }
	  
	  function get(name) {
	    var info = constructors[name.toUpperCase()];
	    return info && info.constructor;
	  }
	  
	  function getIs(options) {
	    return typeof options === 'string' ?
	        options : (options && options.is || '');
	  }
	  
	  function notifyAttributes(self) {
	    var
	      callback = self[ATTRIBUTE_CHANGED_CALLBACK],
	      attributes = callback ? self.attributes : empty,
	      i = attributes.length,
	      attribute
	    ;
	    while (i--) {
	      attribute =  attributes[i]; // || attributes.item(i);
	      callback.call(
	        self,
	        attribute.name || attribute.nodeName,
	        null,
	        attribute.value || attribute.nodeValue
	      );
	    }
	  }
	  
	  function whenDefined(name) {
	    name = name.toUpperCase();
	    if (!(name in waitingList)) {
	      waitingList[name] = {};
	      waitingList[name].p = new Promise(function (resolve) {
	        waitingList[name].r = resolve;
	      });
	    }
	    return waitingList[name].p;
	  }
	  
	  function polyfillV1() {
	    if (customElements) delete window.customElements;
	    defineProperty(window, 'customElements', {
	      configurable: true,
	      value: new CustomElementRegistry()
	    });
	    defineProperty(window, 'CustomElementRegistry', {
	      configurable: true,
	      value: CustomElementRegistry
	    });
	    for (var
	      patchClass = function (name) {
	        var Class = window[name];
	        if (Class) {
	          window[name] = function CustomElementsV1(self) {
	            var info, isNative;
	            if (!self) self = this;
	            if (!self[DRECEV1]) {
	              justCreated = true;
	              info = constructors[nodeNames.get(self.constructor)];
	              isNative = usableCustomElements && info.create.length === 1;
	              self = isNative ?
	                Reflect.construct(Class, empty, info.constructor) :
	                document.createElement.apply(document, info.create);
	              self[DRECEV1] = true;
	              justCreated = false;
	              if (!isNative) notifyAttributes(self);
	            }
	            return self;
	          };
	          window[name].prototype = Class.prototype;
	          try {
	            Class.prototype.constructor = window[name];
	          } catch(WebKit) {
	            fixGetClass = true;
	            defineProperty(Class, DRECEV1, {value: window[name]});
	          }
	        }
	      },
	      Classes = htmlClass.get(/^HTML[A-Z]*[a-z]/),
	      i = Classes.length;
	      i--;
	      patchClass(Classes[i])
	    ) {}
	    (document.createElement = function (name, options) {
	      var is = getIs(options);
	      return is ?
	        patchedCreateElement.call(this, name, secondArgument(is)) :
	        patchedCreateElement.call(this, name);
	    });
	    if (!V0) {
	      justSetup = true;
	      document[REGISTER_ELEMENT]('');
	    }
	  }
	  
	  // if customElements is not there at all
	  if (!customElements || /^force/.test(polyfill.type)) polyfillV1();
	  else if(!polyfill.noBuiltIn) {
	    // if available test extends work as expected
	    try {
	      (function (DRE, options, name) {
	        var re = new RegExp('^<a\\s+is=(\'|")' + name + '\\1></a>$');
	        options[EXTENDS] = 'a';
	        DRE.prototype = create(HTMLAnchorElement.prototype);
	        DRE.prototype.constructor = DRE;
	        window.customElements.define(name, DRE, options);
	        if (
	          !re.test(document.createElement('a', {is: name}).outerHTML) ||
	          !re.test((new DRE()).outerHTML)
	        ) {
	          throw options;
	        }
	      }(
	        function DRE() {
	          return Reflect.construct(HTMLAnchorElement, [], DRE);
	        },
	        {},
	        'document-register-element-a'
	      ));
	    } catch(o_O) {
	      // or force the polyfill if not
	      // and keep internal original reference
	      polyfillV1();
	    }
	  }
	  
	  // FireFox only issue
	  if(!polyfill.noBuiltIn) {
	    try {
	      if (createElement.call(document, 'a', 'a').outerHTML.indexOf('is') < 0)
	        throw {};
	    } catch(FireFox) {
	      secondArgument = function (is) {
	        return {is: is.toLowerCase()};
	      };
	    }
	  }
	  
	}

	module.exports = installCustomElements;
	installCustomElements(global);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 536 */
/***/ (function(module, exports) {

	/*! (c) Andrea Giammarchi - ISC */
	(function (document, customElements, Object) {
	  'use strict';
	  if (customElements.get('ungap-li') || typeof Reflect == typeof EXTENDS)
	    return;
	  var EXTENDS = 'extends';
	  try {
	    // class LI extends HTMLLIElement {}
	    var desc = {};
	    desc[EXTENDS] = 'li';
	    var HtmlLI = HTMLLIElement;
	    var LI = function () {
	      return Reflect.construct(HtmlLI, [], LI);
	    };
	    LI.prototype = Object.create(HtmlLI.prototype);
	    customElements.define('ungap-li', LI, desc);
	    if (!/is="ungap-li"/.test((new LI).outerHTML))
	      throw {};
	  } catch (o_O) {
	    var ATTRIBUTE_CHANGED_CALLBACK = 'attributeChangedCallback';
	    var CONNECTED_CALLBACK = 'connectedCallback';
	    var DISCONNECTED_CALLBACK = 'disconnectedCallback';
	    var assign = Object.assign;
	    var create = Object.create;
	    var defineProperties = Object.defineProperties;
	    var setPrototypeOf = Object.setPrototypeOf;
	    var define = customElements.define;
	    var get = customElements.get;
	    var upgrade = customElements.upgrade;
	    var whenDefined = customElements.whenDefined;
	    var registry = create(null);
	    new MutationObserver(function (changes) {
	      for (var i = 0, length = changes.length; i < length; i++) {
	        var change = changes[i];
	        var addedNodes = change.addedNodes;
	        var removedNodes = change.removedNodes;
	        for (var j = 0, len = addedNodes.length; j < len; j++)
	          setupIfNeeded(addedNodes[j]);
	        for (var j = 0, len = removedNodes.length; j < len; j++)
	          disconnectIfNeeded(removedNodes[j]);
	      }
	    }).observe(
	      document,
	      {childList: true, subtree: true}
	    );
	    defineProperties(
	      customElements,
	      {
	        define: {
	          value: function (name, Class, options) {
	            name = name.toLowerCase();
	            if (options && EXTENDS in options) {
	              // currently options is not used but preserved for the future
	              registry[name] = assign({}, options, {Class: Class});
	              var query = options[EXTENDS] + '[is="' + name + '"]';
	              var changes = document.querySelectorAll(query);
	              for (var i = 0, length = changes.length; i < length; i++)
	                setupIfNeeded(changes[i]);
	            }
	            else
	              define.apply(customElements, arguments);
	          }
	        },
	        get: {
	          value: function (name) {
	            return name in registry ?
	              registry[name].Class :
	              get.call(customElements, name);
	          }
	        },
	        upgrade: {
	          value: function (node) {
	            var info = getInfo(node);
	            if (info && !(node instanceof info.Class))
	              setup(node, info);
	            else
	              upgrade.call(customElements, node);
	          }
	        },
	        whenDefined: {
	          value: function (name) {
	            return name in registry ?
	              Promise.resolve() :
	              whenDefined.call(customElements, name);
	          }
	        }
	      }
	    );
	    var createElement = document.createElement;
	    defineProperties(
	      document,
	      {
	        createElement: {
	          value: function (name, options) {
	            var node = createElement.call(document, name);
	            if (options && 'is' in options) {
	              node.setAttribute('is', options.is);
	              customElements.upgrade(node);
	            }
	            return node;
	          }
	        }
	      }
	    );
	    function attributeChanged(changes) {
	      for (var i = 0, length = changes.length; i < length; i++) {
	        var change = changes[i];
	        var attributeName = change.attributeName;
	        var oldValue = change.oldValue;
	        var target = change.target;
	        var newValue = target.getAttribute(attributeName);
	        if (
	          ATTRIBUTE_CHANGED_CALLBACK in target &&
	          !(oldValue == newValue && newValue == null)
	        )
	          target[ATTRIBUTE_CHANGED_CALLBACK](
	            attributeName,
	            oldValue,
	            target.getAttribute(attributeName),
	            // TODO: add getAttributeNS if the node is XML
	            null
	          );
	      }
	    }
	    function disconnectIfNeeded(node) {
	      if (node.nodeType !== 1)
	        return;
	      setupSubNodes(node, disconnectIfNeeded);
	      var info = getInfo(node);
	      if (
	        info &&
	        node instanceof info.Class &&
	        DISCONNECTED_CALLBACK in node
	      )
	        node[DISCONNECTED_CALLBACK]();
	    }
	    function getInfo(node) {
	      var is = node.getAttribute('is');
	      if (is) {
	        is = is.toLowerCase();
	        if (is in registry)
	          return registry[is];
	      }
	      return null;
	    }
	    function setup(node, info) {
	      var Class = info.Class;
	      var oa = Class.observedAttributes || [];
	      setPrototypeOf(node, Class.prototype);
	      if (oa.length) {
	        new MutationObserver(attributeChanged).observe(
	          node,
	          {
	            attributes: true,
	            attributeFilter: oa,
	            attributeOldValue: true
	          }
	        );
	        var changes = [];
	        for (var i = 0, length = oa.length; i < length; i++)
	          changes.push({attributeName: oa[i], oldValue: null, target: node});
	        attributeChanged(changes);
	      }
	    }
	    function setupIfNeeded(node) {
	      if (node.nodeType !== 1)
	        return;
	      setupSubNodes(node, setupIfNeeded);
	      var info = getInfo(node);
	      if (info) {
	        if (!(node instanceof info.Class))
	          setup(node, info);
	        if (CONNECTED_CALLBACK in node)
	          node[CONNECTED_CALLBACK]();
	      }
	    }
	    function setupSubNodes(node, setup) {
	      var nodes = node.querySelectorAll('[is]');
	      for (var i = 0, length = nodes.length; i < length; i++)
	        setup(nodes[i]);
	    }
	  }
	}(document, customElements, Object));


/***/ }),
/* 537 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isSafari;
	/**
	 * Detect if is safari
	 * @example 	js
	 * import isSafari from 'coffeekraken-sugar/js/utils/is/safari'
	 * if (isSafari()) {
	 *   // do something cool
	 * }
	 *
	 * @return    {Boolean}    true if is safari, false if not
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isSafari() {
	  return navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1;
	}

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.mixwith = mod.exports;
	  }
	})(undefined, function (exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _appliedMixin = '__mixwith_appliedMixin';

	  var apply = exports.apply = function (superclass, mixin) {
	    var application = mixin(superclass);
	    application.prototype[_appliedMixin] = unwrap(mixin);
	    return application;
	  };

	  var isApplicationOf = exports.isApplicationOf = function (proto, mixin) {
	    return proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);
	  };

	  var hasMixin = exports.hasMixin = function (o, mixin) {
	    while (o != null) {
	      if (isApplicationOf(o, mixin)) return true;
	      o = Object.getPrototypeOf(o);
	    }
	    return false;
	  };

	  var _wrappedMixin = '__mixwith_wrappedMixin';

	  var wrap = exports.wrap = function (mixin, wrapper) {
	    Object.setPrototypeOf(wrapper, mixin);
	    if (!mixin[_wrappedMixin]) {
	      mixin[_wrappedMixin] = mixin;
	    }
	    return wrapper;
	  };

	  var unwrap = exports.unwrap = function (wrapper) {
	    return wrapper[_wrappedMixin] || wrapper;
	  };

	  var _cachedApplications = '__mixwith_cachedApplications';

	  var Cached = exports.Cached = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      // Get or create a symbol used to look up a previous application of mixin
	      // to the class. This symbol is unique per mixin definition, so a class will have N
	      // applicationRefs if it has had N mixins applied to it. A mixin will have
	      // exactly one _cachedApplicationRef used to store its applications.

	      var cachedApplications = superclass[_cachedApplications];
	      if (!cachedApplications) {
	        cachedApplications = superclass[_cachedApplications] = new Map();
	      }

	      var application = cachedApplications.get(mixin);
	      if (!application) {
	        application = mixin(superclass);
	        cachedApplications.set(mixin, application);
	      }

	      return application;
	    });
	  };

	  var DeDupe = exports.DeDupe = function (mixin) {
	    return wrap(mixin, function (superclass) {
	      return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass);
	    });
	  };

	  var HasInstance = exports.HasInstance = function (mixin) {
	    if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {
	      Object.defineProperty(mixin, Symbol.hasInstance, {
	        value: function value(o) {
	          return hasMixin(o, mixin);
	        }
	      });
	    }
	    return mixin;
	  };

	  var BareMixin = exports.BareMixin = function (mixin) {
	    return wrap(mixin, function (s) {
	      return apply(s, mixin);
	    });
	  };

	  var Mixin = exports.Mixin = function (mixin) {
	    return DeDupe(Cached(BareMixin(mixin)));
	  };

	  var mix = exports.mix = function (superclass) {
	    return new MixinBuilder(superclass);
	  };

	  var MixinBuilder = function () {
	    function MixinBuilder(superclass) {
	      _classCallCheck(this, MixinBuilder);

	      this.superclass = superclass || function () {
	        function _class() {
	          _classCallCheck(this, _class);
	        }

	        return _class;
	      }();
	    }

	    _createClass(MixinBuilder, [{
	      key: 'with',
	      value: function _with() {
	        for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	          mixins[_key] = arguments[_key];
	        }

	        return mixins.reduce(function (c, m) {
	          return m(c);
	        }, this.superclass);
	      }
	    }]);

	    return MixinBuilder;
	  }();
	});

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mixwith = __webpack_require__(538);

	var _autoCast = __webpack_require__(540);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	var _extend2 = __webpack_require__(541);

	var _extend3 = _interopRequireDefault(_extend2);

	var _camelize = __webpack_require__(559);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _uncamelize = __webpack_require__(560);

	var _uncamelize2 = _interopRequireDefault(_uncamelize);

	var _upperFirst = __webpack_require__(561);

	var _upperFirst2 = _interopRequireDefault(_upperFirst);

	var _fastdom = __webpack_require__(335);

	var _fastdom2 = _interopRequireDefault(_fastdom);

	var _dispatchEvent = __webpack_require__(340);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _whenInViewport = __webpack_require__(519);

	var _whenInViewport2 = _interopRequireDefault(_whenInViewport);

	var _whenVisible = __webpack_require__(520);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _prependChild = __webpack_require__(562);

	var _prependChild2 = _interopRequireDefault(_prependChild);

	var _propertyProxy = __webpack_require__(563);

	var _propertyProxy2 = _interopRequireDefault(_propertyProxy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(564).polyfill();

	/**
	 * @name 		SWebComponent
	 * @extends 	HTMLElement
	 * Base class that abstract a lot of dirty work in order to create nice and clean webcomponents.
	 * Features:
	 * - Listen for attributes changes
	 * - Mount the component at a certain point in time (inViewport, visible, etc...)
	 * - **Automatically cast the attributes** to their proper js variable types (Array, Object, String, etc...)
	 * - **Physical props** : Specify some props that will ALWAYS be present as attribute on the component for styling purpose
	 * - Define some **default CSS** that will be injected in the head automatically
	 * - Specify some **required props**
	 * - **Full lifecycle management**:
	 * 	- componentCreated
	 * 	- componentWillMount
	 * 	- componentMount
	 * 	- componentWillReceiveProp
	 * 	- componentWillReceiveProps
	 * 	- render
	 * 	- componentUnmount
	 * - **Mount dependencies** : This will allows you to set some promises that have to be resolved before mounting the component
	 *
	 * @example 	js
	 * import SWebComponent from 'coffeekraken-sugar/js/core/SWebComponent'
	 * class MyCoolComponent extends SWebComponent {
	 *
	 *	\/**
	 * 	 * Default props
	 * 	 * @definition 		SWebComponent.defaultProps
	 * 	 * @protected
	 * 	 *\/
	 * 	static get defaultProps() {
	 * 		return {
	 * 		};
	 * 	}
	 *
	 * 	\/**
	 * 	 * Css
	 * 	 * @protected
	 * 	 *\/
	 * 	static defaultCss(componentName, componentNameDash) {
	 * 		return `
	 * 			${componentNameDash} {
	 * 				display : block;
	 * 			}
	 * 		`;
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will mount
	 *  	 * @definition 		SWebComponent.componentWillMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillMount() {
	 * 		super.componentWillMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Mount component
	 * 	 * @definition 		SWebComponent.componentMount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentMount() {
	 * 		super.componentMount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component unmount
	 * 	 * @definition 		SWebComponent.componentUnmount
	 * 	 * @protected
	 * 	 *\/
	 * 	componentUnmount() {
	 * 		super.componentUnmount();
	 * 	}
	 *
	 * 	\/**
	 * 	 * Component will receive prop
	 * 	 * @definition 		SWebComponent.componentWillReceiveProp
	 * 	 * @protected
	 * 	 *\/
	 * 	componentWillReceiveProp(name, newVal, oldVal) {
	 * 		switch(name) {
	 * 		}
	 * 	}
	 * }
	 *
	 * // define your component
	 * MyCoolComponent.define('my-cool-component', MyCoolComponent);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */

	if (!window.sugar) window.sugar = {};
	if (!window.sugar._webComponentsClasses) window.sugar._webComponentsClasses = {};
	if (!window.sugar._webComponentsDefaultProps) window.sugar._webComponentsDefaultProps = {};
	if (!window.sugar._webComponentsDefaultCss) window.sugar._webComponentsDefaultCss = {};

	var SWebComponentMixin = (0, _mixwith.Mixin)(function (superclass) {
		return function (_superclass) {
			_inherits(_class2, _superclass);

			_createClass(_class2, [{
				key: 'defaultProps',


				/**
	    * Get the default props for this particular instance
	    * @type  		{Object}
	    */
				get: function get() {

					// check if default props in cache to avoid multiple time
					// computing
					if (this._defaultPropsCache) return this._defaultPropsCache;

					// compute
					var props = window.sugar._webComponentsClasses[this.componentName].defaultProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultProps) {
							props = _extends({}, comp.defaultProps, props);
						}
						if (comp._defaultProps) {
							props = _extends({}, props, comp._defaultProps);
						}
						comp = Object.getPrototypeOf(comp);
					}
					// extend with default props stored in the component default props stack by tagname
					if (window.sugar._webComponentsDefaultProps[this.componentName]) {
						props = _extends({}, props, window.sugar._webComponentsDefaultProps[this.componentName]);
					}

					// save in cache
					this._defaultPropsCache = Object.assign({}, props);

					// return props
					return props;
				}

				/**
	    * Return an array of props to set on the dom
	    * @return 		{Array}
	    */

			}, {
				key: 'physicalProps',


				/**
	    * Get physical props for this particular instance
	    * @return 		{Array} 			The physical props array
	    */
				get: function get() {

					if (this._physicalPropsCache) return this._physicalPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].physicalProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.physicalProps) {
							comp.physicalProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._physicalPropsCache = props;

					return props;
				}

				/**
	    * Return an array of required props to init the component
	    * @return 		{Array}
	    */

			}, {
				key: 'requiredProps',


				/**
	    * Get the required props array for this particular instance
	    * @return 		{Array} 			An array of required props
	    */
				get: function get() {

					if (this._requiredPropsCache) return this._requiredPropsCache;

					var props = window.sugar._webComponentsClasses[this.componentName].requiredProps;
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.requiredProps) {
							comp.requiredProps.forEach(function (prop) {
								if (props.indexOf(prop) === -1) {
									props.push(prop);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._requiredPropsCache = props;

					return props;
				}

				/**
	    * Specify the default css for the component
	    * @param 		{String} 		componentName 		The camelcase component name
	    * @param 		{String} 		componentNameDash 	The dashcase component name
	    * @return 		{String} 							The default css for the component
	    */

			}, {
				key: 'defaultCss',


				/**
	    * Get the default css of the component
	    * @type 		{String}
	    */
				get: function get() {

					if (this._defaultCssCache) return this._defaultCssCache;

					var css = '';
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.defaultCss) {
							css += comp.defaultCss(this.componentName, this.componentNameDash);
						}
						comp = Object.getPrototypeOf(comp);
					}

					this._defaultCssCache = css;

					return css;
				}

				/**
	    * Return an array of props to set on the dom
	    * @type 		{Array}
	    */

			}, {
				key: 'mountDependencies',


				/**
	    * Get an array of promises to resolve before mounting the component.
	    * @type 		{Array<Promise>}
	    */
				get: function get() {
					var _this2 = this;

					var deps = [];
					var comp = window.sugar._webComponentsClasses[this.componentName];
					while (comp) {
						if (comp.mountDependencies) {
							comp.mountDependencies.forEach(function (dep) {
								if (deps.indexOf(dep) === -1) {
									deps.push(dep);
								}
							});
						}
						comp = Object.getPrototypeOf(comp);
					}

					// props mount dependencies
					deps = deps.concat(this.props.mountDependencies);
					var finalDeps = [];
					deps.forEach(function (dep) {
						if (typeof dep === 'function') {
							dep = dep.bind(_this2);
							dep = dep();
						}
						finalDeps.push(dep);
					});
					return finalDeps;
				}

				/**
	    * Constructor
	    * @protected
	    */

			}], [{
				key: 'define',


				/**
	    * Define the new web component
	    * @param 			{String} 			name 		The name of the component
	    * @param 			{Object|String} 	[componentClassOrExt=null] 	The component class or the HTML tag to extend like "input", "button", etc...
	    * @param 			{Object|String}		ext 		The HTML tag to extend like "input", "button", etc...
	    */
				value: function define(name) {
					var componentOrExt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


					var component = componentOrExt && typeof componentOrExt !== 'string' ? componentOrExt : this;
					var componentName = (0, _upperFirst2.default)((0, _camelize2.default)(name));
					var componentNameDash = name;

					ext = typeof componentOrExt === 'string' ? componentOrExt : ext;

					if (window.sugar._webComponentsClasses[componentName]) return;
					window.sugar._webComponentsClasses[componentName] = component;

					// register the webcomponent
					if (window.customElements) {
						var extendsObj = {};
						if (ext) {
							extendsObj.extends = ext;
						}
						window.customElements.define(name, component, extendsObj);
					} else if (document.registerElement) {
						document.registerElement(name, {
							prototype: component.prototype,
							extends: ext
						});
					} else {
						throw 'Your browser does not support either document.registerElement or window.customElements.define webcomponents specification...';
					}

					// create a proxy factory
					var webcomponent = function webcomponent() {
						var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						if (ext) {
							return document.createElement(ext, name).setProps(props);
						}
						return document.createElement(name).setProps(props);
					};

					// fix for firefox and surely other crapy browser...
					// this make sur that the (static) methods of the component
					// are present on the webcomponent itself
					var staticFns = [];
					var comp = component;
					while (comp) {
						try {
							staticFns = staticFns.concat(Object.getOwnPropertyNames(comp).filter(function (prop) {
								return typeof comp[prop] === "function";
							}));
							comp = Object.getPrototypeOf(comp);
						} catch (e) {
							break;
						}
					}
					var keys = staticFns.concat(Object.keys(component));
					keys.forEach(function (key) {
						if (!webcomponent[key]) {
							webcomponent[key] = component[key];
						}
					});

					// handle css
					component._injectDefaultCss(component, componentName, componentNameDash);

					// return the webcomponent instance
					return webcomponent;
				}

				/**
	    * Inject css into html
	    * @param 		{HTMLElement}	componentClass 		The component class for which to inject the base css
	    * @param 		{String} 		componentName 		The component name
	    * @param 		{String} 		componentNameDash 	The dash formated component name
	    */

			}, {
				key: '_injectDefaultCss',
				value: function _injectDefaultCss(componentClass, componentName, componentNameDash) {
					// check if component has a css to be injected into the page
					if (window.sugar._webComponentsDefaultCss[componentName] === undefined) {
						var css = '';
						var comp = componentClass;
						while (comp) {
							if (comp.defaultCss) {
								css += comp.defaultCss(componentName, componentNameDash);
							}
							comp = Object.getPrototypeOf(comp);
						}
						if (css) {
							css = css.replace(/[\s]+/g, ' ');
							window.sugar._webComponentsDefaultCss[componentName] = css;
							var styleElm = document.createElement('style');
							styleElm.setAttribute('name', componentName);
							styleElm.innerHTML = css;
							(0, _prependChild2.default)(styleElm, document.head);
						} else {
							window.sugar._webComponentsDefaultCss[componentName] = false;
						}
					}
				}

				/**
	    * Internal store for all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */


				/**
	    * Store all the props of the component
	    * Props are actual computed props with attributes
	    * @type 		{Object}
	    */

			}, {
				key: 'setDefaultProps',


				/**
	    * Set some default props for a specific component
	    * @param 		{Object} 		props 			A props object to set
	    * @param 		{String} 		[tagname=null] 	The tagname of the component you want to setting up
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */
				value: function setDefaultProps(props) {
					var tagname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// if a tagname is specified, we store the default props for a
					// particular tagname
					if (tagname) {
						tagname = [].concat(tagname);
						tagname.forEach(function (tag) {
							tag = (0, _upperFirst2.default)((0, _camelize2.default)(tag));
							window.sugar._webComponentsDefaultProps[tag] = _extends({}, window.sugar._webComponentsDefaultProps[tag] || {}, props);
						});
					} else {
						var proto = this;
						proto._defaultProps = _extends({}, proto._defaultProps || {}, props);
					}
				}
			}, {
				key: 'defaultCss',
				value: function defaultCss(componentName, componentNameDash) {
					return '';
				}
			}, {
				key: 'defaultProps',


				/**
	    * Return the default props for the component.
	    * Need to take care of the passed props parameter and mix it at the
	    * end of your default props
	    *
	    * @type 	{Object}
	    * @example
	    * getDefaultProps(props = {}) {
	    * 		return super.getDefaultProps({
	    * 			myCoolProp : null,
	    * 			...props
	    * 		});
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */
				get: function get() {
					return {
						mountWhen: null,
						mountDependencies: [],
						unmountTimeout: 500
					};
				}
			}, {
				key: 'physicalProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'requiredProps',
				get: function get() {
					return [];
				}
			}, {
				key: 'mountDependencies',
				get: function get() {
					return [];
				}
			}]);

			function _class2() {
				var _ref;

				var _temp, _this, _ret;

				_classCallCheck(this, _class2);

				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				var self = (_temp = (_this = _possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args))), _this), _this._props = {}, _this.props = {}, _temp);
				self.init();
				return _ret = self, _possibleConstructorReturn(_this, _ret);
			}

			_createClass(_class2, [{
				key: 'init',
				value: function init() {
					this.createdCallback();
				}

				/**
	    * When the component is created.
	    * This is called even if the component is not attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'createdCallback',
				value: function createdCallback() {

					// props
					this.props = this.props || {};

					// track the lifecyle
					this._lifecycle = {
						componentWillMount: false,
						componentMount: false,
						componentUnmount: false
					};

					// created callback
					this.componentCreated();
				}

				/**
	    * When the element is attached in the DOM tree
	    * @protected
	    */

			}, {
				key: 'connectedCallback',
				value: function connectedCallback() {
					var _this3 = this;

					// if not already passed through the created process
					if (!this._lifecycle) this.createdCallback();

					// update attached status
					this._componentAttached = true;

					// clear the unmount timeout
					clearTimeout(this._unmountTimeout);

					// stop here if already mounted once
					if (this._lifecycle.componentMount || this._lifecycle.componentWillMount) return;

					// set the componentName
					var sourceName = this.getAttribute('is') || this.tagName.toLowerCase();
					this.componentNameDash = this._componentNameDash = sourceName;
					this.componentName = this._componentName = (0, _upperFirst2.default)((0, _camelize2.default)(sourceName));

					// default props init
					this._props = Object.assign({}, this.defaultProps, this._props || {}, this.props);

					// if we have some initial props, we set them now
					if (this._initialProps) this.setProps(this._initialProps);

					// init properties proxy object
					if (window.Proxy) {
						this.props = new Proxy(this._props, {
							set: function set(target, property, value) {
								// get the old value
								var oldVal = target[property];
								// apply the new value
								target[property] = value;
								// handle the new property value
								_this3._handleNewPropValue(property, value, oldVal);
								// notify the proxy that the property has been updated
								return true;
							},
							get: function get(target, property) {
								// simply return the property value from the target
								return target[property];
							}
						});
					} else {
						this.props = this._props;
					}

					// listen for updates on the element itself
					// instead of using the attributesChangedCallback
					// cause with the attributesChangedCallback, you'll need to declare
					// at start which attributes to listen and this behavior is not suitable
					// for new attributes added after the component creation...
					var observer = new MutationObserver(function (mutationList) {
						var mutatedAttributes = [];
						mutationList.forEach(function (mutation) {
							if (mutatedAttributes.indexOf(mutation.attributeName) === -1) {
								_this3._attributeMutationCallback(mutation.attributeName, mutation.oldValue, _this3.getAttribute(mutation.attributeName));
							}
							mutatedAttributes.push(mutation.attributeName);
						});
					});
					observer.observe(this, {
						attributes: true,
						attributeOldValue: true
					});

					// internal properties
					this._nextPropsStack = {};
					this._prevPropsStack = {};
					this._fastdomSetProp = null;

					// compute props
					this._initInitialAttributes();

					// props proxy
					// this._initPropsProxy();

					// check the required props
					this.requiredProps.forEach(function (prop) {
						if (!_this3.props[prop]) {
							throw 'The "' + _this3.componentNameDash + '" component need the "' + prop + '" property in order to work';
						}
					});

					// component will mount only if part of the active document
					this.componentWillMount();

					// wait until dependencies are ok
					this._whenMountDependenciesAreOk().then(function () {
						// switch on the mountWhen prop
						switch (_this3.props.mountWhen) {
							case 'inViewport':
							case 'isInViewport':
								(0, _whenInViewport2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							case 'isMouseover':
							case 'mouseover':
								_this3.addEventListener('mouseover', _this3._onMouseoverComponentMount.bind(_this3));
								break;
							case 'isVisible':
							case 'visible':
								(0, _whenVisible2.default)(_this3).then(function () {
									_this3._mountComponent();
								});
								break;
							default:
								// mount component directly
								_this3._mountComponent();
								break;
						}
					});
				}
			}, {
				key: 'attachedCallback',
				value: function attachedCallback() {
					this.connectedCallback();
				}

				/**
	    * When any of the component attribute changes
	    * @param 		{String} 		attribute 		The attribute name that has changed
	    * @param 		{String}		oldVal 			The previous attribute value
	    * @param 		{String} 		newVal 			The new attribute value
	    * @protected
	    */

			}, {
				key: '_attributeMutationCallback',
				value: function _attributeMutationCallback(attribute, oldVal, newVal) {

					// stop if the attribute has not changed
					if (oldVal === newVal) return;

					// keep an original attribute name
					var _attribute = attribute;

					// process the attribute to camelCase
					attribute = (0, _camelize2.default)(attribute);

					// if the property is not a real property
					if (!this.shouldComponentAcceptProp(attribute)) return;

					// cast the new val
					newVal = (0, _autoCast2.default)(newVal);

					// handle the case when newVal is undefined (added attribute whithout any value)
					if ((newVal === undefined || newVal === null || newVal === '') && this.hasAttribute(_attribute)) {
						newVal = true;
					} else if (newVal === null && !this.hasAttribute(_attribute) && this.props[attribute] === false) {
						// the attribute has been removed and
						// the prop is already to false
						return;
					}

					// do nothing if the value is already the same
					if (this.props[attribute] === newVal) return;

					// set the new prop
					this.setProp(attribute, newVal);
				}

				/**
	    * Called directly when the component is created. This act like a constructor.
	    *
	    * @example
	    * componentCreated() {
	    * 		// call parent method
	    * 		super.componentCreated();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'componentCreated',
				value: function componentCreated() {}

				/**
	    * Method called before the component will actually mount and BEFORE the the mountDependencies to be resolved or not.
	    * This is a good place to do directl when the component is attached in the DOM but before any dependencies are resolved
	    *
	    * @example
	    * componentWillMount() {
	    * 		// call parent method
	    * 		super.componentWillMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'componentWillMount',
				value: function componentWillMount() {
					// protect from mounting multiple times when unecessary
					if (this._lifecycle.componentWillMount) return;

					// update lifecycle state
					this._lifecycle.componentWillMount = true;
				}

				/**
	    * Method called right after that the component has been added in the dom,
	    * after and only if the mountDependencies are resolved
	    * and before the initial render.
	    *
	    * @example
	    * componentMount() {
	    * 		// call parent method
	    * 		super.componentMount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'componentMount',
				value: function componentMount() {
					if (this._lifecycle.componentMount) return;
					// update the lifecycle state
					this._lifecycle.componentMount = true;
					// mark the component as mounted
					this.setAttribute('mounted', true);
				}

				/**
	    * Apply all the updated that you need in the dom for the component to reflect the props
	    *
	    * @example
	    * render() {
	    * 		// call the parent method
	    * 		super.render();
	    * 		// apply some classes, properties, styles, etc... in the dom
	    * 		// in order to reflect the props object state
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'render',
				value: function render() {}

				/**
	    * Method called when the component need to unmount itself cause it has been removed from the DOM tree and the props.unmountTimeout is passed.
	    *
	    * @example
	    * componentUnmount() {
	    * 		// call parent method
	    * 		super.componentUnmount();
	    * 		// do something here...
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'componentUnmount',
				value: function componentUnmount() {
					if (this._lifecycle.componentUnmount) return;
					// update lifecycle state
					this._lifecycle.componentUnmount = true;
					// remove the component mounted attribute
					this.removeAttribute('mounted');
				}

				/**
	    * Check all the mountDependencies and try to resolve them.
	    * @return 			{Promise} 				A promise that will be resolved when the dependencies are resolved
	    */

			}, {
				key: '_whenMountDependenciesAreOk',
				value: function _whenMountDependenciesAreOk() {
					var _this4 = this;

					var promise = new Promise(function (resolve, reject) {
						var deps = _this4.mountDependencies;
						if (!deps.length) {
							resolve();
						} else {
							// resolve all the promises
							Promise.all(deps).then(function () {
								resolve();
							});
						}
					});
					return promise;
				}

				/**
	    * Init props proxy.
	    * This will create a getter/setter accessor on the item itself
	    * that get and update his corresponding props.{name} property
	    */
				// _initPropsProxy() {
				// 	// loop on each props
				// 	for(let key in this.defaultProps) {
				// 		if (this.hasOwnProperty(key) || key in this) {
				// 			if (this.props.debug) {
				// 				console.warn(`The component ${this.componentNameDash} has already an "${key}" property... This property will not reflect the this.props['${key}'] value... Try to use a property name that does not already exist on an HTMLElement...`);
				// 			}
				// 			continue;
				// 		}
				// 		((key) => {
				// 			Object.defineProperty(this, key, {
				// 				get : () => {
				// 					return this.props[key];
				// 				},
				// 				set : (value) => {
				// 					this.setProp(key, __autoCast(value));
				// 				},
				// 				enumarable : true
				// 			});
				// 		})(key);
				// 	}
				// }

				/**
	    * On mouse over
	    */

			}, {
				key: '_onMouseoverComponentMount',
				value: function _onMouseoverComponentMount() {
					this._mountComponent();
					this.removeEventListener('mouseover', this._onMouseoverComponentMount);
				}

				/**
	    * Internal mount component method
	    */

			}, {
				key: '_mountComponent',
				value: function _mountComponent() {
					var _this5 = this;

					// wait next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = this.mutate(function () {
						// sometimes, the component has been unmounted between the
						// fastdom execution, so we stop here if it's the case
						if (!_this5._componentAttached) return;
						// init
						_this5.componentMount();
						// render
						_this5.render();
					});
				}

				/**
	    * Detect when the component is detached from the DOM tree.
	    * @protected
	    */

			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					var _this6 = this;

					// update attached status
					this._componentAttached = false;

					// unmount timeout
					clearTimeout(this._unmountTimeout);
					this._unmountTimeout = setTimeout(function () {
						// wait next frame
						_fastdom2.default.clear(_this6._fastdomSetProp);
						_this6._fastdomSetProp = _this6.mutate(function () {
							// unmount only if the component is mounted
							if (!_this6._lifecycle.componentMount) return;
							// unmount
							_this6.componentUnmount();
							// update lifecycle
							_this6._lifecycle.componentMount = false;
						});
					}, this.props.unmountTimeout);
				}
			}, {
				key: 'detachedCallback',
				value: function detachedCallback() {
					this.disconnectedCallback();
				}

				/**
	    * Dispatch an event from the tag with namespaced event name
	    * This will dispatch actually two events :
	    * 1. {tagName}.{name} : example : s-datepicker.change
	    * 2. {name} 		   : example : change
	    *
	    * @param		{String} 		name 		The event name
	    * @param 		{Mixed} 		data 		Some data to attach to the event
	    */

			}, {
				key: 'dispatchComponentEvent',
				value: function dispatchComponentEvent(name) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var fromElm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

					(0, _dispatchEvent2.default)(fromElm, name, data);
					(0, _dispatchEvent2.default)(fromElm, this.tagName.toLowerCase() + '.' + name, data);
				}

				/**
	    * Set a bunch of properties at once
	    * @param 			{Object} 		[props={}] 		An object of props to set
	    */

			}, {
				key: 'setProps',
				value: function setProps() {
					var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

					// set each props
					for (var key in props) {
						this.setProp(key, props[key]);
					}
					// return the component
					return this;
				}

				/**
	    * Set a property
	    * @param 			{String} 		prop 			The property name to set
	    * @param 			{Mixed} 		value 			The new property value
	    */

			}, {
				key: 'setProp',
				value: function setProp(prop, value) {
					var set = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;


					// if the component is not attached to the dom, we don't have the props etc
					// so we save them inside an object that we will merge later in the props
					if (!this._componentAttached) {
						if (!this._initialProps) this._initialProps = {};
						this._initialProps[prop] = value;
						return;
					}

					// save the oldVal
					var oldVal = this.props[prop];

					// stop if same value
					if (oldVal === value) return;

					// set the prop
					this._props[prop] = value;

					// handle new value
					this._handleNewPropValue(prop, value, oldVal);

					// return the component
					return this;
				}

				/**
	    * Get a property
	    * @param 		{String} 		prop 			The property name to get
	    * @return 		{Mixed} 						The property value or null
	    */

			}, {
				key: 'getProp',
				value: function getProp(prop) {
					return this.props[prop];
				}

				/**
	    * Handle new property
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    */

			}, {
				key: '_handleNewPropValue',
				value: function _handleNewPropValue(prop, newVal, oldVal) {
					var _this7 = this;

					// if the component is not mounted
					// we do nothing here...
					if (!this.isComponentMounted()) return;

					// create the stacks
					this._prevPropsStack[prop] = oldVal;
					this._nextPropsStack[prop] = newVal;

					// component will receive prop
					this.componentWillReceiveProp(prop, newVal, oldVal);

					// wait till next frame
					_fastdom2.default.clear(this._fastdomSetProp);
					this._fastdomSetProp = _fastdom2.default.mutate(function () {

						// create array version of each stacks
						var nextPropsArray = [],
						    prevPropsArray = [];
						for (var key in _this7._nextPropsStack) {
							var val = _this7._nextPropsStack[key];
							nextPropsArray.push({
								name: key,
								value: val
							});

							// handle physical props
							_this7._handlePhysicalProp(key, val);
						}
						for (var _key2 in _this7._prevPropsStack) {
							var _val = _this7._prevPropsStack[_key2];
							prevPropsArray.push({
								name: _key2,
								value: _val
							});
						}

						// call the will reveiveProps if exist
						if (_this7.componentWillReceiveProps) {
							_this7.componentWillReceiveProps(_this7._nextPropsStack, nextPropsArray);
						}

						// should component update
						if (_this7.shouldComponentUpdate && !_this7.shouldComponentUpdate(_this7._nextPropsStack, _this7._prevPropsStack)) return;

						// render the component
						_this7.render();
					});
				}

				/**
	    * Get the previous props stack
	    * @return    {Object}    The previous props stack
	    */

			}, {
				key: 'getPreviousPropsStack',
				value: function getPreviousPropsStack() {
					return this._prevPropsStack;
				}

				/**
	    * Get the next props stack
	    * @return    {Object}    The next props stack
	    */

			}, {
				key: 'getNextPropsStack',
				value: function getNextPropsStack() {
					return this._nextPropsStack;
				}

				/**
	    * Method called when the component will receive new props
	    * @param 		{String} 		prop 		The property name
	    * @param 		{Mixed} 		newVal 		The new property value
	    * @param 		{Mixed}			oldVal 		The old property value
	    * @example 	js
	    * componentWillReceiveProp(prop, newVal, oldVal) {
	    *  	switch(prop) {
	    *  		case ...
	    *    			// do something...
	    * 			break;
	    *  	}
	    * }
	    *
	    * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: 'componentWillReceiveProp',
				value: function componentWillReceiveProp(prop, newVal, oldVal) {}
				// do something


				/**
	    * Method that check if a property passed to the component has to be accepted or not.
	    * @param 		{String} 			prop 		The property name
	    * @return 		{Boolean} 						If true, the property will be accepted, if false, it will not be considered as a property
	    */

			}, {
				key: 'shouldComponentAcceptProp',
				value: function shouldComponentAcceptProp(prop) {
					return this.props[prop] !== undefined;
				}

				/**
	    * Check if component is mounted
	    * @return 			{Boolean} 			true if mounted, false if not
	    */

			}, {
				key: 'isComponentMounted',
				value: function isComponentMounted() {
					return this._lifecycle.componentMount;
				}

				/**
	    * Handle physical props by setting or not the prop
	    * on the dom element as attribute
	    * @param 			{String} 			prop 			The property to handle
	    * @param 			{Mixed} 			value 			The property value
	    * @author 			Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	    */

			}, {
				key: '_handlePhysicalProp',
				value: function _handlePhysicalProp(prop, value) {
					// check if is a physical prop to set it in the dom
					var physicalProps = this.physicalProps;
					if (physicalProps.indexOf(prop) !== -1) {
						// set the prop on the node
						if (value !== 0 && (value === false || value === 'null' || !value)) {
							this.removeAttribute((0, _uncamelize2.default)(prop));
						} else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
							this.setAttribute((0, _uncamelize2.default)(prop), JSON.stringify(value));
						} else if (typeof value === 'function') {
							this.setAttribute((0, _uncamelize2.default)(prop), 'fn');
						} else {
							this.setAttribute((0, _uncamelize2.default)(prop), value);
						}
					}
				}

				/**
	    * Compute props by mixing settings with attributes presents on the component
	    */

			}, {
				key: '_initInitialAttributes',
				value: function _initInitialAttributes() {
					for (var i = 0; i < this.attributes.length; i++) {
						var attr = this.attributes[i];
						var attrCamelName = (0, _camelize2.default)(attr.name);
						// do not set if it's not an existing prop
						if (!this.shouldComponentAcceptProp(attrCamelName)) continue;
						// the attribute has no value but it is present
						// so we assume the prop value is true
						if (!attr.value) {
							this._props[attrCamelName] = true;
							continue;
						}
						// cast the value
						this._props[attrCamelName] = (0, _autoCast2.default)(attr.value);
					}

					// handle physicalProps
					for (var key in this.props) {
						var value = this.props[key];
						// handle physical props
						this._handlePhysicalProp(key, value);
					}
				}

				/**
	    * Mutate the dom using an optimize requestAnimationFrame technique
	    * @param 		{Function} 		cb 			The callback to exexute
	    */

			}, {
				key: 'mutate',
				value: function mutate(cb) {
					return _fastdom2.default.mutate(cb);
				}

				/**
	    * Set a class that will be construct with the componentNameDash,
	    * an optional element and modifier
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentClassName',
				value: function componentClassName() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					// if the method is BEM
					var sel = this.componentNameDash;
					if (element) {
						sel += '__' + element;
					}
					if (modifier) {
						sel += '--' + modifier;
					}
					if (state) {
						sel += '--' + state;
					}
					return sel;
				}

				/**
	    * Get a component selector class built with the passed element, modifier and state parameters
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{String} 						The generated class
	    */

			}, {
				key: 'componentSelector',
				value: function componentSelector() {
					var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
					var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

					var sel = this.componentClassName(element, modifier, state);
					sel = ('.' + sel).replace(' ', '.');
					return sel;
				}

				/**
	    * Check if the passed element has the component class generated by the element and modifier argument
	    * @param 	{HTMLElement} 	elm 				The element to check
	    * @param 	{String} 		[element=null] 		The element name
	    * @param 	{String} 		[modifier=null] 	The modifier name
	    * @param 	{String} 		[state=null] 		The state name
	    * @return 	{Boolean} 							The check result
	    */

			}, {
				key: 'hasComponentClass',
				value: function hasComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// generate the class
					var cls = this.componentSelector(element, modifier, state);
					var _cls = cls.split('.');
					for (var i = 0; i < _cls.length; i++) {
						var cl = _cls[i];
						if (cl && cl !== '') {
							if (!elm.classList.contains(cl)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
	    * Add a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 			The component itself
	    */

			}, {
				key: 'addComponentClass',
				value: function addComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this8 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this8.addComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this8.mutate(function () {
								elm.classList.add(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}

				/**
	    * Remove a class on the passed element that will be construct with the componentNameDash,
	    * an optional element, modifier and state
	    * @param 	{String} 	[element=null] 		The element name
	    * @param 	{String} 	[modifier=null] 	The modifier name
	    * @param 	{String} 	[state=null] 		The state name
	    * @return 	{SComponent}} 					The component itself
	    */

			}, {
				key: 'removeComponentClass',
				value: function removeComponentClass(elm) {
					var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					var _this9 = this;

					var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
					var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

					// if is an array
					if (elm instanceof Array || elm instanceof NodeList) {
						[].forEach.call(elm, function (el) {
							_this9.removeComponentClass(el, element, modifier, state);
						});
						return this;
					}

					// get the component class
					var cls = this.componentSelector(element, modifier, state);
					// loop on each classes to add
					cls.split('.').forEach(function (cl) {
						if (cl && cl !== '') {
							_this9.mutate(function () {
								elm.classList.remove(cl);
							});
						}
					});
					// return the instance to maintain chainability
					return this;
				}
			}]);

			return _class2;
		}(superclass);
	});

	// Export the mixin class
	exports.default = SWebComponentMixin;

/***/ }),
/* 540 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = autoCast;
	/**
	 * Auto cast the string into the correct variable type
	 */
	function autoCast(string) {

		// if the passed string is not a string, return the value
		if (typeof string !== 'string') return string;

		// handle the single quotes strings like '"hello world"'
		if (string.substr(0, 1) === '\'' && string.substr(-1) === '\'') {
			return string.substr(1, string.length - 2);
		}

		// number
		// before the window check cause window['0'] correspond to something
		var presumedNumber = parseFloat(string);
		if (!isNaN(presumedNumber)) {
			if (presumedNumber.toString() === string) {
				return presumedNumber;
			}
		}

		// avoid getting item from the window object
		if (window[string]) {
			return string;
		}

		// try to eval the passed string
		// if no exception, mean that it's a valid
		// js variable type
		try {
			var obj = eval('(' + string + ')');
			return obj;
		} catch (e) {
			// assume that the string passed is a string
			return string;
		}
	}

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(542);


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(543),
	    createAssigner = __webpack_require__(547),
	    keysIn = __webpack_require__(556);

	/**
	 * This method is like `_.assign` except that it iterates over own and
	 * inherited source properties.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assign
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	 */
	var assignIn = createAssigner(function(object, source) {
	  copyObject(source, keysIn(source), object);
	});

	module.exports = assignIn;


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(544),
	    baseAssignValue = __webpack_require__(545);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(545),
	    eq = __webpack_require__(408);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(546);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(418);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(548),
	    isIterateeCall = __webpack_require__(555);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(509),
	    overRest = __webpack_require__(549),
	    setToString = __webpack_require__(551);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(550);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ }),
/* 550 */
/***/ (function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(552),
	    shortOut = __webpack_require__(554);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(553),
	    defineProperty = __webpack_require__(546),
	    identity = __webpack_require__(509);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ }),
/* 553 */
/***/ (function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ }),
/* 554 */
/***/ (function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(408),
	    isArrayLike = __webpack_require__(485),
	    isIndex = __webpack_require__(475),
	    isObject = __webpack_require__(427);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(468),
	    baseKeysIn = __webpack_require__(557),
	    isArrayLike = __webpack_require__(485);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(427),
	    isPrototype = __webpack_require__(482),
	    nativeKeysIn = __webpack_require__(558);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ }),
/* 558 */
/***/ (function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ }),
/* 559 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = camelize;
	/**
	 * Camelize a string
	 */
	function camelize(text) {
		var res = '';
		res = text.replace(/(?:^|[-_])(\w)/g, function (_, c) {
			return c ? c.toUpperCase() : '';
		});
		res = res.substr(0, 1).toLowerCase() + res.slice(1);
		return res.trim();
	}

/***/ }),
/* 560 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = uncamelize;
	/**
	 * Uncamelize a string
	 * @param    {String}    string    The string to uncamelize
	 * @param    {String}    [separator='-']    The separator to use
	 * @return    {String}    The uncamelized string
	 *
	 * @example    js
	 * import uncamelize from 'coffeekraken-sugar/js/utils/strings/uncamelize'
	 * uncamelize('helloWorldAndUniverse') // hello-world-and-universe
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function uncamelize(text) {
	  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';

	  // Replace all capital letters by separator followed by lowercase one
	  var res = '';
	  res = text.replace(/[A-Z]/g, function (letter) {
	    return separator + letter.toLowerCase();
	  });

	  // Remove first separator (to avoid _hello_world name)
	  return res.replace("/^" + separator + "/", '').trim();
	}

/***/ }),
/* 561 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = upperFirst;
	/**
	 * Upper first
	 * @param    {String}    string    The string to process
	 * @return    {String}    The processed string with first letter uppercase
	 *
	 * @example    js
	 * import upperFirst from 'coffeekraken-sugar/js/utils/strings/upperFirst'
	 * upperFirst('hello world') // Hello world
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function upperFirst(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

/***/ }),
/* 562 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependChild;
	/**
	 * Prepend an HTMLElement into another HTMLElement
	 *
	 * @name 		prependChild
	 * @param 		{HTMLElement} 				elm  		The element to prepend
	 * @param 		{HTMLElement} 				refElm 		The element in which to prepend the new element
	 * @example  	js
	 * import prependChild from 'sugarcss/js/dom/prependChild'
	 * prependChild(myElementToInsert, theReferenceElement);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function prependChild(elm, refElm) {
	  if (!refElm.firstChild) {
	    refElm.appendChild(elm);
	  } else {
	    refElm.insertBefore(elm, refElm.firstChild);
	  }
	}

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = propertyProxy;

	var _get2 = __webpack_require__(495);

	var _get3 = _interopRequireDefault(_get2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Create a proxy for and object property.
	 * This gives you the possibility to process the data of the property
	 * when it is getted or setted.
	 *
	 * @name 		propertyProxy
	 * @param 		{Object} 		obj 			The object on which to create the proxy
	 * @param 		{String} 		property 		The property name that will be proxied
	 * @param 		{Object} 		descriptor 		A descriptor object that contains at least a get or a set method, or both
	 * @param 		{Boolean} 		applySetterAtStart 	If need to apply the descriptor setter directly on the current value or not
	 *
	 * @example 	js
	 * const myObject = {
	 * 		title : 'World'
	 * };
	 * // create the proxy
	 * propertyProxy(myObject, 'title', {
	 * 		get : (value) => {
	 * 			return `Hello ${value}`;
	 * 		},
	 * 		set : (value) => {
	 * 			return `Youhou ${value}`;
	 * 		}
	 * });
	 * console.log(myObject.title) => 'Hello World';
	 * myObject.title = 'Universe';
	 * console.log(myObject.title) => 'Hello Youhou Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function propertyProxy(obj, property, descriptor) {
		var applySetterAtStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


		// store the current value
		var val = (0, _get3.default)(obj, property);
		var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

		// custom setter check
		var _set = function _set(value) {

			if (descriptor.set) {
				value = descriptor.set(value);
			}

			// descriptor
			if (currentDescriptor && currentDescriptor.set) {
				var ret = currentDescriptor.set(value);
				if (ret) {
					val = ret;
				} else {
					val = currentDescriptor.get();
				}
			} else {
				val = value;
			}
		};

		// apply the setter if needed
		if (applySetterAtStart) _set(val);

		// make sure we have the good descriptor
		var d = Object.getOwnPropertyDescriptor(obj, property);
		Object.defineProperty(obj, property, {
			get: function get() {
				var _val = val;
				if (descriptor.get) {
					_val = descriptor.get(_val);
				}
				if (currentDescriptor && currentDescriptor.get) {
					_val = currentDescriptor.get();
				}
				return _val;
			},
			set: function set(v) {
				// const oldValue = val;
				// internal set to use the good setter
				_set(v);
				// notify of new update
				// this.notify(objPath, val, oldValue);
			},
			configurable: descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
			enumarable: descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
			// writable : currentDescriptor && currentDescriptor.writable !== undefined ? currentDescriptor.writable : true
		});

		// return the value
		return val;
	}

/***/ }),
/* 564 */
/***/ (function(module, exports) {

	/**
	 * Code refactored from Mozilla Developer Network:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	 */

	'use strict';

	function assign(target, firstSource) {
	  if (target === undefined || target === null) {
	    throw new TypeError('Cannot convert first argument to object');
	  }

	  var to = Object(target);
	  for (var i = 1; i < arguments.length; i++) {
	    var nextSource = arguments[i];
	    if (nextSource === undefined || nextSource === null) {
	      continue;
	    }

	    var keysArray = Object.keys(Object(nextSource));
	    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
	      var nextKey = keysArray[nextIndex];
	      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	      if (desc !== undefined && desc.enumerable) {
	        to[nextKey] = nextSource[nextKey];
	      }
	    }
	  }
	  return to;
	}

	function polyfill() {
	  if (!Object.assign) {
	    Object.defineProperty(Object, 'assign', {
	      enumerable: false,
	      configurable: true,
	      writable: true,
	      value: assign
	    });
	  }
	}

	module.exports = {
	  assign: assign,
	  polyfill: polyfill
	};


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isSamsumgBrowser;

	var _mobileDetect = __webpack_require__(528);

	var _mobileDetect2 = _interopRequireDefault(_mobileDetect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Detect if is the samsung stock browser that is running the page
	 * @example    js
	 * import isSamsumgBrowser from 'coffeekraken-sugar/js/utils/is/samsungBrowser'
	 * if (isSamsumgBrowser()) {
	 *   // do something
	 * }
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isSamsumgBrowser() {
	  return window.navigator.userAgent.match(/SamsungBrowser/i) !== null;
	}

/***/ }),
/* 566 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isUcBrowser;
	/**
	 * Detect if is the UC stock browser that is running the page
	 * @example    js
	 * import isUcBrowser from 'coffeekraken-sugar/js/utils/is/ucBrowser'
	 * if (isUcBrowser()) {
	 *   // do something
	 * }
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function isUcBrowser() {
	  return window.navigator.userAgent.match(/UCBrowser/i) !== null;
	}

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

	var _coffeekrakenSDatepickerComponent = __webpack_require__(568);

	var _coffeekrakenSDatepickerComponent2 = _interopRequireDefault(_coffeekrakenSDatepickerComponent);

	var _coffeekrakenSGoogleMapComponent = __webpack_require__(571);

	var _coffeekrakenSGoogleMapComponent2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponent);

	var _coffeekrakenSGoogleMapMarkerComponent = __webpack_require__(576);

	var _coffeekrakenSGoogleMapMarkerComponent2 = _interopRequireDefault(_coffeekrakenSGoogleMapMarkerComponent);

	var _coffeekrakenSRippleComponent = __webpack_require__(596);

	var _coffeekrakenSRippleComponent2 = _interopRequireDefault(_coffeekrakenSRippleComponent);

	var _coffeekrakenSEqualizeComponent = __webpack_require__(610);

	var _coffeekrakenSEqualizeComponent2 = _interopRequireDefault(_coffeekrakenSEqualizeComponent);

	var _coffeekrakenSShareComponent = __webpack_require__(612);

	var _coffeekrakenSShareComponent2 = _interopRequireDefault(_coffeekrakenSShareComponent);

	var _coffeekrakenSBodymovinComponent = __webpack_require__(616);

	var _coffeekrakenSBodymovinComponent2 = _interopRequireDefault(_coffeekrakenSBodymovinComponent);

	var _coffeekrakenSITypedComponent = __webpack_require__(624);

	var _coffeekrakenSITypedComponent2 = _interopRequireDefault(_coffeekrakenSITypedComponent);

	var _coffeekrakenSResponsiveImgComponent = __webpack_require__(627);

	var _coffeekrakenSResponsiveImgComponent2 = _interopRequireDefault(_coffeekrakenSResponsiveImgComponent);

	var _coffeekrakenSCharactersSlideshowComponent = __webpack_require__(630);

	var _coffeekrakenSCharactersSlideshowComponent2 = _interopRequireDefault(_coffeekrakenSCharactersSlideshowComponent);

	var _coffeekrakenSIconComponent = __webpack_require__(632);

	var _coffeekrakenSIconComponent2 = _interopRequireDefault(_coffeekrakenSIconComponent);

	var _coffeekrakenSLayersTransitionComponent = __webpack_require__(660);

	var _coffeekrakenSLayersTransitionComponent2 = _interopRequireDefault(_coffeekrakenSLayersTransitionComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SDatepickerComponent = __webpack_require__(569);

	var _SDatepickerComponent2 = _interopRequireDefault(_SDatepickerComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SDatepickerComponent2.default.define('s-datepicker', _SDatepickerComponent2.default);

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _flatpickr = __webpack_require__(570);

	var _flatpickr2 = _interopRequireDefault(_flatpickr);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SDatepickerComponent
	 * @extends 	SWebComponent
	 * Provide a nice and powerful datepicker component around the nice flatpickr plugin.
	 * Features:
	 * - Fully featured datepicker (thanks to flatpick)
	 * - Ability to display inline as well as on field focus
	 * - Timepicker support
	 * - And more...
	 * @example 	html
	 * <input name="my-cool-date" class="form-input" />
	 * <s-datepicker for="my-cool-date"></s-datepicker>
	 * @see 	https://flatpickr.js.org/options/ 		Flatpickr documentation
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SDatepickerComponent = function (_SWebComponent) {
		_inherits(SDatepickerComponent, _SWebComponent);

		function SDatepickerComponent() {
			_classCallCheck(this, SDatepickerComponent);

			return _possibleConstructorReturn(this, (SDatepickerComponent.__proto__ || Object.getPrototypeOf(SDatepickerComponent)).apply(this, arguments));
		}

		_createClass(SDatepickerComponent, [{
			key: "shouldComponentAcceptProp",


			/**
	   * Should component accept prop
	   * @definition    SWebComponent.shouldComponentAcceptProp
	   * @protected
	   */
			value: function shouldComponentAcceptProp(name) {
				return name !== "mounted";
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: "componentMount",
			value: function componentMount() {
				_get(SDatepickerComponent.prototype.__proto__ || Object.getPrototypeOf(SDatepickerComponent.prototype), "componentMount", this).call(this);

				// get the datepicker input target
				this._targetInput = this;
				if (this.props.for) {
					// try to get the input
					var input = document.querySelector("[name=\"" + this.props.for + "\"],input#" + this.props.for);
					if (input) {
						this._targetInput = input;
					}
				}

				// instanciate the datepicker
				this._instanciateDatepicker();
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: "componentWillReceiveProp",
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case "color":
						break;
					default:
						// destroy and recreate the datepicker
						this._inputValue = this._targetInput.value;
						this._flatpickr.destroy();
						this._instanciateDatepicker();
						break;
				}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: "render",
			value: function render() {
				_get(SDatepickerComponent.prototype.__proto__ || Object.getPrototypeOf(SDatepickerComponent.prototype), "render", this).call(this);
				// copy props
				if (this.props.color) {
					this._flatpickr.calendarContainer.setAttribute("color", this.props.color);
				}
			}

			/**
	   * Create datepicker instance
	   */

		}, {
			key: "_instanciateDatepicker",
			value: function _instanciateDatepicker() {
				var _this2 = this;

				this._flatpickr = new _flatpickr2.default(this._targetInput, _extends({
					disableMobile: true
				}, this.props, {
					defaultDate: this._inputValue || this._targetInput.value || this.props.defaultDate,
					onChange: function onChange(dateObj, dateStr, instance) {
						_this2.props.onChange && _this2.props.onChange(dateObj, dateStr, instance);
						/**
	      * @name    change
	      * @event
	      * Dispatched on date change
	      */
						_this2.dispatchComponentEvent("change", {
							dateObj: dateObj,
							dateStr: dateStr,
							instance: instance
						});
					},
					parseDate: this.props.parseDate ? this.props.parseDate.bind(this) : function (date) {
						var dateInt = parseInt(date).toString();
						// if the date is a time only
						if (this.props.noCalendar && this.props.enableTime) {
							return new Date(Date.parse("2000.01.01 " + date));
						} else if (dateInt === date) {
							// it's a timestamp
							return new Date(parseInt(date) * 1000);
						}
						return new Date(Date.parse(date));
					}.bind(this),
					appendTo: this
				}));
			}
		}], [{
			key: "defaultCss",


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return "\n\t\t\t" + componentNameDash + " {\n\t\t\t\tdisplay:inline-block;\n\t\t\t}\n\t\t\t.flatpickr-calendar{background:transparent;opacity:0;display:none;text-align:center;visibility:hidden;padding:0;-webkit-animation:none;animation:none;direction:ltr;border:0;font-size:14px;line-height:24px;border-radius:5px;position:absolute;width:307.875px;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-touch-action:manipulation;touch-action:manipulation;background:#fff;-webkit-box-shadow:1px 0 0 #e6e6e6,-1px 0 0 #e6e6e6,0 1px 0 #e6e6e6,0 -1px 0 #e6e6e6,0 3px 13px rgba(0,0,0,0.08);box-shadow:1px 0 0 #e6e6e6,-1px 0 0 #e6e6e6,0 1px 0 #e6e6e6,0 -1px 0 #e6e6e6,0 3px 13px rgba(0,0,0,0.08);}.flatpickr-calendar.open,.flatpickr-calendar.inline{opacity:1;max-height:640px;visibility:visible}.flatpickr-calendar.open{display:inline-block;z-index:99999}.flatpickr-calendar.animate.open{-webkit-animation:fpFadeInDown 300ms cubic-bezier(.23,1,.32,1);animation:fpFadeInDown 300ms cubic-bezier(.23,1,.32,1)}.flatpickr-calendar.inline{display:block;position:relative;top:2px}.flatpickr-calendar.static{position:absolute;top:calc(100% + 2px);}.flatpickr-calendar.static.open{z-index:999;display:block}.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7){-webkit-box-shadow:none !important;box-shadow:none !important}.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1){-webkit-box-shadow:-2px 0 0 #e6e6e6,5px 0 0 #e6e6e6;box-shadow:-2px 0 0 #e6e6e6,5px 0 0 #e6e6e6}.flatpickr-calendar .hasWeeks .dayContainer,.flatpickr-calendar .hasTime .dayContainer{border-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.flatpickr-calendar .hasWeeks .dayContainer{border-left:0}.flatpickr-calendar.showTimeInput.hasTime .flatpickr-time{height:40px;border-top:1px solid #e6e6e6}.flatpickr-calendar.noCalendar.hasTime .flatpickr-time{height:auto}.flatpickr-calendar:before,.flatpickr-calendar:after{position:absolute;display:block;pointer-events:none;border:solid transparent;content:'';height:0;width:0;left:22px}.flatpickr-calendar.rightMost:before,.flatpickr-calendar.rightMost:after{left:auto;right:22px}.flatpickr-calendar:before{border-width:5px;margin:0 -5px}.flatpickr-calendar:after{border-width:4px;margin:0 -4px}.flatpickr-calendar.arrowTop:before,.flatpickr-calendar.arrowTop:after{bottom:100%}.flatpickr-calendar.arrowTop:before{border-bottom-color:#e6e6e6}.flatpickr-calendar.arrowTop:after{border-bottom-color:#fff}.flatpickr-calendar.arrowBottom:before,.flatpickr-calendar.arrowBottom:after{top:100%}.flatpickr-calendar.arrowBottom:before{border-top-color:#e6e6e6}.flatpickr-calendar.arrowBottom:after{border-top-color:#fff}.flatpickr-calendar:focus{outline:0}.flatpickr-wrapper{position:relative;display:inline-block}.flatpickr-months{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.flatpickr-months .flatpickr-month{background:transparent;color:rgba(0,0,0,0.9);fill:rgba(0,0,0,0.9);height:28px;line-height:1;text-align:center;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.flatpickr-months .flatpickr-prev-month,.flatpickr-months .flatpickr-next-month{text-decoration:none;cursor:pointer;position:absolute;top:0;line-height:16px;height:28px;padding:10px;z-index:3;color:rgba(0,0,0,0.9);fill:rgba(0,0,0,0.9);}.flatpickr-months .flatpickr-prev-month.disabled,.flatpickr-months .flatpickr-next-month.disabled{display:none}.flatpickr-months .flatpickr-prev-month i,.flatpickr-months .flatpickr-next-month i{position:relative}.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,.flatpickr-months .flatpickr-next-month.flatpickr-prev-month{/*\n      /*rtl:begin:ignore*/left:0;/*\n      /*rtl:end:ignore*/}/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,.flatpickr-months .flatpickr-next-month.flatpickr-next-month{/*\n      /*rtl:begin:ignore*/right:0;/*\n      /*rtl:end:ignore*/}/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,.flatpickr-months .flatpickr-next-month:hover{color:#959ea9;}.flatpickr-months .flatpickr-prev-month:hover svg,.flatpickr-months .flatpickr-next-month:hover svg{fill:#f64747}.flatpickr-months .flatpickr-prev-month svg,.flatpickr-months .flatpickr-next-month svg{width:14px;height:14px;}.flatpickr-months .flatpickr-prev-month svg path,.flatpickr-months .flatpickr-next-month svg path{-webkit-transition:fill .1s;transition:fill .1s;fill:inherit}.numInputWrapper{position:relative;height:auto;}.numInputWrapper input,.numInputWrapper span{display:inline-block}.numInputWrapper input{width:100%;}.numInputWrapper input::-ms-clear{display:none}.numInputWrapper span{position:absolute;right:0;width:14px;padding:0 4px 0 2px;height:50%;line-height:50%;opacity:0;cursor:pointer;border:1px solid rgba(57,57,57,0.15);-webkit-box-sizing:border-box;box-sizing:border-box;}.numInputWrapper span:hover{background:rgba(0,0,0,0.1)}.numInputWrapper span:active{background:rgba(0,0,0,0.2)}.numInputWrapper span:after{display:block;content:\"\";position:absolute}.numInputWrapper span.arrowUp{top:0;border-bottom:0;}.numInputWrapper span.arrowUp:after{border-left:4px solid transparent;border-right:4px solid transparent;border-bottom:4px solid rgba(57,57,57,0.6);top:26%}.numInputWrapper span.arrowDown{top:50%;}.numInputWrapper span.arrowDown:after{border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid rgba(57,57,57,0.6);top:40%}.numInputWrapper span svg{width:inherit;height:auto;}.numInputWrapper span svg path{fill:rgba(0,0,0,0.5)}.numInputWrapper:hover{background:rgba(0,0,0,0.05);}.numInputWrapper:hover span{opacity:1}.flatpickr-current-month{font-size:135%;line-height:inherit;font-weight:300;color:inherit;position:absolute;width:75%;left:12.5%;padding:6.16px 0 0 0;line-height:1;height:28px;display:inline-block;text-align:center;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.flatpickr-current-month span.cur-month{font-family:inherit;font-weight:700;color:inherit;display:inline-block;margin-left:.5ch;padding:0;}.flatpickr-current-month span.cur-month:hover{background:rgba(0,0,0,0.05)}.flatpickr-current-month .numInputWrapper{width:6ch;width:7ch\0;display:inline-block;}.flatpickr-current-month .numInputWrapper span.arrowUp:after{border-bottom-color:rgba(0,0,0,0.9)}.flatpickr-current-month .numInputWrapper span.arrowDown:after{border-top-color:rgba(0,0,0,0.9)}.flatpickr-current-month input.cur-year{background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;cursor:text;padding:0 0 0 .5ch;margin:0;display:inline-block;font-size:inherit;font-family:inherit;font-weight:300;line-height:inherit;height:auto;border:0;border-radius:0;vertical-align:initial;}.flatpickr-current-month input.cur-year:focus{outline:0}.flatpickr-current-month input.cur-year[disabled],.flatpickr-current-month input.cur-year[disabled]:hover{font-size:100%;color:rgba(0,0,0,0.5);background:transparent;pointer-events:none}.flatpickr-weekdays{background:transparent;text-align:center;overflow:hidden;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;height:28px;}.flatpickr-weekdays .flatpickr-weekdaycontainer{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}span.flatpickr-weekday{cursor:default;font-size:90%;background:transparent;color:rgba(0,0,0,0.54);line-height:1;margin:0;text-align:center;display:block;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;font-weight:bolder}.dayContainer,.flatpickr-weeks{padding:1px 0 0 0}.flatpickr-days{position:relative;overflow:hidden;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;width:307.875px;}.flatpickr-days:focus{outline:0}.dayContainer{padding:0;outline:0;text-align:left;width:307.875px;min-width:307.875px;max-width:307.875px;-webkit-box-sizing:border-box;box-sizing:border-box;display:inline-block;display:-ms-flexbox;display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-wrap:wrap;-ms-flex-pack:justify;-webkit-justify-content:space-around;justify-content:space-around;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1;}.dayContainer + .dayContainer{-webkit-box-shadow:-1px 0 0 #e6e6e6;box-shadow:-1px 0 0 #e6e6e6}.flatpickr-day{background:none;border:1px solid transparent;border-radius:150px;-webkit-box-sizing:border-box;box-sizing:border-box;color:#393939;cursor:pointer;font-weight:400;width:14.2857143%;-webkit-flex-basis:14.2857143%;-ms-flex-preferred-size:14.2857143%;flex-basis:14.2857143%;max-width:39px;height:39px;line-height:39px;margin:0;display:inline-block;position:relative;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;}.flatpickr-day.inRange,.flatpickr-day.prevMonthDay.inRange,.flatpickr-day.nextMonthDay.inRange,.flatpickr-day.today.inRange,.flatpickr-day.prevMonthDay.today.inRange,.flatpickr-day.nextMonthDay.today.inRange,.flatpickr-day:hover,.flatpickr-day.prevMonthDay:hover,.flatpickr-day.nextMonthDay:hover,.flatpickr-day:focus,.flatpickr-day.prevMonthDay:focus,.flatpickr-day.nextMonthDay:focus{cursor:pointer;outline:0;background:#e6e6e6;border-color:#e6e6e6}.flatpickr-day.today{border-color:#959ea9;}.flatpickr-day.today:hover,.flatpickr-day.today:focus{border-color:#959ea9;background:#959ea9;color:#fff}.flatpickr-day.selected,.flatpickr-day.startRange,.flatpickr-day.endRange,.flatpickr-day.selected.inRange,.flatpickr-day.startRange.inRange,.flatpickr-day.endRange.inRange,.flatpickr-day.selected:focus,.flatpickr-day.startRange:focus,.flatpickr-day.endRange:focus,.flatpickr-day.selected:hover,.flatpickr-day.startRange:hover,.flatpickr-day.endRange:hover,.flatpickr-day.selected.prevMonthDay,.flatpickr-day.startRange.prevMonthDay,.flatpickr-day.endRange.prevMonthDay,.flatpickr-day.selected.nextMonthDay,.flatpickr-day.startRange.nextMonthDay,.flatpickr-day.endRange.nextMonthDay{background:#569ff7;-webkit-box-shadow:none;box-shadow:none;color:#fff;border-color:#569ff7}.flatpickr-day.selected.startRange,.flatpickr-day.startRange.startRange,.flatpickr-day.endRange.startRange{border-radius:50px 0 0 50px}.flatpickr-day.selected.endRange,.flatpickr-day.startRange.endRange,.flatpickr-day.endRange.endRange{border-radius:0 50px 50px 0}.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)){-webkit-box-shadow:-10px 0 0 #569ff7;box-shadow:-10px 0 0 #569ff7}.flatpickr-day.selected.startRange.endRange,.flatpickr-day.startRange.startRange.endRange,.flatpickr-day.endRange.startRange.endRange{border-radius:50px}.flatpickr-day.inRange{border-radius:0;-webkit-box-shadow:-5px 0 0 #e6e6e6,5px 0 0 #e6e6e6;box-shadow:-5px 0 0 #e6e6e6,5px 0 0 #e6e6e6}.flatpickr-day.disabled,.flatpickr-day.disabled:hover,.flatpickr-day.prevMonthDay,.flatpickr-day.nextMonthDay,.flatpickr-day.notAllowed,.flatpickr-day.notAllowed.prevMonthDay,.flatpickr-day.notAllowed.nextMonthDay{color:rgba(57,57,57,0.3);background:transparent;border-color:transparent;cursor:default}.flatpickr-day.disabled,.flatpickr-day.disabled:hover{cursor:not-allowed;color:rgba(57,57,57,0.1)}.flatpickr-day.week.selected{border-radius:0;-webkit-box-shadow:-5px 0 0 #569ff7,5px 0 0 #569ff7;box-shadow:-5px 0 0 #569ff7,5px 0 0 #569ff7}.flatpickr-day.hidden{visibility:hidden}.rangeMode .flatpickr-day{margin-top:1px}.flatpickr-weekwrapper{display:inline-block;float:left;}.flatpickr-weekwrapper .flatpickr-weeks{padding:0 12px;-webkit-box-shadow:1px 0 0 #e6e6e6;box-shadow:1px 0 0 #e6e6e6}.flatpickr-weekwrapper .flatpickr-weekday{float:none;width:100%;line-height:28px}.flatpickr-weekwrapper span.flatpickr-day,.flatpickr-weekwrapper span.flatpickr-day:hover{display:block;width:100%;max-width:none;color:rgba(57,57,57,0.3);background:transparent;cursor:default;border:none}.flatpickr-innerContainer{display:block;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;}.flatpickr-rContainer{display:inline-block;padding:0;-webkit-box-sizing:border-box;box-sizing:border-box}.flatpickr-time{text-align:center;outline:0;display:block;height:0;line-height:40px;max-height:40px;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.flatpickr-time:after{content:\"\";display:table;clear:both}.flatpickr-time .numInputWrapper{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;width:40%;height:40px;float:left;}.flatpickr-time .numInputWrapper span.arrowUp:after{border-bottom-color:#393939}.flatpickr-time .numInputWrapper span.arrowDown:after{border-top-color:#393939}.flatpickr-time.hasSeconds .numInputWrapper{width:26%}.flatpickr-time.time24hr .numInputWrapper{width:49%}.flatpickr-time input{background:transparent;-webkit-box-shadow:none;box-shadow:none;border:0;border-radius:0;text-align:center;margin:0;padding:0;height:inherit;line-height:inherit;color:#393939;font-size:14px;position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;}.flatpickr-time input.flatpickr-hour{font-weight:bold}.flatpickr-time input.flatpickr-minute,.flatpickr-time input.flatpickr-second{font-weight:400}.flatpickr-time input:focus{outline:0;border:0}.flatpickr-time .flatpickr-time-separator,.flatpickr-time .flatpickr-am-pm{height:inherit;display:inline-block;float:left;line-height:inherit;color:#393939;font-weight:bold;width:2%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-align-self:center;-ms-flex-item-align:center;align-self:center}.flatpickr-time .flatpickr-am-pm{outline:0;width:18%;cursor:pointer;text-align:center;font-weight:400}.flatpickr-time input:hover,.flatpickr-time .flatpickr-am-pm:hover,.flatpickr-time input:focus,.flatpickr-time .flatpickr-am-pm:focus{background:#f3f3f3}.flatpickr-input[readonly]{cursor:pointer}@-webkit-keyframes fpFadeInDown{from{opacity:0;-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}@keyframes fpFadeInDown{from{opacity:0;-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}\n\t\t";
			}
		}, {
			key: "defaultProps",

			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Specify the name or id of the field to link the datepicker to
	     * @prop
	     * @type  		{String}
	     */
					for: null,

					/**
	     * Specify the color to use to skin the datepicker.
	     * @prop
	     * @type		{String}
	     */
					color: null

					/**
	     * @name    flatpickr
	     * All the option that propose the flatpickr library.
	     * You can find these options [here](https://flatpickr.js.org/options/).
	     * This component uses the flatpickr v4.x
	     * @prop
	     * @type    {Mixed}
	     */
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: "physicalProps",
			get: function get() {
				return [];
			}
		}]);

		return SDatepickerComponent;
	}(_SWebComponent3.default);

	exports.default = SDatepickerComponent;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

	/* flatpickr v4.5.2, @license MIT */
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.flatpickr = factory());
	}(this, (function () { 'use strict';

	    var pad = function pad(number) {
	      return ("0" + number).slice(-2);
	    };
	    var int = function int(bool) {
	      return bool === true ? 1 : 0;
	    };
	    function debounce(func, wait, immediate) {
	      if (immediate === void 0) {
	        immediate = false;
	      }

	      var timeout;
	      return function () {
	        var context = this,
	            args = arguments;
	        timeout !== null && clearTimeout(timeout);
	        timeout = window.setTimeout(function () {
	          timeout = null;
	          if (!immediate) func.apply(context, args);
	        }, wait);
	        if (immediate && !timeout) func.apply(context, args);
	      };
	    }
	    var arrayify = function arrayify(obj) {
	      return obj instanceof Array ? obj : [obj];
	    };

	    var do_nothing = function do_nothing() {
	      return undefined;
	    };

	    var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
	      return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
	    };
	    var revFormat = {
	      D: do_nothing,
	      F: function F(dateObj, monthName, locale) {
	        dateObj.setMonth(locale.months.longhand.indexOf(monthName));
	      },
	      G: function G(dateObj, hour) {
	        dateObj.setHours(parseFloat(hour));
	      },
	      H: function H(dateObj, hour) {
	        dateObj.setHours(parseFloat(hour));
	      },
	      J: function J(dateObj, day) {
	        dateObj.setDate(parseFloat(day));
	      },
	      K: function K(dateObj, amPM, locale) {
	        dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
	      },
	      M: function M(dateObj, shortMonth, locale) {
	        dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
	      },
	      S: function S(dateObj, seconds) {
	        dateObj.setSeconds(parseFloat(seconds));
	      },
	      U: function U(_, unixSeconds) {
	        return new Date(parseFloat(unixSeconds) * 1000);
	      },
	      W: function W(dateObj, weekNum) {
	        var weekNumber = parseInt(weekNum);
	        return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
	      },
	      Y: function Y(dateObj, year) {
	        dateObj.setFullYear(parseFloat(year));
	      },
	      Z: function Z(_, ISODate) {
	        return new Date(ISODate);
	      },
	      d: function d(dateObj, day) {
	        dateObj.setDate(parseFloat(day));
	      },
	      h: function h(dateObj, hour) {
	        dateObj.setHours(parseFloat(hour));
	      },
	      i: function i(dateObj, minutes) {
	        dateObj.setMinutes(parseFloat(minutes));
	      },
	      j: function j(dateObj, day) {
	        dateObj.setDate(parseFloat(day));
	      },
	      l: do_nothing,
	      m: function m(dateObj, month) {
	        dateObj.setMonth(parseFloat(month) - 1);
	      },
	      n: function n(dateObj, month) {
	        dateObj.setMonth(parseFloat(month) - 1);
	      },
	      s: function s(dateObj, seconds) {
	        dateObj.setSeconds(parseFloat(seconds));
	      },
	      w: do_nothing,
	      y: function y(dateObj, year) {
	        dateObj.setFullYear(2000 + parseFloat(year));
	      }
	    };
	    var tokenRegex = {
	      D: "(\\w+)",
	      F: "(\\w+)",
	      G: "(\\d\\d|\\d)",
	      H: "(\\d\\d|\\d)",
	      J: "(\\d\\d|\\d)\\w+",
	      K: "",
	      M: "(\\w+)",
	      S: "(\\d\\d|\\d)",
	      U: "(.+)",
	      W: "(\\d\\d|\\d)",
	      Y: "(\\d{4})",
	      Z: "(.+)",
	      d: "(\\d\\d|\\d)",
	      h: "(\\d\\d|\\d)",
	      i: "(\\d\\d|\\d)",
	      j: "(\\d\\d|\\d)",
	      l: "(\\w+)",
	      m: "(\\d\\d|\\d)",
	      n: "(\\d\\d|\\d)",
	      s: "(\\d\\d|\\d)",
	      w: "(\\d\\d|\\d)",
	      y: "(\\d{2})"
	    };
	    var formats = {
	      Z: function Z(date) {
	        return date.toISOString();
	      },
	      D: function D(date, locale, options) {
	        return locale.weekdays.shorthand[formats.w(date, locale, options)];
	      },
	      F: function F(date, locale, options) {
	        return monthToStr(formats.n(date, locale, options) - 1, false, locale);
	      },
	      G: function G(date, locale, options) {
	        return pad(formats.h(date, locale, options));
	      },
	      H: function H(date) {
	        return pad(date.getHours());
	      },
	      J: function J(date, locale) {
	        return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
	      },
	      K: function K(date, locale) {
	        return locale.amPM[int(date.getHours() > 11)];
	      },
	      M: function M(date, locale) {
	        return monthToStr(date.getMonth(), true, locale);
	      },
	      S: function S(date) {
	        return pad(date.getSeconds());
	      },
	      U: function U(date) {
	        return date.getTime() / 1000;
	      },
	      W: function W(date, _, options) {
	        return options.getWeek(date);
	      },
	      Y: function Y(date) {
	        return date.getFullYear();
	      },
	      d: function d(date) {
	        return pad(date.getDate());
	      },
	      h: function h(date) {
	        return date.getHours() % 12 ? date.getHours() % 12 : 12;
	      },
	      i: function i(date) {
	        return pad(date.getMinutes());
	      },
	      j: function j(date) {
	        return date.getDate();
	      },
	      l: function l(date, locale) {
	        return locale.weekdays.longhand[date.getDay()];
	      },
	      m: function m(date) {
	        return pad(date.getMonth() + 1);
	      },
	      n: function n(date) {
	        return date.getMonth() + 1;
	      },
	      s: function s(date) {
	        return date.getSeconds();
	      },
	      w: function w(date) {
	        return date.getDay();
	      },
	      y: function y(date) {
	        return String(date.getFullYear()).substring(2);
	      }
	    };

	    var english = {
	      weekdays: {
	        shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	        longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
	      },
	      months: {
	        shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	        longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
	      },
	      daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
	      firstDayOfWeek: 0,
	      ordinal: function ordinal(nth) {
	        var s = nth % 100;
	        if (s > 3 && s < 21) return "th";

	        switch (s % 10) {
	          case 1:
	            return "st";

	          case 2:
	            return "nd";

	          case 3:
	            return "rd";

	          default:
	            return "th";
	        }
	      },
	      rangeSeparator: " to ",
	      weekAbbreviation: "Wk",
	      scrollTitle: "Scroll to increment",
	      toggleTitle: "Click to toggle",
	      amPM: ["AM", "PM"],
	      yearAriaLabel: "Year"
	    };

	    var createDateFormatter = function createDateFormatter(_ref) {
	      var _ref$config = _ref.config,
	          config = _ref$config === void 0 ? defaults : _ref$config,
	          _ref$l10n = _ref.l10n,
	          l10n = _ref$l10n === void 0 ? english : _ref$l10n;
	      return function (dateObj, frmt, overrideLocale) {
	        var locale = overrideLocale || l10n;

	        if (config.formatDate !== undefined) {
	          return config.formatDate(dateObj, frmt, locale);
	        }

	        return frmt.split("").map(function (c, i, arr) {
	          return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
	        }).join("");
	      };
	    };
	    var createDateParser = function createDateParser(_ref2) {
	      var _ref2$config = _ref2.config,
	          config = _ref2$config === void 0 ? defaults : _ref2$config,
	          _ref2$l10n = _ref2.l10n,
	          l10n = _ref2$l10n === void 0 ? english : _ref2$l10n;
	      return function (date, givenFormat, timeless, customLocale) {
	        if (date !== 0 && !date) return undefined;
	        var locale = customLocale || l10n;
	        var parsedDate;
	        var date_orig = date;
	        if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === "string") {
	          var format = givenFormat || (config || defaults).dateFormat;
	          var datestr = String(date).trim();

	          if (datestr === "today") {
	            parsedDate = new Date();
	            timeless = true;
	          } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {
	            parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
	            var matched,
	                ops = [];

	            for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
	              var token = format[i];
	              var isBackSlash = token === "\\";
	              var escaped = format[i - 1] === "\\" || isBackSlash;

	              if (tokenRegex[token] && !escaped) {
	                regexStr += tokenRegex[token];
	                var match = new RegExp(regexStr).exec(date);

	                if (match && (matched = true)) {
	                  ops[token !== "Y" ? "push" : "unshift"]({
	                    fn: revFormat[token],
	                    val: match[++matchIndex]
	                  });
	                }
	              } else if (!isBackSlash) regexStr += ".";

	              ops.forEach(function (_ref3) {
	                var fn = _ref3.fn,
	                    val = _ref3.val;
	                return parsedDate = fn(parsedDate, val, locale) || parsedDate;
	              });
	            }

	            parsedDate = matched ? parsedDate : undefined;
	          }
	        }

	        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
	          config.errorHandler(new Error("Invalid date provided: " + date_orig));
	          return undefined;
	        }

	        if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
	        return parsedDate;
	      };
	    };
	    function compareDates(date1, date2, timeless) {
	      if (timeless === void 0) {
	        timeless = true;
	      }

	      if (timeless !== false) {
	        return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
	      }

	      return date1.getTime() - date2.getTime();
	    }
	    var getWeek = function getWeek(givenDate) {
	      var date = new Date(givenDate.getTime());
	      date.setHours(0, 0, 0, 0);
	      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
	      var week1 = new Date(date.getFullYear(), 0, 4);
	      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
	    };
	    var isBetween = function isBetween(ts, ts1, ts2) {
	      return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
	    };
	    var duration = {
	      DAY: 86400000
	    };

	    var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
	    var defaults = {
	      _disable: [],
	      _enable: [],
	      allowInput: false,
	      altFormat: "F j, Y",
	      altInput: false,
	      altInputClass: "form-control input",
	      animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
	      ariaDateFormat: "F j, Y",
	      clickOpens: true,
	      closeOnSelect: true,
	      conjunction: ", ",
	      dateFormat: "Y-m-d",
	      defaultHour: 12,
	      defaultMinute: 0,
	      defaultSeconds: 0,
	      disable: [],
	      disableMobile: false,
	      enable: [],
	      enableSeconds: false,
	      enableTime: false,
	      errorHandler: function errorHandler(err) {
	        return typeof console !== "undefined" && console.warn(err);
	      },
	      getWeek: getWeek,
	      hourIncrement: 1,
	      ignoredFocusElements: [],
	      inline: false,
	      locale: "default",
	      minuteIncrement: 5,
	      mode: "single",
	      nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
	      noCalendar: false,
	      now: new Date(),
	      onChange: [],
	      onClose: [],
	      onDayCreate: [],
	      onDestroy: [],
	      onKeyDown: [],
	      onMonthChange: [],
	      onOpen: [],
	      onParseConfig: [],
	      onReady: [],
	      onValueUpdate: [],
	      onYearChange: [],
	      onPreCalendarPosition: [],
	      plugins: [],
	      position: "auto",
	      positionElement: undefined,
	      prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
	      shorthandCurrentMonth: false,
	      showMonths: 1,
	      static: false,
	      time_24hr: false,
	      weekNumbers: false,
	      wrap: false
	    };

	    function toggleClass(elem, className, bool) {
	      if (bool === true) return elem.classList.add(className);
	      elem.classList.remove(className);
	    }
	    function createElement(tag, className, content) {
	      var e = window.document.createElement(tag);
	      className = className || "";
	      content = content || "";
	      e.className = className;
	      if (content !== undefined) e.textContent = content;
	      return e;
	    }
	    function clearNode(node) {
	      while (node.firstChild) {
	        node.removeChild(node.firstChild);
	      }
	    }
	    function findParent(node, condition) {
	      if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
	      return undefined;
	    }
	    function createNumberInput(inputClassName, opts) {
	      var wrapper = createElement("div", "numInputWrapper"),
	          numInput = createElement("input", "numInput " + inputClassName),
	          arrowUp = createElement("span", "arrowUp"),
	          arrowDown = createElement("span", "arrowDown");
	      numInput.type = "text";
	      numInput.pattern = "\\d*";
	      if (opts !== undefined) for (var key in opts) {
	        numInput.setAttribute(key, opts[key]);
	      }
	      wrapper.appendChild(numInput);
	      wrapper.appendChild(arrowUp);
	      wrapper.appendChild(arrowDown);
	      return wrapper;
	    }

	    if (typeof Object.assign !== "function") {
	      Object.assign = function (target) {
	        if (!target) {
	          throw TypeError("Cannot convert undefined or null to object");
	        }

	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }

	        var _loop = function _loop() {
	          var source = args[_i];

	          if (source) {
	            Object.keys(source).forEach(function (key) {
	              return target[key] = source[key];
	            });
	          }
	        };

	        for (var _i = 0; _i < args.length; _i++) {
	          _loop();
	        }

	        return target;
	      };
	    }

	    var DEBOUNCED_CHANGE_MS = 300;

	    function FlatpickrInstance(element, instanceConfig) {
	      var self = {
	        config: Object.assign({}, flatpickr.defaultConfig),
	        l10n: english
	      };
	      self.parseDate = createDateParser({
	        config: self.config,
	        l10n: self.l10n
	      });
	      self._handlers = [];
	      self._bind = bind;
	      self._setHoursFromDate = setHoursFromDate;
	      self._positionCalendar = positionCalendar;
	      self.changeMonth = changeMonth;
	      self.changeYear = changeYear;
	      self.clear = clear;
	      self.close = close;
	      self._createElement = createElement;
	      self.destroy = destroy;
	      self.isEnabled = isEnabled;
	      self.jumpToDate = jumpToDate;
	      self.open = open;
	      self.redraw = redraw;
	      self.set = set;
	      self.setDate = setDate;
	      self.toggle = toggle;

	      function setupHelperFunctions() {
	        self.utils = {
	          getDaysInMonth: function getDaysInMonth(month, yr) {
	            if (month === void 0) {
	              month = self.currentMonth;
	            }

	            if (yr === void 0) {
	              yr = self.currentYear;
	            }

	            if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
	            return self.l10n.daysInMonth[month];
	          }
	        };
	      }

	      function init() {
	        self.element = self.input = element;
	        self.isOpen = false;
	        parseConfig();
	        setupLocale();
	        setupInputs();
	        setupDates();
	        setupHelperFunctions();
	        if (!self.isMobile) build();
	        bindEvents();

	        if (self.selectedDates.length || self.config.noCalendar) {
	          if (self.config.enableTime) {
	            setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);
	          }

	          updateValue(false);
	        }

	        setCalendarWidth();
	        self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;
	        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

	        if (!self.isMobile && isSafari) {
	          positionCalendar();
	        }

	        triggerEvent("onReady");
	      }

	      function bindToInstance(fn) {
	        return fn.bind(self);
	      }

	      function setCalendarWidth() {
	        var config = self.config;
	        if (config.weekNumbers === false && config.showMonths === 1) return;else if (config.noCalendar !== true) {
	          window.requestAnimationFrame(function () {
	            self.calendarContainer.style.visibility = "hidden";
	            self.calendarContainer.style.display = "block";

	            if (self.daysContainer !== undefined) {
	              var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
	              self.daysContainer.style.width = daysWidth + "px";
	              self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
	              self.calendarContainer.style.removeProperty("visibility");
	              self.calendarContainer.style.removeProperty("display");
	            }
	          });
	        }
	      }

	      function updateTime(e) {
	        if (self.selectedDates.length === 0) return;

	        if (e !== undefined && e.type !== "blur") {
	          timeWrapper(e);
	        }

	        var prevValue = self._input.value;
	        setHoursFromInputs();
	        updateValue();

	        if (self._input.value !== prevValue) {
	          self._debouncedChange();
	        }
	      }

	      function ampm2military(hour, amPM) {
	        return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
	      }

	      function military2ampm(hour) {
	        switch (hour % 24) {
	          case 0:
	          case 12:
	            return 12;

	          default:
	            return hour % 12;
	        }
	      }

	      function setHoursFromInputs() {
	        if (self.hourElement === undefined || self.minuteElement === undefined) return;
	        var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
	            minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
	            seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

	        if (self.amPM !== undefined) {
	          hours = ampm2military(hours, self.amPM.textContent);
	        }

	        var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
	        var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;

	        if (limitMaxHours) {
	          var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
	          hours = Math.min(hours, maxTime.getHours());
	          if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
	          if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
	        }

	        if (limitMinHours) {
	          var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
	          hours = Math.max(hours, minTime.getHours());
	          if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());
	          if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
	        }

	        setHours(hours, minutes, seconds);
	      }

	      function setHoursFromDate(dateObj) {
	        var date = dateObj || self.latestSelectedDateObj;
	        if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
	      }

	      function setDefaultHours() {
	        var hours = self.config.defaultHour;
	        var minutes = self.config.defaultMinute;
	        var seconds = self.config.defaultSeconds;

	        if (self.config.minDate !== undefined) {
	          var min_hr = self.config.minDate.getHours();
	          var min_minutes = self.config.minDate.getMinutes();
	          hours = Math.max(hours, min_hr);
	          if (hours === min_hr) minutes = Math.max(min_minutes, minutes);
	          if (hours === min_hr && minutes === min_minutes) seconds = self.config.minDate.getSeconds();
	        }

	        if (self.config.maxDate !== undefined) {
	          var max_hr = self.config.maxDate.getHours();
	          var max_minutes = self.config.maxDate.getMinutes();
	          hours = Math.min(hours, max_hr);
	          if (hours === max_hr) minutes = Math.min(max_minutes, minutes);
	          if (hours === max_hr && minutes === max_minutes) seconds = self.config.maxDate.getSeconds();
	        }

	        setHours(hours, minutes, seconds);
	      }

	      function setHours(hours, minutes, seconds) {
	        if (self.latestSelectedDateObj !== undefined) {
	          self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
	        }

	        if (!self.hourElement || !self.minuteElement || self.isMobile) return;
	        self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
	        self.minuteElement.value = pad(minutes);
	        if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
	        if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
	      }

	      function onYearInput(event) {
	        var year = parseInt(event.target.value) + (event.delta || 0);

	        if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
	          changeYear(year);
	        }
	      }

	      function bind(element, event, handler, options) {
	        if (event instanceof Array) return event.forEach(function (ev) {
	          return bind(element, ev, handler, options);
	        });
	        if (element instanceof Array) return element.forEach(function (el) {
	          return bind(el, event, handler, options);
	        });
	        element.addEventListener(event, handler, options);

	        self._handlers.push({
	          element: element,
	          event: event,
	          handler: handler,
	          options: options
	        });
	      }

	      function onClick(handler) {
	        return function (evt) {
	          evt.which === 1 && handler(evt);
	        };
	      }

	      function triggerChange() {
	        triggerEvent("onChange");
	      }

	      function bindEvents() {
	        if (self.config.wrap) {
	          ["open", "close", "toggle", "clear"].forEach(function (evt) {
	            Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
	              return bind(el, "click", self[evt]);
	            });
	          });
	        }

	        if (self.isMobile) {
	          setupMobile();
	          return;
	        }

	        var debouncedResize = debounce(onResize, 50);
	        self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
	        if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
	          if (self.config.mode === "range") onMouseOver(e.target);
	        });
	        bind(window.document.body, "keydown", onKeyDown);
	        if (!self.config.static) bind(self._input, "keydown", onKeyDown);
	        if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
	        if (window.ontouchstart !== undefined) bind(window.document, "click", documentClick);else bind(window.document, "mousedown", onClick(documentClick));
	        bind(window.document, "focus", documentClick, {
	          capture: true
	        });

	        if (self.config.clickOpens === true) {
	          bind(self._input, "focus", self.open);
	          bind(self._input, "mousedown", onClick(self.open));
	        }

	        if (self.daysContainer !== undefined) {
	          bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
	          bind(self.monthNav, ["keyup", "increment"], onYearInput);
	          bind(self.daysContainer, "mousedown", onClick(selectDate));
	        }

	        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
	          var selText = function selText(e) {
	            return e.target.select();
	          };

	          bind(self.timeContainer, ["increment"], updateTime);
	          bind(self.timeContainer, "blur", updateTime, {
	            capture: true
	          });
	          bind(self.timeContainer, "mousedown", onClick(timeIncrement));
	          bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
	          if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
	            return self.secondElement && self.secondElement.select();
	          });

	          if (self.amPM !== undefined) {
	            bind(self.amPM, "mousedown", onClick(function (e) {
	              updateTime(e);
	              triggerChange();
	            }));
	          }
	        }
	      }

	      function jumpToDate(jumpDate) {
	        var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);

	        try {
	          if (jumpTo !== undefined) {
	            self.currentYear = jumpTo.getFullYear();
	            self.currentMonth = jumpTo.getMonth();
	          }
	        } catch (e) {
	          e.message = "Invalid date supplied: " + jumpTo;
	          self.config.errorHandler(e);
	        }

	        self.redraw();
	      }

	      function timeIncrement(e) {
	        if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
	      }

	      function incrementNumInput(e, delta, inputElem) {
	        var target = e && e.target;
	        var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
	        var event = createEvent("increment");
	        event.delta = delta;
	        input && input.dispatchEvent(event);
	      }

	      function build() {
	        var fragment = window.document.createDocumentFragment();
	        self.calendarContainer = createElement("div", "flatpickr-calendar");
	        self.calendarContainer.tabIndex = -1;

	        if (!self.config.noCalendar) {
	          fragment.appendChild(buildMonthNav());
	          self.innerContainer = createElement("div", "flatpickr-innerContainer");

	          if (self.config.weekNumbers) {
	            var _buildWeeks = buildWeeks(),
	                weekWrapper = _buildWeeks.weekWrapper,
	                weekNumbers = _buildWeeks.weekNumbers;

	            self.innerContainer.appendChild(weekWrapper);
	            self.weekNumbers = weekNumbers;
	            self.weekWrapper = weekWrapper;
	          }

	          self.rContainer = createElement("div", "flatpickr-rContainer");
	          self.rContainer.appendChild(buildWeekdays());

	          if (!self.daysContainer) {
	            self.daysContainer = createElement("div", "flatpickr-days");
	            self.daysContainer.tabIndex = -1;
	          }

	          buildDays();
	          self.rContainer.appendChild(self.daysContainer);
	          self.innerContainer.appendChild(self.rContainer);
	          fragment.appendChild(self.innerContainer);
	        }

	        if (self.config.enableTime) {
	          fragment.appendChild(buildTime());
	        }

	        toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
	        toggleClass(self.calendarContainer, "animate", self.config.animate === true);
	        toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
	        self.calendarContainer.appendChild(fragment);
	        var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;

	        if (self.config.inline || self.config.static) {
	          self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

	          if (self.config.inline) {
	            if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
	          }

	          if (self.config.static) {
	            var wrapper = createElement("div", "flatpickr-wrapper");
	            if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
	            wrapper.appendChild(self.element);
	            if (self.altInput) wrapper.appendChild(self.altInput);
	            wrapper.appendChild(self.calendarContainer);
	          }
	        }

	        if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
	      }

	      function createDay(className, date, dayNumber, i) {
	        var dateIsEnabled = isEnabled(date, true),
	            dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
	        dayElement.dateObj = date;
	        dayElement.$i = i;
	        dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

	        if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
	          self.todayDateElem = dayElement;
	          dayElement.classList.add("today");
	          dayElement.setAttribute("aria-current", "date");
	        }

	        if (dateIsEnabled) {
	          dayElement.tabIndex = -1;

	          if (isDateSelected(date)) {
	            dayElement.classList.add("selected");
	            self.selectedDateElem = dayElement;

	            if (self.config.mode === "range") {
	              toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
	              toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
	              if (className === "nextMonthDay") dayElement.classList.add("inRange");
	            }
	          }
	        } else {
	          dayElement.classList.add("disabled");
	        }

	        if (self.config.mode === "range") {
	          if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
	        }

	        if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
	          self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
	        }

	        triggerEvent("onDayCreate", dayElement);
	        return dayElement;
	      }

	      function focusOnDayElem(targetNode) {
	        targetNode.focus();
	        if (self.config.mode === "range") onMouseOver(targetNode);
	      }

	      function getFirstAvailableDay(delta) {
	        var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
	        var endMonth = delta > 0 ? self.config.showMonths : -1;

	        for (var m = startMonth; m != endMonth; m += delta) {
	          var month = self.daysContainer.children[m];
	          var startIndex = delta > 0 ? 0 : month.children.length - 1;
	          var endIndex = delta > 0 ? month.children.length : -1;

	          for (var i = startIndex; i != endIndex; i += delta) {
	            var c = month.children[i];
	            if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
	          }
	        }

	        return undefined;
	      }

	      function getNextAvailableDay(current, delta) {
	        var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
	        var endMonth = delta > 0 ? self.config.showMonths : -1;
	        var loopDelta = delta > 0 ? 1 : -1;

	        for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
	          var month = self.daysContainer.children[m];
	          var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
	          var numMonthDays = month.children.length;

	          for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
	            var c = month.children[i];
	            if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
	          }
	        }

	        self.changeMonth(loopDelta);
	        focusOnDay(getFirstAvailableDay(loopDelta), 0);
	        return undefined;
	      }

	      function focusOnDay(current, offset) {
	        var dayFocused = isInView(document.activeElement || document.body);
	        var startElem = current !== undefined ? current : dayFocused ? document.activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
	        if (startElem === undefined) return self._input.focus();
	        if (!dayFocused) return focusOnDayElem(startElem);
	        getNextAvailableDay(startElem, offset);
	      }

	      function buildMonthDays(year, month) {
	        var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
	        var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
	        var daysInMonth = self.utils.getDaysInMonth(month),
	            days = window.document.createDocumentFragment(),
	            isMultiMonth = self.config.showMonths > 1,
	            prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
	            nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
	        var dayNumber = prevMonthDays + 1 - firstOfMonth,
	            dayIndex = 0;

	        for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
	          days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
	        }

	        for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
	          days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
	        }

	        for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
	          days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
	        }

	        var dayContainer = createElement("div", "dayContainer");
	        dayContainer.appendChild(days);
	        return dayContainer;
	      }

	      function buildDays() {
	        if (self.daysContainer === undefined) {
	          return;
	        }

	        clearNode(self.daysContainer);
	        if (self.weekNumbers) clearNode(self.weekNumbers);
	        var frag = document.createDocumentFragment();

	        for (var i = 0; i < self.config.showMonths; i++) {
	          var d = new Date(self.currentYear, self.currentMonth, 1);
	          d.setMonth(self.currentMonth + i);
	          frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
	        }

	        self.daysContainer.appendChild(frag);
	        self.days = self.daysContainer.firstChild;

	        if (self.config.mode === "range" && self.selectedDates.length === 1) {
	          onMouseOver();
	        }
	      }

	      function buildMonth() {
	        var container = createElement("div", "flatpickr-month");
	        var monthNavFragment = window.document.createDocumentFragment();
	        var monthElement = createElement("span", "cur-month");
	        var yearInput = createNumberInput("cur-year", {
	          tabindex: "-1"
	        });
	        var yearElement = yearInput.getElementsByTagName("input")[0];
	        yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
	        if (self.config.minDate) yearElement.setAttribute("data-min", self.config.minDate.getFullYear().toString());

	        if (self.config.maxDate) {
	          yearElement.setAttribute("data-max", self.config.maxDate.getFullYear().toString());
	          yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
	        }

	        var currentMonth = createElement("div", "flatpickr-current-month");
	        currentMonth.appendChild(monthElement);
	        currentMonth.appendChild(yearInput);
	        monthNavFragment.appendChild(currentMonth);
	        container.appendChild(monthNavFragment);
	        return {
	          container: container,
	          yearElement: yearElement,
	          monthElement: monthElement
	        };
	      }

	      function buildMonths() {
	        clearNode(self.monthNav);
	        self.monthNav.appendChild(self.prevMonthNav);

	        for (var m = self.config.showMonths; m--;) {
	          var month = buildMonth();
	          self.yearElements.push(month.yearElement);
	          self.monthElements.push(month.monthElement);
	          self.monthNav.appendChild(month.container);
	        }

	        self.monthNav.appendChild(self.nextMonthNav);
	      }

	      function buildMonthNav() {
	        self.monthNav = createElement("div", "flatpickr-months");
	        self.yearElements = [];
	        self.monthElements = [];
	        self.prevMonthNav = createElement("span", "flatpickr-prev-month");
	        self.prevMonthNav.innerHTML = self.config.prevArrow;
	        self.nextMonthNav = createElement("span", "flatpickr-next-month");
	        self.nextMonthNav.innerHTML = self.config.nextArrow;
	        buildMonths();
	        Object.defineProperty(self, "_hidePrevMonthArrow", {
	          get: function get() {
	            return self.__hidePrevMonthArrow;
	          },
	          set: function set(bool) {
	            if (self.__hidePrevMonthArrow !== bool) {
	              toggleClass(self.prevMonthNav, "disabled", bool);
	              self.__hidePrevMonthArrow = bool;
	            }
	          }
	        });
	        Object.defineProperty(self, "_hideNextMonthArrow", {
	          get: function get() {
	            return self.__hideNextMonthArrow;
	          },
	          set: function set(bool) {
	            if (self.__hideNextMonthArrow !== bool) {
	              toggleClass(self.nextMonthNav, "disabled", bool);
	              self.__hideNextMonthArrow = bool;
	            }
	          }
	        });
	        self.currentYearElement = self.yearElements[0];
	        updateNavigationCurrentMonth();
	        return self.monthNav;
	      }

	      function buildTime() {
	        self.calendarContainer.classList.add("hasTime");
	        if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
	        self.timeContainer = createElement("div", "flatpickr-time");
	        self.timeContainer.tabIndex = -1;
	        var separator = createElement("span", "flatpickr-time-separator", ":");
	        var hourInput = createNumberInput("flatpickr-hour");
	        self.hourElement = hourInput.getElementsByTagName("input")[0];
	        var minuteInput = createNumberInput("flatpickr-minute");
	        self.minuteElement = minuteInput.getElementsByTagName("input")[0];
	        self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
	        self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));
	        self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);
	        self.hourElement.setAttribute("data-step", self.config.hourIncrement.toString());
	        self.minuteElement.setAttribute("data-step", self.config.minuteIncrement.toString());
	        self.hourElement.setAttribute("data-min", self.config.time_24hr ? "0" : "1");
	        self.hourElement.setAttribute("data-max", self.config.time_24hr ? "23" : "12");
	        self.minuteElement.setAttribute("data-min", "0");
	        self.minuteElement.setAttribute("data-max", "59");
	        self.timeContainer.appendChild(hourInput);
	        self.timeContainer.appendChild(separator);
	        self.timeContainer.appendChild(minuteInput);
	        if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

	        if (self.config.enableSeconds) {
	          self.timeContainer.classList.add("hasSeconds");
	          var secondInput = createNumberInput("flatpickr-second");
	          self.secondElement = secondInput.getElementsByTagName("input")[0];
	          self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);
	          self.secondElement.setAttribute("data-step", self.minuteElement.getAttribute("data-step"));
	          self.secondElement.setAttribute("data-min", self.minuteElement.getAttribute("data-min"));
	          self.secondElement.setAttribute("data-max", self.minuteElement.getAttribute("data-max"));
	          self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
	          self.timeContainer.appendChild(secondInput);
	        }

	        if (!self.config.time_24hr) {
	          self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
	          self.amPM.title = self.l10n.toggleTitle;
	          self.amPM.tabIndex = -1;
	          self.timeContainer.appendChild(self.amPM);
	        }

	        return self.timeContainer;
	      }

	      function buildWeekdays() {
	        if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);

	        for (var i = self.config.showMonths; i--;) {
	          var container = createElement("div", "flatpickr-weekdaycontainer");
	          self.weekdayContainer.appendChild(container);
	        }

	        updateWeekdays();
	        return self.weekdayContainer;
	      }

	      function updateWeekdays() {
	        var firstDayOfWeek = self.l10n.firstDayOfWeek;
	        var weekdays = self.l10n.weekdays.shorthand.concat();

	        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
	          weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
	        }

	        for (var i = self.config.showMonths; i--;) {
	          self.weekdayContainer.children[i].innerHTML = "\n      <span class=flatpickr-weekday>\n        " + weekdays.join("</span><span class=flatpickr-weekday>") + "\n      </span>\n      ";
	        }
	      }

	      function buildWeeks() {
	        self.calendarContainer.classList.add("hasWeeks");
	        var weekWrapper = createElement("div", "flatpickr-weekwrapper");
	        weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
	        var weekNumbers = createElement("div", "flatpickr-weeks");
	        weekWrapper.appendChild(weekNumbers);
	        return {
	          weekWrapper: weekWrapper,
	          weekNumbers: weekNumbers
	        };
	      }

	      function changeMonth(value, is_offset) {
	        if (is_offset === void 0) {
	          is_offset = true;
	        }

	        var delta = is_offset ? value : value - self.currentMonth;
	        if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
	        self.currentMonth += delta;

	        if (self.currentMonth < 0 || self.currentMonth > 11) {
	          self.currentYear += self.currentMonth > 11 ? 1 : -1;
	          self.currentMonth = (self.currentMonth + 12) % 12;
	          triggerEvent("onYearChange");
	        }

	        buildDays();
	        triggerEvent("onMonthChange");
	        updateNavigationCurrentMonth();
	      }

	      function clear(triggerChangeEvent) {
	        if (triggerChangeEvent === void 0) {
	          triggerChangeEvent = true;
	        }

	        self.input.value = "";
	        if (self.altInput !== undefined) self.altInput.value = "";
	        if (self.mobileInput !== undefined) self.mobileInput.value = "";
	        self.selectedDates = [];
	        self.latestSelectedDateObj = undefined;
	        self.showTimeInput = false;

	        if (self.config.enableTime === true) {
	          setDefaultHours();
	        }

	        self.redraw();
	        if (triggerChangeEvent) triggerEvent("onChange");
	      }

	      function close() {
	        self.isOpen = false;

	        if (!self.isMobile) {
	          self.calendarContainer.classList.remove("open");

	          self._input.classList.remove("active");
	        }

	        triggerEvent("onClose");
	      }

	      function destroy() {
	        if (self.config !== undefined) triggerEvent("onDestroy");

	        for (var i = self._handlers.length; i--;) {
	          var h = self._handlers[i];
	          h.element.removeEventListener(h.event, h.handler, h.options);
	        }

	        self._handlers = [];

	        if (self.mobileInput) {
	          if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
	          self.mobileInput = undefined;
	        } else if (self.calendarContainer && self.calendarContainer.parentNode) {
	          if (self.config.static && self.calendarContainer.parentNode) {
	            var wrapper = self.calendarContainer.parentNode;
	            wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);

	            if (wrapper.parentNode) {
	              while (wrapper.firstChild) {
	                wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
	              }

	              wrapper.parentNode.removeChild(wrapper);
	            }
	          } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
	        }

	        if (self.altInput) {
	          self.input.type = "text";
	          if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
	          delete self.altInput;
	        }

	        if (self.input) {
	          self.input.type = self.input._type;
	          self.input.classList.remove("flatpickr-input");
	          self.input.removeAttribute("readonly");
	          self.input.value = "";
	        }

	        ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
	          try {
	            delete self[k];
	          } catch (_) {}
	        });
	      }

	      function isCalendarElem(elem) {
	        if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;
	        return self.calendarContainer.contains(elem);
	      }

	      function documentClick(e) {
	        if (self.isOpen && !self.config.inline) {
	          var isCalendarElement = isCalendarElem(e.target);
	          var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
	          var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;
	          var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
	            return elem.contains(e.target);
	          });

	          if (lostFocus && isIgnored) {
	            self.close();

	            if (self.config.mode === "range" && self.selectedDates.length === 1) {
	              self.clear(false);
	              self.redraw();
	            }
	          }
	        }
	      }

	      function changeYear(newYear) {
	        if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
	        var newYearNum = newYear,
	            isNewYear = self.currentYear !== newYearNum;
	        self.currentYear = newYearNum || self.currentYear;

	        if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
	          self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
	        } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
	          self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
	        }

	        if (isNewYear) {
	          self.redraw();
	          triggerEvent("onYearChange");
	        }
	      }

	      function isEnabled(date, timeless) {
	        if (timeless === void 0) {
	          timeless = true;
	        }

	        var dateToCheck = self.parseDate(date, undefined, timeless);
	        if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
	        if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;
	        if (dateToCheck === undefined) return false;
	        var bool = self.config.enable.length > 0,
	            array = bool ? self.config.enable : self.config.disable;

	        for (var i = 0, d; i < array.length; i++) {
	          d = array[i];
	          if (typeof d === "function" && d(dateToCheck)) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;else if (typeof d === "string" && dateToCheck !== undefined) {
	            var parsed = self.parseDate(d, undefined, true);
	            return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
	          } else if (typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
	        }

	        return !bool;
	      }

	      function isInView(elem) {
	        if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && self.daysContainer.contains(elem);
	        return false;
	      }

	      function onKeyDown(e) {
	        var isInput = e.target === self._input;
	        var allowInput = self.config.allowInput;
	        var allowKeydown = self.isOpen && (!allowInput || !isInput);
	        var allowInlineKeydown = self.config.inline && isInput && !allowInput;

	        if (e.keyCode === 13 && isInput) {
	          if (allowInput) {
	            self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
	            return e.target.blur();
	          } else self.open();
	        } else if (isCalendarElem(e.target) || allowKeydown || allowInlineKeydown) {
	          var isTimeObj = !!self.timeContainer && self.timeContainer.contains(e.target);

	          switch (e.keyCode) {
	            case 13:
	              if (isTimeObj) updateTime();else selectDate(e);
	              break;

	            case 27:
	              e.preventDefault();
	              focusAndClose();
	              break;

	            case 8:
	            case 46:
	              if (isInput && !self.config.allowInput) {
	                e.preventDefault();
	                self.clear();
	              }

	              break;

	            case 37:
	            case 39:
	              if (!isTimeObj) {
	                e.preventDefault();

	                if (self.daysContainer !== undefined && (allowInput === false || isInView(document.activeElement))) {
	                  var _delta = e.keyCode === 39 ? 1 : -1;

	                  if (!e.ctrlKey) focusOnDay(undefined, _delta);else {
	                    changeMonth(_delta);
	                    focusOnDay(getFirstAvailableDay(1), 0);
	                  }
	                }
	              } else if (self.hourElement) self.hourElement.focus();

	              break;

	            case 38:
	            case 40:
	              e.preventDefault();
	              var delta = e.keyCode === 40 ? 1 : -1;

	              if (self.daysContainer && e.target.$i !== undefined) {
	                if (e.ctrlKey) {
	                  changeYear(self.currentYear - delta);
	                  focusOnDay(getFirstAvailableDay(1), 0);
	                } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
	              } else if (self.config.enableTime) {
	                if (!isTimeObj && self.hourElement) self.hourElement.focus();
	                updateTime(e);

	                self._debouncedChange();
	              }

	              break;

	            case 9:
	              if (!isTimeObj) {
	                self.element.focus();
	                break;
	              }

	              var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].filter(function (x) {
	                return x;
	              });
	              var i = elems.indexOf(e.target);

	              if (i !== -1) {
	                var target = elems[i + (e.shiftKey ? -1 : 1)];

	                if (target !== undefined) {
	                  e.preventDefault();
	                  target.focus();
	                } else {
	                  self.element.focus();
	                }
	              }

	              break;

	            default:
	              break;
	          }
	        }

	        if (self.amPM !== undefined && e.target === self.amPM) {
	          switch (e.key) {
	            case self.l10n.amPM[0].charAt(0):
	            case self.l10n.amPM[0].charAt(0).toLowerCase():
	              self.amPM.textContent = self.l10n.amPM[0];
	              setHoursFromInputs();
	              updateValue();
	              break;

	            case self.l10n.amPM[1].charAt(0):
	            case self.l10n.amPM[1].charAt(0).toLowerCase():
	              self.amPM.textContent = self.l10n.amPM[1];
	              setHoursFromInputs();
	              updateValue();
	              break;
	          }
	        }

	        triggerEvent("onKeyDown", e);
	      }

	      function onMouseOver(elem) {
	        if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("disabled"))) return;
	        var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
	            initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
	            rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
	            rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()),
	            lastDate = self.daysContainer.lastChild.lastChild.dateObj.getTime();
	        var containsDisabled = false;
	        var minRange = 0,
	            maxRange = 0;

	        for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
	          if (!isEnabled(new Date(t), true)) {
	            containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
	            if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
	          }
	        }

	        for (var m = 0; m < self.config.showMonths; m++) {
	          var month = self.daysContainer.children[m];
	          var prevMonth = self.daysContainer.children[m - 1];

	          var _loop = function _loop(i, l) {
	            var dayElem = month.children[i],
	                date = dayElem.dateObj;
	            var timestamp = date.getTime();
	            var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;

	            if (outOfRange) {
	              dayElem.classList.add("notAllowed");
	              ["inRange", "startRange", "endRange"].forEach(function (c) {
	                dayElem.classList.remove(c);
	              });
	              return "continue";
	            } else if (containsDisabled && !outOfRange) return "continue";

	            ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
	              dayElem.classList.remove(c);
	            });

	            if (elem !== undefined) {
	              elem.classList.add(hoverDate < self.selectedDates[0].getTime() ? "startRange" : "endRange");

	              if (month.contains(elem) || !(m > 0 && prevMonth && prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
	                if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
	                if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
	              }
	            }
	          };

	          for (var i = 0, l = month.children.length; i < l; i++) {
	            var _ret = _loop(i, l);

	            if (_ret === "continue") continue;
	          }
	        }
	      }

	      function onResize() {
	        if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
	      }

	      function open(e, positionElement) {
	        if (positionElement === void 0) {
	          positionElement = self._positionElement;
	        }

	        if (self.isMobile === true) {
	          if (e) {
	            e.preventDefault();
	            e.target && e.target.blur();
	          }

	          if (self.mobileInput !== undefined) {
	            self.mobileInput.focus();
	            self.mobileInput.click();
	          }

	          triggerEvent("onOpen");
	          return;
	        }

	        if (self._input.disabled || self.config.inline) return;
	        var wasOpen = self.isOpen;
	        self.isOpen = true;

	        if (!wasOpen) {
	          self.calendarContainer.classList.add("open");

	          self._input.classList.add("active");

	          triggerEvent("onOpen");
	          positionCalendar(positionElement);
	        }

	        if (self.config.enableTime === true && self.config.noCalendar === true) {
	          if (self.selectedDates.length === 0) {
	            self.setDate(self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date(), false);
	            setDefaultHours();
	            updateValue();
	          }

	          if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
	            setTimeout(function () {
	              return self.hourElement.select();
	            }, 50);
	          }
	        }
	      }

	      function minMaxDateSetter(type) {
	        return function (date) {
	          var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
	          var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

	          if (dateObj !== undefined) {
	            self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
	          }

	          if (self.selectedDates) {
	            self.selectedDates = self.selectedDates.filter(function (d) {
	              return isEnabled(d);
	            });
	            if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
	            updateValue();
	          }

	          if (self.daysContainer) {
	            redraw();
	            if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
	            self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
	          }
	        };
	      }

	      function parseConfig() {
	        var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
	        var userConfig = Object.assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
	        var formats$$1 = {};
	        self.config.parseDate = userConfig.parseDate;
	        self.config.formatDate = userConfig.formatDate;
	        Object.defineProperty(self.config, "enable", {
	          get: function get() {
	            return self.config._enable;
	          },
	          set: function set(dates) {
	            self.config._enable = parseDateRules(dates);
	          }
	        });
	        Object.defineProperty(self.config, "disable", {
	          get: function get() {
	            return self.config._disable;
	          },
	          set: function set(dates) {
	            self.config._disable = parseDateRules(dates);
	          }
	        });
	        var timeMode = userConfig.mode === "time";

	        if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
	          formats$$1.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : flatpickr.defaultConfig.dateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
	        }

	        if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
	          formats$$1.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : flatpickr.defaultConfig.altFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
	        }

	        Object.defineProperty(self.config, "minDate", {
	          get: function get() {
	            return self.config._minDate;
	          },
	          set: minMaxDateSetter("min")
	        });
	        Object.defineProperty(self.config, "maxDate", {
	          get: function get() {
	            return self.config._maxDate;
	          },
	          set: minMaxDateSetter("max")
	        });

	        var minMaxTimeSetter = function minMaxTimeSetter(type) {
	          return function (val) {
	            self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
	          };
	        };

	        Object.defineProperty(self.config, "minTime", {
	          get: function get() {
	            return self.config._minTime;
	          },
	          set: minMaxTimeSetter("min")
	        });
	        Object.defineProperty(self.config, "maxTime", {
	          get: function get() {
	            return self.config._maxTime;
	          },
	          set: minMaxTimeSetter("max")
	        });

	        if (userConfig.mode === "time") {
	          self.config.noCalendar = true;
	          self.config.enableTime = true;
	        }

	        Object.assign(self.config, formats$$1, userConfig);

	        for (var i = 0; i < boolOpts.length; i++) {
	          self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
	        }

	        HOOKS.filter(function (hook) {
	          return self.config[hook] !== undefined;
	        }).forEach(function (hook) {
	          self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
	        });
	        self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

	        for (var _i = 0; _i < self.config.plugins.length; _i++) {
	          var pluginConf = self.config.plugins[_i](self) || {};

	          for (var key in pluginConf) {
	            if (HOOKS.indexOf(key) > -1) {
	              self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
	            } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
	          }
	        }

	        triggerEvent("onParseConfig");
	      }

	      function setupLocale() {
	        if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
	        self.l10n = Object.assign({}, flatpickr.l10ns.default, typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
	        tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
	        self.formatDate = createDateFormatter(self);
	        self.parseDate = createDateParser({
	          config: self.config,
	          l10n: self.l10n
	        });
	      }

	      function positionCalendar(customPositionElement) {
	        if (self.calendarContainer === undefined) return;
	        triggerEvent("onPreCalendarPosition");
	        var positionElement = customPositionElement || self._positionElement;
	        var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
	          return acc + child.offsetHeight;
	        }, 0),
	            calendarWidth = self.calendarContainer.offsetWidth,
	            configPos = self.config.position.split(" "),
	            configPosVertical = configPos[0],
	            configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
	            inputBounds = positionElement.getBoundingClientRect(),
	            distanceFromBottom = window.innerHeight - inputBounds.bottom,
	            showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
	        var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
	        toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
	        toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
	        if (self.config.inline) return;
	        var left = window.pageXOffset + inputBounds.left - (configPosHorizontal != null && configPosHorizontal === "center" ? (calendarWidth - inputBounds.width) / 2 : 0);
	        var right = window.document.body.offsetWidth - inputBounds.right;
	        var rightMost = left + calendarWidth > window.document.body.offsetWidth;
	        toggleClass(self.calendarContainer, "rightMost", rightMost);
	        if (self.config.static) return;
	        self.calendarContainer.style.top = top + "px";

	        if (!rightMost) {
	          self.calendarContainer.style.left = left + "px";
	          self.calendarContainer.style.right = "auto";
	        } else {
	          self.calendarContainer.style.left = "auto";
	          self.calendarContainer.style.right = right + "px";
	        }
	      }

	      function redraw() {
	        if (self.config.noCalendar || self.isMobile) return;
	        updateNavigationCurrentMonth();
	        buildDays();
	      }

	      function focusAndClose() {
	        self._input.focus();

	        if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
	          setTimeout(self.close, 0);
	        } else {
	          self.close();
	        }
	      }

	      function selectDate(e) {
	        e.preventDefault();
	        e.stopPropagation();

	        var isSelectable = function isSelectable(day) {
	          return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("disabled") && !day.classList.contains("notAllowed");
	        };

	        var t = findParent(e.target, isSelectable);
	        if (t === undefined) return;
	        var target = t;
	        var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
	        var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
	        self.selectedDateElem = target;
	        if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
	          var selectedIndex = isDateSelected(selectedDate);
	          if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
	        } else if (self.config.mode === "range") {
	          if (self.selectedDates.length === 2) self.clear(false);
	          self.selectedDates.push(selectedDate);
	          if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
	            return a.getTime() - b.getTime();
	          });
	        }
	        setHoursFromInputs();

	        if (shouldChangeMonth) {
	          var isNewYear = self.currentYear !== selectedDate.getFullYear();
	          self.currentYear = selectedDate.getFullYear();
	          self.currentMonth = selectedDate.getMonth();
	          if (isNewYear) triggerEvent("onYearChange");
	          triggerEvent("onMonthChange");
	        }

	        updateNavigationCurrentMonth();
	        buildDays();
	        updateValue();
	        if (self.config.enableTime) setTimeout(function () {
	          return self.showTimeInput = true;
	        }, 50);
	        if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else self.selectedDateElem && self.selectedDateElem.focus();
	        if (self.hourElement !== undefined) setTimeout(function () {
	          return self.hourElement !== undefined && self.hourElement.select();
	        }, 451);

	        if (self.config.closeOnSelect) {
	          var single = self.config.mode === "single" && !self.config.enableTime;
	          var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

	          if (single || range) {
	            focusAndClose();
	          }
	        }

	        triggerChange();
	      }

	      var CALLBACKS = {
	        locale: [setupLocale, updateWeekdays],
	        showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
	      };

	      function set(option, value) {
	        if (option !== null && typeof option === "object") Object.assign(self.config, option);else {
	          self.config[option] = value;
	          if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
	            return x();
	          });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
	        }
	        self.redraw();
	        jumpToDate();
	        updateValue(false);
	      }

	      function setSelectedDate(inputDate, format) {
	        var dates = [];
	        if (inputDate instanceof Array) dates = inputDate.map(function (d) {
	          return self.parseDate(d, format);
	        });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
	          switch (self.config.mode) {
	            case "single":
	            case "time":
	              dates = [self.parseDate(inputDate, format)];
	              break;

	            case "multiple":
	              dates = inputDate.split(self.config.conjunction).map(function (date) {
	                return self.parseDate(date, format);
	              });
	              break;

	            case "range":
	              dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
	                return self.parseDate(date, format);
	              });
	              break;

	            default:
	              break;
	          }
	        } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
	        self.selectedDates = dates.filter(function (d) {
	          return d instanceof Date && isEnabled(d, false);
	        });
	        if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
	          return a.getTime() - b.getTime();
	        });
	      }

	      function setDate(date, triggerChange, format) {
	        if (triggerChange === void 0) {
	          triggerChange = false;
	        }

	        if (format === void 0) {
	          format = self.config.dateFormat;
	        }

	        if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
	        setSelectedDate(date, format);
	        self.showTimeInput = self.selectedDates.length > 0;
	        self.latestSelectedDateObj = self.selectedDates[0];
	        self.redraw();
	        jumpToDate();
	        setHoursFromDate();
	        updateValue(triggerChange);
	        if (triggerChange) triggerEvent("onChange");
	      }

	      function parseDateRules(arr) {
	        return arr.slice().map(function (rule) {
	          if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
	            return self.parseDate(rule, undefined, true);
	          } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
	            from: self.parseDate(rule.from, undefined),
	            to: self.parseDate(rule.to, undefined)
	          };

	          return rule;
	        }).filter(function (x) {
	          return x;
	        });
	      }

	      function setupDates() {
	        self.selectedDates = [];
	        self.now = self.parseDate(self.config.now) || new Date();
	        var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
	        if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
	        var initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
	        self.currentYear = initialDate.getFullYear();
	        self.currentMonth = initialDate.getMonth();
	        if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
	        if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
	        if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
	        self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
	        self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
	        Object.defineProperty(self, "showTimeInput", {
	          get: function get() {
	            return self._showTimeInput;
	          },
	          set: function set(bool) {
	            self._showTimeInput = bool;
	            if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
	            self.isOpen && positionCalendar();
	          }
	        });
	      }

	      function setupInputs() {
	        self.input = self.config.wrap ? element.querySelector("[data-input]") : element;

	        if (!self.input) {
	          self.config.errorHandler(new Error("Invalid input element specified"));
	          return;
	        }

	        self.input._type = self.input.type;
	        self.input.type = "text";
	        self.input.classList.add("flatpickr-input");
	        self._input = self.input;

	        if (self.config.altInput) {
	          self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
	          self._input = self.altInput;
	          self.altInput.placeholder = self.input.placeholder;
	          self.altInput.disabled = self.input.disabled;
	          self.altInput.required = self.input.required;
	          self.altInput.tabIndex = self.input.tabIndex;
	          self.altInput.type = "text";
	          self.input.setAttribute("type", "hidden");
	          if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
	        }

	        if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
	        self._positionElement = self.config.positionElement || self._input;
	      }

	      function setupMobile() {
	        var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
	        self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
	        self.mobileInput.step = self.input.getAttribute("step") || "any";
	        self.mobileInput.tabIndex = 1;
	        self.mobileInput.type = inputType;
	        self.mobileInput.disabled = self.input.disabled;
	        self.mobileInput.required = self.input.required;
	        self.mobileInput.placeholder = self.input.placeholder;
	        self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

	        if (self.selectedDates.length > 0) {
	          self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
	        }

	        if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
	        if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
	        self.input.type = "hidden";
	        if (self.altInput !== undefined) self.altInput.type = "hidden";

	        try {
	          if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
	        } catch (_a) {}

	        bind(self.mobileInput, "change", function (e) {
	          self.setDate(e.target.value, false, self.mobileFormatStr);
	          triggerEvent("onChange");
	          triggerEvent("onClose");
	        });
	      }

	      function toggle(e) {
	        if (self.isOpen === true) return self.close();
	        self.open(e);
	      }

	      function triggerEvent(event, data) {
	        if (self.config === undefined) return;
	        var hooks = self.config[event];

	        if (hooks !== undefined && hooks.length > 0) {
	          for (var i = 0; hooks[i] && i < hooks.length; i++) {
	            hooks[i](self.selectedDates, self.input.value, self, data);
	          }
	        }

	        if (event === "onChange") {
	          self.input.dispatchEvent(createEvent("change"));
	          self.input.dispatchEvent(createEvent("input"));
	        }
	      }

	      function createEvent(name) {
	        var e = document.createEvent("Event");
	        e.initEvent(name, true, true);
	        return e;
	      }

	      function isDateSelected(date) {
	        for (var i = 0; i < self.selectedDates.length; i++) {
	          if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
	        }

	        return false;
	      }

	      function isDateInRange(date) {
	        if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
	        return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
	      }

	      function updateNavigationCurrentMonth() {
	        if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
	        self.yearElements.forEach(function (yearElement, i) {
	          var d = new Date(self.currentYear, self.currentMonth, 1);
	          d.setMonth(self.currentMonth + i);
	          self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
	          yearElement.value = d.getFullYear().toString();
	        });
	        self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
	        self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
	      }

	      function getDateStr(format) {
	        return self.selectedDates.map(function (dObj) {
	          return self.formatDate(dObj, format);
	        }).filter(function (d, i, arr) {
	          return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
	        }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
	      }

	      function updateValue(triggerChange) {
	        if (triggerChange === void 0) {
	          triggerChange = true;
	        }

	        if (self.selectedDates.length === 0) return self.clear(triggerChange);

	        if (self.mobileInput !== undefined && self.mobileFormatStr) {
	          self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
	        }

	        self.input.value = getDateStr(self.config.dateFormat);

	        if (self.altInput !== undefined) {
	          self.altInput.value = getDateStr(self.config.altFormat);
	        }

	        if (triggerChange !== false) triggerEvent("onValueUpdate");
	      }

	      function onMonthNavClick(e) {
	        e.preventDefault();
	        var isPrevMonth = self.prevMonthNav.contains(e.target);
	        var isNextMonth = self.nextMonthNav.contains(e.target);

	        if (isPrevMonth || isNextMonth) {
	          changeMonth(isPrevMonth ? -1 : 1);
	        } else if (self.yearElements.indexOf(e.target) >= 0) {
	          e.target.select();
	        } else if (e.target.classList.contains("arrowUp")) {
	          self.changeYear(self.currentYear + 1);
	        } else if (e.target.classList.contains("arrowDown")) {
	          self.changeYear(self.currentYear - 1);
	        }
	      }

	      function timeWrapper(e) {
	        e.preventDefault();
	        var isKeyDown = e.type === "keydown",
	            input = e.target;

	        if (self.amPM !== undefined && e.target === self.amPM) {
	          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
	        }

	        var min = parseFloat(input.getAttribute("data-min")),
	            max = parseFloat(input.getAttribute("data-max")),
	            step = parseFloat(input.getAttribute("data-step")),
	            curValue = parseInt(input.value, 10),
	            delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
	        var newValue = curValue + step * delta;

	        if (typeof input.value !== "undefined" && input.value.length === 2) {
	          var isHourElem = input === self.hourElement,
	              isMinuteElem = input === self.minuteElement;

	          if (newValue < min) {
	            newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
	            if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
	          } else if (newValue > max) {
	            newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
	            if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
	          }

	          if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
	            self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
	          }

	          input.value = pad(newValue);
	        }
	      }

	      init();
	      return self;
	    }

	    function _flatpickr(nodeList, config) {
	      var nodes = Array.prototype.slice.call(nodeList);
	      var instances = [];

	      for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];

	        try {
	          if (node.getAttribute("data-fp-omit") !== null) continue;

	          if (node._flatpickr !== undefined) {
	            node._flatpickr.destroy();

	            node._flatpickr = undefined;
	          }

	          node._flatpickr = FlatpickrInstance(node, config || {});
	          instances.push(node._flatpickr);
	        } catch (e) {
	          console.error(e);
	        }
	      }

	      return instances.length === 1 ? instances[0] : instances;
	    }

	    if (typeof HTMLElement !== "undefined") {
	      HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
	        return _flatpickr(this, config);
	      };

	      HTMLElement.prototype.flatpickr = function (config) {
	        return _flatpickr([this], config);
	      };
	    }

	    var flatpickr = function flatpickr(selector, config) {
	      if (selector instanceof NodeList) return _flatpickr(selector, config);else if (typeof selector === "string") return _flatpickr(window.document.querySelectorAll(selector), config);
	      return _flatpickr([selector], config);
	    };

	    flatpickr.defaultConfig = defaults;
	    flatpickr.l10ns = {
	      en: Object.assign({}, english),
	      default: Object.assign({}, english)
	    };

	    flatpickr.localize = function (l10n) {
	      flatpickr.l10ns.default = Object.assign({}, flatpickr.l10ns.default, l10n);
	    };

	    flatpickr.setDefaults = function (config) {
	      flatpickr.defaultConfig = Object.assign({}, flatpickr.defaultConfig, config);
	    };

	    flatpickr.parseDate = createDateParser({});
	    flatpickr.formatDate = createDateFormatter({});
	    flatpickr.compareDates = compareDates;

	    if (typeof jQuery !== "undefined") {
	      jQuery.fn.flatpickr = function (config) {
	        return _flatpickr(this, config);
	      };
	    }

	    Date.prototype.fp_incr = function (days) {
	      return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
	    };

	    if (typeof window !== "undefined") {
	      window.flatpickr = flatpickr;
	    }

	    return flatpickr;

	})));


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapComponent = __webpack_require__(572);

	var _SGoogleMapComponent2 = _interopRequireDefault(_SGoogleMapComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapComponent2.default.define('s-google-map', _SGoogleMapComponent2.default);

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _coffeekrakenSGoogleMapComponentBase = __webpack_require__(573);

	var _coffeekrakenSGoogleMapComponentBase2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponentBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SGoogleMapComponent
	 * @extends 	SGoogleMapComponentBase
	 * Provide a nice webcomponent wrapper around the google map api.
	 * @example 	html
	 * <s-google-map center="{lat: -25.363, lng: 131.044}"></s-google-map>
	 * @see 	https://www.npmjs.com/package/google-maps
	 * @see 	https://developers.google.com/maps/documentation/javascript/
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SGoogleMapComponent = function (_SGoogleMapComponentB) {
		_inherits(SGoogleMapComponent, _SGoogleMapComponentB);

		function SGoogleMapComponent() {
			_classCallCheck(this, SGoogleMapComponent);

			return _possibleConstructorReturn(this, (SGoogleMapComponent.__proto__ || Object.getPrototypeOf(SGoogleMapComponent)).apply(this, arguments));
		}

		_createClass(SGoogleMapComponent, [{
			key: 'shouldComponentAcceptProp',


			/**
	   * Accept all props
	   * @definition 		SWebComponent.shouldComponentAcceptProp
	   * @protected
	   */
			value: function shouldComponentAcceptProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentWillMount', this).call(this);

				// save the markers that are in the map
				this._markers = [];
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentMount', this).call(this);

				// create the map container
				this._mapElm = document.createElement('div');
				this._mapElm.className = this._componentNameDash + '__map';
				this._mapElm.setAttribute('s-google-map-map', true);

				// try to get the placeholder
				this._placeholder = this.querySelector(this._componentNameDash + '-placeholder');

				// manage placeholder
				if (this._placeholder) {
					this._handlePlaceholder();
				} else {
					// init directly
					this._internalInit();
				}

				// listen for new markers
				this.addEventListener('new-google-map-marker', this._onNewMarker.bind(this));
				this.addEventListener('remove-google-map-marker', this._onMarkerRemoved.bind(this));

				// append the map elm
				this.appendChild(this._mapElm);

				// dispatch an event to say that the map is ready
				this.dispatchComponentEvent('ready');
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'skin':
						this._map.setOptions({
							styles: SGoogleMapComponent._registeredSkins[newVal]
						});
						break;
				}
			}

			/**
	   * Component will receive props
	   * @definition 		SWebComponent.componentWillReceiveProps
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps, previousProps) {
				if (!this._map) return;
				this._map.setOptions(nextProps);
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SGoogleMapComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Handle the placeholder element
	   */

		}, {
			key: '_handlePlaceholder',
			value: function _handlePlaceholder() {
				// listen to init the map
				this._placeholder.addEventListener(this.props.initOn, this._onPlaceholderInit.bind(this));
			}

			/**
	   * When a new marker is added to the map
	   * @param 	{Event} 	e 		The event
	   */

		}, {
			key: '_onNewMarker',
			value: function _onNewMarker(e) {
				// check if already savec
				if (this._markers.indexOf(e.detail) !== -1) return;
				// save the new marker
				this._markers.push(e.detail);
			}

			/**
	   * When a marker is removed from the map
	   * @param  	{Event} 	e 		The event
	   */

		}, {
			key: '_onMarkerRemoved',
			value: function _onMarkerRemoved(e) {
				var idx = this._markers.indexOf(e.detail);
				if (idx !== -1) {
					this._markers.splice(idx, 1);
				}
			}

			/**
	   * Proxy function of placeholder init listener
	   */

		}, {
			key: '_onPlaceholderInit',
			value: function _onPlaceholderInit() {
				// remove the placeholder
				this._placeholder.parentNode.removeChild(this._placeholder);
				// stop listening for init on placeholder
				this._placeholder.removeEventListener(this.props.initOn, this._onPlaceholderInit);
				// internal init
				this._internalInit();
			}

			/**
	   * Init the map
	   */

		}, {
			key: '_internalInit',
			value: function _internalInit() {
				// init the map
				this._initMap();
			}

			/**
	   * Init the map
	   */

		}, {
			key: '_initMap',
			value: function _initMap() {
				var styles = this.props.styles;
				if (this.props.skin) {
					styles = SGoogleMapComponent._registeredSkins[this.props.skin];
				}
				this._map = new this.google.maps.Map(this._mapElm, _extends({}, this.props, {
					styles: styles
				}));
				// set the component as inited
				// used by the markers to init when the map is ok
				this.setAttribute('inited', true);
			}

			/**
	   * Fit the map to the markers
	   * @param  {Array<Google.Maps.Marker>}  	[markers=this.markers] 		The markers to fit the map to
	   */

		}, {
			key: 'fitToMarkers',
			value: function fitToMarkers() {
				var markers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._markers;

				var bounds = new this.google.maps.LatLngBounds();
				for (var i = 0; i < markers.length; i++) {
					bounds.extend(markers[i].getPosition());
				}
				this.map.fitBounds(bounds);
			}

			/**
	   * Access the google map instance
	   * @name 	map
	   * @type 	{Google.Map}
	   */

		}, {
			key: 'map',
			get: function get() {
				return this._map;
			}

			/**
	   * Access all the google markers instances
	   * @name  markers
	   * @type 	{Array<Google.Maps.Marker>}
	   */

		}, {
			key: 'markers',
			get: function get() {
				return this._markers;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: relative;\n\t\t\t\tmin-height: 50px;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__map {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0; left: 0;\n\t\t\t\twidth: 100%; height: 100%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__placeholder {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tcursor: pointer;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\t\t';
			}

			/**
	   * Register a map style to use later through the "style" property
	   * @param 		{String} 		name 		The name of the style to register
	   * @param 		{Object} 		skin 		The skin object
	   */

		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Set the initial zoom of the map
	     * @prop
	     * @type 	{integer}
	     */
					zoom: 4,

					/**
	     * Set when to init the map if the placeholder setting is used
	     * @prop
	     * @type 	{String}
	     */
					initOn: 'click',

					/**
	     * Specify a registered skin to use. The skin has to be registered through the static ```SGoogleMapComponent.registerSkin``` method.
	     * @prop
	     * @type 	{String}
	     */
					skin: null

					/**
	     * @name 	Google Map API
	     * Support all the google api options
	     * @prop
	     * @name 	All others google map options
	     * @type 	{Mixed}
	     */
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SGoogleMapComponent;
	}(_coffeekrakenSGoogleMapComponentBase2.default);

	SGoogleMapComponent._registeredSkins = {};

	SGoogleMapComponent.registerSkin = function (name, skin) {
		// save the new skin
		SGoogleMapComponent._registeredSkins[name] = skin;
	};

	exports.default = SGoogleMapComponent;

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapComponentBase = __webpack_require__(574);

	var _SGoogleMapComponentBase2 = _interopRequireDefault(_SGoogleMapComponentBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapComponentBase2.default;

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _googleMaps = __webpack_require__(575);

	var _googleMaps2 = _interopRequireDefault(_googleMaps);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SGoogleMapComponentBase = function (_SWebComponent) {
		_inherits(SGoogleMapComponentBase, _SWebComponent);

		function SGoogleMapComponentBase() {
			_classCallCheck(this, SGoogleMapComponentBase);

			return _possibleConstructorReturn(this, (SGoogleMapComponentBase.__proto__ || Object.getPrototypeOf(SGoogleMapComponentBase)).apply(this, arguments));
		}

		_createClass(SGoogleMapComponentBase, [{
			key: '_loadGoogleApi',


			/**
	   * Return a promise that load the google api
	   * @return 	{Promise}
	   */
			value: function _loadGoogleApi() {
				// set some static variables on the google loader
				if (this.props.apiKey) {
					_googleMaps2.default.KEY = this.props.apiKey;
				}
				if (this.props.client) {
					_googleMaps2.default.CLIENT = this.props.client;
				}
				if (this.props.version) {
					_googleMaps2.default.VERSION = this.props.version;
				}
				if (this.props.libraries) {
					_googleMaps2.default.LIBRARIES = this.props.libraries;
				}
				if (this.props.language) {
					_googleMaps2.default.LANGUAGE = this.props.language;
				}
				if (this.props.region) {
					_googleMaps2.default.REGION = this.props.region;
				}
				return new Promise(function (resolve, reject) {
					// load the map api
					_googleMaps2.default.load(function (google) {
						// resolve the promise
						resolve(google);
					});
				});
			}

			/**
	   * Get the google api
	   * @type 	{Google}
	   */

		}, {
			key: 'google',
			get: function get() {
				return window.google;
			}
		}], [{
			key: 'mountDependencies',


			/**
	   * Return a list of promises to resolve before init the component
	   * @return 	{Array} 	An array of promises to resolve
	   */
			get: function get() {
				return [function () {
					return this._loadGoogleApi();
				}];
			}

			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   */

		}, {
			key: 'defaultProps',
			get: function get() {
				return {

					/**
	     * Set the api key used to reach the google services
	     * @prop
	     * @type		{String}
	     */
					apiKey: null,

					/**
	     * Set the client api id used to reach google services
	     * @prop
	     * @type 		{String}
	     */
					client: null,

					/**
	     * Set the version of the api to load
	     * @prop
	     * @type		{String}
	     */
					version: null,

					/**
	     * Set the libraries to load
	     * @prop
	     * @type		{Array}
	     */
					libraries: null,

					/**
	     * Set the language to use
	     * @prop
	     * @type  	{String}
	     */
					language: null,

					/**
	     * Store the region to use
	     * @prop
	     * @type 	{String}
	     */
					region: null
				};
			}
		}]);

		return SGoogleMapComponentBase;
	}(_SWebComponent3.default);

	exports.default = SGoogleMapComponentBase;

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {

		if (root === null) {
			throw new Error('Google-maps package can be used only in browser');
		}

		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			module.exports = factory();
		} else {
			root.GoogleMapsLoader = factory();
		}

	})(typeof window !== 'undefined' ? window : null, function() {


		'use strict';


		var googleVersion = '3.31';

		var script = null;

		var google = null;

		var loading = false;

		var callbacks = [];

		var onLoadEvents = [];

		var originalCreateLoaderMethod = null;


		var GoogleMapsLoader = {};


		GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';

		GoogleMapsLoader.KEY = null;

		GoogleMapsLoader.LIBRARIES = [];

		GoogleMapsLoader.CLIENT = null;

		GoogleMapsLoader.CHANNEL = null;

		GoogleMapsLoader.LANGUAGE = null;

		GoogleMapsLoader.REGION = null;

		GoogleMapsLoader.VERSION = googleVersion;

		GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';


		GoogleMapsLoader._googleMockApiObject = {};


		GoogleMapsLoader.load = function(fn) {
			if (google === null) {
				if (loading === true) {
					if (fn) {
						callbacks.push(fn);
					}
				} else {
					loading = true;

					window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
						ready(fn);
					};

					GoogleMapsLoader.createLoader();
				}
			} else if (fn) {
				fn(google);
			}
		};


		GoogleMapsLoader.createLoader = function() {
			script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = GoogleMapsLoader.createUrl();

			document.body.appendChild(script);
		};


		GoogleMapsLoader.isLoaded = function() {
			return google !== null;
		};


		GoogleMapsLoader.createUrl = function() {
			var url = GoogleMapsLoader.URL;

			url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;

			if (GoogleMapsLoader.KEY) {
				url += '&key=' + GoogleMapsLoader.KEY;
			}

			if (GoogleMapsLoader.LIBRARIES.length > 0) {
				url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
			}

			if (GoogleMapsLoader.CLIENT) {
				url += '&client=' + GoogleMapsLoader.CLIENT;
			}

			if (GoogleMapsLoader.CHANNEL) {
				url += '&channel=' + GoogleMapsLoader.CHANNEL;
			}

			if (GoogleMapsLoader.LANGUAGE) {
				url += '&language=' + GoogleMapsLoader.LANGUAGE;
			}

			if (GoogleMapsLoader.REGION) {
				url += '&region=' + GoogleMapsLoader.REGION;
			}

			if (GoogleMapsLoader.VERSION) {
				url += '&v=' + GoogleMapsLoader.VERSION;
			}

			return url;
		};


		GoogleMapsLoader.release = function(fn) {
			var release = function() {
				GoogleMapsLoader.KEY = null;
				GoogleMapsLoader.LIBRARIES = [];
				GoogleMapsLoader.CLIENT = null;
				GoogleMapsLoader.CHANNEL = null;
				GoogleMapsLoader.LANGUAGE = null;
				GoogleMapsLoader.REGION = null;
				GoogleMapsLoader.VERSION = googleVersion;

				google = null;
				loading = false;
				callbacks = [];
				onLoadEvents = [];

				if (typeof window.google !== 'undefined') {
					delete window.google;
				}

				if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
					delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
				}

				if (originalCreateLoaderMethod !== null) {
					GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
					originalCreateLoaderMethod = null;
				}

				if (script !== null) {
					script.parentElement.removeChild(script);
					script = null;
				}

				if (fn) {
					fn();
				}
			};

			if (loading) {
				GoogleMapsLoader.load(function() {
					release();
				});
			} else {
				release();
			}
		};


		GoogleMapsLoader.onLoad = function(fn) {
			onLoadEvents.push(fn);
		};


		GoogleMapsLoader.makeMock = function() {
			originalCreateLoaderMethod = GoogleMapsLoader.createLoader;

			GoogleMapsLoader.createLoader = function() {
				window.google = GoogleMapsLoader._googleMockApiObject;
				window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
			};
		};


		var ready = function(fn) {
			var i;

			loading = false;

			if (google === null) {
				google = window.google;
			}

			for (i = 0; i < onLoadEvents.length; i++) {
				onLoadEvents[i](google);
			}

			if (fn) {
				fn(google);
			}

			for (i = 0; i < callbacks.length; i++) {
				callbacks[i](google);
			}

			callbacks = [];
		};


		return GoogleMapsLoader;

	});


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SGoogleMapMarkerComponent = __webpack_require__(577);

	var _SGoogleMapMarkerComponent2 = _interopRequireDefault(_SGoogleMapMarkerComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SGoogleMapMarkerComponent2.default.define('s-google-map-marker', _SGoogleMapMarkerComponent2.default);

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _coffeekrakenSGoogleMapComponentBase = __webpack_require__(573);

	var _coffeekrakenSGoogleMapComponentBase2 = _interopRequireDefault(_coffeekrakenSGoogleMapComponentBase);

	var _whenAttribute = __webpack_require__(578);

	var _whenAttribute2 = _interopRequireDefault(_whenAttribute);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SGoogleMapMarkerComponent
	 * @extends 	SGoogleMapComponentBase
	 * Provide a nice webcomponent wrapper around the google map marker api.
	 *
	 * @example 	html
	 * <s-google-map center="{lat: -25.363, lng: 131.044}">
	 * 	<s-google-map-marker position="{lat: -25.363, lng: 131.044}">
	 * 	</s-google-map-marker>
	 * </s-google-map>
	 * @see 	https://www.npmjs.com/package/google-maps
	 * @see 	https://developers.google.com/maps/documentation/javascript/
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SGoogleMapMarkerComponent = function (_SGoogleMapComponentB) {
		_inherits(SGoogleMapMarkerComponent, _SGoogleMapComponentB);

		function SGoogleMapMarkerComponent() {
			_classCallCheck(this, SGoogleMapMarkerComponent);

			return _possibleConstructorReturn(this, (SGoogleMapMarkerComponent.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent)).apply(this, arguments));
		}

		_createClass(SGoogleMapMarkerComponent, [{
			key: 'shouldComponentAcceptProp',


			/**
	   * Should accept component props
	   * @definition 		SWebComponent.shouldComponentAcceptProp
	   * @protected
	   */
			value: function shouldComponentAcceptProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentMount', this).call(this);

				// save reference to the parent node to dispatch an event when unmounted
				this._parentNode = this.parentNode;

				// get the map instance to use for this marker.
				// this is grabed from the parent node that need to be a google-map component
				if (!this.map) {
					throw 'The "' + this._componentNameDash + '" component has to be a direct child of a "SGoogleMapComponent"';
				}

				// add the marker to the map
				// load the map api
				if (!this._marker) {
					this._initMarker();
				} else {
					this._marker.setMap(this.map);
				}

				// dispatch an event to notify the new marker
				this.dispatchComponentEvent('new-google-map-marker', this._marker);
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'componentUnmount', this).call(this);
				// remove the marker from the map
				if (this._marker) {
					this._marker.setMap(null);
				}
				// dispatch an event to notify the new marker
				this.dispatchComponentEvent('remove-google-map-marker', this._marker, this._parentNode);
			}

			/**
	   * Component will receive props
	   * @definition 		SWebComponent.componentWillReceiveProps
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps, previousProps) {
				if (!this._marker) return;
				this._marker.setOptions(nextProps);
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SGoogleMapMarkerComponent.prototype.__proto__ || Object.getPrototypeOf(SGoogleMapMarkerComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Init the marker
	   */

		}, {
			key: '_initMarker',
			value: function _initMarker() {
				this._marker = new this.google.maps.Marker(this.props);
				this._marker.setMap(this.map);
				// set the component as inited
				// used by the markers to init when the map is ok
				this.setAttribute('inited', true);
			}

			/**
	   * Access the google map instance
	   * @type 	{Google.Map}
	   */

		}, {
			key: 'map',
			get: function get() {
				return this.parentNode.map;
			}

			/**
	   * Access the google map marker instance
	   * @type 	{Google.Map.Marker}
	   */

		}, {
			key: 'marker',
			get: function get() {
				return this._marker;
			}
		}], [{
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {

					/**
	     * @name 	Google Map Marker API
	     * Support all the google map marker API properties
	     * @prop
	     * @type 	{Google.Map.Marker}
	     * @see 	https://developers.google.com/maps/documentation/javascript/3.exp/reference#MarkerOptions 	Google Map Marker Options
	     */

				};
			}

			/**
	   * Mount dependencies
	   * @definition 		SWebComponent.mountDependencies
	   * @protected
	   */

		}, {
			key: 'mountDependencies',
			get: function get() {
				return [function () {
					return (0, _whenAttribute2.default)(this.parentNode, 'inited');
				}];
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SGoogleMapMarkerComponent;
	}(_coffeekrakenSGoogleMapComponentBase2.default);

	exports.default = SGoogleMapMarkerComponent;

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = whenAttribute;

	var _attributesObservable = __webpack_require__(579);

	var _attributesObservable2 = _interopRequireDefault(_attributesObservable);

	var _autoCast = __webpack_require__(540);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Resolve a promise when the wanted attribute on the passed HTMLElement exist or pass the check function provided
	 *
	 * @name 		whenAttribute
	 * @param 		{HTMLElement} 				elm 				The HTMLElement on which to monitor the property
	 * @param 		{String} 					attribute 			The attribute to monitor
	 * @param 		{Function} 					[checkFn=null] 		An optional function to check the attribute. The promise is resolved when this function return true
	 * @return 		(Promise) 										The promise that will be resolved when the attribute exist on the element (and that it passes the checkFn)
	 *
	 * @example 	js
	 * import whenAttribute from 'sugarcss/js/dom/whenAttribute'
	 * whenAttribute(myCoolHTMLElement, 'value').then((value) => {
	 * 		// the value attribute exist on the element
	 * });
	 * // with a checkFn
	 * whenAttribute(myCoolHTMLElement, 'value', (newVal, oldVal) => {
	 * 		// make sure the value is a number
	 * 		return typeof(newVal) === 'number';
	 * }).then((value) => {
	 * 		// do something with your number value...
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function whenAttribute(elm, attrName) {
		var checkFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

		return new Promise(function (resolve, reject) {

			if (elm.hasAttribute(attrName)) {
				var value = (0, _autoCast2.default)(elm.getAttribute(attrName));
				if (checkFn && checkFn(value, value)) {
					resolve(value);
					return;
				} else if (!checkFn) {
					resolve(value);
					return;
				}
			}

			var obs = (0, _attributesObservable2.default)(elm).subscribe(function (mutation) {
				if (mutation.attributeName === attrName) {
					var _value = (0, _autoCast2.default)(mutation.target.getAttribute(mutation.attributeName));
					if (checkFn && checkFn(_value, mutation.oldValue)) {
						resolve(_value);
						obs.unsubscribe();
					} else if (!checkFn) {
						resolve(_value);
						obs.unsubscribe();
					}
				}
			});
		});
	}

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	/**
	 * List of attributes to observe
	 * @setting
	 * @name 		attributes
	 * @type 		{Array}
	 * @default 	null
	 */
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	/**
	 * Observe attributes on an HTMLElement and get mutations through the observable subscription
	 *
	 * @name 		attributesObservable
	 * @param 		{HTMLElement} 					target 		The element to observe
	 * @param 		{MutationObserverInit} 			settings 	The mutation observer settings
	 * @return 		{Observable} 								The mutation observable
	 *
	 * @example  	js
	 * import attributesObservable from 'sugarcss/js/dom/attributesObservable'
	 * attributesObservable(myCoolHTMLElement).subscribe((mutation) => {
	 * 		// do something with the mutation
	 * });
	 *
	 * @see 		https://developer.mozilla.org/en/docs/Web/API/MutationObserver
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */


	exports.default = function (target) {
		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		var observable = new _Observable.Observable(function (observer) {

			// create a new observer
			var mutationObserver = new MutationObserver(function (mutations) {
				var mutedAttrs = {};
				// loop on mutations
				mutations.forEach(function (mutation) {
					// push mutation
					if (!mutedAttrs[mutation.attributeName]) {
						observer.next(mutation);
						mutedAttrs[mutation.attributeName] = true;
					}
				});
				mutedAttrs = {};
			});
			mutationObserver.observe(target, _extends({
				attributes: true
			}, settings));
			// unsubscribe routine
			return function () {
				mutationObserver.disconnect();
			};
		});

		return observable;
	};

	var _Observable = __webpack_require__(580);

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(581);
	var toSubscriber_1 = __webpack_require__(582);
	var observable_1 = __webpack_require__(593);
	var pipe_1 = __webpack_require__(594);
	/**
	 * A representation of any set of values over any amount of time. This is the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
	     *
	     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
	     *
	     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
	     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
	     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
	     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
	     * thought.
	     *
	     * Apart from starting the execution of an Observable, this method allows you to listen for values
	     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
	     * following ways.
	     *
	     * The first way is creating an object that implements {@link Observer} interface. It should have methods
	     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
	     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
	     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
	     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
	     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
	     * be left uncaught.
	     *
	     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
	     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
	     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
	     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
	     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
	     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
	     *
	     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
	     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
	     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
	     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
	     *
	     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
	     * It is an Observable itself that decides when these functions will be called. For example {@link of}
	     * by default emits all its values synchronously. Always check documentation for how given Observable
	     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
	     *
	     * @example <caption>Subscribe with an Observer</caption>
	     * const sumObserver = {
	     *   sum: 0,
	     *   next(value) {
	     *     console.log('Adding: ' + value);
	     *     this.sum = this.sum + value;
	     *   },
	     *   error() { // We actually could just remove this method,
	     *   },        // since we do not really care about errors right now.
	     *   complete() {
	     *     console.log('Sum equals: ' + this.sum);
	     *   }
	     * };
	     *
	     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
	     * .subscribe(sumObserver);
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Subscribe with functions</caption>
	     * let sum = 0;
	     *
	     * Rx.Observable.of(1, 2, 3)
	     * .subscribe(
	     *   function(value) {
	     *     console.log('Adding: ' + value);
	     *     sum = sum + value;
	     *   },
	     *   undefined,
	     *   function() {
	     *     console.log('Sum equals: ' + sum);
	     *   }
	     * );
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Cancel a subscription</caption>
	     * const subscription = Rx.Observable.interval(1000).subscribe(
	     *   num => console.log(num),
	     *   undefined,
	     *   () => console.log('completed!') // Will not be called, even
	     * );                                // when cancelling subscription
	     *
	     *
	     * setTimeout(() => {
	     *   subscription.unsubscribe();
	     *   console.log('unsubscribed!');
	     * }, 2500);
	     *
	     * // Logs:
	     * // 0 after 1s
	     * // 1 after 2s
	     * // "unsubscribed!" after 2.5s
	     *
	     *
	     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
	     *  Observable.
	     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled.
	     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     * @method subscribe
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    /** @deprecated internal use only */ Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    /* tslint:enable:max-line-length */
	    /**
	     * Used to stitch together functional operators into a chain.
	     * @method pipe
	     * @return {Observable} the Observable result of all of the operators having
	     * been called in the order they were passed in.
	     *
	     * @example
	     *
	     * import { map, filter, scan } from 'rxjs/operators';
	     *
	     * Rx.Observable.interval(1000)
	     *   .pipe(
	     *     filter(x => x % 2 === 0),
	     *     map(x => x + x),
	     *     scan((acc, x) => acc + x)
	     *   )
	     *   .subscribe(x => console.log(x))
	     */
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i - 0] = arguments[_i];
	        }
	        if (operations.length === 0) {
	            return this;
	        }
	        return pipe_1.pipeFromArray(operations)(this);
	    };
	    /* tslint:enable:max-line-length */
	    Observable.prototype.toPromise = function (PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ }),
/* 581 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	// CommonJS / Node have global context exposed as "global" variable.
	// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
	// the global "global" var for now.
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _root = __window || __global || __self;
	exports.root = _root;
	// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
	// This is needed when used with angular/tsickle which inserts a goog.module statement.
	// Wrap in IIFE
	(function () {
	    if (!_root) {
	        throw new Error('RxJS could not find any global context (window, self, global)');
	    }
	})();
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(583);
	var rxSubscriber_1 = __webpack_require__(592);
	var Observer_1 = __webpack_require__(591);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(584);
	var Subscription_1 = __webpack_require__(585);
	var Observer_1 = __webpack_require__(591);
	var rxSubscriber_1 = __webpack_require__(592);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    // HACK(benlesh): To resolve an issue where Node users may have multiple
	                    // copies of rxjs in their node_modules directory.
	                    if (isTrustedSubscriber(destinationOrNext)) {
	                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
	                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
	                        this.destination = trustedSubscriber;
	                        trustedSubscriber.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    /** @deprecated internal use only */ Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    /** @deprecated internal use only */ SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	function isTrustedSubscriber(obj) {
	    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber]);
	}
	//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 584 */
/***/ (function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(586);
	var isObject_1 = __webpack_require__(587);
	var isFunction_1 = __webpack_require__(584);
	var tryCatch_1 = __webpack_require__(588);
	var errorObject_1 = __webpack_require__(589);
	var UnsubscriptionError_1 = __webpack_require__(590);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 586 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ }),
/* 587 */
/***/ (function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(589);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 589 */
/***/ (function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 590 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 591 */
/***/ (function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(581);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(581);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var noop_1 = __webpack_require__(595);
	/* tslint:enable:max-line-length */
	function pipe() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i - 0] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	exports.pipe = pipe;
	/* @internal */
	function pipeFromArray(fns) {
	    if (!fns) {
	        return noop_1.noop;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}
	exports.pipeFromArray = pipeFromArray;
	//# sourceMappingURL=pipe.js.map

/***/ }),
/* 595 */
/***/ (function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SRippleComponent = __webpack_require__(597);

	var _SRippleComponent2 = _interopRequireDefault(_SRippleComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SRippleComponent2.default.define('s-ripple', _SRippleComponent2.default);

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _coffeekrakenSParticlesSystemComponent = __webpack_require__(598);

	var _coffeekrakenSParticlesSystemComponent2 = _interopRequireDefault(_coffeekrakenSParticlesSystemComponent);

	var _style = __webpack_require__(606);

	var _style2 = _interopRequireDefault(_style);

	var _offset = __webpack_require__(609);

	var _offset2 = _interopRequireDefault(_offset);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SRippleComponent
	 * @extends 	SWebComponent
	 * Provide a nice and simple to use ripple webcomponent fully customizable
	 *
	 * @example 		html
	 * <div style="height:500px; position:relative;">
	 * 	<s-ripple></s-ripple>
	 * 	<div style="position:absolute; top:50%; left:50%; transform:translateX(-50%) translateY(-50%)">
	 * 	 Click to see the ripple effect in action
	 * 	</div>
	 * </div>
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SRippleComponent = function (_SWebComponent) {
		_inherits(SRippleComponent, _SWebComponent);

		function SRippleComponent() {
			_classCallCheck(this, SRippleComponent);

			return _possibleConstructorReturn(this, (SRippleComponent.__proto__ || Object.getPrototypeOf(SRippleComponent)).apply(this, arguments));
		}

		_createClass(SRippleComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentWillMount', this).call(this);
				this._particlesSystem = null;
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentMount', this).call(this);
				// set initial styles
				this._setInitialStyles();
				// listen for click on parent
				this.parentNode.addEventListener('click', this._onParentClick.bind(this));
				this._parentNode = this.parentNode;
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SRippleComponent.prototype.__proto__ || Object.getPrototypeOf(SRippleComponent.prototype), 'componentUnmount', this).call(this);
				// do not listen for click anymore
				this._parentNode.removeEventListener('click', this._onParentClick);
			}

			/**
	   * When click on parent, trigger a ripple
	   */

		}, {
			key: '_onParentClick',
			value: function _onParentClick(e) {

				// calculate position of the emitter
				var emitterX = void 0,
				    emitterY = void 0;
				if (this.props.centered) {
					emitterX = this.offsetWith * .5;
					emitterY = this.offsetHeight * .5;
				} else {
					var elmOffset = (0, _offset2.default)(this);
					emitterX = e.pageX - elmOffset.left;
					emitterY = e.pageY - elmOffset.top;
				}

				// add a particle system
				if (!this._particlesSystem) {
					this._particlesSystem = document.createElement('s-particles-system').setProps({
						particleClass: this._componentNameDash + '__particle',
						loop: false
					});
					this.appendChild(this._particlesSystem);
				}

				// amit a particle
				this._emitRipples(emitterX, emitterY);
			}

			/**
	   * Emit ripples
	   */

		}, {
			key: '_emitRipples',
			value: function _emitRipples(emitterX, emitterY) {
				var _this2 = this;

				var current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;


				var emX = emitterX,
				    emY = emitterY;

				// handle spread
				if (this.props.spread) {
					emX += -this.props.spread + Math.round(Math.random() * (this.props.spread * 2));
					emY += -this.props.spread + Math.round(Math.random() * (this.props.spread * 2));
				}

				// set emitter position
				this._particlesSystem.setProps({
					emitterX: emX,
					emitterY: emY
				});

				// emit a particle
				this._particlesSystem.emitParticle();
				// check if need more that 1
				if (this.props.count > 1 && current < this.props.count) {
					setTimeout(function () {
						_this2._emitRipples(emitterX, emitterY, current + 1);
					}, this.props.delay);
				}
			}

			/**
	   * Set initial styles
	   */

		}, {
			key: '_setInitialStyles',
			value: function _setInitialStyles() {
				if (this.parentNode.style.position !== 'relative' || this.parentNode.style.position !== 'absolute') {
					(0, _style2.default)(this.parentNode, {
						position: 'relative'
					});
				}
				if (this.props.contains) {
					(0, _style2.default)(this, {
						overflow: 'hidden'
					});
				} else {
					(0, _style2.default)(this, {
						overflow: null
					});
				}
			}

			/**
	   * Should component update
	   * @protected
	   */

		}, {
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate(nextProps) {
				return false;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tpointer-events : none;\n\t\t\t\tposition : absolute;\n\t\t\t\ttop : 0;\n\t\t\t\tleft : 0;\n\t\t\t\twidth : 100%;\n\t\t\t\theight : 100%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__particle {\n\t\t\t\ttop:50%; left:50%;\n\t\t\t\t-webkit-transform: translateX(-50%) translateY(-50%);\n\t\t\t\ttransform: translateX(-50%) translateY(-50%);\n\t\t\t\tposition:absolute;\n\t\t\t\twidth:150%;\n\t\t\t\tborder-radius: 50%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__particle:after {\n\t\t\t\tcontent:"";\n\t\t\t\tdisplay:block;\n\t\t\t\twidth:100%;\n\t\t\t\theight:0;\n\t\t\t\tpadding-top:100%;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Set if need to stay contained in the parent (overflow hidden)
	     * @prop
	     * @type 		{Boolean}
	     */
					contains: true,

					/**
	     * Set if want the ripple to be centered into his parent and not be placed where the user has clicked
	     * @prop
	     * @type 		{Boolean}
	     */
					centered: false,

					/**
	     * Set the delay between each ripples if the props.count is more that 1
	     * @prop
	     * @type 		{Number}
	     */
					delay: 130,

					/**
	     * Set the number of ripples wanted on each click
	     * @prop
	     * @type 		{Integer}
	     */
					count: 1,

					/**
	     * Set the random distance that each ripples will takes relative to the emitter position
	     * @prop
	     * @type 		{Number}
	     */
					spread: 0
				};
			}
		}]);

		return SRippleComponent;
	}(_SWebComponent3.default);

	exports.default = SRippleComponent;

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SParticlesSystemComponent = __webpack_require__(599);

	var _SParticlesSystemComponent2 = _interopRequireDefault(_SParticlesSystemComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SParticlesSystemComponent2.default.define('s-particles-system', _SParticlesSystemComponent2.default);

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _coffeekrakenSParticleComponent = __webpack_require__(600);

	var _coffeekrakenSParticleComponent2 = _interopRequireDefault(_coffeekrakenSParticleComponent);

	var _STimer = __webpack_require__(605);

	var _STimer2 = _interopRequireDefault(_STimer);

	var _getAnimationProperties = __webpack_require__(602);

	var _getAnimationProperties2 = _interopRequireDefault(_getAnimationProperties);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SParticlesSystemComponent
	 * @extends 	SWebComponent
	 * Webcomponent to handle particles emission
	 *
	 * @example 	html
	 * <s-particles-system loop spread="100" duration="1000" amount="10" particle-class="my-cool-particle">
	 * </s-particles-system>
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SParticlesSystemComponent = function (_SWebComponent) {
		_inherits(SParticlesSystemComponent, _SWebComponent);

		function SParticlesSystemComponent() {
			_classCallCheck(this, SParticlesSystemComponent);

			return _possibleConstructorReturn(this, (SParticlesSystemComponent.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent)).apply(this, arguments));
		}

		_createClass(SParticlesSystemComponent, [{
			key: 'componentMount',


			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */
			value: function componentMount() {
				var _this2 = this;

				_get(SParticlesSystemComponent.prototype.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent.prototype), 'componentMount', this).call(this);

				// check if need to create a timer or not
				if (this.props.amount && this.props.duration) {
					this._timer = new _STimer2.default(this.props.duration, {
						tickCount: this.props.amount,
						loop: this.props.loop
					});
					// on tick
					this._timer.onTick(function () {
						// emit a particle
						_this2.emitParticle();
					});
					if (this.props.onComplete) {
						this._timer.onComplete(this.props.onComplete);
					}
					if (this.props.active) {
						// start the timer
						this._timer.start();
					}
				}
			}

			/**
	   * Unmount component
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SParticlesSystemComponent.prototype.__proto__ || Object.getPrototypeOf(SParticlesSystemComponent.prototype), 'componentUnmount', this).call(this);
				if (this._timer) {
					this._timer.destroy();
				}
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'active':
						if (!newVal) this.stop();else this.start();
						break;
				}
			}

			/**
	   * Emit a particle
	   * @return 		{HTMLElement} 		The emited particle
	   */

		}, {
			key: 'emitParticle',
			value: function emitParticle() {
				var _this3 = this;

				// append a new particle
				var particle = document.createElement('s-particle');

				// set particle position
				particle.style.top = this.props.emitterY - this.props.spread / 2 + Math.random() * this.props.spread + 'px';
				particle.style.left = this.props.emitterX - this.props.spread / 2 + Math.random() * this.props.spread + 'px';

				// append class if needed
				if (this.props.particleClass) {
					if (this.props.particleClass instanceof Array) {
						if (this.props.particleClassSelection === 'random') {
							particle.classList.add(this.props.particleClass[Math.round(Math.random() * (this.props.particleClass.length - 1))]);
						}
					} else {
						particle.classList.add(this.props.particleClass);
					}
				}

				// add the particle element if specified
				if (this.props.particleElm) {
					var particles = [].concat(this.props.particleElm);
					particle.appendChild(particles[Math.round(Math.random() * particles.length - 1)]);
				}

				// before emit
				this.props.beforeEmit && this.props.beforeEmit(particle);

				this.mutate(function () {
					// append the new particle into the system
					_this3.appendChild(particle);
					// onEmit
					_this3.props.onEmit && _this3.props.onEmit(particle);
				});

				// return the emited particle
				return particle;
			}

			/**
	   * Stop the system
	   */

		}, {
			key: 'stop',
			value: function stop() {
				this._timer.stop();
			}

			/**
	   * Start the system
	   */

		}, {
			key: 'start',
			value: function start() {
				this._timer.start();
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Emitter x position
	     * @prop
	     * @type	{Number}
	     */
					emitterX: 0,
					/**
	     * Emitter y position
	     * @prop
	     * @type	{Number}
	     */
					emitterY: 0,
					/**
	     * Max distance where the particle will take birth from the emiter position
	     * @prop
	     * @type	{Number}
	     */
					spread: 0,
					/**
	     * Amount of particles to emit during the props.duration property
	     * @prop
	     * @type	{Integer}
	     */
					amount: 0,
					/**
	     * Duration of the particles emission
	     * @prop
	     * @type	{Number}
	     */
					duration: null,
					/**
	     * Class to apply to each particles
	     * @prop
	     * @type	{String|Array}
	     */
					particleClass: null,
					/**
	     * Specify the method to pick a particle class if the props.particleClass is an array. Only random is supported for now
	     * @prop
	     * @type 	{String|Array<String>}
	     * @values 	random
	     */
					particleClassSelection: 'random',
					/**
	     * DOM element to add into particle. If is an array, will pick a particle randomly
	     * @prop
	     * @type	{HTMLElement|Array<HTMLElement>}
	     */
					particleElm: null,
					/**
	     * Callback when the emission is completed
	     * @prop
	     * @type  	{Function}
	     */
					onComplete: null,

					/**
	     * Called just before emit the particle
	     * The passed function will have as parameter the particle that will be emitted
	     * @prop
	     * @type 	{Function}
	     */
					beforeEmit: null,

					/**
	     * When a particle is emitted
	     * The passed function will have as parameter the emitted particle
	     * @prop
	     * @type 	{Function}
	     */
					onEmit: null,

					/**
	     * Specify if the system if active or not
	     * @prop
	     * @type	{Boolean}
	     */
					active: true,
					/**
	     * Specify if the system hs to start again at the end automatically
	     * @prop
	     * @type 	{Boolean}
	     */
					loop: false
				};
			}
		}]);

		return SParticlesSystemComponent;
	}(_SWebComponent3.default);

	exports.default = SParticlesSystemComponent;

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SParticleComponent = __webpack_require__(601);

	var _SParticleComponent2 = _interopRequireDefault(_SParticleComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SParticleComponent2.default.define('s-particle', _SParticleComponent2.default);

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _getAnimationProperties = __webpack_require__(602);

	var _getAnimationProperties2 = _interopRequireDefault(_getAnimationProperties);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SParticleComponent
	 * @extends 	SWebComponent
	 * Simple webcomponent that will monitor his animation and will self destroy itself at the end of it
	 * @example 	html
	 * <style>
	 * 	.my-cool-particle {
	 * 		position:absolute; top:50%; left:50%; transform:translateX(-50%) translateY(-50%);
	 * 		width: 50px; height: 50px; border-radius:50%;
	 * 		background: red;
	 * 		animation: my-cool-particle .5s ease-in-out 0s;
	 * 	}
	 * 	@keyframes my-cool-particle {
	 * 	    0% { transform:translateX(-50%) translateY(-50%) scale(0,0); opacity:0; }
	 * 	    80% { transform:translateX(-50%) translateY(-50%) scale(.8,.8); opacity:1; }
	 * 	    100% { transform:translateX(-50%) translateY(-50%) scale(1,1); opacity:0; }
	 * 	}
	 * </style>
	 * <script>
	 * 	setInterval(function() {
	 * 	 	var particle = document.createElement('s-particle');
	 * 	 	particle.classList.add('my-cool-particle');
	 * 	 	document.body.appendChild(particle);
	 * 	}, 1000);
	 * </script>
	 * <s-particle class="my-cool-particle"></s-particle>
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SParticleComponent = function (_SWebComponent) {
		_inherits(SParticleComponent, _SWebComponent);

		function SParticleComponent() {
			_classCallCheck(this, SParticleComponent);

			return _possibleConstructorReturn(this, (SParticleComponent.__proto__ || Object.getPrototypeOf(SParticleComponent)).apply(this, arguments));
		}

		_createClass(SParticleComponent, [{
			key: 'componentMount',


			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */
			value: function componentMount() {
				var _this2 = this;

				_get(SParticleComponent.prototype.__proto__ || Object.getPrototypeOf(SParticleComponent.prototype), 'componentMount', this).call(this);

				var lifetime = this.props.lifetime;
				if (!lifetime) {
					// get the animation properties
					var animation = (0, _getAnimationProperties2.default)(this);
					lifetime = animation.totalDuration;
				}

				// wait till the animation is finished to remove the particle from DOM
				setTimeout(function () {
					if (_this2.parentNode) {
						_this2.parentNode.removeChild(_this2);
					}
				}, lifetime);
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Specify the particle lifetime in ms. If not specified, will be auto-detected from his animation.
	     * @prop
	     * @type 		{Number}
	     */
					lifetime: null
				};
			}
		}]);

		return SParticleComponent;
	}(_SWebComponent3.default);

	exports.default = SParticleComponent;

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = getAnimationProperties;

	var _getStyleProperty = __webpack_require__(603);

	var _getStyleProperty2 = _interopRequireDefault(_getStyleProperty);

	var _toMs = __webpack_require__(604);

	var _toMs2 = _interopRequireDefault(_toMs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get the css animation properties from an HTMLElement in an object format
	 *
	 * @name 		getAnimationProperties
	 * @param 		{HTMLElement} 					elm  		The element to get the properties from
	 * @return 		{Object} 									The animation properties
	 *
	 * @example  	js
	 * import getAnimationProperties from 'sugarcss/js/dom/getAnimationProperties'
	 * const props = getAnimationProperties(myCoolHTMLElement);
	 * // output format
	 * // {
	 * // 	name : ['animation1'],
	 * // 	duration : [200],
	 * // 	delay : [0],
	 * // 	timingFunction : ['linear'],
	 * // 	iterationCount : [1],
	 * // 	direction : ['forward'],
	 * // 	totalDuration : 200
	 * // }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */

	function splitIfNeeded(what, separator) {
		if (what.indexOf(separator) !== -1) {
			return what.split(separator).map(function (item) {
				return item.trim();
			});
		}
		return what;
	}
	function getAnimationProperties(elm) {
		// get the animation properties
		var name = (0, _getStyleProperty2.default)(elm, 'animation-name') || '';
		var duration = (0, _getStyleProperty2.default)(elm, 'animation-duration') || '0s';
		var timingFunction = (0, _getStyleProperty2.default)(elm, 'animation-timing-function') || 'linear';
		var delay = (0, _getStyleProperty2.default)(elm, 'animation-delay') || '0s';
		var iterationCount = (0, _getStyleProperty2.default)(elm, 'animation-iteration-count') || 1;
		var direction = (0, _getStyleProperty2.default)(elm, 'animation-direction') || 'normal';

		// return the animation object
		var props = {
			name: name.split(','),
			duration: duration.split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			delay: ('' + delay).split(',').map(function (value) {
				return (0, _toMs2.default)(value);
			}),
			timingFunction: timingFunction.split(','),
			iterationCount: ('' + iterationCount).split(','),
			direction: direction.split(',')
		};
		var totalDuration = 0;
		var i = 0;
		var delays = [0].concat(props.delay);
		[0].concat(props.duration).forEach(function (val) {
			if (val + delays[i] > totalDuration) {
				totalDuration = val + delays[i];
			}
		});
		props.totalDuration = totalDuration;
		return props;
	}

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getStyleProperty;

	var _camelize = __webpack_require__(559);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _autoCast = __webpack_require__(540);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Get a style property on the passed element through the computed style.
	 * This function try to store the actual style to not trigger more that 1 redraw
	 * each js execution loop.
	 *
	 * @name 		getStyleProperty
	 * @param 		{HTMLElement} 					elm  		The element to get style from
	 * @param 		{String} 						property 	The css property to get
	 * @return 		{Mixed} 									The style value
	 *
	 * @example  	js
	 * import getStyleProperty from 'sugarcss/js/dom/getStyleProperty'
	 * const opacity = getStyleProperty(myCoolHTMLElement, 'opacity');
	 *
	 * @see 		https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function getStyleProperty(elm, property) {

	  // caching mecanisme
	  setTimeout(function () {
	    elm._sComputedStyle = null;
	  });

	  var computed = elm._sComputedStyle || window.getComputedStyle(elm);
	  elm._sComputedStyle = computed;

	  var prefixes = ['', 'webkit-', 'moz-', 'ms-', 'o-', 'khtml-'];
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var value = computed[(0, _camelize2.default)('' + prefix + property)];
	    if (value && value.trim() !== '') return (0, _autoCast2.default)(value);
	  }
	  return null;
	}

/***/ }),
/* 604 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = toMs;
	/**
	 * Return the milisecond (ms) representation of a css timing unit
	 * Currently support:
	 * - milisecond (ms)
	 * - second (s)
	 *
	 * @param    {String}    string    The string timing representation like 1s, 50ms, etc...
	 * @return    {String}    The ms representation of the passed string
	 *
	 * @example    js
	 * import toMs from 'coffeekraken-sugar/js/utils/strings/toMs'
	 * toMs('1.2s') // 1200
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function toMs(string) {
		// parse the string to int to get the lenght of the suffix
		// if (string.substr(0,1) === '.') string = '0${string}';
		var value = parseFloat(string);
		var valueLength = ('' + value).length;
		var suffix = string.substr(valueLength);
		// switch on suffix
		switch (suffix) {
			case 'ms':
				// milisecond
				return value;
				break;
			case 's': // seconds
			default:
				return value * 1000;
				break;
		}
	}

/***/ }),
/* 605 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		STimer
	 * Class that let you create and handle timer with ease.
	 * With this class you can set some callback function that will be
	 * called each x ms or tell that you want your callbacks to be called
	 * a certain number of time during the timer time.
	 *
	 * @example 	js
	 * const myTimer = new STimer(2000, {
	 * 		tickCount : 5
	 * })
	 * myTimer.onTick((myTimer) => {
	 * 		// do something here...
	 * })
	 * myTimer.start()
	 *
	 * @author 		Olivier Bossel<olivier.bossel@gmail.com>
	 */
	var STimer = function () {

		/**
	  * @constructor
	  * @param 	{number} 	[duration=1000] 		The duration of the timer in ms
	  * @param 	{Object} 	settings 		The settings for the timer
	  * @return 	{STimer} 					The STimer instance
	  */


		/**
	  * Store the last tick time
	  *
	  * @type 	{Date}
	  */


		/**
	  * Store the setInterval instance
	  *
	  * @type 	{Number}
	  */


		/**
	  * Store all the functions to call on tick
	  *
	  * @type 	{Array}
	  */


		/**
	  * How many ticks wanted during the timeout
	  *
	  * @type    {Integer}
	  */


		/**
	  * Store the timer duration wanted
	  *
	  * @type 	{Number}
	  */
		function STimer(duration) {
			var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			_classCallCheck(this, STimer);

			this._settings = {

				/**
	    * Store the interval between ticks
	    *
	    * @setting
	    * @type 		{Number}
	    * @default 	1000
	    */
				tickInterval: 1000,

				/**
	    * Set the number of tick wanted
	    *
	    * @setting
	    * @type 		{Integer}
	    * @default 	null
	    */
				tickCount: null,

				/**
	    * Set if the timer has to loop
	    *
	    * @setting
	    * @type 		{Boolean}
	    * @default 	false
	    */
				loop: false };
			this._duration = 0;
			this._remaining = 0;
			this._tickCount = null;
			this._tickInterval = 1000;
			this._ticks = [];
			this._completes = [];
			this._tickSetTimeout = null;
			this._startTime = null;
			this._tickTime = null;
			this._pauseTime = null;

			this._duration = duration;

			// updating settings
			this._settings = Object.assign(this._settings, settings);

			// calculate the tickInterval
			if (this._settings.tickCount) {
				this._tickCount = this._settings.tickCount;
				this._tickInterval = this._duration / this._tickCount; // remove 1 cause the first tick is always the start time
			} else {
				this._tickInterval = this._settings.tickInterval;
			}
		}

		/**
	  * Internal tick function
	  * @return 	{void}
	  */


		/**
	  * Store the pause time
	  *
	  * @type 	{Date}
	  */


		/**
	  * Store the time when the timer is started
	  *
	  * @type 	{Date}
	  */


		/**
	  * Store all the functions to call on complete
	  *
	  * @type 	{Array}
	  */


		/**
	  * Computed value depending on the settings
	  *
	  * @type 	{Number}
	  */


		/**
	  * Store the remaining time
	  *
	  * @type 	{Number}
	  */


		/**
	  * Store the settings for the timer
	  *
	  * @type 		{Object}
	  */


		_createClass(STimer, [{
			key: "_tick",
			value: function _tick() {
				var _this = this;

				// save the remaining timeout
				this._tickTime = new Date();

				// update remaing
				this._remaining -= this._tickInterval;

				// if we are at the end of the timer
				if (this.remaining() <= 0) {
					// stop the timer
					this.stop();
					// check if need to loop
					if (this._settings.loop) {
						this.start();
					}
					// loop on each completes functions
					this._completes.forEach(function (complete) {
						complete(_this);
					});
				} else {
					// launch another tick
					clearTimeout(this._tickSetTimeout);
					this._tickSetTimeout = setTimeout(function () {
						_this._tick();
					}, this._tickInterval);
				}

				// loop on each ticks functions
				this._ticks.forEach(function (tick) {
					tick(_this);
				});
			}

			/**
	   * Return the remaining time in ms
	   * @return 	{Number} 	The remaining time in ms
	   */

		}, {
			key: "remaining",
			value: function remaining() {
				return this._remaining;
			}

			/**
	   * Set or get the duration
	   * @param	{Number} 	[duration=null]		Set the duration
	   * @return 	{Number} 						The duration
	   */

		}, {
			key: "duration",
			value: function duration() {
				var _duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

				if (_duration) {
					this._duration = _duration;
					if (this._tickCount) {
						this._tickInterval = this._duration / this._tickCount; // remove 1 cause the first tick is always the start time
					}
				}
				return this._duration;
			}

			/**
	   * Set of get the tickCount
	   * @param    {Inreger}    [tickCount=null]    Set the tickCount
	   * @return    {Inreger}    The tickCount
	   */

		}, {
			key: "tickCount",
			value: function tickCount() {
				var _tickCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

				if (_tickCount) {
					this._tickCount = _tickCount;
					this._tickInterval = this._duration / this._tickCount;
				}
			}

			/**
	   * Register a function called on tick
	   * @param 	{Function} 	A function to call on tick
	   * @return 	{STimer} 	The timer instance
	   */

		}, {
			key: "onTick",
			value: function onTick(fn) {
				// add the function if not already
				if (this._ticks.indexOf(fn) !== -1) return;
				this._ticks.push(fn);
			}

			/**
	   * Register a function called on complete
	   * @param 	{Function} 	A function to call on complete
	   * @retun 	{STimer} 	The timer instance
	   */

		}, {
			key: "onComplete",
			value: function onComplete(fn) {
				// add the function if not already
				if (this._completes.indexOf(fn) !== -1) return;
				this._completes.push(fn);
			}

			/**
	   * Reset the timer
	   * @param 	{Boolean} 	start 	If the timer has to start after reseting or not
	   * @return 	{STimer}
	   */

		}, {
			key: "reset",
			value: function reset() {
				var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


				// stop the timeout
				clearTimeout(this._tickSetTimeout);

				// reset the different timer elements
				this._pauseTime = null;
				this._startTime = null;
				this._remaining = this._duration;

				// check if need to start again
				if (start) this.start();

				// maintain chainability
				return this;
			}

			/**
	   * Start the timer
	   * @return 	{STimer}
	   */

		}, {
			key: "start",
			value: function start() {
				var _this2 = this;

				var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;


				// clear the timeout to be sure
				clearTimeout(this._tickSetTimeout);

				// set the duration
				if (duration) this.duration(duration);

				// if no tick time
				if (!this._tickTime) {
					this._tickTime = new Date();
				}

				// if is a pausetime
				// mean that we resume the timer
				if (this._pauseTime) {

					// calculate time before new tick
					var elapsed = this._pauseTime.getTime() - this._tickTime.getTime();
					var remaining = this._tickInterval - elapsed;
					clearTimeout(this._tickSetTimeout);
					this._tickSetTimeout = setTimeout(function () {
						_this2._tick();
					}, remaining);

					// set the start time
					this._startTime = new Date();

					// reset pauseTime
					this._pauseTime = null;
				} else {
					// save the start time
					this._startTime = new Date();
					this._remaining = this._duration;

					// first time tick
					clearTimeout(this._tickSetTimeout);
					this._tickSetTimeout = setTimeout(function () {
						_this2._tick();
					}, this._tickInterval);
				}

				// maintain chainability
				return this;
			}

			/**
	   * Pause the timer
	   * @return 	{STimer}
	   */

		}, {
			key: "pause",
			value: function pause() {

				// set the pauseTime
				this._pauseTime = new Date();

				// clean the interval
				clearTimeout(this._tickSetTimeout);

				// maintain chainability
				return this;
			}

			/**
	   * Stop the timer
	   * @return 	{STimer}
	   */

		}, {
			key: "stop",
			value: function stop() {
				// reset
				this.reset();

				// maintain chainability
				return this;
			}

			/**
	   * Destroy the timer
	   */

		}, {
			key: "destroy",
			value: function destroy() {
				this.stop();
				this._completes = [];
				this._ticks = [];
			}

			/**
	   * Check if the timer is started
	   * @return    {Boolean}    true if is started, false if not
	   */

		}, {
			key: "isStarted",
			value: function isStarted() {
				return this._startTime && !this._pauseTime;
			}
		}]);

		return STimer;
	}();

	exports.default = STimer;

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = style;

	var _uncamelize = __webpack_require__(560);

	var _uncamelize2 = _interopRequireDefault(_uncamelize);

	var _styleString2Object = __webpack_require__(607);

	var _styleString2Object2 = _interopRequireDefault(_styleString2Object);

	var _styleObject2String = __webpack_require__(608);

	var _styleObject2String2 = _interopRequireDefault(_styleObject2String);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Set or remove a css style property on an HTMLElement
	 *
	 * @name 		style
	 * @param 		{HTMLElement} 			elm 			The element to process
	 * @param 		{Object} 				styleObj 		An object of style to apply
	 * @return 		(Object) 								The element applied style
	 *
	 * @example 	js
	 * import style from 'sugarcss/js/dom/style'
	 * style(myCoolHTMLElement, {
	 * 		paddingLeft : 20,
	 * 		display : null
	 * });
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function style(elm, styleObj) {

	  // convert style string to object
	  var styleAttr = elm.getAttribute('style');

	  if (styleAttr) {
	    styleObj = _extends({}, (0, _styleString2Object2.default)(styleAttr), styleObj);
	  }

	  // apply the style to the element
	  // elm.setAttribute('style', __styleObject2String(current.styleObj));
	  elm.style.cssText = (0, _styleObject2String2.default)(styleObj);

	  // return the style
	  return elm.style;
	}

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = styleString2Object;

	var _camelize = __webpack_require__(559);

	var _camelize2 = _interopRequireDefault(_camelize);

	var _autoCast = __webpack_require__(540);

	var _autoCast2 = _interopRequireDefault(_autoCast);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Transform a style string to an object representation
	 *
	 * @name 		styleString2Object
	 * @param 		{String} 				style 			The style string
	 * @return 		(Object) 								The string object representation
	 *
	 * @example 	js
	 * import styleString2Object from 'sugarcss/js/dom/styleString2Object'
	 * const styleString = styleString2Object('padding-left:20px; display:block;');
	 * // output => {
	 * //		paddingLeft : '20px',
	 * // 		display : 'block'
	 * // }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function styleString2Object(style) {
	  if (!style || style === '') return {};
	  var obj = {};
	  var split = style.replace(/\s/g, '').split(';');
	  split.forEach(function (statement) {
	    // split statement by key value pairs
	    var spl = statement.split(':'),
	        key = (0, _camelize2.default)(spl[0]),
	        value = spl[1];
	    // add element into object
	    obj[key] = (0, _autoCast2.default)(value);
	  });
	  // return the style object
	  return obj;
	}

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = styleObject2String;

	var _uncamelize = __webpack_require__(560);

	var _uncamelize2 = _interopRequireDefault(_uncamelize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Transform a style object to inline string separated by ;
	 *
	 * @name 		styleObject2String
	 * @param 		{Object} 				styleObj 		An object of style to apply
	 * @return 		(String) 								The string style representation
	 *
	 * @example 	js
	 * import styleObject2String from 'sugarcss/js/dom/styleObject2String'
	 * const styleString = styleObject2String({
	 * 		paddingLeft : '20px',
	 * 		display : 'block'
	 * });
	 * // output => padding-left:20px; display:block;
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function styleObject2String(styleObj) {
	  // process the style object
	  var propertiesArray = [];
	  for (var key in styleObj) {
	    var value = styleObj[key];
	    // if the value is ''
	    // mean that we need to get rid of
	    if (value === undefined || value === '') {
	      delete styleObj[key];
	    } else {
	      propertiesArray.push((0, _uncamelize2.default)(key) + ':' + value + ';');
	    }
	  }
	  // return the css text
	  return propertiesArray.join(' ');
	}

/***/ }),
/* 609 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = offset;
	// import __getTranslateProperties from './getTranslateProperties'

	/**
	 * Get the offset top and left of the passed element from the document top left point
	 *
	 * @name 		offset
	 * @param 		{HTMLElement} 					elm  		The element to get the offset from
	 * @return 		{Object} 									The offset top and left object
	 *
	 * @example  	js
	 * import offset from 'sugarcss/js/dom/offset'
	 * const offsetElm = offset(myCoolElement);
	 * // output : { top : 200, left : 300 }
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function offset(elm) {
		var body = void 0,
		    box = void 0,
		    clientLeft = void 0,
		    clientTop = void 0,
		    docEl = void 0,
		    left = void 0,
		    scrollLeft = void 0,
		    scrollTop = void 0,
		    top = void 0,
		    translates = void 0,
		    transX = void 0,
		    transY = void 0;
		box = elm.getBoundingClientRect();
		body = document.body;
		docEl = document.documentElement;
		scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
		scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
		clientTop = docEl.clientTop || body.clientTop || 0;
		clientLeft = docEl.clientLeft || body.clientLeft || 0;
		// translates = __getTranslateProperties(elm);
		// transX = translates.x;
		// transY = translates.y;
		top = box.top + scrollTop - clientTop;
		left = box.left + scrollLeft - clientLeft;
		return {
			top: Math.round(top),
			left: Math.round(left)
		};
	}

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SEqualizeComponent = __webpack_require__(611);

	var _SEqualizeComponent2 = _interopRequireDefault(_SEqualizeComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SEqualizeComponent2.default.define('s-equalize', _SEqualizeComponent2.default);

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _dispatchEvent = __webpack_require__(340);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _offset = __webpack_require__(609);

	var _offset2 = _interopRequireDefault(_offset);

	var _whenVisible = __webpack_require__(520);

	var _whenVisible2 = _interopRequireDefault(_whenVisible);

	var _whenAttribute = __webpack_require__(578);

	var _whenAttribute2 = _interopRequireDefault(_whenAttribute);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 	SEqualizeComponent
	 * @extends 	SWebComponent
	 * Simply made some equal height columns.
	 *
	 * @example 	html
	 * <div style="overflow:hidden">
	 * 	<div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 1</h4>
	 *  	<p>Integer congue a nibh sed elementum. Mauris ligula sem, scelerisque.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * <div class="my-cool-column tf vr" style="width:400px; float:left;">
	 * 	<s-equalize group="cols">
	 *  	<h4>Column 2</h4>
	 *  	<p>Donec scelerisque eu felis sit amet sodales. Nam sit amet lacus purus. Aliquam rutrum facilisis velit non egestas. Maecenas condimentum condimentum eleifend. Ut sed massa tempus, pellentesque orci id, facilisis dolor. Integer ac ligula convallis, egestas sem ut, luctus purus.</p>
	 *  	<s-equalize-equalizer></s-equalize-equalizer>
	 *  	<a href="javascript:void(0);" class="btn btn--primary">
	 *   		More infos...
	 * 		</a>
	 *  </s-equalize>
	 * </div>
	 * </div>
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SEqualizeComponent = function (_SWebComponent) {
		_inherits(SEqualizeComponent, _SWebComponent);

		function SEqualizeComponent() {
			_classCallCheck(this, SEqualizeComponent);

			return _possibleConstructorReturn(this, (SEqualizeComponent.__proto__ || Object.getPrototypeOf(SEqualizeComponent)).apply(this, arguments));
		}

		_createClass(SEqualizeComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				var _this2 = this;

				_get(SEqualizeComponent.prototype.__proto__ || Object.getPrototypeOf(SEqualizeComponent.prototype), 'componentMount', this).call(this);

				if (!SEqualizeComponent._groups[this.props.group]) {
					SEqualizeComponent._groups[this.props.group] = {
						refreshLinesInProgress: false,
						elements: [],
						lines: []
					};
				}
				SEqualizeComponent._groups[this.props.group].elements = document.querySelectorAll(this._componentNameDash + '[group="' + this.props.group + '"]');

				// init lines
				this.lines = [];

				// wait a small amount of time
				// to avoid some weird layout issues
				setTimeout(function () {
					// refresh lines first time
					_this2.refreshLines();
					// equalize
					_this2.equalize();
				}, this.props.firstEqualizeDelay);

				// listen for resizing window
				var resizeWindowTimeout = void 0;
				window.addEventListener('resize', function (e) {
					clearTimeout(resizeWindowTimeout);
					resizeWindowTimeout = setTimeout(function () {
						_this2.equalize();
					}, _this2.props.resizeTimeout);
				});

				// listen for webfonts loaded
				var htmlElm = document.querySelector('html');
				if (htmlElm && window.WebFont) {
					(0, _whenAttribute2.default)(document.querySelector('html'), 'class', function () {
						return htmlElm.classList.contains('wf-active');
					}).then(function () {
						setTimeout(function () {
							_this2.refreshLines(true); // force refresh
							_this2.equalize();
						}, 200);
					});
				}
			}

			/**
	   * Return the equalizer(s) HTMLElement if exist
	   * @return 	{HTMLElement} 		The equalizer(s) HTMLElement
	   */

		}, {
			key: 'refreshLines',


			/**
	   * Refresh the lines values
	   */
			value: function refreshLines() {
				var _this3 = this;

				var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

				if (!force) {
					if (SEqualizeComponent._groups[this.props.group].refreshLinesInProgress) return;
					SEqualizeComponent._groups[this.props.group].refreshLinesInProgress = true;
					setTimeout(function () {
						SEqualizeComponent._groups[_this3.props.group].refreshLinesInProgress = false;
					}, 100);
				}

				// loop on all the columns
				var offsetTop = void 0;
				this.lines = [];
				var line = {
					inProgress: false,
					height: 0,
					elements: []
				};
				[].forEach.call(SEqualizeComponent._groups[this.props.group].elements, function (elm) {

					// reset the equalizer or element min-height
					// to get the real height of the element
					if (elm.equalizerElms.length) {
						[].forEach.call(elm.equalizerElms, function (equalizerElm) {
							equalizerElm.style.minHeight = 0;
						});
					} else {
						elm.style.minHeight = 0;
					}

					var elmHeight = elm.offsetHeight;
					var elmOffset = (0, _offset2.default)(elm);

					// check if is on new line
					if (offsetTop !== elmOffset.top && line.height > 0) {
						// add the new line to lines stack
						_this3.lines.push(line);
						// reset the line
						line = {
							inProgress: false,
							height: 0,
							elements: []
						};
					}
					// add the element in the line
					line.elements.push(elm);
					// check if the element is higher that the highest of the line
					if (elmHeight > line.height) {
						line.height = elmHeight;
					}
					// save the new offset
					offsetTop = elmOffset.top;
				});

				// add the last line
				this.lines.push(line);

				// save the lins in static stack
				SEqualizeComponent._groups[this.props.group].lines = this.lines;
			}

			/**
	   * Get the line object from an HTMLElement
	   * @param 		{HTMLElement} 		elm 		The element to get the line from
	   * @return 		{Object} 		The line object
	   */

		}, {
			key: 'getLineFromElm',
			value: function getLineFromElm(elm) {
				// loop on lines
				for (var key in SEqualizeComponent._groups[this.props.group].lines) {
					var line = SEqualizeComponent._groups[this.props.group].lines[key];
					if (line.elements.indexOf(elm) !== -1) return line;
				}
				return null;
			}

			/**
	   * Equalize the passed line
	   * @param 		{Object} 		line 		The line object to equalize the elements from
	   */

		}, {
			key: 'equalizeLine',
			value: function equalizeLine(line) {

				// do nothing if the line is already in progress
				if (line.inProgress) return;
				// flag the line as inProgress
				line.inProgress = true;

				// refresh lines
				// don't worry, it will not do the work
				// every time it is called but only 1 by group every 100ms
				this.refreshLines();

				setTimeout(function () {
					// loop on each columns
					[].forEach.call(line.elements, function (element) {
						element.classList.add('clear-transmations');
						// reset the equalizer or element min-height
						// to get the real height of the element
						if (element.equalizerElms.length) {
							[].forEach.call(element.equalizerElms, function (equalizerElm) {
								equalizerElm.style.minHeight = 0;
							});
						} else {
							element.style.minHeight = 0;
						}
					});
					// loop on each columns
					[].forEach.call(line.elements, function (element) {
						// check if some equalizer(s) exist to use it/them
						// @TODO : find a way to not query each time in the column for the equalizer
						// reset the equalizer or element min-height
						// to get the real height of the element
						if (element.equalizerElms.length) {
							var equalizersHeight = (line.height - element.offsetHeight) / element.equalizerElms.length;
							[].forEach.call(element.equalizerElms, function (equalizerElm) {
								equalizerElm.style.display = 'block';
								equalizerElm.style.minHeight = equalizersHeight + 'px';
							});
						} else {
							element.style.minHeight = line.height + 'px';
						}
					});
					[].forEach.call(line.elements, function (element) {
						element.classList.remove('clear-transmations');
					});
					// reset the line progress status
					line.inProgress = false;
				});
			}

			/**
	   * Equalize from an element or a line object
	   * @param 		{HTMLElement|Object} 		[elmOrLine=null] 		An HTMLElement that belong to a line or directly a line object
	   */

		}, {
			key: 'equalize',
			value: function equalize() {
				var _this4 = this;

				var elmOrLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

				// if we have an element passed
				if (elmOrLine && elmOrLine.tagName) {
					// equalize from an element
					var line = this.getLineFromElm(elmOrLine);
					if (!line) return;
					this.equalizeLine(line);
				} else if (elmOrLine && elmOrLine.elements) {
					// equalize a line directly
					this.equalizeLine(elmOrLine);
				} else {
					// equalize the whole set
					SEqualizeComponent._groups[this.props.group].lines.forEach(function (line) {
						// equalize line
						_this4.equalizeLine(line);
					});
				}
				setTimeout(function () {
					(0, _dispatchEvent2.default)(_this4, 'update:height');
				});
			}
		}, {
			key: 'equalizerElms',
			get: function get() {
				if (this._equalizerElmsCache) return this._equalizerElmsCache;
				this._equalizerElmsCache = this.querySelectorAll(this._componentNameDash + '-equalizer');
				return this._equalizerElmsCache;
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay : block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Specify the group name that the equalize element belong to
	     * @prop
	     * @type 	{String}
	     */
					group: null,

					/**
	     * Specify the timeout to wait before resize again after a window resizeTimeout
	     * @prop
	     * @type 	{Number}
	     */
					resizeTimeout: 200,

					/**
	     * Time to wait before making the first equalize in ms
	     * @prop
	     * @type 	{Number}
	     */
					firstEqualizeDelay: 0
				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */


			/**
	   * Store the groups
	   * @type	{Object}
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return ['group'];
			}
		}]);

		return SEqualizeComponent;
	}(_SWebComponent3.default);

	SEqualizeComponent._groups = {};
	exports.default = SEqualizeComponent;

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SShareComponent = __webpack_require__(613);

	var _SShareComponent2 = _interopRequireDefault(_SShareComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SShareComponent2.default.define('s-share', _SShareComponent2.default, 'a');

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SAnchorWebComponent2 = __webpack_require__(614);

	var _SAnchorWebComponent3 = _interopRequireDefault(_SAnchorWebComponent2);

	var _sharerNpm = __webpack_require__(615);

	var _sharerNpm2 = _interopRequireDefault(_sharerNpm);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 	SShareComponent
	 * @extends 	SAnchorWebComponent
	 * Easily create some share buttons to target facebook, twitter, linkedin, google+, etc...
	 *
	 * @example 	html
	 * <a is="s-share" href="#" network="facebook" title="Share on facebook">
	 * 	Share on facebook
	 * </a>
	 *
	 * @author 	Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SShareComponent = function (_SAnchorWebComponent) {
		_inherits(SShareComponent, _SAnchorWebComponent);

		function SShareComponent() {
			_classCallCheck(this, SShareComponent);

			return _possibleConstructorReturn(this, (SShareComponent.__proto__ || Object.getPrototypeOf(SShareComponent)).apply(this, arguments));
		}

		_createClass(SShareComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentMount', this).call(this);

				// list all attributes available for each networks
				this._networkAttrs = {
					twitter: ['title', 'url', 'hashtags', 'via'],
					facebook: ['url'],
					linkedin: ['url'],
					googleplus: ['url'],
					email: ['title', 'url', 'to', 'subject'],
					whatsapp: ['title', 'url'],
					telegram: ['title', 'url'],
					viber: ['title', 'url'],
					pinterest: ['url', 'image', 'description'],
					tumblr: ['url', 'title', 'caption', 'tags'],
					hackernews: ['url', 'title'],
					reddit: ['url'],
					vk: ['url', 'title', 'image', 'caption'],
					buffer: ['url', 'title', 'via', 'picture'],
					xing: ['url', 'title'],
					line: ['url', 'title'],
					instapaper: ['url', 'title', 'description'],
					pocket: ['url'],
					digg: ['url'],
					stumbleupon: ['title', 'url'],
					flipboard: ['title', 'url'],
					weibo: ['url', 'title', 'image', 'apikey', 'relateui'],
					renren: ['url'],
					myspace: ['url', 'title', 'description'],
					blogger: ['url', 'title', 'description'],
					baidu: ['url', 'title'],
					okru: ['url', 'title']
				};

				// listen for click on the element
				this.addEventListener('click', this._onClick.bind(this));
			}

			/**
	   * Component unmount
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {}
			}

			/**
	   * Render the component
	   * Here goes the code that reflect the this.props state on the actual html element
	   * @definition 		SWebComponent.render
	   * @protected
	   */

		}, {
			key: 'render',
			value: function render() {
				_get(SShareComponent.prototype.__proto__ || Object.getPrototypeOf(SShareComponent.prototype), 'render', this).call(this);
			}

			/**
	   * Get default share attributes
	   * @param 		{String} 		attr 		The attribute name to process
	   * @return 		{String} 					The default attribute
	   */

		}, {
			key: '_getDefaultShareAttriute',
			value: function _getDefaultShareAttriute(attr) {
				switch (attr) {
					case 'title':
					case 'subject':
					case 'caption':
						return document.title;
						break;
					case 'description':
						var descElm = document.querySelector('meta[name="description"]');
						if (descElm && descElm.content) return descElm.content;
						break;
					case 'url':
						var href = this.getAttribute('href');
						return href && href !== '#' ? href : document.location.href;
						break;
				}
				return null;
			}

			/**
	   * Handle click
	   * @param 		{Event} 		e 		The click event
	   */

		}, {
			key: '_onClick',
			value: function _onClick(e) {
				var _this2 = this;

				e.preventDefault();
				// loop on network attributes
				if (!this._networkAttrs[this.props.network]) return;
				this.setAttribute('data-sharer', this.props.network);
				this._networkAttrs[this.props.network].forEach(function (attr) {
					if (_this2.hasAttribute('data-' + attr)) return;
					var val = _this2.props[attr];
					if (!val) {
						val = _this2._getDefaultShareAttriute(attr);
					}
					if (val) {
						_this2.setAttribute('data-' + attr, val);
					}
				});

				// create a new sharer
				var sharer = new _sharerNpm2.default(this);
				sharer.share();
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * On which network to share the content
	     * @prop
	     * @type 		{String}
	     * @values 		twitter, facebook, linkedin, googleplus, email, whatsapp, telegram, viber, pinterest, tumblr, hackernews, reddit, vk, buffer, xing, line, instapaper, pocket, digg, stumbleupon, flipboard, weibo, renren, myspace, blogger, baidu, okru
	     */
					network: null,

					/**
	     * Set the title to share
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					title: null,

					/**
	     * Set the url to share
	     * @prop
	     * @type 		{String}
	     * @default 	document.location.href
	     */
					url: null,

					/**
	     * Set a username to tweet through without @
	     * @prop
	     * @type 		{String}
	     */
					via: null,

					/**
	     * Set some hashtags to add to tweet comma separated without #
	     * @prop
	     * @type 		{String}
	     */
					hashtags: null,

					/**
	     * Set an email address to share to
	     * @prop
	     * @type 		{String}
	     */
					to: null,

					/**
	     * Set the email subject
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					subject: null,

					/**
	     * Set the absolute image url to share through (pinterest,vk,weibo)
	     * @prop
	     * @type 		{String}
	     */
					image: null,

					/**
	     * Set the description to share (pinterest,instapaper,myspace,blogger,)
	     * @prop
	     * @type 		{String}
	     * @default 	meta[description]
	     */
					description: null,

					/**
	     * Set the caption to share (tumblr,vk)
	     * @prop
	     * @type 		{String}
	     * @default 	document.title
	     */
					caption: null,

					/**
	     * Set the tags to share comma separated (tumblr)
	     * @prop
	     * @type 		{String}
	     */
					tags: null
				};
			}

			/**
	   * Required props
	   * @definition 		SWebComponent.requiredProps
	   * @protected
	   */

		}, {
			key: 'requiredProps',
			get: function get() {
				return ['network'];
			}
		}]);

		return SShareComponent;
	}(_SAnchorWebComponent3.default);

	exports.default = SShareComponent;

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sNativeWebComponent = __webpack_require__(534);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SAnchorWebComponent = function (_native) {
	  _inherits(SAnchorWebComponent, _native);

	  function SAnchorWebComponent() {
	    _classCallCheck(this, SAnchorWebComponent);

	    return _possibleConstructorReturn(this, (SAnchorWebComponent.__proto__ || Object.getPrototypeOf(SAnchorWebComponent)).apply(this, arguments));
	  }

	  return SAnchorWebComponent;
	}((0, _sNativeWebComponent2.default)(HTMLAnchorElement));

	exports.default = SAnchorWebComponent;

/***/ }),
/* 615 */
/***/ (function(module, exports) {

	/**
	 * @preserve
	 * Sharer.js
	 *
	 * @description Create your own social share buttons
	 * @version 0.2.12
	 * @author Ellison Leao <ellisonleao@gmail.com>
	 * @license GPLv3
	 *
	 */

	/**
	 * @constructor
	 */
	var Sharer = function(elem) {
	    this.elem = elem;
	};

	Sharer.prototype = {
	    /**
	     *  @function getValue
	     *  @description Helper to get the attribute of a DOM element
	     *  @param {String} attr DOM element attribute
	     *  @returns {String|Empty} returns the attr value or empty string
	     */
	    getValue: function(attr) {
	        var val = this.elem.getAttribute('data-' + attr);
	        return (val === undefined || val === null) ? false : val;
	    },

	    /**
	     * @event share
	     * @description Main share event. Will pop a window or redirect to a link
	     * based on the data-sharer attribute.
	     */
	    share: function() {
	        var sharer = this.getValue('sharer').toLowerCase(),
	            sharers = {
	                facebook: {
	                    shareUrl: 'https://www.facebook.com/sharer/sharer.php',
	                    params: {u: this.getValue('url')}
	                },
	                googleplus: {
	                    shareUrl: 'https://plus.google.com/share',
	                    params: {url: this.getValue('url')}
	                },
	                linkedin: {
	                    shareUrl: 'https://www.linkedin.com/shareArticle',
	                    params: {
	                        url: this.getValue('url'),
	                        mini: true
	                    }
	                },
	                twitter: {
	                    shareUrl: 'https://twitter.com/intent/tweet/',
	                    params: {
	                        text: this.getValue('title'),
	                        url: this.getValue('url'),
	                        hashtags: this.getValue('hashtags'),
	                        via: this.getValue('via')
	                    }
	                },
	                email: {
	                    shareUrl: 'mailto:' + this.getValue('to'),
	                    params: {
	                        subject: this.getValue('subject'),
	                        body: this.getValue('title') + '\n' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                whatsapp: {
	                    shareUrl: 'whatsapp://send',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                telegram: {
	                    shareUrl: 'tg://msg_url',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                viber: {
	                    shareUrl: 'viber://forward',
	                    params: {
	                        text: this.getValue('title') + ' ' + this.getValue('url')
	                    },
	                    isLink: true
	                },
	                line: {
	                    shareUrl: 'http://line.me/R/msg/text/?' + encodeURIComponent(this.getValue('title') + ' ' + this.getValue('url')),
	                    isLink: true
	                },
	                pinterest: {
	                    shareUrl: 'https://www.pinterest.com/pin/create/button/',
	                    params: {url: this.getValue('url')}
	                },
	                tumblr: {
	                    shareUrl: 'http://tumblr.com/widgets/share/tool',
	                    params: {
	                        canonicalUrl: this.getValue('url'),
	                        content: this.getValue('url'),
	                        posttype: 'link',
	                        title: this.getValue('title'),
	                        caption: this.getValue('caption'),
	                        tags: this.getValue('tags')
	                    }
	                },
	                hackernews: {
	                    shareUrl: 'https://news.ycombinator.com/submitlink',
	                    params: {
	                        u: this.getValue('url'),
	                        t: this.getValue('title')
	                    }
	                },
	                reddit: {
	                    shareUrl: 'https://www.reddit.com/submit',
	                    params: {'url': this.getValue('url')}
	                },
	                vk: {
	                    shareUrl: 'http://vk.com/share.php',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        description: this.getValue('caption'),
	                        image: this.getValue('image')
	                    }
	                },
	                xing: {
	                    shareUrl: 'https://www.xing.com/app/user',
	                    params: {
	                        'op': 'share',
	                        'url': this.getValue('url'),
	                        'title': this.getValue('title')
	                    }
	                },
	                buffer: {
	                    shareUrl: 'https://buffer.com/add',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        via: this.getValue('via'),
	                        picture: this.getValue('picture')
	                    }
	                },
	                instapaper: {
	                    shareUrl: 'http://www.instapaper.com/edit',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        description: this.getValue('description')
	                    }
	                },
	                pocket: {
	                    shareUrl: 'https://getpocket.com/save',
	                    params: {
	                        url: this.getValue('url')
	                    }
	                },
	                digg: {
	                    shareUrl: 'http://www.digg.com/submit',
	                    params: {
	                        url: this.getValue('url')
	                    }
	                },
	                stumbleupon: {
	                    shareUrl: 'http://www.stumbleupon.com/submit',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title')
	                    }
	                },
	                flipboard: {
	                    shareUrl: 'https://share.flipboard.com/bookmarklet/popout',
	                    params: {
	                        v: 2,
	                        title: this.getValue('title'),
	                        url: this.getValue('url'),
	                        t: Date.now()
	                    }
	                },
	                weibo: {
	                    shareUrl: 'http://service.weibo.com/share/share.php',
	                    params: {
	                        url: this.getValue('url'),
	                        title: this.getValue('title'),
	                        language: 'zh_cn'
	                    }
	                },
	                renren: {
	                    shareUrl: 'http://share.renren.com/share/buttonshare',
	                    params: {
	                        link: this.getValue('url')
	                    }
	                },
	                myspace: {
	                    shareUrl: 'https://myspace.com/post',
	                    params: {
	                        u: this.getValue('url'),
	                        t: this.getValue('title'),
	                        c: this.getValue('description')
	                    }
	                },
	                blogger: {
	                    shareUrl: 'https://www.blogger.com/blog-this.g',
	                    params: {
	                        u: this.getValue('url'),
	                        n: this.getValue('title'),
	                        t: this.getValue('description')
	                    }
	                },
	                baidu: {
	                    shareUrl: 'http://cang.baidu.com/do/add',
	                    params: {
	                        it: this.getValue('title'),
	                        iu: this.getValue('url')
	                    }
	                },
	                hatenabookmark: {
	                    shareUrl: 'http://b.hatena.ne.jp/entry/' + this.getValue('url'),
	                }
	            },
	            s = sharers[sharer];

	        // custom popups sizes
	        if (s) {
	            s.width = this.getValue('width');
	            s.height = this.getValue('height');
	        }
	        return s !== undefined ? this.urlSharer(s) : false;
	    },
	    /**
	     * @event urlSharer
	     * @param {Object} sharer
	     */
	    urlSharer: function(sharer) {
	        var p = sharer.params || {},
	            keys = Object.keys(p),
	            i,
	            str = keys.length > 0 ? '?' : '';
	        for (i = 0; i < keys.length; i++) {
	            if (str !== '?') {
	                str += '&';
	            }
	            if (p[keys[i]]) {
	                str += keys[i] + '=' + encodeURIComponent(p[keys[i]]);
	            }
	        }
	        sharer.shareUrl += str;

	        if (!sharer.isLink) {
	            var popWidth = sharer.width || 600,
	                popHeight = sharer.height || 480,
	                left = window.innerWidth / 2 - popWidth / 2 + window.screenX,
	                top = window.innerHeight / 2 - popHeight / 2 + window.screenY,
	                popParams = 'scrollbars=no, width=' + popWidth + ', height=' + popHeight + ', top=' + top + ', left=' + left,
	                newWindow = window.open(sharer.shareUrl, '', popParams);

	            if (window.focus) {
	                newWindow.focus();
	            }
	        } else {
	            window.location.href = sharer.shareUrl;
	        }
	    }
	};

	module.exports = Sharer;


/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _BodymovinComponent = __webpack_require__(617);

	var _BodymovinComponent2 = _interopRequireDefault(_BodymovinComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _BodymovinComponent2.default.define('s-bodymovin', _BodymovinComponent2.default);

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _bodymovin = __webpack_require__(618);

	var _bodymovin2 = _interopRequireDefault(_bodymovin);

	var _whenProperty = __webpack_require__(619);

	var _whenProperty2 = _interopRequireDefault(_whenProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SBodymivinComponent
	 * @extends 	SWebComponent
	 * Simple webcomponent wrapper around the freaking cool bodymovin library.
	 * Features:
	 * - All bodymovin capabilities
	 * - Use it as an image tag ```<s-bodymovin src="..."></s-bodymovin>```
	 * - Support a reactive mode that play the animation when a special class is detected
	 * - Cool "yoyo" mode that will play the animation backward when complete
	 *
	 * @example 	html
	 * <s-bodymovin src="my-cool-animation.json" yoyo></s-bodymovin>
	 *
	 * @see 		http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0 		Bodymovin repository
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */
	var SBodymovinComponent = function (_SWebComponent) {
		_inherits(SBodymovinComponent, _SWebComponent);

		function SBodymovinComponent() {
			_classCallCheck(this, SBodymovinComponent);

			return _possibleConstructorReturn(this, (SBodymovinComponent.__proto__ || Object.getPrototypeOf(SBodymovinComponent)).apply(this, arguments));
		}

		_createClass(SBodymovinComponent, [{
			key: 'componentWillMount',


			/**
	   * Component will mount
	  	 * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */
			value: function componentWillMount() {
				_get(SBodymovinComponent.prototype.__proto__ || Object.getPrototypeOf(SBodymovinComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				var _this2 = this;

				_get(SBodymovinComponent.prototype.__proto__ || Object.getPrototypeOf(SBodymovinComponent.prototype), 'componentMount', this).call(this);

				// init bodymovin
				this.bodymovin = _bodymovin2.default.loadAnimation(_extends({}, this.props, {
					autoplay: false,
					container: this,
					loop: !this.props.yoyo ? this.props.loop : false,
					path: this.props.path || this.props.src
				}));
				this.bodymovin.setDirection(this.props.direction);
				this.bodymovin.setSpeed(this.props.speed);

				// add the loading class
				this.classList.add(this.props.loadingClass);

				// when is ready
				(0, _whenProperty2.default)(this.bodymovin, 'isLoaded', function (value) {
					return value === true;
				}).then(function (property) {
					setTimeout(function () {
						_this2._onAnimationReady();
					});
				});

				// bodymovin proxy
				this._exposeBodymovinFn(['play', 'stop', 'pause', 'setSpeed', 'goToAndPlay', 'goToAndStop', 'setDirection', 'playSegments']);
			}

			/**
	   * Unmount component
	   * @definition 		SWebComponent.componentUnmount
	   * @protected
	   */

		}, {
			key: 'componentUnmount',
			value: function componentUnmount() {
				// destroy bodymovin
				this.bodymovin.destroy();

				// make sure we call the parent method
				_get(SBodymovinComponent.prototype.__proto__ || Object.getPrototypeOf(SBodymovinComponent.prototype), 'componentUnmount', this).call(this);
			}

			/**
	   * Component will receive prop
	   * @definition 		SWebComponent.componentWillReceiveProp
	   * @protected
	   */

		}, {
			key: 'componentWillReceiveProp',
			value: function componentWillReceiveProp(name, newVal, oldVal) {
				switch (name) {
					case 'speed':
						this.bodymovin.setSpeed(newVal);
						break;
					case 'direction':
						this.bodymovin.setDirection(newVal);
						break;
					case 'class':
						newVal = typeof newVal !== 'string' ? '' : newVal;
						oldVal = typeof oldVal !== 'string' ? '' : oldVal;
						// check reactiveClass<
						if (this.props.reactive) {
							var classes = newVal.split(' ');
							var oldClasses = oldVal.split(' ');
							if (classes.indexOf(this.props.reactiveClass) === -1 && oldClasses.indexOf(this.props.reactiveClass) !== -1) {
								if (this.props.reactiveBackward) {
									// play back
									this.bodymovin.setDirection(-1);
									this.bodymovin.goToAndPlay(this.bodymovin.totalFrames, true);
								} else {
									// goto frame 0 without playing
									this.bodymovin.goToAndStop(0, true);
								}
							} else if (classes.indexOf(this.props.reactiveClass) !== -1 && oldClasses.indexOf(this.props.reactiveClass) === -1) {
								// play forward if needed
								this.bodymovin.setDirection(1);
								this.bodymovin.goToAndPlay(0, true);
							}
						}
						break;
				}
			}

			/**
	   * Actual real init method that will be fired when the bodymovin animation is ready
	   */

		}, {
			key: '_onAnimationReady',
			value: function _onAnimationReady() {
				var _this3 = this;

				// remove the loading class
				this.classList.remove(this.props.loadingClass);

				// autoplay delay
				setTimeout(function () {

					if (_this3.props.autoplay) {
						_this3.bodymovin.play();
					}

					// reactiveClass
					if (_this3.props.reactive && _this3.classList.contains(_this3.props.reactiveClass)) {
						_this3.bodymovin.goToAndStop(_this3.bodymovin.totalFrames, true);
					}

					// check the play on prop
					if (_this3.props.playOn) {
						_this3.addEventListener(_this3.props.playOn, function (e) {
							_this3.bodymovin.goToAndPlay(0, true);
						});
					}

					// handle yoyo
					if (_this3.props.yoyo) {
						_this3.bodymovin.addEventListener('complete', function (e) {
							if (_this3.bodymovin.currentFrame <= 0) {
								_this3.bodymovin.setSpeed(_this3.props.speed);
								_this3.bodymovin.setDirection(1);
							} else {
								setTimeout(function () {
									_this3.bodymovin.setSpeed(_this3.props.yoyoSpeed);
									_this3.bodymovin.setDirection(-1);
								}, _this3.props.yoyoTimeout);
							}
							if (_this3.props.loop || _this3.bodymovin.currentFrame > 0) {
								_this3.bodymovin.play();
							}
						});
					}
				}, this.props.autoplayDelay);
			}

			/**
	   * Expose some bodymovin functions on the component iutlself
	   */

		}, {
			key: '_exposeBodymovinFn',
			value: function _exposeBodymovinFn(fns) {
				var _this4 = this;

				// loop on each functions to expose
				fns.forEach(function (fn) {
					_this4[fn] = function () {
						this.bodymovin[fn].apply(this.bodymovin, arguments);
					};
				});
			}

			/**
	   * @name 	bodymovin
	   * Heres the list of bodymovin methods that are exposed on the component itself:
	   * - play()
	   * - pause()
	   * - stop()
	   * - setSpeed(speed)
	   * - setDirection(direction)
	   * - goToAndPlay(timeOrFrame, isFrame)
	   * - goToAndStop(timeOrFeame, isFrame)
	   * - playSegments(segments)
	   */

		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t' + componentNameDash + ' {\n\t\t\t\tdisplay : inline-block;\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {

					/**
	     * Bodymovin animation data object
	     * @prop
	     * @type 	{object}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					animationData: null,

					/**
	     * Bodymovin json animation relative path
	     * @prop
	     * @type 	{String}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					path: null,

					/**
	     * Alias to the "path" prop
	     * @prop
	     * @type 	{String}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					src: null,

					/**
	     * Set if the animation has to loop or not
	     * @prop
	     * @type 	{Boolean}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					loop: false,

					/**
	     * Set if the animation has to autoplay or not
	     * @prop
	     * @type 	{Boolean}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					autoplay: false,

					/**
	     * Specify a delay in ms to autoplay the animation
	     * @prop
	     * @type    {Integer}
	     */
					autoplayDelay: 0,

					/**
	     * Specify the direction of the animation
	     * @prop
	     * @type 	{Integer}
	     * @see		http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					direction: 1,

					/**
	     * Set the playback speed
	     * @prop
	     * @type 	{Number}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					speed: 1,

					/**
	     * Set a name to the animation to get it later through the bodymovin api
	     * @prop
	     * @type 	{String}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					name: null,

					/**
	     * Set the renderer to use
	     * @prop
	     * @type 	{String}
	     * @see 	http://github.coffeekraken.io/bodymovin/bodymovin/^4.0.0
	     */
					renderer: 'svg',

					/**
	     * Specify when to play the animation
	     * @prop
	     * @type 	{String}
	     */
					playOn: null,

					/**
	     * Specify if we want the animation to react to a class change
	     * @prop
	     * @type 	{Boolean}
	     */
					reactive: false,

					/**
	     * Specify the class that the bodymovin will react to
	     * @prop
	     * @type	{String}
	     */
					reactiveClass: 'active',

					/**
	     * Specify if the animation has to take place when the reactive class is removed.
	     * If false, the animation will simply jump to start when the class is removed.
	     * @prop
	     * @type 	{Boolean}
	     */
					reactiveBackward: false,

					/**
	     * Specify if the animation has to play backward when arrived to the end. Like a yoyo
	     * @prop
	     * @type 	{Boolean}
	     */
					yoyo: false,

					/**
	     * Specify the speed for the yoyo backward animation
	     * @prop
	     * @type 	{Number}
	     */
					yoyoSpeed: 1,

					/**
	     * Specify how many time to wait before playing the animation back to his starting point
	     * @prop
	     * @type 	{Number}
	     */
					yoyoTimeout: 0,

					/**
	     * Specify the laoding class to set on the element before the animation is ready to play
	     * @prop
	     * @type 	{String}
	     */
					loadingClass: 'loading',

					/**
	     * Listen for classes changes
	     * @protected
	     */
					class: null

				};
			}

			/**
	   * Physical props
	   * @definition 		SWebComponent.physicalProps
	   * @protected
	   */

		}, {
			key: 'physicalProps',
			get: function get() {
				return [];
			}
		}]);

		return SBodymovinComponent;
	}(_SWebComponent3.default);

	exports.default = SBodymovinComponent;

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return factory(root);
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === "object" && module.exports) {
	        module.exports = factory(root);
	    } else {
	        root.bodymovin = factory(root);
	    }
	}((window || {}), function(window) {
	    var svgNS = "http://www.w3.org/2000/svg";

	var locationHref = '';

	var subframeEnabled = true;
	var expressionsPlugin;
	var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	var cachedColors = {};
	var bm_rounder = Math.round;
	var bm_rnd;
	var bm_pow = Math.pow;
	var bm_sqrt = Math.sqrt;
	var bm_abs = Math.abs;
	var bm_floor = Math.floor;
	var bm_max = Math.max;
	var bm_min = Math.min;
	var blitter = 10;

	var BMMath = {};
	(function(){
	    var propertyNames = Object.getOwnPropertyNames(Math);
	    var i, len = propertyNames.length;
	    for(i=0;i<len;i+=1){
	        BMMath[propertyNames[i]] = Math[propertyNames[i]];
	    }
	}());

	function ProjectInterface(){return {}};

	BMMath.random = Math.random;
	BMMath.abs = function(val){
	    var tOfVal = typeof val;
	    if(tOfVal === 'object' && val.length){
	        var absArr = Array.apply(null,{length:val.length});
	        var i, len = val.length;
	        for(i=0;i<len;i+=1){
	            absArr[i] = Math.abs(val[i]);
	        }
	        return absArr;
	    }
	    return Math.abs(val);

	}
	var defaultCurveSegments = 150;
	var degToRads = Math.PI/180;
	var roundCorner = 0.5519;

	function roundValues(flag){
	    if(flag){
	        bm_rnd = Math.round;
	    }else{
	        bm_rnd = function(val){
	            return val;
	        };
	    }
	}
	roundValues(false);

	function roundTo2Decimals(val){
	    return Math.round(val*10000)/10000;
	}

	function roundTo3Decimals(val){
	    return Math.round(val*100)/100;
	}

	function styleDiv(element){
	    element.style.position = 'absolute';
	    element.style.top = 0;
	    element.style.left = 0;
	    element.style.display = 'block';
	    element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';
	    element.style.backfaceVisibility  = element.style.webkitBackfaceVisibility = 'visible';
	    element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = "preserve-3d";
	}

	function styleUnselectableDiv(element){
	    element.style.userSelect = 'none';
	    element.style.MozUserSelect = 'none';
	    element.style.webkitUserSelect = 'none';
	    element.style.oUserSelect = 'none';

	}

	function BMEnterFrameEvent(n,c,t,d){
	    this.type = n;
	    this.currentTime = c;
	    this.totalTime = t;
	    this.direction = d < 0 ? -1:1;
	}

	function BMCompleteEvent(n,d){
	    this.type = n;
	    this.direction = d < 0 ? -1:1;
	}

	function BMCompleteLoopEvent(n,c,t,d){
	    this.type = n;
	    this.currentLoop = c;
	    this.totalLoops = t;
	    this.direction = d < 0 ? -1:1;
	}

	function BMSegmentStartEvent(n,f,t){
	    this.type = n;
	    this.firstFrame = f;
	    this.totalFrames = t;
	}

	function BMDestroyEvent(n,t){
	    this.type = n;
	    this.target = t;
	}

	function _addEventListener(eventName, callback){

	    if (!this._cbs[eventName]){
	        this._cbs[eventName] = [];
	    }
	    this._cbs[eventName].push(callback);

		return function() {
			this.removeEventListener(eventName, callback);
		}.bind(this);
	}

	function _removeEventListener(eventName,callback){

	    if (!callback){
	        this._cbs[eventName] = null;
	    }else if(this._cbs[eventName]){
	        var i = 0, len = this._cbs[eventName].length;
	        while(i<len){
	            if(this._cbs[eventName][i] === callback){
	                this._cbs[eventName].splice(i,1);
	                i -=1;
	                len -= 1;
	            }
	            i += 1;
	        }
	        if(!this._cbs[eventName].length){
	            this._cbs[eventName] = null;
	        }
	    }

	}

	function _triggerEvent(eventName, args){
	    if (this._cbs[eventName]) {
	        var len = this._cbs[eventName].length;
	        for (var i = 0; i < len; i++){
	            this._cbs[eventName][i](args);
	        }
	    }
	}

	function randomString(length, chars){
	    if(chars === undefined){
	        chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
	    }
	    var i;
	    var result = '';
	    for (i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];
	    return result;
	}

	function HSVtoRGB(h, s, v) {
	    var r, g, b, i, f, p, q, t;
	    if (arguments.length === 1) {
	        s = h.s, v = h.v, h = h.h;
	    }
	    i = Math.floor(h * 6);
	    f = h * 6 - i;
	    p = v * (1 - s);
	    q = v * (1 - f * s);
	    t = v * (1 - (1 - f) * s);
	    switch (i % 6) {
	        case 0: r = v, g = t, b = p; break;
	        case 1: r = q, g = v, b = p; break;
	        case 2: r = p, g = v, b = t; break;
	        case 3: r = p, g = q, b = v; break;
	        case 4: r = t, g = p, b = v; break;
	        case 5: r = v, g = p, b = q; break;
	    }
	    return [ r,
	        g,
	         b ];
	}

	function RGBtoHSV(r, g, b) {
	    if (arguments.length === 1) {
	        g = r.g, b = r.b, r = r.r;
	    }
	    var max = Math.max(r, g, b), min = Math.min(r, g, b),
	        d = max - min,
	        h,
	        s = (max === 0 ? 0 : d / max),
	        v = max / 255;

	    switch (max) {
	        case min: h = 0; break;
	        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
	        case g: h = (b - r) + d * 2; h /= 6 * d; break;
	        case b: h = (r - g) + d * 4; h /= 6 * d; break;
	    }

	    return [
	         h,
	         s,
	         v
	    ];
	}

	function addSaturationToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[1] += offset;
	    if (hsv[1] > 1) {
	        hsv[1] = 1;
	    }
	    else if (hsv[1] <= 0) {
	        hsv[1] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function addBrightnessToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[2] += offset;
	    if (hsv[2] > 1) {
	        hsv[2] = 1;
	    }
	    else if (hsv[2] < 0) {
	        hsv[2] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function addHueToRGB(color,offset) {
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[0] += offset/360;
	    if (hsv[0] > 1) {
	        hsv[0] -= 1;
	    }
	    else if (hsv[0] < 0) {
	        hsv[0] += 1;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}

	function componentToHex(c) {
	    var hex = c.toString(16);
	    return hex.length == 1 ? '0' + hex : hex;
	}

	var rgbToHex = (function(){
	    var colorMap = [];
	    var i;
	    var hex;
	    for(i=0;i<256;i+=1){
	        hex = i.toString(16);
	        colorMap[i] = hex.length == 1 ? '0' + hex : hex;
	    }

	    return function(r, g, b) {
	        if(r<0){
	            r = 0;
	        }
	        if(g<0){
	            g = 0;
	        }
	        if(b<0){
	            b = 0;
	        }
	        return '#' + colorMap[r] + colorMap[g] + colorMap[b];
	    };
	}());

	function fillToRgba(hex,alpha){
	    if(!cachedColors[hex]){
	        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	        cachedColors[hex] = parseInt(result[1], 16)+','+parseInt(result[2], 16)+','+parseInt(result[3], 16);
	    }
	    return 'rgba('+cachedColors[hex]+','+alpha+')';
	}

	var fillColorToString = (function(){

	    var colorMap = [];
	    return function(colorArr,alpha){
	        if(alpha !== undefined){
	            colorArr[3] = alpha;
	        }
	        if(!colorMap[colorArr[0]]){
	            colorMap[colorArr[0]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]]){
	            colorMap[colorArr[0]][colorArr[1]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]][colorArr[2]]){
	            colorMap[colorArr[0]][colorArr[1]][colorArr[2]] = {};
	        }
	        if(!colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]]){
	            colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]] = 'rgba(' + colorArr.join(',')+')';
	        }
	        return colorMap[colorArr[0]][colorArr[1]][colorArr[2]][colorArr[3]];
	    };
	}());

	function RenderedFrame(tr,o) {
	    this.tr = tr;
	    this.o = o;
	}

	function iterateDynamicProperties(num){
	    var i, len = this.dynamicProperties;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue(num);
	    }
	}

	function reversePath(paths){
	    var newI = [], newO = [], newV = [];
	    var i, len, newPaths = {};
	    var init = 0;
	    if (paths.c) {
	        newI[0] = paths.o[0];
	        newO[0] = paths.i[0];
	        newV[0] = paths.v[0];
	        init = 1;
	    }
	    len = paths.i.length;
	    var cnt = len - 1;

	    for (i = init; i < len; i += 1) {
	        newI.push(paths.o[cnt]);
	        newO.push(paths.i[cnt]);
	        newV.push(paths.v[cnt]);
	        cnt -= 1;
	    }

	    newPaths.i = newI;
	    newPaths.o = newO;
	    newPaths.v = newV;

	    return newPaths;
	}
	/*!
	 Transformation Matrix v2.0
	 (c) Epistemex 2014-2015
	 www.epistemex.com
	 By Ken Fyrstenberg
	 Contributions by leeoniya.
	 License: MIT, header required.
	 */

	/**
	 * 2D transformation matrix object initialized with identity matrix.
	 *
	 * The matrix can synchronize a canvas context by supplying the context
	 * as an argument, or later apply current absolute transform to an
	 * existing context.
	 *
	 * All values are handled as floating point values.
	 *
	 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
	 * @prop {number} a - scale x
	 * @prop {number} b - shear y
	 * @prop {number} c - shear x
	 * @prop {number} d - scale y
	 * @prop {number} e - translate x
	 * @prop {number} f - translate y
	 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
	 * @constructor
	 */

	var Matrix = (function(){

	    function reset(){
	        this.props[0] = 1;
	        this.props[1] = 0;
	        this.props[2] = 0;
	        this.props[3] = 0;
	        this.props[4] = 0;
	        this.props[5] = 1;
	        this.props[6] = 0;
	        this.props[7] = 0;
	        this.props[8] = 0;
	        this.props[9] = 0;
	        this.props[10] = 1;
	        this.props[11] = 0;
	        this.props[12] = 0;
	        this.props[13] = 0;
	        this.props[14] = 0;
	        this.props[15] = 1;
	        return this;
	    }

	    function rotate(angle) {
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateX(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(1, 0, 0, 0
	            , 0, mCos, -mSin, 0
	            , 0, mSin,  mCos, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateY(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos,  0,  mSin, 0
	            , 0, 1, 0, 0
	            , -mSin,  0,  mCos, 0
	            , 0, 0, 0, 1);
	    }

	    function rotateZ(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	    }

	    function shear(sx,sy){
	        return this._t(1, sy, sx, 1, 0, 0);
	    }

	    function skew(ax, ay){
	        return this.shear(Math.tan(ax), Math.tan(ay));
	    }

	    function skewFromAxis(ax, angle){
	        var mCos = Math.cos(angle);
	        var mSin = Math.sin(angle);
	        return this._t(mCos, mSin,  0, 0
	            , -mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1)
	            ._t(1, 0,  0, 0
	            , Math.tan(ax),  1, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1)
	            ._t(mCos, -mSin,  0, 0
	            , mSin,  mCos, 0, 0
	            , 0,  0,  1, 0
	            , 0, 0, 0, 1);
	        //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, Math.tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
	    }

	    function scale(sx, sy, sz) {
	        sz = isNaN(sz) ? 1 : sz;
	        if(sx == 1 && sy == 1 && sz == 1){
	            return this;
	        }
	        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
	    }

	    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
	        this.props[0] = a;
	        this.props[1] = b;
	        this.props[2] = c;
	        this.props[3] = d;
	        this.props[4] = e;
	        this.props[5] = f;
	        this.props[6] = g;
	        this.props[7] = h;
	        this.props[8] = i;
	        this.props[9] = j;
	        this.props[10] = k;
	        this.props[11] = l;
	        this.props[12] = m;
	        this.props[13] = n;
	        this.props[14] = o;
	        this.props[15] = p;
	        return this;
	    }

	    function translate(tx, ty, tz) {
	        tz = tz || 0;
	        if(tx !== 0 || ty !== 0 || tz !== 0){
	            return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);
	        }
	        return this;
	    }

	    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {

	        if(a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0){
	            if(m2 !== 0 || n2 !== 0 || o2 !== 0){

	                this.props[12] = this.props[12] * a2 + this.props[13] * e2 + this.props[14] * i2 + this.props[15] * m2 ;
	                this.props[13] = this.props[12] * b2 + this.props[13] * f2 + this.props[14] * j2 + this.props[15] * n2 ;
	                this.props[14] = this.props[12] * c2 + this.props[13] * g2 + this.props[14] * k2 + this.props[15] * o2 ;
	                this.props[15] = this.props[12] * d2 + this.props[13] * h2 + this.props[14] * l2 + this.props[15] * p2 ;
	            }
	            this._identityCalculated = false;
	            return this;
	        }

	        var a1 = this.props[0];
	        var b1 = this.props[1];
	        var c1 = this.props[2];
	        var d1 = this.props[3];
	        var e1 = this.props[4];
	        var f1 = this.props[5];
	        var g1 = this.props[6];
	        var h1 = this.props[7];
	        var i1 = this.props[8];
	        var j1 = this.props[9];
	        var k1 = this.props[10];
	        var l1 = this.props[11];
	        var m1 = this.props[12];
	        var n1 = this.props[13];
	        var o1 = this.props[14];
	        var p1 = this.props[15];

	        /* matrix order (canvas compatible):
	         * ace
	         * bdf
	         * 001
	         */
	        this.props[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
	        this.props[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2 ;
	        this.props[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2 ;
	        this.props[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2 ;

	        this.props[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2 ;
	        this.props[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2 ;
	        this.props[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2 ;
	        this.props[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2 ;

	        this.props[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2 ;
	        this.props[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2 ;
	        this.props[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2 ;
	        this.props[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2 ;

	        this.props[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2 ;
	        this.props[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2 ;
	        this.props[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2 ;
	        this.props[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2 ;

	        this._identityCalculated = false;
	        return this;
	    }

	    function isIdentity() {
	        if(!this._identityCalculated){
	            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0
	                || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0
	                || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0
	                || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
	            this._identityCalculated = true;
	        }
	        return this._identity;
	    }

	    function clone(matr){
	        var i;
	        for(i=0;i<16;i+=1){
	            matr.props[i] = this.props[i];
	        }
	    }

	    function cloneFromProps(props){
	        var i;
	        for(i=0;i<16;i+=1){
	            this.props[i] = props[i];
	        }
	    }

	    function applyToPoint(x, y, z) {

	        return {
	            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
	            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
	            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
	        };
	        /*return {
	         x: x * me.a + y * me.c + me.e,
	         y: x * me.b + y * me.d + me.f
	         };*/
	    }
	    function applyToX(x, y, z) {
	        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
	    }
	    function applyToY(x, y, z) {
	        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
	    }
	    function applyToZ(x, y, z) {
	        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
	    }

	    function inversePoint(pt) {
	        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
	        var a = this.props[5]/determinant;
	        var b = - this.props[1]/determinant;
	        var c = - this.props[4]/determinant;
	        var d = this.props[0]/determinant;
	        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12])/determinant;
	        var f = - (this.props[0] * this.props[13] - this.props[1] * this.props[12])/determinant;
	        return [pt[0] * a + pt[1] * c + e, pt[0] * b + pt[1] * d + f, 0];
	    }

	    function inversePoints(pts){
	        var i, len = pts.length, retPts = [];
	        for(i=0;i<len;i+=1){
	            retPts[i] = inversePoint(pts[i]);
	        }
	        return retPts;
	    }

	    function applyToPointArray(x,y,z,dimensions){
	        if(dimensions && dimensions === 2) {
	            var arr = point_pool.newPoint();
	            arr[0] = x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12]; 
	            arr[1] = x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13]; 
	            return arr;    
	        }
	        return [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
	    }
	    function applyToPointStringified(x, y) {
	        if(this.isIdentity()) {
	            return x + ',' + y;
	        }
	        return (bm_rnd(x * this.props[0] + y * this.props[4] + this.props[12]))+','+(bm_rnd(x * this.props[1] + y * this.props[5] + this.props[13]));
	    }

	    function toArray() {
	        return [this.props[0],this.props[1],this.props[2],this.props[3],this.props[4],this.props[5],this.props[6],this.props[7],this.props[8],this.props[9],this.props[10],this.props[11],this.props[12],this.props[13],this.props[14],this.props[15]];
	    }

	    function toCSS() {
	        if(isSafari){
	            return "matrix3d(" + roundTo2Decimals(this.props[0]) + ',' + roundTo2Decimals(this.props[1]) + ',' + roundTo2Decimals(this.props[2]) + ',' + roundTo2Decimals(this.props[3]) + ',' + roundTo2Decimals(this.props[4]) + ',' + roundTo2Decimals(this.props[5]) + ',' + roundTo2Decimals(this.props[6]) + ',' + roundTo2Decimals(this.props[7]) + ',' + roundTo2Decimals(this.props[8]) + ',' + roundTo2Decimals(this.props[9]) + ',' + roundTo2Decimals(this.props[10]) + ',' + roundTo2Decimals(this.props[11]) + ',' + roundTo2Decimals(this.props[12]) + ',' + roundTo2Decimals(this.props[13]) + ',' + roundTo2Decimals(this.props[14]) + ',' + roundTo2Decimals(this.props[15]) + ')';
	        } else {
	            this.cssParts[1] = this.props.join(',');
	            return this.cssParts.join('');
	        }
	    }

	    function to2dCSS() {
	        return "matrix(" + roundTo2Decimals(this.props[0]) + ',' + roundTo2Decimals(this.props[1]) + ',' + roundTo2Decimals(this.props[4]) + ',' + roundTo2Decimals(this.props[5]) + ',' + roundTo2Decimals(this.props[12]) + ',' + roundTo2Decimals(this.props[13]) + ")";
	    }

	    function toString() {
	        return "" + this.toArray();
	    }

	    return function(){
	        this.reset = reset;
	        this.rotate = rotate;
	        this.rotateX = rotateX;
	        this.rotateY = rotateY;
	        this.rotateZ = rotateZ;
	        this.skew = skew;
	        this.skewFromAxis = skewFromAxis;
	        this.shear = shear;
	        this.scale = scale;
	        this.setTransform = setTransform;
	        this.translate = translate;
	        this.transform = transform;
	        this.applyToPoint = applyToPoint;
	        this.applyToX = applyToX;
	        this.applyToY = applyToY;
	        this.applyToZ = applyToZ;
	        this.applyToPointArray = applyToPointArray;
	        this.applyToPointStringified = applyToPointStringified;
	        this.toArray = toArray;
	        this.toCSS = toCSS;
	        this.to2dCSS = to2dCSS;
	        this.toString = toString;
	        this.clone = clone;
	        this.cloneFromProps = cloneFromProps;
	        this.inversePoints = inversePoints;
	        this.inversePoint = inversePoint;
	        this._t = this.transform;
	        this.isIdentity = isIdentity;
	        this._identity = true;
	        this._identityCalculated = false;

	        this.props = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];

	        this.cssParts = ['matrix3d(','',')'];
	    }
	}());

	function Matrix() {


	}

	/*
	 Copyright 2014 David Bau.

	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:

	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	 */

	(function (pool, math) {
	//
	// The following constants are related to IEEE 754 limits.
	//
	    var global = this,
	        width = 256,        // each RC4 output is 0 <= x < 256
	        chunks = 6,         // at least six RC4 outputs for each double
	        digits = 52,        // there are 52 significant digits in a double
	        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
	        startdenom = math.pow(width, chunks),
	        significance = math.pow(2, digits),
	        overflow = significance * 2,
	        mask = width - 1,
	        nodecrypto;         // node.js crypto module, initialized at the bottom.

	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	    function seedrandom(seed, options, callback) {
	        var key = [];
	        options = (options == true) ? { entropy: true } : (options || {});

	        // Flatten the seed string or build one from local entropy if needed.
	        var shortseed = mixkey(flatten(
	            options.entropy ? [seed, tostring(pool)] :
	                (seed == null) ? autoseed() : seed, 3), key);

	        // Use the seed to initialize an ARC4 generator.
	        var arc4 = new ARC4(key);

	        // This function returns a random double in [0, 1) that contains
	        // randomness in every bit of the mantissa of the IEEE 754 value.
	        var prng = function() {
	            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
	                d = startdenom,                 //   and denominator d = 2 ^ 48.
	                x = 0;                          //   and no 'extra last byte'.
	            while (n < significance) {          // Fill up all significant digits by
	                n = (n + x) * width;              //   shifting numerator and
	                d *= width;                       //   denominator and generating a
	                x = arc4.g(1);                    //   new least-significant-byte.
	            }
	            while (n >= overflow) {             // To avoid rounding up, before adding
	                n /= 2;                           //   last byte, shift everything
	                d /= 2;                           //   right using integer math until
	                x >>>= 1;                         //   we have exactly the desired bits.
	            }
	            return (n + x) / d;                 // Form the number within [0, 1).
	        };

	        prng.int32 = function() { return arc4.g(4) | 0; }
	        prng.quick = function() { return arc4.g(4) / 0x100000000; }
	        prng.double = prng;

	        // Mix the randomness into accumulated entropy.
	        mixkey(tostring(arc4.S), pool);

	        // Calling convention: what to return as a function of prng, seed, is_math.
	        return (options.pass || callback ||
	        function(prng, seed, is_math_call, state) {
	            if (state) {
	                // Load the arc4 state from the given state if it has an S array.
	                if (state.S) { copy(state, arc4); }
	                // Only provide the .state method if requested via options.state.
	                prng.state = function() { return copy(arc4, {}); }
	            }

	            // If called as a method of Math (Math.seedrandom()), mutate
	            // Math.random because that is how seedrandom.js has worked since v1.0.
	            if (is_math_call) { math[rngname] = prng; return seed; }

	            // Otherwise, it is a newer calling convention, so return the
	            // prng directly.
	            else return prng;
	        })(
	            prng,
	            shortseed,
	            'global' in options ? options.global : (this == math),
	            options.state);
	    }
	    math['seed' + rngname] = seedrandom;

	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	    function ARC4(key) {
	        var t, keylen = key.length,
	            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	        // The empty key [] is treated as [0].
	        if (!keylen) { key = [keylen++]; }

	        // Set up S using the standard key scheduling algorithm.
	        while (i < width) {
	            s[i] = i++;
	        }
	        for (i = 0; i < width; i++) {
	            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
	            s[j] = t;
	        }

	        // The "g" method returns the next (count) outputs as one number.
	        (me.g = function(count) {
	            // Using instance members instead of closure state nearly doubles speed.
	            var t, r = 0,
	                i = me.i, j = me.j, s = me.S;
	            while (count--) {
	                t = s[i = mask & (i + 1)];
	                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
	            }
	            me.i = i; me.j = j;
	            return r;
	            // For robust unpredictability, the function call below automatically
	            // discards an initial batch of values.  This is called RC4-drop[256].
	            // See http://google.com/search?q=rsa+fluhrer+response&btnI
	        })(width);
	    }

	//
	// copy()
	// Copies internal state of ARC4 to or from a plain object.
	//
	    function copy(f, t) {
	        t.i = f.i;
	        t.j = f.j;
	        t.S = f.S.slice();
	        return t;
	    };

	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	    function flatten(obj, depth) {
	        var result = [], typ = (typeof obj), prop;
	        if (depth && typ == 'object') {
	            for (prop in obj) {
	                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	            }
	        }
	        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
	    }

	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	    function mixkey(seed, key) {
	        var stringseed = seed + '', smear, j = 0;
	        while (j < stringseed.length) {
	            key[mask & j] =
	                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	        }
	        return tostring(key);
	    }

	//
	// autoseed()
	// Returns an object for autoseeding, using window.crypto and Node crypto
	// module if available.
	//
	    function autoseed() {
	        try {
	            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
	            var out = new Uint8Array(width);
	            (global.crypto || global.msCrypto).getRandomValues(out);
	            return tostring(out);
	        } catch (e) {
	            var browser = global.navigator,
	                plugins = browser && browser.plugins;
	            return [+new Date, global, plugins, global.screen, tostring(pool)];
	        }
	    }

	//
	// tostring()
	// Converts an array of charcodes to a string
	//
	    function tostring(a) {
	        return String.fromCharCode.apply(0, a);
	    }

	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to interfere with deterministic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	    mixkey(math.random(), pool);

	//
	// Nodejs and AMD support: export the implementation as a module using
	// either convention.
	//

	// End anonymous scope, and pass initial values.
	})(
	    [],     // pool: entropy pool starts empty
	    BMMath    // math: package containing random, pow, and seedrandom
	);
	var BezierFactory = (function(){
	    /**
	     * BezierEasing - use bezier curve for transition easing function
	     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	     *
	     * Credits: is based on Firefox's nsSMILKeySpline.cpp
	     * Usage:
	     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
	     * spline.get(x) => returns the easing value | x must be in [0, 1] range
	     *
	     */

	        var ob = {};
	    ob.getBezierEasing = getBezierEasing;
	    var beziers = {};

	    function getBezierEasing(a,b,c,d,nm){
	        var str = nm || ('bez_' + a+'_'+b+'_'+c+'_'+d).replace(/\./g, 'p');
	        if(beziers[str]){
	            return beziers[str];
	        }
	        var bezEasing = new BezierEasing([a,b,c,d]);
	        beziers[str] = bezEasing;
	        return bezEasing;
	    }

	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	    var NEWTON_ITERATIONS = 4;
	    var NEWTON_MIN_SLOPE = 0.001;
	    var SUBDIVISION_PRECISION = 0.0000001;
	    var SUBDIVISION_MAX_ITERATIONS = 10;

	    var kSplineTableSize = 11;
	    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	    var float32ArraySupported = typeof Float32Array === "function";

	    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	    function C (aA1)      { return 3.0 * aA1; }

	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	    function calcBezier (aT, aA1, aA2) {
	        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
	    }

	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	    function getSlope (aT, aA1, aA2) {
	        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	    }

	    function binarySubdivide (aX, aA, aB, mX1, mX2) {
	        var currentX, currentT, i = 0;
	        do {
	            currentT = aA + (aB - aA) / 2.0;
	            currentX = calcBezier(currentT, mX1, mX2) - aX;
	            if (currentX > 0.0) {
	                aB = currentT;
	            } else {
	                aA = currentT;
	            }
	        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	        return currentT;
	    }

	    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
	        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	            var currentSlope = getSlope(aGuessT, mX1, mX2);
	            if (currentSlope === 0.0) return aGuessT;
	            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	            aGuessT -= currentX / currentSlope;
	        }
	        return aGuessT;
	    }

	    /**
	     * points is an array of [ mX1, mY1, mX2, mY2 ]
	     */
	    function BezierEasing (points) {
	        this._p = points;
	        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	        this._precomputed = false;

	        this.get = this.get.bind(this);
	    }

	    BezierEasing.prototype = {

	        get: function (x) {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            if (!this._precomputed) this._precompute();
	            if (mX1 === mY1 && mX2 === mY2) return x; // linear
	            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	            if (x === 0) return 0;
	            if (x === 1) return 1;
	            return calcBezier(this._getTForX(x), mY1, mY2);
	        },

	        // Private part

	        _precompute: function () {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            this._precomputed = true;
	            if (mX1 !== mY1 || mX2 !== mY2)
	                this._calcSampleValues();
	        },

	        _calcSampleValues: function () {
	            var mX1 = this._p[0],
	                mX2 = this._p[2];
	            for (var i = 0; i < kSplineTableSize; ++i) {
	                this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	            }
	        },

	        /**
	         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
	         */
	        _getTForX: function (aX) {
	            var mX1 = this._p[0],
	                mX2 = this._p[2],
	                mSampleValues = this._mSampleValues;

	            var intervalStart = 0.0;
	            var currentSample = 1;
	            var lastSample = kSplineTableSize - 1;

	            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
	                intervalStart += kSampleStepSize;
	            }
	            --currentSample;

	            // Interpolate to provide an initial guess for t
	            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
	            var guessForT = intervalStart + dist * kSampleStepSize;

	            var initialSlope = getSlope(guessForT, mX1, mX2);
	            if (initialSlope >= NEWTON_MIN_SLOPE) {
	                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	            } else if (initialSlope === 0.0) {
	                return guessForT;
	            } else {
	                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	            }
	        }
	    };

	    return ob;

	}());
	(function () {
	    var lastTime = 0;
	    var vendors = ['ms', 'moz', 'webkit', 'o'];
	    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
	        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	    }
	    if(!window.requestAnimationFrame)
	        window.requestAnimationFrame = function (callback, element) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	            var id = setTimeout(function () {
	                    callback(currTime + timeToCall);
	                },
	                timeToCall);
	            lastTime = currTime + timeToCall;
	            return id;
	        };
	    if(!window.cancelAnimationFrame)
	        window.cancelAnimationFrame = function (id) {
	            clearTimeout(id);
	        };
	}());

	function createElement(parent,child,params){
	    if(child){
	        child.prototype = Object.create(parent.prototype);
	        child.prototype.constructor = child;
	        child.prototype._parent = parent.prototype;
	    }else{
	        var instance = Object.create(parent.prototype,params);
	        var getType = {};
	        if(instance && getType.toString.call(instance.init) === '[object Function]'){
	            instance.init();
	        }
	        return instance;
	    }
	}

	function extendPrototype(source,destination){
	    for (var attr in source.prototype) {
	        if (source.prototype.hasOwnProperty(attr)) destination.prototype[attr] = source.prototype[attr];
	    }
	}
	function bezFunction(){

	    var easingFunctions = [];
	    var math = Math;

	    function pointOnLine2D(x1,y1, x2,y2, x3,y3){
	        var det1 = (x1*y2) + (y1*x3) + (x2*y3) - (x3*y2) - (y3*x1) - (x2*y1);
	        return det1 > -0.0001 && det1 < 0.0001;
	    }

	    function pointOnLine3D(x1,y1,z1, x2,y2,z2, x3,y3,z3){
	        if(z1 === 0 && z2 === 0 && z3 === 0) {
	            return pointOnLine2D(x1,y1, x2,y2, x3,y3);
	        }
	        var dist1 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));
	        var dist2 = Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2) + Math.pow(z3 - z1, 2));
	        var dist3 = Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2) + Math.pow(z3 - z2, 2));
	        var diffDist;
	        if(dist1 > dist2){
	            if(dist1 > dist3){
	                diffDist = dist1 - dist2 - dist3;
	            } else {
	                diffDist = dist3 - dist2 - dist1;
	            }
	        } else if(dist3 > dist2){
	            diffDist = dist3 - dist2 - dist1;
	        } else {
	            diffDist = dist2 - dist1 - dist3;
	        }
	        return diffDist > -0.0001 && diffDist < 0.0001;
	    }

	    /*function getEasingCurve(aa,bb,cc,dd,encodedFuncName) {
	        if(!encodedFuncName){
	            encodedFuncName = ('bez_' + aa+'_'+bb+'_'+cc+'_'+dd).replace(/\./g, 'p');
	        }
	        if(easingFunctions[encodedFuncName]){
	            return easingFunctions[encodedFuncName];
	        }
	        var A0, B0, C0;
	        var A1, B1, C1;
	        easingFunctions[encodedFuncName] = function(tt) {
	            var x = tt;
	            var i = 0, z;
	            while (++i < 20) {
	                C0 = 3 * aa;
	                B0 = 3 * (cc - aa) - C0;
	                A0 = 1 - C0 - B0;
	                z = (x * (C0 + x * (B0 + x * A0))) - tt;
	                if (bm_abs(z) < 1e-3) break;
	                x -= z / (C0 + x * (2 * B0 + 3 * A0 * x));
	            }
	            C1 = 3 * bb;
	            B1 = 3 * (dd - bb) - C1;
	            A1 = 1 - C1 - B1;
	            var polyB = x * (C1 + x * (B1 + x * A1));
	            //return c * polyB + b;
	            return polyB;
	        };
	        return easingFunctions[encodedFuncName];
	    }*/
	    var getBezierLength = (function(){

	        function Segment(l,p){
	            this.l = l;
	            this.p = p;
	        }

	        return function(pt1,pt2,pt3,pt4){
	            var curveSegments = defaultCurveSegments;
	            var k;
	            var i, len;
	            var ptCoord,perc,addedLength = 0;
	            var ptDistance;
	            var point = [],lastPoint = [];
	            var lengthData = {
	                addedLength: 0,
	                segments: []
	            };
	            len = pt3.length;
	            for(k=0;k<curveSegments;k+=1){
	                perc = k/(curveSegments-1);
	                ptDistance = 0;
	                for(i=0;i<len;i+=1){
	                    ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bm_pow(perc,2)*pt4[i]+bm_pow(perc,3)*pt2[i];
	                    point[i] = ptCoord;
	                    if(lastPoint[i] !== null){
	                        ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                    }
	                    lastPoint[i] = point[i];
	                }
	                if(ptDistance){
	                    ptDistance = bm_sqrt(ptDistance);
	                    addedLength += ptDistance;
	                }
	                lengthData.segments.push(new Segment(addedLength,perc));
	            }
	            lengthData.addedLength = addedLength;
	            return lengthData;
	        };
	    }());

	    function getSegmentsLength(shapeData) {
	        var closed = shapeData.c;
	        var pathV = shapeData.v;
	        var pathO = shapeData.o;
	        var pathI = shapeData.i;
	        var i, len = shapeData._length;
	        var lengths = [];
	        var totalLength = 0;
	        for(i=0;i<len-1;i+=1){
	            lengths[i] = getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);
	            totalLength += lengths[i].addedLength;
	        }
	        if(closed){
	            lengths[i] = getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);
	            totalLength += lengths[i].addedLength;
	        }
	        return {lengths:lengths,totalLength:totalLength};
	    }

	    function BezierData(length){
	        this.segmentLength = 0;
	        this.points = new Array(length);
	    }

	    function PointData(partial,point){
	        this.partialLength = partial;
	        this.point = point;
	    }

	    var buildBezierData = (function(){

	        var storedData = {};

	        return function (keyData){
	            var pt1 = keyData.s;
	            var pt2 = keyData.e;
	            var pt3 = keyData.to;
	            var pt4 = keyData.ti;
	            var bezierName = (pt1.join('_')+'_'+pt2.join('_')+'_'+pt3.join('_')+'_'+pt4.join('_')).replace(/\./g, 'p');
	            if(storedData[bezierName]){
	                keyData.bezierData = storedData[bezierName];
	                return;
	            }
	        var curveSegments = defaultCurveSegments;
	        var k, i, len;
	            var ptCoord,perc,addedLength = 0;
	            var ptDistance;
	            var point,lastPoint = null;
	            if(pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){
	                curveSegments = 2;
	            }
	            var bezierData = new BezierData(curveSegments);
	            len = pt3.length;
	            for(k=0;k<curveSegments;k+=1){
	            point = new Array(len);
	                perc = k/(curveSegments-1);
	                ptDistance = 0;
	                for(i=0;i<len;i+=1){
	                ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*(pt1[i] + pt3[i])+3*(1-perc)*bm_pow(perc,2)*(pt2[i] + pt4[i])+bm_pow(perc,3)*pt2[i];
	                point[i] = ptCoord;
	                    if(lastPoint !== null){
	                    ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                    }
	                }
	            ptDistance = bm_sqrt(ptDistance);
	                addedLength += ptDistance;
	                bezierData.points[k] = new PointData(ptDistance,point);
	                lastPoint = point;
	            }
	            bezierData.segmentLength = addedLength;
	            keyData.bezierData = bezierData;
	            storedData[bezierName] = bezierData;

	        }
	    }());

	    function getDistancePerc(perc,bezierData){
	        var segments = bezierData.segments;
	        var len = segments.length;
	        var initPos = bm_floor((len-1)*perc);
	        var lengthPos = perc*bezierData.addedLength;
	        var lPerc = 0;
	        if(lengthPos == segments[initPos].l){
	            return segments[initPos].p;
	        }else{
	            var dir = segments[initPos].l > lengthPos ? -1 : 1;
	            var flag = true;
	            while(flag){
	                if(segments[initPos].l <= lengthPos && segments[initPos+1].l > lengthPos){
	                    lPerc = (lengthPos - segments[initPos].l)/(segments[initPos+1].l-segments[initPos].l);
	                    flag = false;
	                }else{
	                    initPos += dir;
	                }
	                if(initPos < 0 || initPos >= len - 1){
	                    flag = false;
	                }
	            }
	            return segments[initPos].p + (segments[initPos+1].p - segments[initPos].p)*lPerc;
	        }
	    }

	    function SegmentPoints(){
	        this.pt1 = new Array(2);
	        this.pt2 = new Array(2);
	        this.pt3 = new Array(2);
	        this.pt4 = new Array(2);
	    }

	    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
	        var t1 = getDistancePerc(percent,bezierData);
	        var u0 = 1;
	        var u1 = 1 - t1;
	        var ptX = Math.round((u1*u1*u1* pt1[0] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[0] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[0] + t1*t1*t1* pt2[0])* 1000) / 1000;
	        var ptY = Math.round((u1*u1*u1* pt1[1] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[1] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[1] + t1*t1*t1* pt2[1])* 1000) / 1000;
	        return [ptX, ptY];
	    }

	    function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc, bezierData){

	        var pts = new SegmentPoints();
	        startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;
	        var t0 = getDistancePerc(startPerc,bezierData);
	        endPerc = endPerc > 1 ? 1 : endPerc;
	        var t1 = getDistancePerc(endPerc,bezierData);
	        var i, len = pt1.length;
	        var u0 = 1 - t0;
	        var u1 = 1 - t1;
	        //Math.round(num * 100) / 100
	        for(i=0;i<len;i+=1){
	            pts.pt1[i] =  Math.round((u0*u0*u0* pt1[i] + (t0*u0*u0 + u0*t0*u0 + u0*u0*t0) * pt3[i] + (t0*t0*u0 + u0*t0*t0 + t0*u0*t0)* pt4[i] + t0*t0*t0* pt2[i])* 1000) / 1000;
	            pts.pt3[i] = Math.round((u0*u0*u1*pt1[i] + (t0*u0*u1 + u0*t0*u1 + u0*u0*t1)* pt3[i] + (t0*t0*u1 + u0*t0*t1 + t0*u0*t1)* pt4[i] + t0*t0*t1* pt2[i])* 1000) / 1000;
	            pts.pt4[i] = Math.round((u0*u1*u1* pt1[i] + (t0*u1*u1 + u0*t1*u1 + u0*u1*t1)* pt3[i] + (t0*t1*u1 + u0*t1*t1 + t0*u1*t1)* pt4[i] + t0*t1*t1* pt2[i])* 1000) / 1000;
	            pts.pt2[i] = Math.round((u1*u1*u1* pt1[i] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[i] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[i] + t1*t1*t1* pt2[i])* 1000) / 1000;
	        }
	        return pts;
	    }

	    return {
	        //getEasingCurve : getEasingCurve,
	        getBezierLength : getBezierLength,
	        getSegmentsLength : getSegmentsLength,
	        getNewSegment : getNewSegment,
	        getPointInSegment : getPointInSegment,
	        buildBezierData : buildBezierData,
	        pointOnLine2D : pointOnLine2D,
	        pointOnLine3D : pointOnLine3D
	    };
	}

	var bez = bezFunction();
	function dataFunctionManager(){

	    //var tCanvasHelper = document.createElement('canvas').getContext('2d');

	    function completeLayers(layers, comps, fontManager){
	        var layerData;
	        var animArray, lastFrame;
	        var i, len = layers.length;
	        var j, jLen, k, kLen;
	        for(i=0;i<len;i+=1){
	            layerData = layers[i];
	            if(!('ks' in layerData) || layerData.completed){
	                continue;
	            }
	            layerData.completed = true;
	            if(layerData.tt){
	                layers[i-1].td = layerData.tt;
	            }
	            animArray = [];
	            lastFrame = -1;
	            if(layerData.hasMask){
	                var maskProps = layerData.masksProperties;
	                jLen = maskProps.length;
	                for(j=0;j<jLen;j+=1){
	                    if(maskProps[j].pt.k.i){
	                        convertPathsToAbsoluteValues(maskProps[j].pt.k);
	                    }else{
	                        kLen = maskProps[j].pt.k.length;
	                        for(k=0;k<kLen;k+=1){
	                            if(maskProps[j].pt.k[k].s){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
	                            }
	                            if(maskProps[j].pt.k[k].e){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
	                            }
	                        }
	                    }
	                }
	            }
	            if(layerData.ty===0){
	                layerData.layers = findCompLayers(layerData.refId, comps);
	                completeLayers(layerData.layers,comps, fontManager);
	            }else if(layerData.ty === 4){
	                completeShapes(layerData.shapes);
	            }else if(layerData.ty == 5){
	                completeText(layerData, fontManager);
	            }
	        }
	    }

	    function findCompLayers(id,comps){
	        var i = 0, len = comps.length;
	        while(i<len){
	            if(comps[i].id === id){
	                if(!comps[i].layers.__used) {
	                    comps[i].layers.__used = true;
	                    return comps[i].layers;
	                }
	                return JSON.parse(JSON.stringify(comps[i].layers));
	            }
	            i += 1;
	        }
	    }

	    function completeShapes(arr){
	        var i, len = arr.length;
	        var j, jLen;
	        var hasPaths = false;
	        for(i=len-1;i>=0;i-=1){
	            if(arr[i].ty == 'sh'){
	                if(arr[i].ks.k.i){
	                    convertPathsToAbsoluteValues(arr[i].ks.k);
	                }else{
	                    jLen = arr[i].ks.k.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(arr[i].ks.k[j].s){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
	                        }
	                        if(arr[i].ks.k[j].e){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
	                        }
	                    }
	                }
	                hasPaths = true;
	            }else if(arr[i].ty == 'gr'){
	                completeShapes(arr[i].it);
	            }
	        }
	        /*if(hasPaths){
	            //mx: distance
	            //ss: sensitivity
	            //dc: decay
	            arr.splice(arr.length-1,0,{
	                "ty": "ms",
	                "mx":20,
	                "ss":10,
	                 "dc":0.001,
	                "maxDist":200
	            });
	        }*/
	    }

	    function convertPathsToAbsoluteValues(path){
	        var i, len = path.i.length;
	        for(i=0;i<len;i+=1){
	            path.i[i][0] += path.v[i][0];
	            path.i[i][1] += path.v[i][1];
	            path.o[i][0] += path.v[i][0];
	            path.o[i][1] += path.v[i][1];
	        }
	    }

	    function checkVersion(minimum,animVersionString){
	        var animVersion = animVersionString ? animVersionString.split('.') : [100,100,100];
	        if(minimum[0]>animVersion[0]){
	            return true;
	        } else if(animVersion[0] > minimum[0]){
	            return false;
	        }
	        if(minimum[1]>animVersion[1]){
	            return true;
	        } else if(animVersion[1] > minimum[1]){
	            return false;
	        }
	        if(minimum[2]>animVersion[2]){
	            return true;
	        } else if(animVersion[2] > minimum[2]){
	            return false;
	        }
	    }

	    var checkText = (function(){
	        var minimumVersion = [4,4,14];

	        function updateTextLayer(textLayer){
	            var documentData = textLayer.t.d;
	            textLayer.t.d = {
	                k: [
	                    {
	                        s:documentData,
	                        t:0
	                    }
	                ]
	            }
	        }

	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 5){
	                    updateTextLayer(layers[i]);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }())

	    var checkChars = (function() {
	        var minimumVersion = [4,7,99];
	        return function (animationData){
	            if(animationData.chars && !checkVersion(minimumVersion,animationData.v)){
	                var i, len = animationData.chars.length, j, jLen, k, kLen;
	                var pathData, paths;
	                for(i = 0; i < len; i += 1) {
	                    if(animationData.chars[i].data && animationData.chars[i].data.shapes) {
	                        paths = animationData.chars[i].data.shapes[0].it;
	                        jLen = paths.length;

	                        for(j = 0; j < jLen; j += 1) {
	                            pathData = paths[j].ks.k;
	                            if(!pathData.__converted) {
	                                convertPathsToAbsoluteValues(paths[j].ks.k);
	                                pathData.__converted = true;
	                            }
	                        }
	                    }
	                }
	            }
	        }

	    }())

	    var checkColors = (function(){
	        var minimumVersion = [4,1,9];

	        function iterateShapes(shapes){
	            var i, len = shapes.length;
	            var j, jLen;
	            for(i=0;i<len;i+=1){
	                if(shapes[i].ty === 'gr'){
	                    iterateShapes(shapes[i].it);
	                }else if(shapes[i].ty === 'fl' || shapes[i].ty === 'st'){
	                    if(shapes[i].c.k && shapes[i].c.k[0].i){
	                        jLen = shapes[i].c.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(shapes[i].c.k[j].s){
	                                shapes[i].c.k[j].s[0] /= 255;
	                                shapes[i].c.k[j].s[1] /= 255;
	                                shapes[i].c.k[j].s[2] /= 255;
	                                shapes[i].c.k[j].s[3] /= 255;
	                            }
	                            if(shapes[i].c.k[j].e){
	                                shapes[i].c.k[j].e[0] /= 255;
	                                shapes[i].c.k[j].e[1] /= 255;
	                                shapes[i].c.k[j].e[2] /= 255;
	                                shapes[i].c.k[j].e[3] /= 255;
	                            }
	                        }
	                    } else {
	                        shapes[i].c.k[0] /= 255;
	                        shapes[i].c.k[1] /= 255;
	                        shapes[i].c.k[2] /= 255;
	                        shapes[i].c.k[3] /= 255;
	                    }
	                }
	            }
	        }

	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 4){
	                    iterateShapes(layers[i].shapes);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }());

	    var checkShapes = (function(){
	        var minimumVersion = [4,4,18];



	        function completeShapes(arr){
	            var i, len = arr.length;
	            var j, jLen;
	            var hasPaths = false;
	            for(i=len-1;i>=0;i-=1){
	                if(arr[i].ty == 'sh'){
	                    if(arr[i].ks.k.i){
	                        arr[i].ks.k.c = arr[i].closed;
	                    }else{
	                        jLen = arr[i].ks.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(arr[i].ks.k[j].s){
	                                arr[i].ks.k[j].s[0].c = arr[i].closed;
	                            }
	                            if(arr[i].ks.k[j].e){
	                                arr[i].ks.k[j].e[0].c = arr[i].closed;
	                            }
	                        }
	                    }
	                    hasPaths = true;
	                }else if(arr[i].ty == 'gr'){
	                    completeShapes(arr[i].it);
	                }
	            }
	        }

	        function iterateLayers(layers){
	            var layerData;
	            var i, len = layers.length;
	            var j, jLen, k, kLen;
	            for(i=0;i<len;i+=1){
	                layerData = layers[i];
	                if(layerData.hasMask){
	                    var maskProps = layerData.masksProperties;
	                    jLen = maskProps.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(maskProps[j].pt.k.i){
	                            maskProps[j].pt.k.c = maskProps[j].cl;
	                        }else{
	                            kLen = maskProps[j].pt.k.length;
	                            for(k=0;k<kLen;k+=1){
	                                if(maskProps[j].pt.k[k].s){
	                                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
	                                }
	                                if(maskProps[j].pt.k[k].e){
	                                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
	                                }
	                            }
	                        }
	                    }
	                }
	                if(layerData.ty === 4){
	                    completeShapes(layerData.shapes);
	                }
	            }
	        }

	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);

	                        }
	                    }
	                }
	            }
	        }
	    }());

	    /*function blitPaths(path){
	        var i, len = path.i.length;
	        for(i=0;i<len;i+=1){
	            path.i[i][0] /= blitter;
	            path.i[i][1] /= blitter;
	            path.o[i][0] /= blitter;
	            path.o[i][1] /= blitter;
	            path.v[i][0] /= blitter;
	            path.v[i][1] /= blitter;
	        }
	    }

	    function blitShapes(arr){
	        var i, len = arr.length;
	        var j, jLen;
	        var hasPaths = false;
	        for(i=len-1;i>=0;i-=1){
	            if(arr[i].ty == 'sh'){
	                if(arr[i].ks.k.i){
	                    blitPaths(arr[i].ks.k);
	                }else{
	                    jLen = arr[i].ks.k.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(arr[i].ks.k[j].s){
	                            blitPaths(arr[i].ks.k[j].s[0]);
	                        }
	                        if(arr[i].ks.k[j].e){
	                            blitPaths(arr[i].ks.k[j].e[0]);
	                        }
	                    }
	                }
	                hasPaths = true;
	            }else if(arr[i].ty == 'gr'){
	                blitShapes(arr[i].it);
	            }else if(arr[i].ty == 'rc'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].s);
	            }else if(arr[i].ty == 'st'){
	                blitProperty(arr[i].w);
	            }else if(arr[i].ty == 'tr'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].sk);
	                blitProperty(arr[i].a);
	            }else if(arr[i].ty == 'el'){
	                blitProperty(arr[i].p);
	                blitProperty(arr[i].s);
	            }else if(arr[i].ty == 'rd'){
	                blitProperty(arr[i].r);
	            }else{

	                //console.log(arr[i].ty );
	            }
	        }
	    }

	    function blitText(data, fontManager){

	    }

	    function blitValue(val){
	        if(typeof(val) === 'number'){
	            val /= blitter;
	        } else {
	            var i = val.length-1;
	            while(i>=0){
	                val[i] /= blitter;
	                i-=1;
	            }
	        }
	        return val;
	    }

	    function blitProperty(data){
	        if(!data.k.length){
	            data.k = blitValue(data.k);
	        }else if(typeof(data.k[0]) === 'number'){
	            data.k = blitValue(data.k);
	        } else {
	            var i, len = data.k.length;
	            for(i=0;i<len;i+=1){
	                if(data.k[i].s){
	                    //console.log('pre S: ', data.k[i].s);
	                    data.k[i].s = blitValue(data.k[i].s);
	                    //console.log('post S: ', data.k[i].s);
	                }
	                if(data.k[i].e){
	                    //console.log('pre E: ', data.k[i].e);
	                    data.k[i].e = blitValue(data.k[i].e);
	                    //console.log('post E: ', data.k[i].e);
	                }
	            }
	        }
	    }

	    function blitLayers(layers,comps, fontManager){
	        var layerData;
	        var animArray, lastFrame;
	        var i, len = layers.length;
	        var j, jLen, k, kLen;
	        for(i=0;i<len;i+=1){
	            layerData = layers[i];
	            if(!('ks' in layerData)){
	                continue;
	            }
	            blitProperty(layerData.ks.a);
	            blitProperty(layerData.ks.p);
	            layerData.completed = true;
	            if(layerData.tt){
	                layers[i-1].td = layerData.tt;
	            }
	            animArray = [];
	            lastFrame = -1;
	            if(layerData.hasMask){
	                var maskProps = layerData.masksProperties;
	                jLen = maskProps.length;
	                for(j=0;j<jLen;j+=1){
	                    if(maskProps[j].pt.k.i){
	                        blitPaths(maskProps[j].pt.k);
	                    }else{
	                        kLen = maskProps[j].pt.k.length;
	                        for(k=0;k<kLen;k+=1){
	                            if(maskProps[j].pt.k[k].s){
	                                blitPaths(maskProps[j].pt.k[k].s[0]);
	                            }
	                            if(maskProps[j].pt.k[k].e){
	                                blitPaths(maskProps[j].pt.k[k].e[0]);
	                            }
	                        }
	                    }
	                }
	            }
	            if(layerData.ty===0){
	                layerData.w = Math.round(layerData.w/blitter);
	                layerData.h = Math.round(layerData.h/blitter);
	                blitLayers(layerData.layers,comps, fontManager);
	            }else if(layerData.ty === 4){
	                blitShapes(layerData.shapes);
	            }else if(layerData.ty == 5){
	                blitText(layerData, fontManager);
	            }else if(layerData.ty == 1){
	                layerData.sh /= blitter;
	                layerData.sw /= blitter;
	            } else {
	            }
	        }
	    }

	    function blitAnimation(animationData,comps, fontManager){
	        blitLayers(animationData.layers,comps, fontManager);
	    }*/

	    function completeData(animationData, fontManager){
	        if(animationData.__complete){
	            return;
	        }
	        checkColors(animationData);
	        checkText(animationData);
	        checkChars(animationData);
	        checkShapes(animationData);
	        completeLayers(animationData.layers, animationData.assets, fontManager);
	        animationData.__complete = true;
	        //blitAnimation(animationData, animationData.assets, fontManager);
	    }

	    function completeText(data, fontManager){
	        if(data.t.a.length === 0 && !('m' in data.t.p)){
	            data.singleShape = true;
	        }
	    }

	    var moduleOb = {};
	    moduleOb.completeData = completeData;

	    return moduleOb;
	}

	var dataManager = dataFunctionManager();
	var FontManager = (function(){

	    var maxWaitingTime = 5000;

	    function setUpNode(font, family){
	        var parentNode = document.createElement('span');
	        parentNode.style.fontFamily    = family;
	        var node = document.createElement('span');
	        // Characters that vary significantly among different fonts
	        node.innerHTML = 'giItT1WQy@!-/#';
	        // Visible - so we can measure it - but not on the screen
	        parentNode.style.position      = 'absolute';
	        parentNode.style.left          = '-10000px';
	        parentNode.style.top           = '-10000px';
	        // Large font size makes even subtle changes obvious
	        parentNode.style.fontSize      = '300px';
	        // Reset any font properties
	        parentNode.style.fontVariant   = 'normal';
	        parentNode.style.fontStyle     = 'normal';
	        parentNode.style.fontWeight    = 'normal';
	        parentNode.style.letterSpacing = '0';
	        parentNode.appendChild(node);
	        document.body.appendChild(parentNode);

	        // Remember width with no applied web font
	        var width = node.offsetWidth;
	        node.style.fontFamily = font + ', '+family;
	        return {node:node, w:width, parent:parentNode};
	    }

	    function checkLoadedFonts() {
	        var i, len = this.fonts.length;
	        var node, w;
	        var loadedCount = len;
	        for(i=0;i<len; i+= 1){
	            if(this.fonts[i].loaded){
	                loadedCount -= 1;
	                continue;
	            }
	            if(this.fonts[i].fOrigin === 't' || this.fonts[i].origin === 2){
	                if(window.Typekit && window.Typekit.load && this.typekitLoaded === 0){
	                    this.typekitLoaded = 1;
	                    try{window.Typekit.load({
	                        async: true,
	                        active: function() {
	                            this.typekitLoaded = 2;
	                        }.bind(this)
	                    });}catch(e){}
	                }
	                if(this.typekitLoaded === 2) {
	                    this.fonts[i].loaded = true;
	                }
	            } else if(this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0){
	                this.fonts[i].loaded = true;
	            } else{
	                node = this.fonts[i].monoCase.node;
	                w = this.fonts[i].monoCase.w;
	                if(node.offsetWidth !== w){
	                    loadedCount -= 1;
	                    this.fonts[i].loaded = true;
	                }else{
	                    node = this.fonts[i].sansCase.node;
	                    w = this.fonts[i].sansCase.w;
	                    if(node.offsetWidth !== w){
	                        loadedCount -= 1;
	                        this.fonts[i].loaded = true;
	                    }
	                }
	                if(this.fonts[i].loaded){
	                    this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
	                    this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
	                }
	            }
	        }

	        if(loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime){
	            setTimeout(checkLoadedFonts.bind(this),20);
	        }else{
	            setTimeout(function(){this.loaded = true;}.bind(this),0);

	        }
	    };

	    function createHelper(def, fontData){
	        var tHelper = document.createElementNS(svgNS,'text');
	        tHelper.style.fontSize = '100px';
	        tHelper.style.fontFamily = fontData.fFamily;
	        tHelper.textContent = '1';
	        if(fontData.fClass){
	            tHelper.style.fontFamily = 'inherit';
	            tHelper.className = fontData.fClass;
	        } else {
	            tHelper.style.fontFamily = fontData.fFamily;
	        }
	        def.appendChild(tHelper);
	        var tCanvasHelper = document.createElement('canvas').getContext('2d');
	        tCanvasHelper.font = '100px '+ fontData.fFamily;
	        return tCanvasHelper;
	    }

	    function addFonts(fontData, defs){
	        if(!fontData){
	            this.loaded = true;
	            return;
	        }
	        if(this.chars){
	            this.loaded = true;
	            this.fonts = fontData.list;
	            return;
	        }

	        var fontArr = fontData.list;
	        var i, len = fontArr.length;
	        for(i=0; i<len; i+= 1){
	            fontArr[i].loaded = false;
	            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily,'monospace');
	            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily,'sans-serif');
	            if(!fontArr[i].fPath) {
	                fontArr[i].loaded = true;
	            }else if(fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3){
	                var s = document.createElement('style');
	                s.type = "text/css";
	                s.innerHTML = "@font-face {" + "font-family: "+fontArr[i].fFamily+"; font-style: normal; src: url('"+fontArr[i].fPath+"');}";
	                defs.appendChild(s);
	            } else if(fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1){
	                //<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
	                var l = document.createElement('link');
	                l.type = "text/css";
	                l.rel = "stylesheet";
	                l.href = fontArr[i].fPath;
	                defs.appendChild(l);
	            } else if(fontArr[i].fOrigin === 't' || fontArr[i].origin === 2){
	                //<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
	                var sc = document.createElement('script');
	                sc.setAttribute('src',fontArr[i].fPath);
	                defs.appendChild(sc);
	            }
	            fontArr[i].helper = createHelper(defs,fontArr[i]);
	            this.fonts.push(fontArr[i]);
	        }
	        checkLoadedFonts.bind(this)();
	    }

	    function addChars(chars){
	        if(!chars){
	            return;
	        }
	        if(!this.chars){
	            this.chars = [];
	        }
	        var i, len = chars.length;
	        var j, jLen = this.chars.length, found;
	        for(i=0;i<len;i+=1){
	            j = 0;
	            found = false;
	            while(j<jLen){
	                if(this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch){
	                    found = true;
	                }
	                j += 1;
	            }
	            if(!found){
	                this.chars.push(chars[i]);
	                jLen += 1;
	            }
	        }
	    }

	    function getCharData(char, style, font){
	        var i = 0, len = this.chars.length;
	        while( i < len) {
	            if(this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font){
	                return this.chars[i];
	            }
	            i+= 1;
	        }
	    }

	    function measureText(char, fontName, size){
	        var fontData = this.getFontByName(fontName);
	        var tHelper = fontData.helper;
	        //tHelper.textContent = char;
	        return tHelper.measureText(char).width*size/100;
	        //return tHelper.getComputedTextLength()*size/100;
	    }

	    function getFontByName(name){
	        var i = 0, len = this.fonts.length;
	        while(i<len){
	            if(this.fonts[i].fName === name) {
	                return this.fonts[i];
	            }
	            i += 1;
	        }
	        return 'sans-serif';
	    }

	    var Font = function(){
	        this.fonts = [];
	        this.chars = null;
	        this.typekitLoaded = 0;
	        this.loaded = false;
	        this.initTime = Date.now();
	    };
	    Font.prototype.addChars = addChars;
	    Font.prototype.addFonts = addFonts;
	    Font.prototype.getCharData = getCharData;
	    Font.prototype.getFontByName = getFontByName;
	    Font.prototype.measureText = measureText;

	    return Font;

	}());
	var PropertyFactory = (function(){

	    var initFrame = -999999;

	    function interpolateValue(frameNum, iterationIndex, previousValue, caching){
	        var offsetTime = this.offsetTime;
	        var newValue;
	        if(previousValue.constructor === Array) {
	            newValue = Array.apply(null,{length:previousValue.length})
	        }
	        var i = iterationIndex;
	        var len = this.keyframes.length- 1,flag = true;
	        var keyData, nextKeyData;

	        while(flag){
	            keyData = this.keyframes[i];
	            nextKeyData = this.keyframes[i+1];
	            if(i == len-1 && frameNum >= nextKeyData.t - offsetTime){
	                if(keyData.h){
	                    keyData = nextKeyData;
	                }
	                iterationIndex = 0;
	                break;
	            }
	            if((nextKeyData.t - offsetTime) > frameNum){
	                iterationIndex = i;
	                break;
	            }
	            if(i < len - 1){
	                i += 1;
	            }else{
	                iterationIndex = 0;
	                flag = false;
	            }
	        }

	        var k, kLen,perc,jLen, j, fnc;
	        if(keyData.to){

	            if(!keyData.bezierData){
	                bez.buildBezierData(keyData);
	            }
	            var bezierData = keyData.bezierData;
	            if(frameNum >= nextKeyData.t-offsetTime || frameNum < keyData.t-offsetTime){
	                var ind = frameNum >= nextKeyData.t-offsetTime ? bezierData.points.length - 1 : 0;
	                kLen = bezierData.points[ind].point.length;
	                for(k = 0; k < kLen; k += 1){
	                    newValue[k] = bezierData.points[ind].point[k];
	                }
	                caching._lastBezierData = null;
	            }else{
	                if(keyData.__fnct){
	                    fnc = keyData.__fnct;
	                }else{
	                    fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y,keyData.n).get;
	                    keyData.__fnct = fnc;
	                }
	                perc = fnc((frameNum-(keyData.t-offsetTime))/((nextKeyData.t-offsetTime)-(keyData.t-offsetTime)));
	                var distanceInLine = bezierData.segmentLength*perc;

	                var segmentPerc;
	                var addedLength =  (caching.lastFrame < frameNum && caching._lastBezierData === bezierData) ? caching._lastAddedLength : 0;
	                j =  (caching.lastFrame < frameNum && caching._lastBezierData === bezierData) ? caching._lastPoint : 0;
	                flag = true;
	                jLen = bezierData.points.length;
	                while(flag){
	                    addedLength +=bezierData.points[j].partialLength;
	                    if(distanceInLine === 0 || perc === 0 || j == bezierData.points.length - 1){
	                        kLen = bezierData.points[j].point.length;
	                        for(k=0;k<kLen;k+=1){
	                            newValue[k] = bezierData.points[j].point[k];
	                        }
	                        break;
	                    }else if(distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j+1].partialLength){
	                        segmentPerc = (distanceInLine-addedLength)/(bezierData.points[j+1].partialLength);
	                        kLen = bezierData.points[j].point.length;
	                        for(k=0;k<kLen;k+=1){
	                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j+1].point[k] - bezierData.points[j].point[k])*segmentPerc;
	                        }
	                        break;
	                    }
	                    if(j < jLen - 1){
	                        j += 1;
	                    }else{
	                        flag = false;
	                    }
	                }
	                caching._lastPoint = j;
	                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
	                caching._lastBezierData = bezierData;
	            }
	        }else{
	            var outX,outY,inX,inY, keyValue;
	            len = keyData.s.length;
	            for(i=0;i<len;i+=1){
	                if(keyData.h !== 1){
	                    if(frameNum >= nextKeyData.t-offsetTime){
	                        perc = 1;
	                    }else if(frameNum < keyData.t-offsetTime){
	                        perc = 0;
	                    }else{
	                        if(keyData.o.x.constructor === Array){
	                            if(!keyData.__fnct){
	                                keyData.__fnct = [];
	                            }
	                            if (!keyData.__fnct[i]) {
	                                outX = keyData.o.x[i] || keyData.o.x[0];
	                                outY = keyData.o.y[i] || keyData.o.y[0];
	                                inX = keyData.i.x[i] || keyData.i.x[0];
	                                inY = keyData.i.y[i] || keyData.i.y[0];
	                                fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                                keyData.__fnct[i] = fnc;
	                            } else {
	                                fnc = keyData.__fnct[i];
	                            }
	                        } else {
	                            if (!keyData.__fnct) {
	                                outX = keyData.o.x;
	                                outY = keyData.o.y;
	                                inX = keyData.i.x;
	                                inY = keyData.i.y;
	                                fnc = BezierFactory.getBezierEasing(outX,outY,inX,inY).get;
	                                keyData.__fnct = fnc;
	                            } else{
	                                fnc = keyData.__fnct;
	                            }
	                        }
	                        perc = fnc((frameNum-(keyData.t-offsetTime))/((nextKeyData.t-offsetTime)-(keyData.t-offsetTime)));
	                    }
	                }
	                if(this.sh && keyData.h !== 1){
	                    var initP = keyData.s[i];
	                    var endP = keyData.e[i];
	                    if(initP-endP < -180){
	                        initP += 360;
	                    } else if(initP-endP > 180){
	                        initP -= 360;
	                    }
	                    keyValue = initP+(endP-initP)*perc;
	                } else {
	                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i]+(keyData.e[i]-keyData.s[i])*perc;
	                }
	                if(len === 1){
	                    newValue = keyValue;
	                }else{
	                    newValue[i] = keyValue;
	                }
	            }
	        }
	        return {
	            value: newValue,
	            iterationIndex: iterationIndex
	        }
	    }

	    function getValueAtCurrentTime(){
	        if(this.elem.globalData.frameId === this.frameId){
	            return;
	        }
	        this.mdf = false;
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        var initTime = this.keyframes[0].t-this.offsetTime;
	        var endTime = this.keyframes[this.keyframes.length- 1].t-this.offsetTime;
	        if(!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))){
	            var i = this._caching.lastFrame < frameNum ? this._caching.lastIndex : 0;
	            var renderResult = this.interpolateValue(frameNum, i, this.pv, this._caching);
	            this._caching.lastIndex = renderResult.iterationIndex;
	            if(this.pv.constructor === Array){
	                i = 0;
	                while(i<this.v.length){
	                    this.pv[i] = renderResult.value[i];
	                    this.v[i] = this.mult ? this.pv[i] * this.mult : this.pv[i];
	                    if(this.lastPValue[i] !== this.pv[i]) {
	                        this.mdf = true;
	                        this.lastPValue[i] = this.pv[i];
	                    }
	                    i += 1;
	                }
	            } else {
	                this.pv = renderResult.value;
	                this.v = this.mult ? this.pv*this.mult : this.pv;
	                if(this.lastPValue != this.pv){
	                    this.mdf = true;
	                    this.lastPValue = this.pv;
	                }
	            }
	            
	        }
	        this._caching.lastFrame = frameNum;
	        this.frameId = this.elem.globalData.frameId;
	    }

	    function getNoValue(){}

	    function ValueProperty(elem,data, mult){
	        this.mult = mult;
	        this.v = mult ? data.k * mult : data.k;
	        this.pv = data.k;
	        this.mdf = false;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.vel = 0;
	        this.getValue = getNoValue;
	    }

	    function MultiDimensionalProperty(elem,data, mult){
	        this.mult = mult;
	        this.data = data;
	        this.mdf = false;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.frameId = -1;
	        this.v = Array.apply(null, {length:data.k.length});
	        this.pv = Array.apply(null, {length:data.k.length});
	        this.lastValue = Array.apply(null, {length:data.k.length});
	        var arr = Array.apply(null, {length:data.k.length});
	        this.vel = arr.map(function () { return 0 });
	        var i, len = data.k.length;
	        for(i = 0;i<len;i+=1){
	            this.v[i] = mult ? data.k[i] * mult : data.k[i];
	            this.pv[i] = data.k[i];
	        }
	        this.getValue = getNoValue;
	    }

	    function KeyframedValueProperty(elem, data, mult){
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.lastValue = -99999;
	        this.lastPValue = -99999;
	        this.frameId = -1;
	        this._caching={lastFrame:initFrame,lastIndex:0};
	        this.k = true;
	        this.kf = true;
	        this.data = data;
	        this.mult = mult;
	        this.elem = elem;
	        this.comp = elem.comp;
	        this.v = mult ? data.k[0].s[0]*mult : data.k[0].s[0];
	        this.pv = data.k[0].s[0];
	        this.getValue = getValueAtCurrentTime;
	        this.interpolateValue = interpolateValue;
	    }

	    function KeyframedMultidimensionalProperty(elem, data, mult){
	        var i, len = data.k.length;
	        var s, e,to,ti;
	        for(i=0;i<len-1;i+=1){
	            if(data.k[i].to && data.k[i].s && data.k[i].e){
	                s = data.k[i].s;
	                e = data.k[i].e;
	                to = data.k[i].to;
	                ti = data.k[i].ti;
	                if((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0] + to[0],s[1] + to[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0] + ti[0],e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0] + to[0],s[1] + to[1],s[2] + to[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0] + ti[0],e[1] + ti[1],e[2] + ti[2]))){
	                    data.k[i].to = null;
	                    data.k[i].ti = null;
	                }
	            }
	        }
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.k = true;
	        this.kf = true;
	        this.mult = mult;
	        this.elem = elem;
	        this.comp = elem.comp;
	        this._caching={lastFrame:initFrame,lastIndex:0};
	        this.getValue = getValueAtCurrentTime;
	        this.interpolateValue = interpolateValue;
	        this.frameId = -1;
	        this.v = Array.apply(null, {length:data.k[0].s.length});
	        this.pv = Array.apply(null, {length:data.k[0].s.length});
	        this.lastValue = Array.apply(null, {length:data.k[0].s.length});
	        this.lastPValue = Array.apply(null, {length:data.k[0].s.length});
	    }

	    var TransformProperty = (function() {
	        function positionGetter() {
	            if(this.p) {
	                return ExpressionValue(this.p);
	            } else {
	                return [this.px.v, this.py.v, this.pz ? this.pz.v : 0];
	            }
	        }
	        function xPositionGetter() {
	            return ExpressionValue(this.px);
	        }
	        function yPositionGetter() {
	            return ExpressionValue(this.py);
	        }
	        function zPositionGetter() {
	            return ExpressionValue(this.pz);
	        }
	        function anchorGetter() {
	            return ExpressionValue(this.a);
	        }
	        function orientationGetter() {
	            return ExpressionValue(this.or);
	        }
	        function rotationGetter() {
	            if(this.r) {
	                return ExpressionValue(this.r, 1/degToRads);
	            } else {
	                return ExpressionValue(this.rz, 1/degToRads);
	            }
	        }
	        function scaleGetter() {
	            return ExpressionValue(this.s, 100);
	        }
	        function opacityGetter() {
	            return ExpressionValue(this.o, 100);
	        }
	        function skewGetter() {
	            return ExpressionValue(this.sk);
	        }
	        function skewAxisGetter() {
	            return ExpressionValue(this.sa);
	        }
	        function applyToMatrix(mat) {
	            var i, len = this.dynamicProperties.length;
	            for(i = 0; i < len; i += 1) {
	                this.dynamicProperties[i].getValue();
	                if (this.dynamicProperties[i].mdf) {
	                    this.mdf = true;
	                }
	            }
	            if (this.a) {
	                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	            }
	            if (this.s) {
	                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	            }
	            if (this.r) {
	                mat.rotate(-this.r.v);
	            } else {
	                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	            }
	            if (this.data.p.s) {
	                if (this.data.p.z) {
	                    mat.translate(this.px.v, this.py.v, -this.pz.v);
	                } else {
	                    mat.translate(this.px.v, this.py.v, 0);
	                }
	            } else {
	                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
	            }
	        }
	        function processKeys(){
	            if (this.elem.globalData.frameId === this.frameId) {
	                return;
	            }

	            this.mdf = false;
	            var i, len = this.dynamicProperties.length;

	            for(i = 0; i < len; i += 1) {
	                this.dynamicProperties[i].getValue();
	                if (this.dynamicProperties[i].mdf) {
	                    this.mdf = true;
	                }
	            }
	            if (this.mdf) {
	                this.v.reset();
	                if (this.a) {
	                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	                }
	                if(this.s) {
	                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	                }
	                if (this.sk) {
	                    this.v.skewFromAxis(-this.sk.v, this.sa.v);
	                }
	                if (this.r) {
	                    this.v.rotate(-this.r.v);
	                } else {
	                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	                }
	                if (this.autoOriented && this.p.keyframes && this.p.getValueAtTime) {
	                    var v1,v2;
	                    if (this.p._caching.lastFrame+this.p.offsetTime <= this.p.keyframes[0].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / this.elem.globalData.frameRate,0);
	                        v2 = this.p.getValueAtTime(this.p.keyframes[0].t / this.elem.globalData.frameRate, 0);
	                    } else if(this.p._caching.lastFrame+this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / this.elem.globalData.frameRate), 0);
	                        v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.01) / this.elem.globalData.frameRate, 0);
	                    } else {
	                        v1 = this.p.pv;
	                        v2 = this.p.getValueAtTime((this.p._caching.lastFrame+this.p.offsetTime - 0.01) / this.elem.globalData.frameRate, this.p.offsetTime);
	                    }
	                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
	                }
	                if(this.data.p.s){
	                    if(this.data.p.z) {
	                        this.v.translate(this.px.v, this.py.v, -this.pz.v);
	                    } else {
	                        this.v.translate(this.px.v, this.py.v, 0);
	                    }
	                }else{
	                    this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	            }
	            this.frameId = this.elem.globalData.frameId;
	        }

	        function setInverted(){
	            this.inverted = true;
	            this.iv = new Matrix();
	            if(!this.k){
	                if(this.data.p.s){
	                    this.iv.translate(this.px.v,this.py.v,-this.pz.v);
	                }else{
	                    this.iv.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	                if(this.r){
	                    this.iv.rotate(-this.r.v);
	                }else{
	                    this.iv.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	                }
	                if(this.s){
	                    this.iv.scale(this.s.v[0],this.s.v[1],1);
	                }
	                if(this.a){
	                    this.iv.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);
	                }
	            }
	        }

	        function autoOrient(){
	            //
	            //var prevP = this.getValueAtTime();
	        }

	        return function TransformProperty(elem,data,arr){
	            this.elem = elem;
	            this.frameId = -1;
	            this.type = 'transform';
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.data = data;
	            this.getValue = processKeys;
	            this.applyToMatrix = applyToMatrix;
	            this.setInverted = setInverted;
	            this.autoOrient = autoOrient;
	            this.v = new Matrix();
	            if(data.p.s){
	                this.px = PropertyFactory.getProp(elem,data.p.x,0,0,this.dynamicProperties);
	                this.py = PropertyFactory.getProp(elem,data.p.y,0,0,this.dynamicProperties);
	                if(data.p.z){
	                    this.pz = PropertyFactory.getProp(elem,data.p.z,0,0,this.dynamicProperties);
	                }
	            }else{
	                this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            }
	            if(data.r) {
	                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this.dynamicProperties);
	            } else if(data.rx) {
	                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this.dynamicProperties);
	                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this.dynamicProperties);
	                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this.dynamicProperties);
	                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this.dynamicProperties);
	                //sh Indicates it needs to be capped between -180 and 180
	                this.or.sh = true;
	            }
	            if(data.sk){
	                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this.dynamicProperties);
	                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this.dynamicProperties);
	            }
	            if(data.a) {
	                this.a = PropertyFactory.getProp(elem,data.a,1,0,this.dynamicProperties);
	            }
	            if(data.s) {
	                this.s = PropertyFactory.getProp(elem,data.s,1,0.01,this.dynamicProperties);
	            }
	            if(data.o){
	                this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this.dynamicProperties);
	            } else {
	                this.o = {mdf:false,v:1};
	            }
	            if(this.dynamicProperties.length){
	                arr.push(this);
	            }else{
	                if(this.a){
	                    this.v.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);
	                }
	                if(this.s){
	                    this.v.scale(this.s.v[0],this.s.v[1],this.s.v[2]);
	                }
	                if(this.sk){
	                    this.v.skewFromAxis(-this.sk.v,this.sa.v);
	                }
	                if(this.r){
	                    this.v.rotate(-this.r.v);
	                }else{
	                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	                }
	                if(this.data.p.s){
	                    if(data.p.z) {
	                        this.v.translate(this.px.v, this.py.v, -this.pz.v);
	                    } else {
	                        this.v.translate(this.px.v, this.py.v, 0);
	                    }
	                }else{
	                    this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	                }
	            }
	            Object.defineProperty(this, "position", { get: positionGetter});
	            Object.defineProperty(this, "xPosition", { get: xPositionGetter});
	            Object.defineProperty(this, "yPosition", { get: yPositionGetter});
	            Object.defineProperty(this, "orientation", { get: orientationGetter});
	            Object.defineProperty(this, "anchorPoint", { get: anchorGetter});
	            Object.defineProperty(this, "rotation", { get: rotationGetter});
	            Object.defineProperty(this, "scale", { get: scaleGetter});
	            Object.defineProperty(this, "opacity", { get: opacityGetter});
	            Object.defineProperty(this, "skew", { get: skewGetter});
	            Object.defineProperty(this, "skewAxis", { get: skewAxisGetter});
	        }
	    }());

	    function getProp(elem,data,type, mult, arr) {
	        var p;
	        if(type === 2){
	            p = new TransformProperty(elem, data, arr);
	        } else if(data.a === 0){
	            if(type === 0) {
	                p = new ValueProperty(elem,data,mult);
	            } else {
	                p = new MultiDimensionalProperty(elem,data, mult);
	            }
	        } else if(data.a === 1){
	            if(type === 0) {
	                p = new KeyframedValueProperty(elem,data,mult);
	            } else {
	                p = new KeyframedMultidimensionalProperty(elem,data, mult);
	            }
	        } else if(!data.k.length){
	            p = new ValueProperty(elem,data, mult);
	        }else if(typeof(data.k[0]) === 'number'){
	            p = new MultiDimensionalProperty(elem,data, mult);
	        }else{
	            switch(type){
	                case 0:
	                    p = new KeyframedValueProperty(elem,data,mult);
	                    break;
	                case 1:
	                    p = new KeyframedMultidimensionalProperty(elem,data,mult);
	                    break;
	            }
	        }
	        if(p.k){
	            arr.push(p);
	        }
	        return p;
	    }

	    var getGradientProp = (function(){

	        function getValue(forceRender){
	            this.prop.getValue();
	            this.cmdf = false;
	            this.omdf = false;
	            if(this.prop.mdf || forceRender){
	                var i, len = this.data.p*4;
	                var mult, val;
	                for(i=0;i<len;i+=1){
	                    mult = i%4 === 0 ? 100 : 255;
	                    val = Math.round(this.prop.v[i]*mult);
	                    if(this.c[i] !== val){
	                        this.c[i] = val;
	                        this.cmdf = true;
	                    }
	                }
	                if(this.o.length){
	                    len = this.prop.v.length;
	                    for(i=this.data.p*4;i<len;i+=1){
	                        mult = i%2 === 0 ? 100 : 1;
	                        val = i%2 === 0 ?  Math.round(this.prop.v[i]*100):this.prop.v[i];
	                        if(this.o[i-this.data.p*4] !== val){
	                            this.o[i-this.data.p*4] = val;
	                            this.omdf = true;
	                        }
	                    }
	                }
	            }

	        }

	        function gradientProp(elem,data,arr){
	            this.prop = getProp(elem,data.k,1,null,[]);
	            this.data = data;
	            this.k = this.prop.k;
	            this.c = Array.apply(null,{length:data.p*4});
	            var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p*4) : data.k.k.length - data.p*4;
	            this.o = Array.apply(null,{length:cLength});
	            this.cmdf = false;
	            this.omdf = false;
	            this.getValue = getValue;
	            if(this.prop.k){
	                arr.push(this);
	            }
	            this.getValue(true);
	        }

	        return function getGradientProp(elem,data,arr){
	            return new gradientProp(elem,data,arr);
	        }
	    }());




	    var DashProperty = (function(){

	        function processKeys(forceRender){
	            var i = 0, len = this.dataProps.length;

	            if(this.elem.globalData.frameId === this.frameId && !forceRender){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            while(i<len){
	                if(this.dataProps[i].p.mdf){
	                    this.mdf = true;
	                    break;
	                }
	                i+=1;
	            }
	            if(this.mdf || forceRender){
	                if(this.renderer === 'svg') {
	                    this.dasharray = '';
	                }
	                for(i=0;i<len;i+=1){
	                    if(this.dataProps[i].n != 'o'){
	                        if(this.renderer === 'svg') {
	                            this.dasharray += ' ' + this.dataProps[i].p.v;
	                        }else{
	                            this.dasharray[i] = this.dataProps[i].p.v;
	                        }
	                    }else{
	                        this.dashoffset = this.dataProps[i].p.v;
	                    }
	                }
	            }
	        }

	        return function(elem, data,renderer, dynamicProperties){
	            this.elem = elem;
	            this.frameId = -1;
	            this.dataProps = new Array(data.length);
	            this.renderer = renderer;
	            this.mdf = false;
	            this.k = false;
	            if(this.renderer === 'svg'){
	                this.dasharray = '';
	            }else{

	                this.dasharray = new Array(data.length - 1);
	            }
	            this.dashoffset = 0;
	            var i, len = data.length, prop;
	            for(i=0;i<len;i+=1){
	                prop = PropertyFactory.getProp(elem,data[i].v,0, 0, dynamicProperties);
	                this.k = prop.k ? true : this.k;
	                this.dataProps[i] = {n:data[i].n,p:prop};
	            }
	            this.getValue = processKeys;
	            if(this.k){
	                dynamicProperties.push(this);
	            }else{
	                this.getValue(true);
	            }

	        }
	    }());

	    function getDashProp(elem, data,renderer, dynamicProperties) {
	        return new DashProperty(elem, data,renderer, dynamicProperties);
	    };

	    var TextSelectorProp = (function(){
	        var max = Math.max;
	        var min = Math.min;
	        var floor = Math.floor;
	        function updateRange(newCharsFlag){
	            this.mdf = newCharsFlag || false;
	            if(this.dynamicProperties.length){
	                var i, len = this.dynamicProperties.length;
	                for(i=0;i<len;i+=1){
	                    this.dynamicProperties[i].getValue();
	                    if(this.dynamicProperties[i].mdf){
	                        this.mdf = true;
	                    }
	                }
	            }
	            var totalChars = this.elem.textProperty.currentData ? this.elem.textProperty.currentData.l.length : 0;
	            if(newCharsFlag && this.data.r === 2) {
	                this.e.v = totalChars;
	            }
	            var divisor = this.data.r === 2 ? 1 : 100 / totalChars;
	            var o = this.o.v/divisor;
	            var s = this.s.v/divisor + o;
	            var e = (this.e.v/divisor) + o;
	            if(s>e){
	                var _s = s;
	                s = e;
	                e = _s;
	            }
	            this.finalS = s;
	            this.finalE = e;
	        }

	        function getMult(ind){
	            //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
	            var easer = BezierFactory.getBezierEasing(this.ne.v/100,0,1-this.xe.v/100,1).get;
	            var mult = 0;
	            var s = this.finalS;
	            var e = this.finalE;
	            var type = this.data.sh;
	            if(type == 2){
	                if(e === s){
	                    mult = ind >= e ? 1 : 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }
	                mult = easer(mult);
	            }else if(type == 3){
	                if(e === s){
	                    mult = ind >= e ? 0 : 1;
	                }else{
	                    mult = 1 - max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }

	                mult = easer(mult);
	            }else if(type == 4){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                    if(mult<.5){
	                        mult *= 2;
	                    }else{
	                        mult = 1 - 2*(mult-0.5);
	                    }
	                }
	                mult = easer(mult);
	            }else if(type == 5){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    var tot = e - s;
	                    /*ind += 0.5;
	                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    var x = -tot/2+ind;
	                    var a = tot/2;
	                    mult = Math.sqrt(1 - (x*x)/(a*a));
	                }
	                mult = easer(mult);
	            }else if(type == 6){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind)/(e-s)))))/2;
	                    /*
	                     ind = Math.min(Math.max(s,ind),e-1);
	                     mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind-s)/(e-1-s)))))/2;
	                     mult = Math.max(mult,(1/(e-1-s))/(e-1-s));*/
	                }
	                mult = easer(mult);
	            }else {
	                if(ind >= floor(s)){
	                    if(ind-s < 0){
	                        mult = 1 - (s - ind);
	                    }else{
	                        mult = max(0,min(e-ind,1));
	                    }
	                }
	                mult = easer(mult);
	            }
	            return mult*this.a.v;
	        }

	        return function TextSelectorProp(elem,data, arr){
	            this.mdf = false;
	            this.k = false;
	            this.data = data;
	            this.dynamicProperties = [];
	            this.getValue = updateRange;
	            this.getMult = getMult;
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.finalS = 0;
	            this.finalE = 0;
	            this.s = PropertyFactory.getProp(elem,data.s || {k:0},0,0,this.dynamicProperties);
	            if('e' in data){
	                this.e = PropertyFactory.getProp(elem,data.e,0,0,this.dynamicProperties);
	            }else{
	                this.e = {v:100};
	            }
	            this.o = PropertyFactory.getProp(elem,data.o || {k:0},0,0,this.dynamicProperties);
	            this.xe = PropertyFactory.getProp(elem,data.xe || {k:0},0,0,this.dynamicProperties);
	            this.ne = PropertyFactory.getProp(elem,data.ne || {k:0},0,0,this.dynamicProperties);
	            this.a = PropertyFactory.getProp(elem,data.a,0,0.01,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                arr.push(this);
	            }else{
	                this.getValue();
	            }
	        }
	    }());

	    function getTextSelectorProp(elem, data,arr) {
	        return new TextSelectorProp(elem, data, arr);
	    };

	    var ob = {
	        getProp: getProp,
	        getDashProp: getDashProp,
	        getTextSelectorProp: getTextSelectorProp,
	        getGradientProp: getGradientProp
	    };
	    return ob;
	}());
	function ShapePath(){
		this.c = false;
		this._length = 0;
		this._maxLength = 8;
		this.v = Array.apply(null,{length:this._maxLength});
		this.o = Array.apply(null,{length:this._maxLength});
		this.i = Array.apply(null,{length:this._maxLength});
	};

	ShapePath.prototype.setPathData = function(closed, len) {
		this.c = closed;
		this.setLength(len);
		var i = 0;
		while(i < len){
			this.v[i] = point_pool.newPoint();
			this.o[i] = point_pool.newPoint();
			this.i[i] = point_pool.newPoint();
			i += 1;
		}
	};

	ShapePath.prototype.setLength = function(len) {
		while(this._maxLength < len) {
			this.doubleArrayLength();
		}
		this._length = len;
	}

	ShapePath.prototype.doubleArrayLength = function() {
		this.v = this.v.concat(Array.apply(null,{length:this._maxLength}))
		this.i = this.i.concat(Array.apply(null,{length:this._maxLength}))
		this.o = this.o.concat(Array.apply(null,{length:this._maxLength}))
		this._maxLength *= 2;
	};

	ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
		var arr;
		this._length = Math.max(this._length, pos + 1);
		if(this._length >= this._maxLength) {
			this.doubleArrayLength();
		}
		switch(type){
			case 'v':
				arr = this.v;
				break;
			case 'i':
				arr = this.i;
				break;
			case 'o':
				arr = this.o;
				break;
		}
		if(!arr[pos] || (arr[pos] && !replace)){
			arr[pos] = point_pool.newPoint();
		}
		arr[pos][0] = x;
		arr[pos][1] = y;
	};

	ShapePath.prototype.setTripleAt = function(vX,vY,oX,oY,iX,iY,pos, replace) {
		this.setXYAt(vX,vY,'v',pos, replace);
		this.setXYAt(oX,oY,'o',pos, replace);
		this.setXYAt(iX,iY,'i',pos, replace);
	};
	var ShapePropertyFactory = (function(){

	    var initFrame = -999999;

	    function interpolateShape(frameNum, iterationIndex, previousValue, isCurrentRender) {
	        var keyPropS,keyPropE,isHold;
	        if(frameNum < this.keyframes[0].t-this.offsetTime){
	            keyPropS = this.keyframes[0].s[0];
	            isHold = true;
	            iterationIndex = 0;
	        }else if(frameNum >= this.keyframes[this.keyframes.length - 1].t-this.offsetTime){
	            if(this.keyframes[this.keyframes.length - 2].h === 1){
	                keyPropS = this.keyframes[this.keyframes.length - 1].s[0];
	            }else{
	                keyPropS = this.keyframes[this.keyframes.length - 2].e[0];
	            }
	            isHold = true;
	        }else{
	            var i = iterationIndex;
	            var len = this.keyframes.length- 1,flag = true,keyData,nextKeyData, j, jLen, k, kLen;
	            while(flag){
	                keyData = this.keyframes[i];
	                nextKeyData = this.keyframes[i+1];
	                if((nextKeyData.t - this.offsetTime) > frameNum){
	                    break;
	                }
	                if(i < len - 1){
	                    i += 1;
	                }else{
	                    flag = false;
	                }
	            }
	            isHold = keyData.h === 1;
	            iterationIndex = i;

	            var perc;
	            if(!isHold){
	                if(frameNum >= nextKeyData.t-this.offsetTime){
	                    perc = 1;
	                }else if(frameNum < keyData.t-this.offsetTime){
	                    perc = 0;
	                }else{
	                    var fnc;
	                    if(keyData.__fnct){
	                        fnc = keyData.__fnct;
	                    }else{
	                        fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;
	                        keyData.__fnct = fnc;
	                    }
	                    perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
	                }
	                keyPropE = keyData.e[0];
	            }
	            keyPropS = keyData.s[0];
	        }
	        jLen = previousValue._length;
	        kLen = keyPropS.i[0].length;
	        var hasModified = false;
	        var vertexValue;
	        for(j=0;j<jLen;j+=1){
	            for(k=0;k<kLen;k+=1){
	                if(isHold){
	                    vertexValue = keyPropS.i[j][k];
	                    if(previousValue.i[j][k] !== vertexValue){
	                        previousValue.i[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.i[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                    vertexValue = keyPropS.o[j][k];
	                    if(previousValue.o[j][k] !== vertexValue){
	                        previousValue.o[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.o[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                    vertexValue = keyPropS.v[j][k];
	                    if(previousValue.v[j][k] !== vertexValue){
	                        previousValue.v[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.v[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                }else{
	                    vertexValue = keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;
	                    if(previousValue.i[j][k] !== vertexValue){
	                        previousValue.i[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.i[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                    vertexValue = keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;
	                    if(previousValue.o[j][k] !== vertexValue){
	                        previousValue.o[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.o[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                    vertexValue = keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;
	                    if(previousValue.v[j][k] !== vertexValue){
	                        previousValue.v[j][k] = vertexValue;
	                        if(isCurrentRender) {
	                            this.pv.v[j][k] = vertexValue;
	                        }
	                        hasModified = true;
	                    }
	                }
	            }
	        }
	        if(hasModified) {
	            previousValue.c = keyPropS.c;
	        }
	        return {
	            iterationIndex: iterationIndex,
	            hasModified: hasModified
	        }
	    }

	    function interpolateShapeCurrentTime(){
	        if(this.elem.globalData.frameId === this.frameId){
	            return;
	        }
	        this.mdf = false;
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        var initTime = this.keyframes[0].t - this.offsetTime;
	        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
	        if(!(this.lastFrame !== initFrame && ((this.lastFrame < initTime && frameNum < initTime) || (this.lastFrame > endTime && frameNum > endTime)))){
	            ////
	            var i = this.lastFrame < frameNum ? this._lastIndex : 0;
	            var renderResult = this.interpolateShape(frameNum, i, this.v, true);
	            ////
	            this._lastIndex = renderResult.iterationIndex;
	            this.mdf = renderResult.hasModified;
	            if(renderResult.hasModified) {
	                this.paths = this.localShapeCollection;
	            }
	        }
	        this.lastFrame = frameNum;
	        this.frameId = this.elem.globalData.frameId;
	    }

	    function getShapeValue(){
	        return this.v;
	    }

	    function resetShape(){
	        this.paths = this.localShapeCollection;
	        if(!this.k){
	            this.mdf = false;
	        }
	    }

	    function ShapeProperty(elem, data, type){
	        this.__shapeObject = 1;
	        this.comp = elem.comp;
	        this.k = false;
	        this.mdf = false;
	        var pathData = type === 3 ? data.pt.k : data.ks.k;
	        this.v = shape_pool.clone(pathData);
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.reset = resetShape;
	    }
	    ShapeProperty.prototype.interpolateShape = interpolateShape;
	    ShapeProperty.prototype.getValue = getShapeValue;

	    function KeyframedShapeProperty(elem,data,type){
	        this.__shapeObject = 1;
	        this.comp = elem.comp;
	        this.elem = elem;
	        this.offsetTime = elem.data.st;
	        this._lastIndex = 0;
	        this.keyframes = type === 3 ? data.pt.k : data.ks.k;
	        this.k = true;
	        this.kf = true;
	        var i, len = this.keyframes[0].s[0].i.length;
	        var jLen = this.keyframes[0].s[0].i[0].length;
	        this.v = shape_pool.newShape();
	        this.v.setPathData(this.keyframes[0].s[0].c, len);
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.lastFrame = initFrame;
	        this.reset = resetShape;
	    }
	    KeyframedShapeProperty.prototype.getValue = interpolateShapeCurrentTime;
	    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;

	    var EllShapeProperty = (function(){

	        var cPoint = roundCorner;

	        function convertEllToPath(){
	            var p0 = this.p.v[0], p1 = this.p.v[1], s0 = this.s.v[0]/2, s1 = this.s.v[1]/2;
	            if(this.d !== 3){
	                this.v.v[0][0] = p0;
	                this.v.v[0][1] = p1-s1;
	                this.v.v[1][0] = p0 + s0;
	                this.v.v[1][1] = p1;
	                this.v.v[2][0] = p0;
	                this.v.v[2][1] = p1+s1;
	                this.v.v[3][0] = p0 - s0;
	                this.v.v[3][1] = p1;
	                this.v.i[0][0] = p0 - s0*cPoint;
	                this.v.i[0][1] = p1 - s1;
	                this.v.i[1][0] = p0 + s0;
	                this.v.i[1][1] = p1 - s1*cPoint;
	                this.v.i[2][0] = p0 + s0*cPoint;
	                this.v.i[2][1] = p1 + s1;
	                this.v.i[3][0] = p0 - s0;
	                this.v.i[3][1] = p1 + s1*cPoint;
	                this.v.o[0][0] = p0 + s0*cPoint;
	                this.v.o[0][1] = p1 - s1;
	                this.v.o[1][0] = p0 + s0;
	                this.v.o[1][1] = p1 + s1*cPoint;
	                this.v.o[2][0] = p0 - s0*cPoint;
	                this.v.o[2][1] = p1 + s1;
	                this.v.o[3][0] = p0 - s0;
	                this.v.o[3][1] = p1 - s1*cPoint;
	            }else{
	                this.v.v[0][0] = p0;
	                this.v.v[0][1] = p1-s1;
	                this.v.v[1][0] = p0 - s0;
	                this.v.v[1][1] = p1;
	                this.v.v[2][0] = p0;
	                this.v.v[2][1] = p1+s1;
	                this.v.v[3][0] = p0 + s0;
	                this.v.v[3][1] = p1;
	                this.v.i[0][0] = p0 + s0*cPoint;
	                this.v.i[0][1] = p1 - s1;
	                this.v.i[1][0] = p0 - s0;
	                this.v.i[1][1] = p1 - s1*cPoint;
	                this.v.i[2][0] = p0 - s0*cPoint;
	                this.v.i[2][1] = p1 + s1;
	                this.v.i[3][0] = p0 + s0;
	                this.v.i[3][1] = p1 + s1*cPoint;
	                this.v.o[0][0] = p0 - s0*cPoint;
	                this.v.o[0][1] = p1 - s1;
	                this.v.o[1][0] = p0 - s0;
	                this.v.o[1][1] = p1 + s1*cPoint;
	                this.v.o[2][0] = p0 + s0*cPoint;
	                this.v.o[2][1] = p1 + s1;
	                this.v.o[3][0] = p0 + s0;
	                this.v.o[3][1] = p1 - s1*cPoint;
	            }
	        }

	        function processKeys(frameNum){
	            var i, len = this.dynamicProperties.length;
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue(frameNum);
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertEllToPath();
	            }
	        }

	        return function EllShapeProperty(elem,data) {
	            /*this.v = {
	                v: Array.apply(null,{length:4}),
	                i: Array.apply(null,{length:4}),
	                o: Array.apply(null,{length:4}),
	                c: true
	            };*/
	            this.v = shape_pool.newShape();
	            this.v.setPathData(true, 4);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.paths = this.localShapeCollection;
	            this.localShapeCollection.addShape(this.v);
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.convertEllToPath = convertEllToPath;
	            this.reset = resetShape;
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertEllToPath();
	            }
	        }
	    }());

	    var StarShapeProperty = (function() {

	        function convertPolygonToPath(){
	            var numPts = Math.floor(this.pt.v);
	            var angle = Math.PI*2/numPts;
	            /*this.v.v.length = numPts;
	            this.v.i.length = numPts;
	            this.v.o.length = numPts;*/
	            var rad = this.or.v;
	            var roundness = this.os.v;
	            var perimSegment = 2*Math.PI*rad/(numPts*4);
	            var i, currentAng = -Math.PI/ 2;
	            var dir = this.data.d === 3 ? -1 : 1;
	            currentAng += this.r.v;
	            this.v._length = 0;
	            for(i=0;i<numPts;i+=1){
	                var x = rad * Math.cos(currentAng);
	                var y = rad * Math.sin(currentAng);
	                var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                x +=  + this.p.v[0];
	                y +=  + this.p.v[1];
	                this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);
	                /*this.v.v[i] = [x,y];
	                this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];*/
	                currentAng += angle*dir;
	            }
	            this.paths.length = 0;
	            this.paths[0] = this.v;
	        }

	        function convertStarToPath() {
	            var numPts = Math.floor(this.pt.v)*2;
	            var angle = Math.PI*2/numPts;
	            /*this.v.v.length = numPts;
	            this.v.i.length = numPts;
	            this.v.o.length = numPts;*/
	            var longFlag = true;
	            var longRad = this.or.v;
	            var shortRad = this.ir.v;
	            var longRound = this.os.v;
	            var shortRound = this.is.v;
	            var longPerimSegment = 2*Math.PI*longRad/(numPts*2);
	            var shortPerimSegment = 2*Math.PI*shortRad/(numPts*2);
	            var i, rad,roundness,perimSegment, currentAng = -Math.PI/ 2;
	            currentAng += this.r.v;
	            var dir = this.data.d === 3 ? -1 : 1;
	            this.v._length = 0;
	            for(i=0;i<numPts;i+=1){
	                rad = longFlag ? longRad : shortRad;
	                roundness = longFlag ? longRound : shortRound;
	                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
	                var x = rad * Math.cos(currentAng);
	                var y = rad * Math.sin(currentAng);
	                var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                x +=  + this.p.v[0];
	                y +=  + this.p.v[1];
	                this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);

	                /*this.v.v[i] = [x,y];
	                this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
	                this.v._length = numPts;*/
	                longFlag = !longFlag;
	                currentAng += angle*dir;
	            }
	        }

	        function processKeys() {
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            var i, len = this.dynamicProperties.length;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue();
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertToPath();
	            }
	        }

	        return function StarShapeProperty(elem,data) {
	            /*this.v = {
	                v: [],
	                i: [],
	                o: [],
	                c: true
	            };*/
	            this.v = shape_pool.newShape();
	            this.v.setPathData(true, 0);
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.data = data;
	            this.frameId = -1;
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.reset = resetShape;
	            if(data.sy === 1){
	                this.ir = PropertyFactory.getProp(elem,data.ir,0,0,this.dynamicProperties);
	                this.is = PropertyFactory.getProp(elem,data.is,0,0.01,this.dynamicProperties);
	                this.convertToPath = convertStarToPath;
	            } else {
	                this.convertToPath = convertPolygonToPath;
	            }
	            this.pt = PropertyFactory.getProp(elem,data.pt,0,0,this.dynamicProperties);
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.r = PropertyFactory.getProp(elem,data.r,0,degToRads,this.dynamicProperties);
	            this.or = PropertyFactory.getProp(elem,data.or,0,0,this.dynamicProperties);
	            this.os = PropertyFactory.getProp(elem,data.os,0,0.01,this.dynamicProperties);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertToPath();
	            }
	        }
	    }());

	    var RectShapeProperty = (function() {
	        function processKeys(frameNum){
	            if(this.elem.globalData.frameId === this.frameId){
	                return;
	            }
	            this.mdf = false;
	            this.frameId = this.elem.globalData.frameId;
	            var i, len = this.dynamicProperties.length;

	            for(i=0;i<len;i+=1){
	                this.dynamicProperties[i].getValue(frameNum);
	                if(this.dynamicProperties[i].mdf){
	                    this.mdf = true;
	                }
	            }
	            if(this.mdf){
	                this.convertRectToPath();
	            }

	        }

	        function convertRectToPath(){
	            var p0 = this.p.v[0], p1 = this.p.v[1], v0 = this.s.v[0]/2, v1 = this.s.v[1]/2;
	            var round = bm_min(v0,v1,this.r.v);
	            var cPoint = round*(1-roundCorner);
	            this.v._length = 0;

	            if(this.d === 2 || this.d === 1) {
	                this.v.setTripleAt(p0+v0, p1-v1+round,p0+v0, p1-v1+round,p0+v0,p1-v1+cPoint,0, true);
	                this.v.setTripleAt(p0+v0, p1+v1-round,p0+v0, p1+v1-cPoint,p0+v0, p1+v1-round,1, true);
	                if(round!== 0){
	                    this.v.setTripleAt(p0+v0-round, p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2, true);
	                    this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3, true);
	                    this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4, true);
	                    this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5, true);
	                    this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6, true);
	                    this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7, true);
	                } else {
	                    this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);
	                    this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);
	                }
	            }else{
	                this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0, true);
	                if(round!== 0){
	                    this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1, true);
	                    this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2, true);
	                    this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3, true);
	                    this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4, true);
	                    this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5, true);
	                    this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6, true);
	                    this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7, true);
	                } else {
	                    this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1, true);
	                    this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2, true);
	                    this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3, true);

	                }
	            }
	        }

	        return function RectShapeProperty(elem,data) {
	            this.v = shape_pool.newShape();
	            this.v.c = true;
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.d = data.d;
	            this.dynamicProperties = [];
	            this.mdf = false;
	            this.getValue = processKeys;
	            this.convertRectToPath = convertRectToPath;
	            this.reset = resetShape;
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this.dynamicProperties);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this.dynamicProperties);
	            this.r = PropertyFactory.getProp(elem,data.r,0,0,this.dynamicProperties);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.convertRectToPath();
	            }
	        }
	    }());

	    function getShapeProp(elem,data,type, arr){
	        var prop;
	        if(type === 3 || type === 4){
	            var dataProp = type === 3 ? data.pt : data.ks;
	            var keys = dataProp.k;
	            if(dataProp.a === 1 || keys.length){
	                prop = new KeyframedShapeProperty(elem, data, type);
	            }else{
	                prop = new ShapeProperty(elem, data, type);
	            }
	        }else if(type === 5){
	            prop = new RectShapeProperty(elem, data);
	        }else if(type === 6){
	            prop = new EllShapeProperty(elem, data);
	        }else if(type === 7){
	            prop = new StarShapeProperty(elem, data);
	        }
	        if(prop.k){
	            arr.push(prop);
	        }
	        return prop;
	    }

	    function getConstructorFunction() {
	        return ShapeProperty;
	    }

	    function getKeyframedConstructorFunction() {
	        return KeyframedShapeProperty;
	    }

	    var ob = {};
	    ob.getShapeProp = getShapeProp;
	    ob.getConstructorFunction = getConstructorFunction;
	    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
	    return ob;
	}());
	var ShapeModifiers = (function(){
	    var ob = {};
	    var modifiers = {};
	    ob.registerModifier = registerModifier;
	    ob.getModifier = getModifier;

	    function registerModifier(nm,factory){
	        if(!modifiers[nm]){
	            modifiers[nm] = factory;
	        }
	    }

	    function getModifier(nm,elem, data, dynamicProperties){
	        return new modifiers[nm](elem, data, dynamicProperties);
	    }

	    return ob;
	}());

	function ShapeModifier(){}
	ShapeModifier.prototype.initModifierProperties = function(){};
	ShapeModifier.prototype.addShapeToModifier = function(){};
	ShapeModifier.prototype.addShape = function(data){
	    if(!this.closed){
	        this.shapes.push({shape:data.sh, data: data, localShapeCollection:shapeCollection_pool.newShapeCollection()});
	        this.addShapeToModifier(data.sh);
	    }
	}
	ShapeModifier.prototype.init = function(elem,data,dynamicProperties){
	    this.elem = elem;
	    this.frameId = -1;
	    this.shapes = [];
	    this.dynamicProperties = [];
	    this.mdf = false;
	    this.closed = false;
	    this.k = false;
	    this.comp = elem.comp;
	    this.initModifierProperties(elem,data);
	    if(this.dynamicProperties.length){
	        this.k = true;
	        dynamicProperties.push(this);
	    }else{
	        this.getValue(true);
	    }
	}
	function TrimModifier(){};
	extendPrototype(ShapeModifier,TrimModifier);
	TrimModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    this.frameId = this.elem.globalData.frameId;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	    if(this.mdf || forceRender){
	        var o = (this.o.v%360)/360;
	        if(o < 0){
	            o += 1;
	        }
	        var s = this.s.v + o;
	        var e = this.e.v + o;
	        if(s == e){

	        }
	        if(s>e){
	            var _s = s;
	            s = e;
	            e = _s;
	        }
	        this.sValue = s;
	        this.eValue = e;
	        this.oValue = o;
	    }
	}
	TrimModifier.prototype.initModifierProperties = function(elem,data){
	    this.sValue = 0;
	    this.eValue = 0;
	    this.oValue = 0;
	    this.getValue = this.processKeys;
	    this.s = PropertyFactory.getProp(elem,data.s,0,0.01,this.dynamicProperties);
	    this.e = PropertyFactory.getProp(elem,data.e,0,0.01,this.dynamicProperties);
	    this.o = PropertyFactory.getProp(elem,data.o,0,0,this.dynamicProperties);
	    this.m = data.m;
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	};

	TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
	    var segments = []
	    if(e <= 1){
	        segments.push({
	            s: s,
	            e: e
	        })
	    }else if(s >= 1){
	        segments.push({
	            s: s - 1,
	            e: e - 1
	        })
	    }else{
	        segments.push({
	            s: s,
	            e: 1
	        })
	        segments.push({
	            s: 0,
	            e: e - 1
	        })
	    }
	    var shapeSegments = [];
	    var i, len = segments.length, segmentOb;
	    for(i = 0; i < len; i += 1) {
	        segmentOb = segments[i];
	        if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) {
	            
	        } else {
	            var shapeS, shapeE;
	            if(segmentOb.s * totalModifierLength <= addedLength) {
	                shapeS = 0;
	            } else {
	                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
	            }
	            if(segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
	                shapeE = 1;
	            } else {
	                shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
	            }
	            shapeSegments.push([shapeS, shapeE]);
	        }
	    }
	    if(!shapeSegments.length){
	        shapeSegments.push([0,0]);
	    }
	    return shapeSegments;
	}

	TrimModifier.prototype.processShapes = function(firstFrame){
	    var shapePaths;
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var s = this.sValue;
	    var e = this.eValue;
	    var pathsData,pathData, totalShapeLength, totalModifierLength = 0;

	    if(e === s){
	        for(i=0;i<len;i+=1){
	            this.shapes[i].localShapeCollection.releaseShapes();
	            this.shapes[i].shape.mdf = true;
	            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
	        }
	    } else if(!((e === 1 && s === 0) || (e===0 && s === 1))){
	        var segments = [], shapeData, localShapeCollection;
	        for(i=0;i<len;i+=1){
	            shapeData = this.shapes[i];
	            if(!shapeData.shape.mdf && !this.mdf && !firstFrame && this.m !== 2){
	                shapeData.shape.paths = shapeData.localShapeCollection;
	            } else {
	                shapePaths = shapeData.shape.paths;
	                jLen = shapePaths._length;
	                totalShapeLength = 0;
	                if(!shapeData.shape.mdf && shapeData.pathsData){
	                    totalShapeLength = shapeData.totalShapeLength;
	                } else {
	                    pathsData = [];
	                    for(j=0;j<jLen;j+=1){
	                        pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
	                        pathsData.push(pathData);
	                        totalShapeLength += pathData.totalLength;
	                    }
	                    shapeData.totalShapeLength = totalShapeLength;
	                    shapeData.pathsData = pathsData;
	                }

	                totalModifierLength += totalShapeLength;
	                shapeData.shape.mdf = true;
	            }
	        }
	        var shapeS = s, shapeE = e, addedLength = 0;
	        var j, jLen;
	        for(i = len - 1; i >= 0; i -= 1){
	            shapeData = this.shapes[i];
	            if (shapeData.shape.mdf) {
	                localShapeCollection = shapeData.localShapeCollection;
	                localShapeCollection.releaseShapes();
	                if(this.m === 2 && len > 1) {
	                    var edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
	                    addedLength += shapeData.totalShapeLength;
	                } else {
	                    edges = [[shapeS, shapeE]]
	                }
	                jLen = edges.length;
	                for (j = 0; j < jLen; j += 1) {
	                    shapeS = edges[j][0];
	                    shapeE = edges[j][1];
	                    segments.length = 0;
	                    if(shapeE <= 1){
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength * shapeE
	                        })
	                    }else if(shapeS >= 1){
	                        segments.push({
	                            s:shapeData.totalShapeLength * (shapeS - 1),
	                            e:shapeData.totalShapeLength * (shapeE - 1)
	                        })
	                    }else{
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength
	                        })
	                        segments.push({
	                            s:0,
	                            e:shapeData.totalShapeLength*(shapeE - 1)
	                        })
	                    }
	                    var newShapesData = this.addShapes(shapeData,segments[0]);
	                    if (segments[0].s !== segments[0].e) {
	                        var lastPos;
	                        if(segments.length > 1){
	                            if(shapeData.shape.v.c){
	                                var lastShape = newShapesData.pop();
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData,segments[1], lastShape);
	                            } else {
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData,segments[1]);
	                            }
	                        } 
	                        this.addPaths(newShapesData, localShapeCollection);
	                    }
	                    
	                }
	                shapeData.shape.paths = localShapeCollection;
	            }
	        }
	    } else if(this.mdf){
	        for(i=0;i<len;i+=1){
	            this.shapes[i].shape.mdf = true;
	        }
	    }
	    if(!this.dynamicProperties.length){
	        this.mdf = false;
	    }
	}

	TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
	    var i, len = newPaths.length;
	    for(i = 0; i < len; i += 1) {
	        localShapeCollection.addShape(newPaths[i])
	    }
	}

	TrimModifier.prototype.addSegment = function(pt1,pt2,pt3,pt4,shapePath,pos, newShape) {
	    /*console.log(pt1, 'vertex: v, at: ', pos);
	    console.log(pt2, 'vertex: o, at: ', pos);
	    console.log(pt3, 'vertex: i, at: ', pos + 1);
	    console.log(pt4, 'vertex: v, at: ', pos + 1);
	    console.log('newShape: ', newShape);*/
	    shapePath.setXYAt(pt2[0],pt2[1],'o',pos);
	    shapePath.setXYAt(pt3[0],pt3[1],'i',pos + 1);
	    if(newShape){
	        shapePath.setXYAt(pt1[0],pt1[1],'v',pos);
	    }
	    shapePath.setXYAt(pt4[0],pt4[1],'v',pos + 1);
	}

	TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath){
	    var pathsData = shapeData.pathsData;
	    var shapePaths = shapeData.shape.paths.shapes;
	    var i, len = shapeData.shape.paths._length, j, jLen;
	    var addedLength = 0;
	    var currentLengthData,segmentCount;
	    var lengths;
	    var segment;
	    var shapes = [];
	    var initPos;
	    var newShape = true;
	    if(!shapePath){
	        shapePath = shape_pool.newShape();
	        segmentCount = 0;
	        initPos = 0;
	    } else {
	        segmentCount = shapePath._length;
	        initPos = shapePath._length;
	    }
	    shapes.push(shapePath);
	    for(i=0;i<len;i+=1){
	        lengths = pathsData[i].lengths;
	        shapePath.c = shapePaths[i].c;
	        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
	        for(j=1;j<jLen;j+=1){
	            currentLengthData = lengths[j-1];
	            if(addedLength + currentLengthData.addedLength < shapeSegment.s){
	                addedLength += currentLengthData.addedLength;
	                shapePath.c = false;
	            } else if(addedLength > shapeSegment.e){
	                shapePath.c = false;
	                break;
	            } else {
	                if(shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength){
	                    this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[j],shapePaths[i].v[j],shapePath,segmentCount,newShape);
	                    newShape = false;
	                } else {
	                    segment = bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[j],shapePaths[i].o[j-1],shapePaths[i].i[j], (shapeSegment.s - addedLength)/currentLengthData.addedLength,(shapeSegment.e - addedLength)/currentLengthData.addedLength, lengths[j-1]);
	                    this.addSegment(segment.pt1,segment.pt3,segment.pt4,segment.pt2,shapePath,segmentCount,newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	                addedLength += currentLengthData.addedLength;
	                segmentCount += 1;
	            }
	        }
	        if(shapePaths[i].c){
	            currentLengthData = lengths[j-1];
	            if(addedLength <= shapeSegment.e){
	                var segmentLength = lengths[j-1].addedLength;
	                if(shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength){
	                    this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[0],shapePaths[i].v[0],shapePath,segmentCount,newShape);
	                    newShape = false;
	                }else{
	                    segment = bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[0],shapePaths[i].o[j-1],shapePaths[i].i[0], (shapeSegment.s - addedLength)/segmentLength,(shapeSegment.e - addedLength)/segmentLength, lengths[j-1]);
	                    this.addSegment(segment.pt1,segment.pt3,segment.pt4,segment.pt2,shapePath,segmentCount,newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	            } else {
	                shapePath.c = false;
	            }
	            addedLength += currentLengthData.addedLength;
	            segmentCount += 1;
	        }
	        if(shapePath._length){
	            shapePath.setXYAt(shapePath.v[initPos][0],shapePath.v[initPos][1],'i',initPos);
	            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0],shapePath.v[shapePath._length - 1][1],'o',shapePath._length - 1);
	        }
	        if(addedLength > shapeSegment.e){
	            break;
	        }
	        if(i<len-1){
	            shapePath = shape_pool.newShape();
	            newShape = true;
	            shapes.push(shapePath);
	            segmentCount = 0;
	        }
	    }
	    return shapes;

	}


	ShapeModifiers.registerModifier('tm',TrimModifier);
	function RoundCornersModifier(){};
	extendPrototype(ShapeModifier,RoundCornersModifier);
	RoundCornersModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    this.frameId = this.elem.globalData.frameId;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	}
	RoundCornersModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.rd = PropertyFactory.getProp(elem,data.r,0,null,this.dynamicProperties);
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	};

	RoundCornersModifier.prototype.processPath = function(path, round){
	    var cloned_path = shape_pool.newShape();
	    cloned_path.c = path.c;
	    var i, len = path._length;
	    var currentV,currentI,currentO,closerV, newV,newO,newI,distance,newPosPerc,index = 0;
	    var vX,vY,oX,oY,iX,iY;
	    for(i=0;i<len;i+=1){
	        currentV = path.v[i];
	        currentO = path.o[i];
	        currentI = path.i[i];
	        if(currentV[0]===currentO[0] && currentV[1]===currentO[1] && currentV[0]===currentI[0] && currentV[1]===currentI[1]){
	            if((i===0 || i === len - 1) && !path.c){
	                cloned_path.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);
	                /*cloned_path.v[index] = currentV;
	                cloned_path.o[index] = currentO;
	                cloned_path.i[index] = currentI;*/
	                index += 1;
	            } else {
	                if(i===0){
	                    closerV = path.v[len-1];
	                } else {
	                    closerV = path.v[i-1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = iX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = iY = currentV[1]-(currentV[1]-closerV[1])*newPosPerc;
	                oX = vX-(vX-currentV[0])*roundCorner;
	                oY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
	                index += 1;

	                if(i === len - 1){
	                    closerV = path.v[0];
	                } else {
	                    closerV = path.v[i+1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = oX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = oY = currentV[1]+(closerV[1]-currentV[1])*newPosPerc;
	                iX = vX-(vX-currentV[0])*roundCorner;
	                iY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
	                index += 1;
	            }
	        } else {
	            cloned_path.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);
	            index += 1;
	        }
	    }
	    return cloned_path;
	}

	RoundCornersModifier.prototype.processShapes = function(firstFrame){
	    var shapePaths;
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var rd = this.rd.v;

	    if(rd !== 0){
	        var shapeData, newPaths, localShapeCollection;
	        for(i=0;i<len;i+=1){
	            shapeData = this.shapes[i];
	            newPaths = shapeData.shape.paths;
	            localShapeCollection = shapeData.localShapeCollection;
	            if(!(!shapeData.shape.mdf && !this.mdf && !firstFrame)){
	                localShapeCollection.releaseShapes();
	                shapeData.shape.mdf = true;
	                shapePaths = shapeData.shape.paths.shapes;
	                jLen = shapeData.shape.paths._length;
	                for(j=0;j<jLen;j+=1){
	                    localShapeCollection.addShape(this.processPath(shapePaths[j],rd));
	                }
	            }
	            shapeData.shape.paths = shapeData.localShapeCollection;
	        }

	    }
	    if(!this.dynamicProperties.length){
	        this.mdf = false;
	    }
	}


	ShapeModifiers.registerModifier('rd',RoundCornersModifier);
	function RepeaterModifier(){};
	RepeaterModifier.prototype.processKeys = function(forceRender){
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.mdf = forceRender ? true : false;
	    var i, len = this.dynamicProperties.length;

	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        if(this.dynamicProperties[i].mdf){
	            this.mdf = true;
	        }
	    }
	};

	RepeaterModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.c = PropertyFactory.getProp(elem,data.c,0,null,this.dynamicProperties);
	    this.o = PropertyFactory.getProp(elem,data.o,0,null,this.dynamicProperties);
	    this.tr = PropertyFactory.getProp(elem,data.tr,2,null,this.dynamicProperties);
	    this.data = data;
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	    this.pMatrix = new Matrix();
	    this.rMatrix = new Matrix();
	    this.sMatrix = new Matrix();
	    this.tMatrix = new Matrix();
	    this.matrix = new Matrix();
	};

	RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv){
	    var dir = inv ? -1 : 1;
	    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
	    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
	    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
	    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    rMatrix.rotate(-transform.r.v * dir * perc);
	    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    sMatrix.scale(inv ? 1/scaleX : scaleX, inv ? 1/scaleY : scaleY);
	    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	}

	RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData, dynamicProperties) {
	    this.elem = elem;
	    this.arr = arr;
	    this.pos = pos;
	    this.elemsData = elemsData;
	    this._currentCopies = 0;
	    this._elements = [];
	    this._groups = [];
	    this.dynamicProperties = [];
	    this.frameId = -1;
	    this.initModifierProperties(elem,arr[pos]);
	    var cont = 0;
	    while(pos>0){
	        pos -= 1;
	        //this._elements.unshift(arr.splice(pos,1)[0]);
	        this._elements.unshift(arr[pos]);
	        cont += 1;
	    }
	    if(this.dynamicProperties.length){
	        this.k = true;
	        dynamicProperties.push(this);
	    }else{
	        this.getValue(true);
	    }
	}

	RepeaterModifier.prototype.resetElements = function(elements){
	    var i, len = elements.length;
	    for(i = 0; i < len; i += 1) {
	        elements[i]._processed = false;
	        if(elements[i].ty === 'gr'){
	            this.resetElements(elements[i].it);
	        }
	    }
	}

	RepeaterModifier.prototype.cloneElements = function(elements){
	    var i, len = elements.length;
	    var newElements = JSON.parse(JSON.stringify(elements));
	    this.resetElements(newElements);
	    return newElements;
	}

	RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
	    var i, len = elements.length;
	    for(i = 0; i < len ; i += 1) {
	        elements[i]._render = renderFlag;
	        if(elements[i].ty === 'gr') {
	            this.changeGroupRender(elements[i].it, renderFlag);
	        }
	    }
	}

	RepeaterModifier.prototype.processShapes = function(firstFrame){

	    if(this.elem.globalData.frameId === this.frameId){
	        return;
	    }
	    this.frameId = this.elem.globalData.frameId;
	    if(!this.dynamicProperties.length && !firstFrame){
	        this.mdf = false;
	    }
	    if(this.mdf){
	        var copies = Math.ceil(this.c.v);
	        if(this._groups.length < copies){
	            while(this._groups.length < copies){
	                var group = {
	                    it:this.cloneElements(this._elements),
	                    ty:'gr'
	                }
	                group.it.push({"a":{"a":0,"ix":1,"k":[0,0]},"nm":"Transform","o":{"a":0,"ix":7,"k":100},"p":{"a":0,"ix":2,"k":[0,0]},"r":{"a":0,"ix":6,"k":0},"s":{"a":0,"ix":3,"k":[100,100]},"sa":{"a":0,"ix":5,"k":0},"sk":{"a":0,"ix":4,"k":0},"ty":"tr"});
	                
	                this.arr.splice(0,0,group);
	                this._groups.splice(0,0,group);
	                this._currentCopies += 1;
	            }
	            this.elem.reloadShapes();
	        }
	        var i, cont = 0, renderFlag;
	        for(i = 0; i  <= this._groups.length - 1; i += 1){
	            renderFlag = cont < copies;
	            this._groups[i]._render = renderFlag;
	            this.changeGroupRender(this._groups[i].it, renderFlag);
	            cont += 1;
	        }
	        
	        this._currentCopies = copies;
	        this.elem.firstFrame = true;
	        ////

	        var offset = this.o.v;
	        var offsetModulo = offset%1;
	        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
	        var k;
	        var tMat = this.tr.v.props;
	        var pProps = this.pMatrix.props;
	        var rProps = this.rMatrix.props;
	        var sProps = this.sMatrix.props;
	        this.pMatrix.reset();
	        this.rMatrix.reset();
	        this.sMatrix.reset();
	        this.tMatrix.reset();
	        this.matrix.reset();
	        var iteration = 0;

	        if(offset > 0) {
	            while(iteration<roundOffset){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                iteration += 1;
	            }
	            if(offsetModulo){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
	                iteration += offsetModulo;
	            }
	        } else if(offset < 0) {
	            while(iteration>roundOffset){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
	                iteration -= 1;
	            }
	            if(offsetModulo){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, - offsetModulo, true);
	                iteration -= offsetModulo;
	            }
	        }
	        i = this.data.m === 1 ? 0 : this._currentCopies - 1;
	        var dir = this.data.m === 1 ? 1 : -1;
	        cont = this._currentCopies;
	        while(cont){
	            if(iteration !== 0){
	                if((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                }
	                this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);
	                this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);
	                this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);
	                var items = this.elemsData[i].it;
	                var itemsTransform = items[items.length - 1].transform.mProps.v.props;
	                var j, jLen = itemsTransform.length;
	                for(j=0;j<jLen;j+=1) {
	                    itemsTransform[j] = this.matrix.props[j];
	                }
	                this.matrix.reset();
	            } else {
	                this.matrix.reset();
	                var items = this.elemsData[i].it;
	                var itemsTransform = items[items.length - 1].transform.mProps.v.props;
	                var j, jLen = itemsTransform.length;
	                for(j=0;j<jLen;j+=1) {
	                    itemsTransform[j] = this.matrix.props[j];
	                }
	            }
	            iteration += 1;
	            cont -= 1;
	            i += dir;
	        }
	    }
	}

	RepeaterModifier.prototype.addShape = function(){}

	ShapeModifiers.registerModifier('rp',RepeaterModifier);
	function ShapeCollection(){
		this._length = 0;
		this._maxLength = 4;
		this.shapes = Array.apply(null,{length:this._maxLength});
	};

	ShapeCollection.prototype.addShape = function(shapeData){
		if(this._length === this._maxLength){
			this.shapes = this.shapes.concat(Array.apply(null,{length:this._maxLength}));
			this._maxLength *= 2;
		}
		this.shapes[this._length] = shapeData;
		this._length += 1;
	};

	ShapeCollection.prototype.releaseShapes = function(){
		var i;
		for(i = 0; i < this._length; i += 1) {
			shape_pool.release(this.shapes[i]);
		}
		this._length = 0;
	};
	var ImagePreloader = (function(){

	    var imagesLoadedCb;

	    function imageLoaded(){
	        this.loadedAssets += 1;
	        if(this.loadedAssets === this.totalImages){
	            if(imagesLoadedCb) {
	                imagesLoadedCb(null);
	            }
	        }
	    }

	    function getAssetsPath(assetData){
	        var path = '';
	        if(this.assetsPath){
	            var imagePath = assetData.p;
	            if(imagePath.indexOf('images/') !== -1){
	                imagePath = imagePath.split('/')[1];
	            }
	            path = this.assetsPath + imagePath;
	        } else {
	            path = this.path;
	            path += assetData.u ? assetData.u : '';
	            path += assetData.p;
	        }
	        return path;
	    }

	    function loadImage(path){
	        var img = document.createElement('img');
	        img.addEventListener('load', imageLoaded.bind(this), false);
	        img.addEventListener('error', imageLoaded.bind(this), false);
	        img.src = path;
	    }
	    function loadAssets(assets, cb){
	        imagesLoadedCb = cb;
	        this.totalAssets = assets.length;
	        var i;
	        for(i=0;i<this.totalAssets;i+=1){
	            if(!assets[i].layers){
	                loadImage.bind(this)(getAssetsPath.bind(this)(assets[i]));
	                this.totalImages += 1;
	            }
	        }
	    }

	    function setPath(path){
	        this.path = path || '';
	    }

	    function setAssetsPath(path){
	        this.assetsPath = path || '';
	    }

	    return function ImagePreloader(){
	        this.loadAssets = loadAssets;
	        this.setAssetsPath = setAssetsPath;
	        this.setPath = setPath;
	        this.assetsPath = '';
	        this.path = '';
	        this.totalAssets = 0;
	        this.totalImages = 0;
	        this.loadedAssets = 0;
	    }
	}());
	var featureSupport = (function(){
		var ob = {
			maskType: true
		}
		if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
		   ob.maskType = false;
		}
		return ob;
	}());
	var filtersFactory = (function(){
		var ob = {};
		ob.createFilter = createFilter;
		ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

		function createFilter(filId){
	        	var fil = document.createElementNS(svgNS,'filter');
	        	fil.setAttribute('id',filId);
	                fil.setAttribute('filterUnits','objectBoundingBox');
	                fil.setAttribute('x','0%');
	                fil.setAttribute('y','0%');
	                fil.setAttribute('width','100%');
	                fil.setAttribute('height','100%');
	                return fil;
		}

		function createAlphaToLuminanceFilter(){
	                var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	                feColorMatrix.setAttribute('type','matrix');
	                feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	                feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
	                return feColorMatrix;
		}

		return ob;
	}())
	function TextAnimatorProperty(textData, renderType, elem){
	    this.mdf = false;
	    this._firstFrame = true;
		this._hasMaskedPath = false;
		this._frameId = -1;
		this._dynamicProperties = [];
		this._textData = textData;
		this._renderType = renderType;
		this._elem = elem;
		this._animatorsData = Array.apply(null,{length:this._textData.a.length});
		this._pathData = {}
		this._moreOptions = {
			alignment: {}
		};
		this.renderedLetters = [];
	    this.lettersChangedFlag = false;

	}

	TextAnimatorProperty.prototype.searchProperties = function(dynamicProperties){
	    var i, len = this._textData.a.length, animatorData, animatorProps;
	    var getProp = PropertyFactory.getProp;
	    for(i=0;i<len;i+=1){
	        animatorProps = this._textData.a[i];
	        animatorData = {
	            a: {},
	            s: {}
	        };
	        if('r' in animatorProps.a) {
	            animatorData.a.r = getProp(this._elem,animatorProps.a.r,0,degToRads,this._dynamicProperties);
	        }
	        if('rx' in animatorProps.a) {
	            animatorData.a.rx = getProp(this._elem,animatorProps.a.rx,0,degToRads,this._dynamicProperties);
	        }
	        if('ry' in animatorProps.a) {
	            animatorData.a.ry = getProp(this._elem,animatorProps.a.ry,0,degToRads,this._dynamicProperties);
	        }
	        if('sk' in animatorProps.a) {
	            animatorData.a.sk = getProp(this._elem,animatorProps.a.sk,0,degToRads,this._dynamicProperties);
	        }
	        if('sa' in animatorProps.a) {
	            animatorData.a.sa = getProp(this._elem,animatorProps.a.sa,0,degToRads,this._dynamicProperties);
	        }
	        if('s' in animatorProps.a) {
	            animatorData.a.s = getProp(this._elem,animatorProps.a.s,1,0.01,this._dynamicProperties);
	        }
	        if('a' in animatorProps.a) {
	            animatorData.a.a = getProp(this._elem,animatorProps.a.a,1,0,this._dynamicProperties);
	        }
	        if('o' in animatorProps.a) {
	            animatorData.a.o = getProp(this._elem,animatorProps.a.o,0,0.01,this._dynamicProperties);
	        }
	        if('p' in animatorProps.a) {
	            animatorData.a.p = getProp(this._elem,animatorProps.a.p,1,0,this._dynamicProperties);
	        }
	        if('sw' in animatorProps.a) {
	            animatorData.a.sw = getProp(this._elem,animatorProps.a.sw,0,0,this._dynamicProperties);
	        }
	        if('sc' in animatorProps.a) {
	            animatorData.a.sc = getProp(this._elem,animatorProps.a.sc,1,0,this._dynamicProperties);
	        }
	        if('fc' in animatorProps.a) {
	            animatorData.a.fc = getProp(this._elem,animatorProps.a.fc,1,0,this._dynamicProperties);
	        }
	        if('fh' in animatorProps.a) {
	            animatorData.a.fh = getProp(this._elem,animatorProps.a.fh,0,0,this._dynamicProperties);
	        }
	        if('fs' in animatorProps.a) {
	            animatorData.a.fs = getProp(this._elem,animatorProps.a.fs,0,0.01,this._dynamicProperties);
	        }
	        if('fb' in animatorProps.a) {
	            animatorData.a.fb = getProp(this._elem,animatorProps.a.fb,0,0.01,this._dynamicProperties);
	        }
	        if('t' in animatorProps.a) {
	            animatorData.a.t = getProp(this._elem,animatorProps.a.t,0,0,this._dynamicProperties);
	        }
	        animatorData.s = PropertyFactory.getTextSelectorProp(this._elem,animatorProps.s,this._dynamicProperties);
	        animatorData.s.t = animatorProps.s.t;
	        this._animatorsData[i] = animatorData;
	    }
	    if(this._textData.p && 'm' in this._textData.p){
	        this._pathData = {
	            f: getProp(this._elem,this._textData.p.f,0,0,this._dynamicProperties),
	            l: getProp(this._elem,this._textData.p.l,0,0,this._dynamicProperties),
	            r: this._textData.p.r,
	            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
	        };
	        this._hasMaskedPath = true;
	    } else {
	        this._hasMaskedPath = false;
	    }
	    this._moreOptions.alignment = getProp(this._elem,this._textData.m.a,1,0,this._dynamicProperties);
	    if(this._dynamicProperties.length) {
	    	dynamicProperties.push(this);
	    }
	}

	TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag){
	    this.lettersChangedFlag = lettersChangedFlag;
	    if(!this.mdf && !this._firstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m.mdf)) {
	        return;
	    }
	    this._firstFrame = false;
	    var alignment = this._moreOptions.alignment.v;
	    var animators = this._animatorsData;
	    var textData = this._textData;
	    var matrixHelper = this.mHelper;
	    var renderType = this._renderType;
	    var renderedLettersCount = this.renderedLetters.length;
	    var data = this.data;
	    var xPos,yPos;
	    var i, len;
	    var letters = documentData.l;
	    if(this._hasMaskedPath) {
	        var mask = this._pathData.m;
	        if(!this._pathData.n || this._pathData.mdf){
	            var paths = mask.v;
	            if(this._pathData.r){
	                paths = reversePath(paths);
	            }
	            var pathInfo = {
	                tLength: 0,
	                segments: []
	            };
	            len = paths._length - 1;
	            var pathData;
	            var totalLength = 0;
	            for (i = 0; i < len; i += 1) {
	                pathData = {
	                    s: paths.v[i],
	                    e: paths.v[i + 1],
	                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	                    ti: [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]
	                };
	                bez.buildBezierData(pathData);
	                pathInfo.tLength += pathData.bezierData.segmentLength;
	                pathInfo.segments.push(pathData);
	                totalLength += pathData.bezierData.segmentLength;
	            }
	            i = len;
	            if (mask.v.c) {
	                pathData = {
	                    s: paths.v[i],
	                    e: paths.v[0],
	                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	                    ti: [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]
	                };
	                bez.buildBezierData(pathData);
	                pathInfo.tLength += pathData.bezierData.segmentLength;
	                pathInfo.segments.push(pathData);
	                totalLength += pathData.bezierData.segmentLength;
	            }
	            this._pathData.pi = pathInfo;
	        }
	        var pathInfo = this._pathData.pi;

	        var currentLength = this._pathData.f.v, segmentInd = 0, pointInd = 1, currentPoint, prevPoint, points;
	        var segmentLength = 0, flag = true;
	        var segments = pathInfo.segments;
	        if (currentLength < 0 && mask.v.c) {
	            if (pathInfo.tLength < Math.abs(currentLength)) {
	                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
	            }
	            segmentInd = segments.length - 1;
	            points = segments[segmentInd].bezierData.points;
	            pointInd = points.length - 1;
	            while (currentLength < 0) {
	                currentLength += points[pointInd].partialLength;
	                pointInd -= 1;
	                if (pointInd < 0) {
	                    segmentInd -= 1;
	                    points = segments[segmentInd].bezierData.points;
	                    pointInd = points.length - 1;
	                }
	            }

	        }
	        points = segments[segmentInd].bezierData.points;
	        prevPoint = points[pointInd - 1];
	        currentPoint = points[pointInd];
	        var partialLength = currentPoint.partialLength;
	        var perc, tanAngle;
	    }


	    len = letters.length;
	    xPos = 0;
	    yPos = 0;
	    var yOff = documentData.s*1.2*.714;
	    var firstLine = true;
	    var animatorProps, animatorSelector;
	    var j, jLen;
	    var letterValue;

	    jLen = animators.length;
	    if (lettersChangedFlag) {
	        for (j = 0; j < jLen; j += 1) {
	            animatorSelector = animators[j].s;
	            animatorSelector.getValue(true);
	        }
	    }
	    var lastLetter;

	    var mult, ind = -1, offf, xPathPos, yPathPos;
	    var initPathPos = currentLength,initSegmentInd = segmentInd, initPointInd = pointInd, currentLine = -1;
	    var elemOpacity;
	    var sc,sw,fc,k;
	    var lineLength = 0;
	    var letterSw,letterSc,letterFc,letterM = '',letterP = this.defaultPropsArray,letterO;
	    for( i = 0; i < len; i += 1) {
	        matrixHelper.reset();
	        elemOpacity = 1;
	        if(letters[i].n) {
	            xPos = 0;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            currentLength = initPathPos ;
	            firstLine = false;
	            lineLength = 0;
	            if(this._hasMaskedPath) {
	                segmentInd = initSegmentInd;
	                pointInd = initPointInd;
	                points = segments[segmentInd].bezierData.points;
	                prevPoint = points[pointInd - 1];
	                currentPoint = points[pointInd];
	                partialLength = currentPoint.partialLength;
	                segmentLength = 0;
	            }
	            letterO = letterSw = letterFc = letterM = '';
	            letterP = this.defaultPropsArray;
	        }else{
	            if(this._hasMaskedPath) {
	                if(currentLine !== letters[i].line){
	                    switch(documentData.j){
	                        case 1:
	                            currentLength += totalLength - documentData.lineWidths[letters[i].line];
	                            break;
	                        case 2:
	                            currentLength += (totalLength - documentData.lineWidths[letters[i].line])/2;
	                            break;
	                    }
	                    currentLine = letters[i].line;
	                }
	                if (ind !== letters[i].ind) {
	                    if (letters[ind]) {
	                        currentLength += letters[ind].extra;
	                    }
	                    currentLength += letters[i].an / 2;
	                    ind = letters[i].ind;
	                }
	                currentLength += alignment[0] * letters[i].an / 200;
	                var animatorOffset = 0;
	                for (j = 0; j < jLen; j += 1) {
	                    animatorProps = animators[j].a;
	                    if ('p' in animatorProps) {
	                        animatorSelector = animators[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                        if(mult.length){
	                            animatorOffset += animatorProps.p.v[0] * mult[0];
	                        } else{
	                            animatorOffset += animatorProps.p.v[0] * mult;
	                        }

	                    }
	                    if ('a' in animatorProps) {
	                        animatorSelector = animators[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                        if(mult.length){
	                            animatorOffset += animatorProps.a.v[0] * mult[0];
	                        } else{
	                            animatorOffset += animatorProps.a.v[0] * mult;
	                        }

	                    }
	                }
	                flag = true;
	                while (flag) {
	                    if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
	                        perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
	                        xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
	                        yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
	                        matrixHelper.translate(-alignment[0]*letters[i].an/200, -(alignment[1] * yOff / 100));
	                        flag = false;
	                    } else if (points) {
	                        segmentLength += currentPoint.partialLength;
	                        pointInd += 1;
	                        if (pointInd >= points.length) {
	                            pointInd = 0;
	                            segmentInd += 1;
	                            if (!segments[segmentInd]) {
	                                if (mask.v.c) {
	                                    pointInd = 0;
	                                    segmentInd = 0;
	                                    points = segments[segmentInd].bezierData.points;
	                                } else {
	                                    segmentLength -= currentPoint.partialLength;
	                                    points = null;
	                                }
	                            } else {
	                                points = segments[segmentInd].bezierData.points;
	                            }
	                        }
	                        if (points) {
	                            prevPoint = currentPoint;
	                            currentPoint = points[pointInd];
	                            partialLength = currentPoint.partialLength;
	                        }
	                    }
	                }
	                offf = letters[i].an / 2 - letters[i].add;
	                matrixHelper.translate(-offf, 0, 0);
	            } else {
	                offf = letters[i].an/2 - letters[i].add;
	                matrixHelper.translate(-offf,0,0);

	                // Grouping alignment
	                matrixHelper.translate(-alignment[0]*letters[i].an/200, -alignment[1]*yOff/100, 0);
	            }

	            lineLength += letters[i].l/2;
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if ('t' in animatorProps) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    if(this._hasMaskedPath) {
	                        if(mult.length) {
	                            currentLength += animatorProps.t*mult[0];
	                        } else {
	                            currentLength += animatorProps.t*mult;
	                        }
	                    }else{
	                        if(mult.length) {
	                            xPos += animatorProps.t.v*mult[0];
	                        } else {
	                            xPos += animatorProps.t.v*mult;
	                        }
	                    }
	                }
	            }
	            lineLength += letters[i].l/2;
	            if(documentData.strokeWidthAnim) {
	                sw = documentData.sw || 0;
	            }
	            if(documentData.strokeColorAnim) {
	                if(documentData.sc){
	                    sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
	                }else{
	                    sc = [0,0,0];
	                }
	            }
	            if(documentData.fillColorAnim && documentData.fc) {
	                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if ('a' in animatorProps) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);

	                    if(mult.length){
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult[0], -animatorProps.a.v[1]*mult[1], animatorProps.a.v[2]*mult[2]);
	                    } else {
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult, -animatorProps.a.v[1]*mult, animatorProps.a.v[2]*mult);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if ('s' in animatorProps) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    if(mult.length){
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult[0]),1+((animatorProps.s.v[1]-1)*mult[1]),1);
	                    } else {
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult),1+((animatorProps.s.v[1]-1)*mult),1);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1) {
	                animatorProps = animators[j].a;
	                animatorSelector = animators[j].s;
	                mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                if ('sk' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
	                    } else {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
	                    }
	                }
	                if ('r' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
	                    } else {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult);
	                    }
	                }
	                if ('ry' in animatorProps) {

	                    if(mult.length) {
	                        matrixHelper.rotateY(animatorProps.ry.v*mult[1]);
	                    }else{
	                        matrixHelper.rotateY(animatorProps.ry.v*mult);
	                    }
	                }
	                if ('rx' in animatorProps) {
	                    if(mult.length) {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult[0]);
	                    } else {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult);
	                    }
	                }
	                if ('o' in animatorProps) {
	                    if(mult.length) {
	                        elemOpacity += ((animatorProps.o.v)*mult[0] - elemOpacity)*mult[0];
	                    } else {
	                        elemOpacity += ((animatorProps.o.v)*mult - elemOpacity)*mult;
	                    }
	                }
	                if (documentData.strokeWidthAnim && 'sw' in animatorProps) {
	                    if(mult.length) {
	                        sw += animatorProps.sw.v*mult[0];
	                    } else {
	                        sw += animatorProps.sw.v*mult;
	                    }
	                }
	                if (documentData.strokeColorAnim && 'sc' in animatorProps) {
	                    for(k=0;k<3;k+=1){
	                        if(mult.length) {
	                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult[0]
	                        } else {
	                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult;
	                        }
	                    }
	                }
	                if (documentData.fillColorAnim && documentData.fc) {
	                    if('fc' in animatorProps){
	                        for(k=0;k<3;k+=1){
	                            if(mult.length) {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult[0];
	                            } else {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult;
	                            }
	                        }
	                    }
	                    if('fh' in animatorProps){
	                        if(mult.length) {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult[0]);
	                        } else {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult);
	                        }
	                    }
	                    if('fs' in animatorProps){
	                        if(mult.length) {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);
	                        } else {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult);
	                        }
	                    }
	                    if('fb' in animatorProps){
	                        if(mult.length) {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);
	                        } else {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult);
	                        }
	                    }
	                }
	            }

	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;

	                if ('p' in animatorProps) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    if(this._hasMaskedPath) {
	                        if(mult.length) {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
	                        } else {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        }
	                    }else{
	                        if(mult.length) {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
	                        } else {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        }
	                    }
	                }
	            }
	            if(documentData.strokeWidthAnim){
	                letterSw = sw < 0 ? 0 : sw;
	            }
	            if(documentData.strokeColorAnim){
	                letterSc = 'rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';
	            }
	            if(documentData.fillColorAnim && documentData.fc){
	                letterFc = 'rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';
	            }

	            if(this._hasMaskedPath) {
	                matrixHelper.translate(0,-documentData.ls);

	                matrixHelper.translate(0, alignment[1]*yOff/100 + yPos,0);
	                if (textData.p.p) {
	                    tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
	                    var rot = Math.atan(tanAngle) * 180 / Math.PI;
	                    if (currentPoint.point[0] < prevPoint.point[0]) {
	                        rot += 180;
	                    }
	                    matrixHelper.rotate(-rot * Math.PI / 180);
	                }
	                matrixHelper.translate(xPathPos, yPathPos, 0);
	                currentLength -= alignment[0]*letters[i].an/200;
	                if(letters[i+1] && ind !== letters[i+1].ind){
	                    currentLength += letters[i].an / 2;
	                    currentLength += documentData.tr/1000*documentData.s;
	                }
	            }else{

	                matrixHelper.translate(xPos,yPos,0);

	                if(documentData.ps){
	                    //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
	                    matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	                }
	                switch(documentData.j){
	                    case 1:
	                        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]),0,0);
	                        break;
	                    case 2:
	                        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line])/2,0,0);
	                        break;
	                }
	                matrixHelper.translate(0,-documentData.ls);
	                matrixHelper.translate(offf,0,0);
	                matrixHelper.translate(alignment[0]*letters[i].an/200,alignment[1]*yOff/100,0);
	                xPos += letters[i].l + documentData.tr/1000*documentData.s;
	            }
	            if(renderType === 'html'){
	                letterM = matrixHelper.toCSS();
	            }else if(renderType === 'svg'){
	                letterM = matrixHelper.to2dCSS();
	            }else{
	                letterP = [matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];
	            }
	            letterO = elemOpacity;
	        }

	        if(renderedLettersCount <= i) {
	            letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);
	            this.renderedLetters.push(letterValue);
	            renderedLettersCount += 1;
	            this.lettersChangedFlag = true;
	        } else {
	            letterValue = this.renderedLetters[i];
	            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
	        }
	    }
	}

	TextAnimatorProperty.prototype.getValue = function(){
		if(this._elem.globalData.frameId === this._frameId){
	        return;
	    }
	    this._frameId = this._elem.globalData.frameId;
		var i, len = this._dynamicProperties.length;
	    this.mdf = false;
		for(i = 0; i < len; i += 1) {
			this._dynamicProperties[i].getValue();
	        this.mdf = this._dynamicProperties[i].mdf || this.mdf;
		}
	}

	TextAnimatorProperty.prototype.mHelper = new Matrix();
	TextAnimatorProperty.prototype.defaultPropsArray = [];
	function LetterProps(o, sw, sc, fc, m, p){
	    this.o = o;
	    this.sw = sw;
	    this.sc = sc;
	    this.fc = fc;
	    this.m = m;
	    this.p = p;
	    this.mdf = {
	    	o: true,
	    	sw: !!sw,
	    	sc: !!sc,
	    	fc: !!fc,
	    	m: true,
	    	p: true
	    };
	}

	LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
		this.mdf.o = false;
		this.mdf.sw = false;
		this.mdf.sc = false;
		this.mdf.fc = false;
		this.mdf.m = false;
		this.mdf.p = false;
		var updated = false;

		if(this.o !== o) {
			this.o = o;
			this.mdf.o = true;
			updated = true;
		}
		if(this.sw !== sw) {
			this.sw = sw;
			this.mdf.sw = true;
			updated = true;
		}
		if(this.sc !== sc) {
			this.sc = sc;
			this.mdf.sc = true;
			updated = true;
		}
		if(this.fc !== fc) {
			this.fc = fc;
			this.mdf.fc = true;
			updated = true;
		}
		if(this.m !== m) {
			this.m = m;
			this.mdf.m = true;
			updated = true;
		}
		if(p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
			this.p = p;
			this.mdf.p = true;
			updated = true;
		}
		return updated;
	}
	function TextProperty(elem, data, dynamicProperties){
		this._frameId = -99999;
		this.pv = '';
		this.v = '';
		this.kf = false;
		this.firstFrame = true;
		this.mdf = true;
		this.data = data;
		this.elem = elem;
		this.keysIndex = -1;
		this.currentData = {
			ascent: 0,
	        boxWidth: [0,0],
	        f: '',
	        fStyle: '',
	        fWeight: '',
	        fc: '',
	        j: '',
	        justifyOffset: '',
	        l: [],
	        lh: 0,
	        lineWidths: [],
	        ls: '',
	        of: '',
	        s: '',
	        sc: '',
	        sw: 0,
	        t: 0,
	        tr: 0,
	        fillColorAnim: false,
	        strokeColorAnim: false,
	        strokeWidthAnim: false,
	        yOffset: 0,
	        __complete: false

		}
		if(this.searchProperty()) {
			dynamicProperties.push(this);
		} else {
			this.getValue(true);
		}
	}

	TextProperty.prototype.setCurrentData = function(data){
			var currentData = this.currentData;
	        currentData.ascent = data.ascent;
	        currentData.boxWidth = data.boxWidth ? data.boxWidth : currentData.boxWidth;
	        currentData.f = data.f;
	        currentData.fStyle = data.fStyle;
	        currentData.fWeight = data.fWeight;
	        currentData.fc = data.fc;
	        currentData.j = data.j;
	        currentData.justifyOffset = data.justifyOffset;
	        currentData.l = data.l;
	        currentData.lh = data.lh;
	        currentData.lineWidths = data.lineWidths;
	        currentData.ls = data.ls;
	        currentData.of = data.of;
	        currentData.s = data.s;
	        currentData.sc = data.sc;
	        currentData.sw = data.sw;
	        currentData.t = data.t;
	        currentData.tr = data.tr;
	        currentData.fillColorAnim = data.fillColorAnim || currentData.fillColorAnim;
	        currentData.strokeColorAnim = data.strokeColorAnim || currentData.strokeColorAnim;
	        currentData.strokeWidthAnim = data.strokeWidthAnim || currentData.strokeWidthAnim;
	        currentData.yOffset = data.yOffset;
	        currentData.__complete = false;
	}

	TextProperty.prototype.searchProperty = function() {
		this.kf = this.data.d.k.length > 1;
		return this.kf;
	}

	TextProperty.prototype.getValue = function() {
		this.mdf = false;
		var frameId = this.elem.globalData.frameId;
		if((frameId === this._frameId || !this.kf) && !this.firstFrame) {
			return;
		}
		var textKeys = this.data.d.k, textDocumentData;
	    var i = 0, len = textKeys.length;
	    while(i <= len - 1) {
	        textDocumentData = textKeys[i].s;
	        if(i === len - 1 || textKeys[i+1].t > frameId){
	            break;
	        }
	        i += 1;
	    }
	    if(this.keysIndex !== i) {
	    	if(!textDocumentData.__complete) {
	            this.completeTextData(textDocumentData);
	        }
	        this.setCurrentData(textDocumentData);
	        this.mdf = this.firstFrame ? false : true;
	        this.pv = this.v = this.currentData.t;
	        this.keysIndex = i;
	    }
		this._frameId = frameId;
	}

	TextProperty.prototype.completeTextData = function(documentData) {
	    documentData.__complete = true;
	    var fontManager = this.elem.globalData.fontManager;
	    var data = this.data;
	    var letters = [];
	    var i, len;
	    var newLineFlag, index = 0, val;
	    var anchorGrouping = data.m.g;
	    var currentSize = 0, currentPos = 0, currentLine = 0, lineWidths = [];
	    var lineWidth = 0;
	    var maxLineWidth = 0;
	    var j, jLen;
	    var fontData = fontManager.getFontByName(documentData.f);
	    var charData, cLength = 0;
	    var styles = fontData.fStyle.split(' ');

	    var fWeight = 'normal', fStyle = 'normal';
	    len = styles.length;
	    var styleName;
	    for(i=0;i<len;i+=1){
	        styleName = styles[i].toLowerCase();
	        switch(styleName) {
	            case 'italic':
	            fStyle = 'italic';
	            break;
	            case 'bold':
	            fWeight = '700';
	            break;
	            case 'black':
	            fWeight = '900';
	            break;
	            case 'medium':
	            fWeight = '500';
	            break;
	            case 'regular':
	            case 'normal':
	            fWeight = '400';
	            case 'light':
	            case 'thin':
	            fWeight = '200';
	            break;
	        }
	    }
	    documentData.fWeight = fWeight;
	    documentData.fStyle = fStyle;
	    len = documentData.t.length;
	    var trackingOffset = documentData.tr/1000*documentData.s;
	    if(documentData.sz){
	        var boxWidth = documentData.sz[0];
	        var lastSpaceIndex = -1;
	        for(i=0;i<len;i+=1){
	            newLineFlag = false;
	            if(documentData.t.charAt(i) === ' '){
	                lastSpaceIndex = i;
	            }else if(documentData.t.charCodeAt(i) === 13){
	                lineWidth = 0;
	                newLineFlag = true;
	            }
	            if(fontManager.chars){
	                charData = fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, fontData.fFamily);
	                cLength = newLineFlag ? 0 : charData.w*documentData.s/100;
	            }else{
	                //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
	                cLength = fontManager.measureText(documentData.t.charAt(i), documentData.f, documentData.s);
	            }
	            if(lineWidth + cLength > boxWidth && documentData.t.charAt(i) !== ' '){
	                if(lastSpaceIndex === -1){
	                    len += 1;
	                } else {
	                    i = lastSpaceIndex;
	                }
	                documentData.t = documentData.t.substr(0,i) + "\r" + documentData.t.substr(i === lastSpaceIndex ? i + 1 : i);
	                lastSpaceIndex = -1;
	                lineWidth = 0;
	            }else {
	                lineWidth += cLength;
	                lineWidth += trackingOffset;
	            }
	        }
	        len = documentData.t.length;
	    }
	    lineWidth = - trackingOffset;
	    cLength = 0;
	    var uncollapsedSpaces = 0;
	    var currentChar;
	    for (i = 0;i < len ;i += 1) {
	        newLineFlag = false;
	        currentChar = documentData.t.charAt(i);
	        if(currentChar === ' '){
	            val = '\u00A0';
	        }else if(currentChar.charCodeAt(0) === 13){
	            uncollapsedSpaces = 0;
	            lineWidths.push(lineWidth);
	            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	            lineWidth = - 2 * trackingOffset;
	            val = '';
	            newLineFlag = true;
	            currentLine += 1;
	        }else{
	            val = documentData.t.charAt(i);
	        }
	        if(fontManager.chars){
	            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
	            cLength = newLineFlag ? 0 : charData.w*documentData.s/100;
	        }else{
	            //var charWidth = fontManager.measureText(val, documentData.f, documentData.s);
	            //tCanvasHelper.font = documentData.s + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
	            cLength = fontManager.measureText(val, documentData.f, documentData.s);
	        }

	        //
	        if(currentChar === ' '){
	            uncollapsedSpaces += cLength + trackingOffset;
	        } else {
	            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
	            uncollapsedSpaces = 0;
	        }
	        letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag, anIndexes:[], val: val, line: currentLine});
	        if(anchorGrouping == 2){
	            currentSize += cLength;
	            if(val == '' || val == '\u00A0' || i == len - 1){
	                if(val == '' || val == '\u00A0'){
	                    currentSize -= cLength;
	                }
	                while(currentPos<=i){
	                    letters[currentPos].an = currentSize;
	                    letters[currentPos].ind = index;
	                    letters[currentPos].extra = cLength;
	                    currentPos += 1;
	                }
	                index += 1;
	                currentSize = 0;
	            }
	        }else if(anchorGrouping == 3){
	            currentSize += cLength;
	            if(val == '' || i == len - 1){
	                if(val == ''){
	                    currentSize -= cLength;
	                }
	                while(currentPos<=i){
	                    letters[currentPos].an = currentSize;
	                    letters[currentPos].ind = index;
	                    letters[currentPos].extra = cLength;
	                    currentPos += 1;
	                }
	                currentSize = 0;
	                index += 1;
	            }
	        }else{
	            letters[index].ind = index;
	            letters[index].extra = 0;
	            index += 1;
	        }
	    }
	    documentData.l = letters;
	    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	    lineWidths.push(lineWidth);
	    if(documentData.sz){
	        documentData.boxWidth = documentData.sz[0];
	        documentData.justifyOffset = 0;
	    }else{
	        documentData.boxWidth = maxLineWidth;
	        switch(documentData.j){
	            case 1:
	                documentData.justifyOffset = - documentData.boxWidth;
	                break;
	            case 2:
	                documentData.justifyOffset = - documentData.boxWidth/2;
	                break;
	            default:
	                documentData.justifyOffset = 0;
	        }
	    }
	    documentData.lineWidths = lineWidths;

	    var animators = data.a, animatorData, letterData;
	    jLen = animators.length;
	    var based, ind, indexes = [];
	    for(j=0;j<jLen;j+=1){
	        animatorData = animators[j];
	        if(animatorData.a.sc){
	            documentData.strokeColorAnim = true;
	        }
	        if(animatorData.a.sw){
	            documentData.strokeWidthAnim = true;
	        }
	        if(animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb){
	            documentData.fillColorAnim = true;
	        }
	        ind = 0;
	        based = animatorData.s.b;
	        for(i=0;i<len;i+=1){
	            letterData = letters[i];
	            letterData.anIndexes[j] = ind;
	            if((based == 1 && letterData.val != '') || (based == 2 && letterData.val != '' && letterData.val != '\u00A0') || (based == 3 && (letterData.n || letterData.val == '\u00A0' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))){
	                if(animatorData.s.rn === 1){
	                    indexes.push(ind);
	                }
	                ind += 1;
	            }
	        }
	        data.a[j].s.totalChars = ind;
	        var currentInd = -1, newInd;
	        if(animatorData.s.rn === 1){
	            for(i = 0; i < len; i += 1){
	                letterData = letters[i];
	                if(currentInd != letterData.anIndexes[j]){
	                    currentInd = letterData.anIndexes[j];
	                    newInd = indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];
	                }
	                letterData.anIndexes[j] = newInd;
	            }
	        }
	    }
	    documentData.yOffset = documentData.lh || documentData.s*1.2;
	    documentData.ls = documentData.ls || 0;
	    documentData.ascent = fontData.ascent*documentData.s/100;
	}

	TextProperty.prototype.updateDocumentData = function(newData, index) {
		index = index === undefined ? this.keysIndex : index;
	    var dData = this.data.d.k[index].s;
	    dData.__complete = false;
	    dData.t = newData.t;
	    this.keysIndex = -1;
	    this.firstFrame = true;
	    this.getValue();
	}

	var pooling = (function(){

		function double(arr){
			return arr.concat(Array.apply(null,{length:arr.length}))
		}

		return {
			double: double
		}
	}());
	var point_pool = (function(){
		var ob = {
			newPoint: newPoint,
			release: release
		}

		var _length = 0;
		var _maxLength = 8;
		var pool = Array.apply(null,{length:_maxLength});

		function newPoint(){
			var point;
			if(_length){
				_length -= 1;
				point = pool[_length];
			} else {
				point = [0.1,0.1];
			}
			return point;
		}

		function release(point) {
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = point;
			_length += 1;
		}


		return ob;
	}());
	var shape_pool = (function(){
		var ob = {
			clone: clone,
			newShape: newShape,
			release: release,
			releaseArray: releaseArray
		}

		var _length = 0;
		var _maxLength = 4;
		var pool = Array.apply(null,{length:_maxLength});

		function newShape(){
			var shapePath;
			if(_length){
				_length -= 1;
				shapePath = pool[_length];
			} else {
				shapePath = new ShapePath();
			}
			return shapePath;
		}

		function release(shapePath) {
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			var len = shapePath._length, i;
			for(i = 0; i < len; i += 1) {
				point_pool.release(shapePath.v[i]);
				point_pool.release(shapePath.i[i]);
				point_pool.release(shapePath.o[i]);
				shapePath.v[i] = null;
				shapePath.i[i] = null;
				shapePath.o[i] = null;
			}
			shapePath._length = 0;
			shapePath.c = false;
			pool[_length] = shapePath;
			_length += 1;
		}

		function releaseArray(shapePathsCollection, length) {
			while(length--) {
				release(shapePathsCollection[length]);
			}
		}

		function clone(shape, transform) {
			var i, len = shape._length === undefined ? shape.v.length : shape._length;
			var cloned = newShape();
			cloned.setLength(len);
			cloned.c = shape.c;

			var pt;
			
			for(i = 0; i < len; i += 1) {
				if(transform){
					pt = transform.applyToPointArray(shape.v[i][0],shape.v[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'v',i);
					point_pool.release(pt);
					pt = transform.applyToPointArray(shape.o[i][0],shape.o[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'o',i);
					point_pool.release(pt);
					pt = transform.applyToPointArray(shape.i[i][0],shape.i[i][1],0,2);
					cloned.setXYAt(pt[0],pt[1],'i',i);
					point_pool.release(pt);
				}else{
					cloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1], i);
				}
			}
			return cloned
		}


		return ob;
	}());
	var shapeCollection_pool = (function(){
		var ob = {
			newShapeCollection: newShapeCollection,
			release: release,
			clone: clone
		}

		var _length = 0;
		var _maxLength = 4;
		var pool = Array.apply(null,{length:_maxLength});

		var cont = 0;

		function newShapeCollection(){
			var shapeCollection;
			if(_length){
				_length -= 1;
				shapeCollection = pool[_length];
			} else {
				shapeCollection = new ShapeCollection();
			}
			return shapeCollection;
		}

		function release(shapeCollection) {
			var i, len = shapeCollection._length;
			for(i = 0; i < len; i += 1) {
				shape_pool.release(shapeCollection.shapes[i]);
			}
			shapeCollection._length = 0;

			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = shapeCollection;
			_length += 1;
		}

		function clone(shapeCollection, originCollection) {
			release(shapeCollection);
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = shapeCollection;
			_length += 1;
		}


		return ob;
	}());
	function BaseRenderer(){}
	BaseRenderer.prototype.checkLayers = function(num){
	    var i, len = this.layers.length, data;
	    this.completeLayers = true;
	    for (i = len - 1; i >= 0; i--) {
	        if (!this.elements[i]) {
	            data = this.layers[i];
	            if(data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st))
	            {
	                this.buildItem(i);
	            }
	        }
	        this.completeLayers = this.elements[i] ? this.completeLayers:false;
	    }
	    this.checkPendingElements();
	};

	BaseRenderer.prototype.createItem = function(layer){
	    switch(layer.ty){
	        case 2:
	            return this.createImage(layer);
	        case 0:
	            return this.createComp(layer);
	        case 1:
	            return this.createSolid(layer);
	        case 4:
	            return this.createShape(layer);
	        case 5:
	            return this.createText(layer);
	        case 13:
	            return this.createCamera(layer);
	        case 99:
	            return null;
	    }
	    return this.createBase(layer);
	};

	BaseRenderer.prototype.createCamera = function(){
	    throw new Error('You\'re using a 3d camera. Try the html renderer.');
	}

	BaseRenderer.prototype.buildAllItems = function(){
	    var i, len = this.layers.length;
	    for(i=0;i<len;i+=1){
	        this.buildItem(i);
	    }
	    this.checkPendingElements();
	};

	BaseRenderer.prototype.includeLayers = function(newLayers){
	    this.completeLayers = false;
	    var i, len = newLayers.length;
	    var j, jLen = this.layers.length;
	    for(i=0;i<len;i+=1){
	        j = 0;
	        while(j<jLen){
	            if(this.layers[j].id == newLayers[i].id){
	                this.layers[j] = newLayers[i];
	                break;
	            }
	            j += 1;
	        }
	    }
	};

	BaseRenderer.prototype.setProjectInterface = function(pInterface){
	    this.globalData.projectInterface = pInterface;
	};

	BaseRenderer.prototype.initItems = function(){
	    if(!this.globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	};
	BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy){
	    hierarchy = hierarchy || [];
	    var elements = this.elements;
	    var layers = this.layers;
	    var i=0, len = layers.length;
	    while(i<len){
	        if(layers[i].ind == parentName){
	            if(!elements[i] || elements[i] === true){
	                this.buildItem(i);
	                this.addPendingElement(element);
	            } else if(layers[i].parent !== undefined){
	                hierarchy.push(elements[i]);
	                elements[i]._isParent = true;
	                this.buildElementParenting(element,layers[i].parent, hierarchy);
	            } else {
	                hierarchy.push(elements[i]);
	                elements[i]._isParent = true;
	                element.setHierarchy(hierarchy);
	            }


	        }
	        i += 1;
	    }
	};

	BaseRenderer.prototype.addPendingElement = function(element){
	    this.pendingElements.push(element);
	};
	function SVGRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.renderConfig = {
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	        progressiveLoad: (config && config.progressiveLoad) || false,
	        hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true,
	        viewBoxOnly: (config && config.viewBoxOnly) || false,
	        className: (config && config.className) || ''
	    };
	    this.globalData.renderConfig = this.renderConfig;
	    this.elements = [];
	    this.pendingElements = [];
	    this.destroyed = false;

	}

	extendPrototype(BaseRenderer,SVGRenderer);

	SVGRenderer.prototype.createBase = function (data) {
	    return new SVGBaseElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createShape = function (data) {
	    return new IShapeElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createText = function (data) {
	    return new SVGTextElement(data, this.layerElement,this.globalData,this);

	};

	SVGRenderer.prototype.createImage = function (data) {
	    return new IImageElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.createComp = function (data) {
	    return new ICompElement(data, this.layerElement,this.globalData,this);

	};

	SVGRenderer.prototype.createSolid = function (data) {
	    return new ISolidElement(data, this.layerElement,this.globalData,this);
	};

	SVGRenderer.prototype.configAnimation = function(animData){
	    this.layerElement = document.createElementNS(svgNS,'svg');
	    this.layerElement.setAttribute('xmlns','http://www.w3.org/2000/svg');
	    this.layerElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);
	    if(!this.renderConfig.viewBoxOnly) {
	        this.layerElement.setAttribute('width',animData.w);
	        this.layerElement.setAttribute('height',animData.h);
	        this.layerElement.style.width = '100%';
	        this.layerElement.style.height = '100%';
	    }
	    if(this.renderConfig.className) {
	        this.layerElement.setAttribute('class', this.renderConfig.className);
	    }
	    this.layerElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);
	    //this.layerElement.style.transform = 'translate3d(0,0,0)';
	    //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
	    this.animationItem.wrapper.appendChild(this.layerElement);
	    //Mask animation
	    var defs = document.createElementNS(svgNS, 'defs');
	    this.globalData.defs = defs;
	    this.layerElement.appendChild(defs);
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.globalData.frameId = 0;
	    this.globalData.nm = animData.nm;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.data = animData;
	    this.globalData.frameRate = animData.fr;
	    var maskElement = document.createElementNS(svgNS, 'clipPath');
	    var rect = document.createElementNS(svgNS,'rect');
	    rect.setAttribute('width',animData.w);
	    rect.setAttribute('height',animData.h);
	    rect.setAttribute('x',0);
	    rect.setAttribute('y',0);
	    var maskId = 'animationMask_'+randomString(10);
	    maskElement.setAttribute('id', maskId);
	    maskElement.appendChild(rect);
	    var maskedElement = document.createElementNS(svgNS,'g');
	    maskedElement.setAttribute("clip-path", "url(" + locationHref + "#"+maskId+")");
	    this.layerElement.appendChild(maskedElement);
	    defs.appendChild(maskElement);
	    this.layerElement = maskedElement;
	    this.layers = animData.layers;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,defs);
	    this.elements = Array.apply(null,{length:animData.layers.length});
	};


	SVGRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.layerElement = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};

	SVGRenderer.prototype.updateContainerSize = function () {
	};

	SVGRenderer.prototype.buildItem  = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    elements[pos] = true;
	    var element = this.createItem(this.layers[pos]);

	    elements[pos] = element;
	    if(expressionsPlugin){
	        if(this.layers[pos].ty === 0){
	            this.globalData.projectInterface.registerComposition(element);
	        }
	        element.initExpressions();
	    }
	    this.appendElementInPos(element,pos);
	    if(this.layers[pos].tt){
	        if(!this.elements[pos - 1] || this.elements[pos - 1] === true){
	            this.buildItem(pos - 1);
	            this.addPendingElement(element);
	        } else {
	            element.setMatte(elements[pos - 1].layerId);
	        }
	    }
	};

	SVGRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	        if(element.data.tt){
	            var i = 0, len = this.elements.length;
	            while(i<len){
	                if(this.elements[i] === element){
	                    element.setMatte(this.elements[i - 1].layerId);
	                    break;
	                }
	                i += 1;
	            }
	        }
	    }
	};

	SVGRenderer.prototype.renderFrame = function(num){
	    if(this.renderedFrame == num || this.destroyed){
	        return;
	    }
	    if(num === null){
	        num = this.renderedFrame;
	    }else{
	        this.renderedFrame = num;
	    }
	    //clearPoints();
	    /*console.log('-------');
	    console.log('FRAME ',num);*/
	    this.globalData.frameNum = num;
	    this.globalData.frameId += 1;
	    this.globalData.projectInterface.currentFrame = num;
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }
	    for (i = len - 1; i >= 0; i--) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    for (i = len - 1; i >= 0; i--) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	};

	SVGRenderer.prototype.appendElementInPos = function(element, pos){
	    var newElement = element.getBaseElement();
	    if(!newElement){
	        return;
	    }
	    var i = 0;
	    var nextElement;
	    while(i<pos){
	        if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement()){
	            nextElement = this.elements[i].getBaseElement();
	        }
	        i += 1;
	    }
	    if(nextElement){
	        this.layerElement.insertBefore(newElement, nextElement);
	    } else {
	        this.layerElement.appendChild(newElement);
	    }
	};

	SVGRenderer.prototype.hide = function(){
	    this.layerElement.style.display = 'none';
	};

	SVGRenderer.prototype.show = function(){
	    this.layerElement.style.display = 'block';
	};

	SVGRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElementNS(svgNS,'g');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
	            comp.initExpressions();
	            //comp.compInterface = CompExpressionInterface(comp);
	            //Expressions.addLayersInterface(comp.elements, this.globalData.projectInterface);
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};

	function MaskElement(data,element,globalData) {
	    this.dynamicProperties = [];
	    this.data = data;
	    this.element = element;
	    this.globalData = globalData;
	    this.storedData = [];
	    this.masksProperties = this.data.masksProperties;
	    this.viewData = Array.apply(null,{length:this.masksProperties.length});
	    this.maskElement = null;
	    this.firstFrame = true;
	    var defs = this.globalData.defs;
	    var i, len = this.masksProperties.length;


	    var path, properties = this.masksProperties;
	    var count = 0;
	    var currentMasks = [];
	    var j, jLen;
	    var layerId = randomString(10);
	    var rect, expansor, feMorph,x;
	    var maskType = 'clipPath', maskRef = 'clip-path';
	    for (i = 0; i < len; i++) {

	        if((properties[i].mode !== 'a' && properties[i].mode !== 'n')|| properties[i].inv || properties[i].o.k !== 100){
	            maskType = 'mask';
	            maskRef = 'mask';
	        }

	        if((properties[i].mode == 's' || properties[i].mode == 'i') && count == 0){
	            rect = document.createElementNS(svgNS, 'rect');
	            rect.setAttribute('fill', '#ffffff');
	            rect.setAttribute('width', this.element.comp.data.w);
	            rect.setAttribute('height', this.element.comp.data.h);
	            currentMasks.push(rect);
	        } else {
	            rect = null;
	        }

	        path = document.createElementNS(svgNS, 'path');
	        if(properties[i].mode == 'n') {
	            this.viewData[i] = {
	                op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.dynamicProperties),
	                prop: ShapePropertyFactory.getShapeProp(this.element,properties[i],3,this.dynamicProperties,null),
	                elem: path
	            };
	            defs.appendChild(path);
	            continue;
	        }
	        count += 1;

	        if(properties[i].mode == 's'){
	            path.setAttribute('fill', '#000000');
	        }else{
	            path.setAttribute('fill', '#ffffff');
	        }
	        path.setAttribute('clip-rule','nonzero');

	        if(properties[i].x.k !== 0){
	            maskType = 'mask';
	            maskRef = 'mask';
	            x = PropertyFactory.getProp(this.element,properties[i].x,0,null,this.dynamicProperties);
	            var filterID = 'fi_'+randomString(10);
	            expansor = document.createElementNS(svgNS,'filter');
	            expansor.setAttribute('id',filterID);
	            feMorph = document.createElementNS(svgNS,'feMorphology');
	            feMorph.setAttribute('operator','dilate');
	            feMorph.setAttribute('in','SourceGraphic');
	            feMorph.setAttribute('radius','0');
	            expansor.appendChild(feMorph);
	            defs.appendChild(expansor);
	            if(properties[i].mode == 's'){
	                path.setAttribute('stroke', '#000000');
	            }else{
	                path.setAttribute('stroke', '#ffffff');
	            }
	        }else{
	            feMorph = null;
	            x = null;
	        }


	        this.storedData[i] = {
	             elem: path,
	             x: x,
	             expan: feMorph,
	            lastPath: '',
	            lastOperator:'',
	            filterId:filterID,
	            lastRadius:0
	        };
	        if(properties[i].mode == 'i'){
	            jLen = currentMasks.length;
	            var g = document.createElementNS(svgNS,'g');
	            for(j=0;j<jLen;j+=1){
	                g.appendChild(currentMasks[j]);
	            }
	            var mask = document.createElementNS(svgNS,'mask');
	            mask.setAttribute('mask-type','alpha');
	            mask.setAttribute('id',layerId+'_'+count);
	            mask.appendChild(path);
	            defs.appendChild(mask);
	            g.setAttribute('mask','url(' + locationHref + '#'+layerId+'_'+count+')');

	            currentMasks.length = 0;
	            currentMasks.push(g);
	        }else{
	            currentMasks.push(path);
	        }
	        if(properties[i].inv && !this.solidPath){
	            this.solidPath = this.createLayerSolidPath();
	        }
	        this.viewData[i] = {
	            elem: path,
	            lastPath: '',
	            op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.dynamicProperties),
	            prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3,this.dynamicProperties,null)
	        };
	        if(rect){
	            this.viewData[i].invRect = rect;
	        }
	        if(!this.viewData[i].prop.k){
	            this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	    }

	    this.maskElement = document.createElementNS(svgNS, maskType);

	    len = currentMasks.length;
	    for(i=0;i<len;i+=1){
	        this.maskElement.appendChild(currentMasks[i]);
	    }

	    this.maskElement.setAttribute('id', layerId);
	    if(count > 0){
	        this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
	    }

	    defs.appendChild(this.maskElement);
	};

	MaskElement.prototype.getMaskProperty = function(pos){
	    return this.viewData[pos].prop;
	};

	MaskElement.prototype.prepareFrame = function(){
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();

	    }
	};

	MaskElement.prototype.renderFrame = function (finalMat) {
	    var i, len = this.masksProperties.length;
	    for (i = 0; i < len; i++) {
	        if(this.viewData[i].prop.mdf || this.firstFrame){
	            this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	        if(this.viewData[i].op.mdf || this.firstFrame){
	            this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);
	        }
	        if(this.masksProperties[i].mode !== 'n'){
	            if(this.viewData[i].invRect && (this.element.finalTransform.mProp.mdf || this.firstFrame)){
	                this.viewData[i].invRect.setAttribute('x', -finalMat.props[12]);
	                this.viewData[i].invRect.setAttribute('y', -finalMat.props[13]);
	            }
	            if(this.storedData[i].x && (this.storedData[i].x.mdf || this.firstFrame)){
	                var feMorph = this.storedData[i].expan;
	                if(this.storedData[i].x.v < 0){
	                    if(this.storedData[i].lastOperator !== 'erode'){
	                        this.storedData[i].lastOperator = 'erode';
	                        this.storedData[i].elem.setAttribute('filter','url(' + locationHref + '#'+this.storedData[i].filterId+')');
	                    }
	                    feMorph.setAttribute('radius',-this.storedData[i].x.v);
	                }else{
	                    if(this.storedData[i].lastOperator !== 'dilate'){
	                        this.storedData[i].lastOperator = 'dilate';
	                        this.storedData[i].elem.setAttribute('filter',null);
	                    }
	                    this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v*2);

	                }
	            }
	        }
	    }
	    this.firstFrame = false;
	};

	MaskElement.prototype.getMaskelement = function () {
	    return this.maskElement;
	};

	MaskElement.prototype.createLayerSolidPath = function(){
	    var path = 'M0,0 ';
	    path += ' h' + this.globalData.compSize.w ;
	    path += ' v' + this.globalData.compSize.h ;
	    path += ' h-' + this.globalData.compSize.w ;
	    path += ' v-' + this.globalData.compSize.h + ' ';
	    return path;
	};

	MaskElement.prototype.drawPath = function(pathData,pathNodes,viewData){
	    var pathString = " M"+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    var i, len;
	    len = pathNodes._length;
	    for(i=1;i<len;i+=1){
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
	        pathString += " C"+bm_rnd(pathNodes.o[i-1][0])+','+bm_rnd(pathNodes.o[i-1][1]) + " "+bm_rnd(pathNodes.i[i][0])+','+bm_rnd(pathNodes.i[i][1]) + " "+bm_rnd(pathNodes.v[i][0])+','+bm_rnd(pathNodes.v[i][1]);
	    }
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    if(pathNodes.c && len > 1){
	        pathString += " C"+bm_rnd(pathNodes.o[i-1][0])+','+bm_rnd(pathNodes.o[i-1][1]) + " "+bm_rnd(pathNodes.i[0][0])+','+bm_rnd(pathNodes.i[0][1]) + " "+bm_rnd(pathNodes.v[0][0])+','+bm_rnd(pathNodes.v[0][1]);
	    }
	    //pathNodes.__renderedString = pathString;


	    if(viewData.lastPath !== pathString){
	        if(viewData.elem){
	            if(!pathNodes.c){
	                viewData.elem.setAttribute('d','');
	            }else if(pathData.inv){
	                viewData.elem.setAttribute('d',this.solidPath + pathString);
	            }else{
	                viewData.elem.setAttribute('d',pathString);
	            }
	        }
	        viewData.lastPath = pathString;
	    }
	};

	MaskElement.prototype.destroy = function(){
	    this.element = null;
	    this.globalData = null;
	    this.maskElement = null;
	    this.data = null;
	    this.masksProperties = null;
	};
	function BaseElement(){
	};
	BaseElement.prototype.checkMasks = function(){
	    if(!this.data.hasMask){
	        return false;
	    }
	    var i = 0, len = this.data.masksProperties.length;
	    while(i<len) {
	        if((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
	            return true;
	        }
	        i += 1;
	    }
	    return false;
	}

	BaseElement.prototype.checkParenting = function(){
	    if(this.data.parent !== undefined){
	        this.comp.buildElementParenting(this, this.data.parent);
	    }
	}

	BaseElement.prototype.prepareFrame = function(num){
	    if(this.data.ip - this.data.st <= num && this.data.op - this.data.st > num)
	    {
	        if(this.isVisible !== true){
	            this.elemMdf = true;
	            this.globalData.mdf = true;
	            this.isVisible = true;
	            this.firstFrame = true;
	            if(this.data.hasMask){
	                this.maskManager.firstFrame = true;
	            }
	        }
	    }else{
	        if(this.isVisible !== false){
	            this.elemMdf = true;
	            this.globalData.mdf = true;
	            this.isVisible = false;
	        }
	    }
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        if(this.isVisible || (this._isParent && this.dynamicProperties[i].type === 'transform')){
	            this.dynamicProperties[i].getValue();
	            if(this.dynamicProperties[i].mdf){
	                this.elemMdf = true;
	                this.globalData.mdf = true;
	            }
	        }
	    }
	    if(this.data.hasMask && this.isVisible){
	        this.maskManager.prepareFrame(num*this.data.sr);
	    }
	    
	    /* TODO check this
	    if(this.data.sy){
	        if(this.data.sy[0].renderedData[num]){
	            if(this.data.sy[0].renderedData[num].c){
	                this.feFlood.setAttribute('flood-color','rgb('+Math.round(this.data.sy[0].renderedData[num].c[0])+','+Math.round(this.data.sy[0].renderedData[num].c[1])+','+Math.round(this.data.sy[0].renderedData[num].c[2])+')');
	            }
	            if(this.data.sy[0].renderedData[num].s){
	                this.feMorph.setAttribute('radius',this.data.sy[0].renderedData[num].s);
	            }
	        }
	    }
	    */


	    this.currentFrameNum = num*this.data.sr;
	    return this.isVisible;
	};

	BaseElement.prototype.globalToLocal = function(pt){
	    var transforms = [];
	    transforms.push(this.finalTransform);
	    var flag = true;
	    var comp = this.comp;
	    while(flag){
	        if(comp.finalTransform){
	            if(comp.data.hasMask){
	                transforms.splice(0,0,comp.finalTransform);
	            }
	            comp = comp.comp;
	        } else {
	            flag = false;
	        }
	    }
	    var i, len = transforms.length,ptNew;
	    for(i=0;i<len;i+=1){
	        ptNew = transforms[i].mat.applyToPointArray(0,0,0);
	        //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
	        pt = [pt[0] - ptNew[0],pt[1] - ptNew[1],0];
	    }
	    return pt;
	};

	BaseElement.prototype.initExpressions = function(){
	    this.layerInterface = LayerExpressionInterface(this);
	    //layers[i].layerInterface = LayerExpressionInterface(layers[i]);
	    //layers[i].layerInterface = LayerExpressionInterface(layers[i]);
	    if(this.data.hasMask){
	        this.layerInterface.registerMaskInterface(this.maskManager);
	    }
	    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);
	    this.layerInterface.registerEffectsInterface(effectsInterface);

	    if(this.data.ty === 0 || this.data.xt){
	        this.compInterface = CompExpressionInterface(this);
	    } else if(this.data.ty === 4){
	        this.layerInterface.shapeInterface = ShapeExpressionInterface.createShapeInterface(this.shapesData,this.itemsData,this.layerInterface);
	    } else if(this.data.ty === 5){
	        this.layerInterface.textInterface = TextExpressionInterface(this);
	    }
	}

	BaseElement.prototype.setBlendMode = function(){
	    var blendModeValue = '';
	    switch(this.data.bm){
	        case 1:
	            blendModeValue = 'multiply';
	            break;
	        case 2:
	            blendModeValue = 'screen';
	            break;
	        case 3:
	            blendModeValue = 'overlay';
	            break;
	        case 4:
	            blendModeValue = 'darken';
	            break;
	        case 5:
	            blendModeValue = 'lighten';
	            break;
	        case 6:
	            blendModeValue = 'color-dodge';
	            break;
	        case 7:
	            blendModeValue = 'color-burn';
	            break;
	        case 8:
	            blendModeValue = 'hard-light';
	            break;
	        case 9:
	            blendModeValue = 'soft-light';
	            break;
	        case 10:
	            blendModeValue = 'difference';
	            break;
	        case 11:
	            blendModeValue = 'exclusion';
	            break;
	        case 12:
	            blendModeValue = 'hue';
	            break;
	        case 13:
	            blendModeValue = 'saturation';
	            break;
	        case 14:
	            blendModeValue = 'color';
	            break;
	        case 15:
	            blendModeValue = 'luminosity';
	            break;
	    }
	    var elem = this.baseElement || this.layerElement;

	    elem.style['mix-blend-mode'] = blendModeValue;
	}

	BaseElement.prototype.init = function(){
	    if(!this.data.sr){
	        this.data.sr = 1;
	    }
	    this.dynamicProperties = this.dynamicProperties || [];
	    if(this.data.ef){
	        this.effects = new EffectsManager(this.data,this,this.dynamicProperties);
	        //this.effect = this.effectsManager.bind(this.effectsManager);
	    }
	    //this.elemInterface = buildLayerExpressionInterface(this);
	    this.hidden = false;
	    this.firstFrame = true;
	    this.isVisible = false;
	    this._isParent = false;
	    this.currentFrameNum = -99999;
	    this.lastNum = -99999;
	    if(this.data.ks){
	        this.finalTransform = {
	            mProp: PropertyFactory.getProp(this,this.data.ks,2,null,this.dynamicProperties),
	            matMdf: false,
	            opMdf: false,
	            mat: new Matrix(),
	            opacity: 1
	        };
	        if(this.data.ao){
	            this.finalTransform.mProp.autoOriented = true;
	        }
	        this.finalTransform.op = this.finalTransform.mProp.o;
	        this.transform = this.finalTransform.mProp;
	        if(this.data.ty !== 11){
	            this.createElements();
	        }
	        if(this.data.hasMask){
	            this.addMasks(this.data);
	        }
	    }
	    this.elemMdf = false;
	};
	BaseElement.prototype.getType = function(){
	    return this.type;
	};

	BaseElement.prototype.resetHierarchy = function(){
	    if(!this.hierarchy){
	        this.hierarchy = [];
	    }else{
	        this.hierarchy.length = 0;
	    }
	};

	BaseElement.prototype.getHierarchy = function(){
	    if(!this.hierarchy){
	        this.hierarchy = [];
	    }
	    return this.hierarchy;
	};

	BaseElement.prototype.setHierarchy = function(hierarchy){
	    this.hierarchy = hierarchy;
	};

	BaseElement.prototype.getLayerSize = function(){
	    if(this.data.ty === 5){
	        return {w:this.data.textData.width,h:this.data.textData.height};
	    }else{
	        return {w:this.data.width,h:this.data.height};
	    }
	};

	BaseElement.prototype.hide = function(){

	};

	BaseElement.prototype.sourceRectAtTime = function(){
	    return {
	        top:0,
	        left:0,
	        width:100,
	        height:100
	    }
	};

	BaseElement.prototype.mHelper = new Matrix();
	function SVGBaseElement(data,parentContainer,globalData,comp, placeholder){
	    this.globalData = globalData;
	    this.comp = comp;
	    this.data = data;
	    this.matteElement = null;
	    this.transformedElement = null;
	    this.isTransparent = false;
	    this.parentContainer = parentContainer;
	    this.layerId = placeholder ? placeholder.layerId : 'ly_'+randomString(10);
	    this.placeholder = placeholder;
	    this._sizeChanged = false;
	    this.init();
	};

	createElement(BaseElement, SVGBaseElement);

	SVGBaseElement.prototype.createElements = function(){
	    this.layerElement = document.createElementNS(svgNS,'g');
	    this.transformedElement = this.layerElement;
	    if(this.data.hasMask){
	        this.maskedElement = this.layerElement;
	    }
	    var layerElementParent = null;
	    if(this.data.td){
	        if(this.data.td == 3 || this.data.td == 1){
	            var masker = document.createElementNS(svgNS,'mask');
	            masker.setAttribute('id',this.layerId);
	            masker.setAttribute('mask-type',this.data.td == 3 ? 'luminance':'alpha');
	            masker.appendChild(this.layerElement);
	            layerElementParent = masker;
	            this.globalData.defs.appendChild(masker);
	            ////// This is only for IE and Edge when mask if of type alpha
	            if(!featureSupport.maskType && this.data.td == 1){
	                masker.setAttribute('mask-type','luminance');
	                var filId = randomString(10);
	                var fil = filtersFactory.createFilter(filId);
	                this.globalData.defs.appendChild(fil);
	                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                var gg = document.createElementNS(svgNS,'g');
	                gg.appendChild(this.layerElement);
	                layerElementParent = gg;
	                masker.appendChild(gg);
	                gg.setAttribute('filter','url(' + locationHref + '#'+filId+')');
	            }
	        }else if(this.data.td == 2){
	            var maskGroup = document.createElementNS(svgNS,'mask');
	            maskGroup.setAttribute('id',this.layerId);
	            maskGroup.setAttribute('mask-type','alpha');
	            var maskGrouper = document.createElementNS(svgNS,'g');
	            maskGroup.appendChild(maskGrouper);
	            var filId = randomString(10);
	            var fil = filtersFactory.createFilter(filId);
	            ////

	            var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	            feColorMatrix.setAttribute('type','matrix');
	            feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	            feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
	            fil.appendChild(feColorMatrix);

	            ////
	            /*var feCTr = document.createElementNS(svgNS,'feComponentTransfer');
	            feCTr.setAttribute('in','SourceGraphic');
	            fil.appendChild(feCTr);
	            var feFunc = document.createElementNS(svgNS,'feFuncA');
	            feFunc.setAttribute('type','table');
	            feFunc.setAttribute('tableValues','1.0 0.0');
	            feCTr.appendChild(feFunc);*/
	            this.globalData.defs.appendChild(fil);
	            var alphaRect = document.createElementNS(svgNS,'rect');
	            alphaRect.setAttribute('width',this.comp.data.w);
	            alphaRect.setAttribute('height',this.comp.data.h);
	            alphaRect.setAttribute('x','0');
	            alphaRect.setAttribute('y','0');
	            alphaRect.setAttribute('fill','#ffffff');
	            alphaRect.setAttribute('opacity','0');
	            maskGrouper.setAttribute('filter','url(' + locationHref + '#'+filId+')');
	            maskGrouper.appendChild(alphaRect);
	            maskGrouper.appendChild(this.layerElement);
	            layerElementParent = maskGrouper;
	            if(!featureSupport.maskType){
	                maskGroup.setAttribute('mask-type','luminance');
	                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                var gg = document.createElementNS(svgNS,'g');
	                maskGrouper.appendChild(alphaRect);
	                gg.appendChild(this.layerElement);
	                layerElementParent = gg;
	                maskGrouper.appendChild(gg);
	            }
	            this.globalData.defs.appendChild(maskGroup);
	        }
	    }else if(this.data.hasMask || this.data.tt){
	        if(this.data.tt){
	            this.matteElement = document.createElementNS(svgNS,'g');
	            this.matteElement.appendChild(this.layerElement);
	            layerElementParent = this.matteElement;
	            this.baseElement = this.matteElement;
	        }else{
	            this.baseElement = this.layerElement;
	        }
	    }else{
	        this.baseElement = this.layerElement;
	    }
	    if((this.data.ln || this.data.cl) && (this.data.ty === 4 || this.data.ty === 0)){
	        if(this.data.ln){
	            this.layerElement.setAttribute('id',this.data.ln);
	        }
	        if(this.data.cl){
	            this.layerElement.setAttribute('class',this.data.cl);
	        }
	    }
	    if(this.data.ty === 0){
	            var cp = document.createElementNS(svgNS, 'clipPath');
	            var pt = document.createElementNS(svgNS,'path');
	            pt.setAttribute('d','M0,0 L'+this.data.w+',0'+' L'+this.data.w+','+this.data.h+' L0,'+this.data.h+'z');
	            var clipId = 'cp_'+randomString(8);
	            cp.setAttribute('id',clipId);
	            cp.appendChild(pt);
	            this.globalData.defs.appendChild(cp);
	        if(this.checkMasks()){
	            var cpGroup = document.createElementNS(svgNS,'g');
	            cpGroup.setAttribute('clip-path','url(' + locationHref + '#'+clipId+')');
	            cpGroup.appendChild(this.layerElement);
	            this.transformedElement = cpGroup;
	            if(layerElementParent){
	                layerElementParent.appendChild(this.transformedElement);
	            } else {
	                this.baseElement = this.transformedElement;
	            }
	        } else {
	            this.layerElement.setAttribute('clip-path','url(' + locationHref + '#'+clipId+')');
	        }
	        
	    }
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    if(this.layerElement !== this.parentContainer){
	        this.placeholder = null;
	    }
	    /* Todo performance killer
	    if(this.data.sy){
	        var filterID = 'st_'+randomString(10);
	        var c = this.data.sy[0].c.k;
	        var r = this.data.sy[0].s.k;
	        var expansor = document.createElementNS(svgNS,'filter');
	        expansor.setAttribute('id',filterID);
	        var feFlood = document.createElementNS(svgNS,'feFlood');
	        this.feFlood = feFlood;
	        if(!c[0].e){
	            feFlood.setAttribute('flood-color','rgb('+c[0]+','+c[1]+','+c[2]+')');
	        }
	        feFlood.setAttribute('result','base');
	        expansor.appendChild(feFlood);
	        var feMorph = document.createElementNS(svgNS,'feMorphology');
	        feMorph.setAttribute('operator','dilate');
	        feMorph.setAttribute('in','SourceGraphic');
	        feMorph.setAttribute('result','bigger');
	        this.feMorph = feMorph;
	        if(!r.length){
	            feMorph.setAttribute('radius',this.data.sy[0].s.k);
	        }
	        expansor.appendChild(feMorph);
	        var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	        feColorMatrix.setAttribute('result','mask');
	        feColorMatrix.setAttribute('in','bigger');
	        feColorMatrix.setAttribute('type','matrix');
	        feColorMatrix.setAttribute('values','0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0');
	        expansor.appendChild(feColorMatrix);
	        var feComposite = document.createElementNS(svgNS,'feComposite');
	        feComposite.setAttribute('result','drop');
	        feComposite.setAttribute('in','base');
	        feComposite.setAttribute('in2','mask');
	        feComposite.setAttribute('operator','in');
	        expansor.appendChild(feComposite);
	        var feBlend = document.createElementNS(svgNS,'feBlend');
	        feBlend.setAttribute('in','SourceGraphic');
	        feBlend.setAttribute('in2','drop');
	        feBlend.setAttribute('mode','normal');
	        expansor.appendChild(feBlend);
	        this.globalData.defs.appendChild(expansor);
	        var cont = document.createElementNS(svgNS,'g');
	        if(this.layerElement === this.parentContainer){
	            this.layerElement = cont;
	        }else{
	            cont.appendChild(this.layerElement);
	        }
	        cont.setAttribute('filter','url(#'+filterID+')');
	        if(this.data.td){
	            cont.setAttribute('data-td',this.data.td);
	        }
	        if(this.data.td == 3){
	            this.globalData.defs.appendChild(cont);
	        }else if(this.data.td == 2){
	            maskGrouper.appendChild(cont);
	        }else if(this.data.td == 1){
	            masker.appendChild(cont);
	        }else{
	            if(this.data.hasMask && this.data.tt){
	                this.matteElement.appendChild(cont);
	            }else{
	                this.appendNodeToParent(cont);
	            }
	        }
	    }*/
	    if(this.data.ef){
	        this.effectsManager = new SVGEffects(this);
	    }
	    this.checkParenting();
	};


	SVGBaseElement.prototype.setBlendMode = BaseElement.prototype.setBlendMode;

	SVGBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3 || this.data.hd || !this.isVisible){
	        return false;
	    }

	    this.lastNum = this.currentFrameNum;
	    this.finalTransform.opMdf = this.firstFrame || this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.firstFrame || this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i = 0, len = this.hierarchy.length;
	        if(!this.finalTransform.matMdf) {
	            while(i < len) {
	                if(this.hierarchy[i].finalTransform.mProp.mdf) {
	                    this.finalTransform.matMdf = true;
	                    break;
	                }
	                i += 1;
	            }
	        }
	        
	        if(this.finalTransform.matMdf) {
	            mat = this.finalTransform.mProp.v.props;
	            finalMat.cloneFromProps(mat);
	            for(i=0;i<len;i+=1){
	                mat = this.hierarchy[i].finalTransform.mProp.v.props;
	                finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	            }
	        }
	        
	    }else if(this.isVisible){
	        finalMat = this.finalTransform.mProp.v;
	    }
	    if(this.finalTransform.matMdf && this.layerElement){
	        this.transformedElement.setAttribute('transform',finalMat.to2dCSS());
	    }
	    if(this.finalTransform.opMdf && this.layerElement){
	        if(this.finalTransform.op.v <= 0) {
	            if(!this.isTransparent && this.globalData.renderConfig.hideOnTransparent){
	                this.isTransparent = true;
	                this.hide();
	            }
	        } else if(this.hidden && this.isTransparent){
	            this.isTransparent = false;
	            this.show();
	        }
	        this.transformedElement.setAttribute('opacity',this.finalTransform.op.v);
	    }

	    if(this.data.hasMask){
	        this.maskManager.renderFrame(finalMat);
	    }
	    if(this.effectsManager){
	        this.effectsManager.renderFrame(this.firstFrame);
	    }
	    return this.isVisible;
	};

	SVGBaseElement.prototype.destroy = function(){
	    this.layerElement = null;
	    this.parentContainer = null;
	    if(this.matteElement) {
	        this.matteElement = null;
	    }
	    if(this.maskManager) {
	        this.maskManager.destroy();
	    }
	};

	SVGBaseElement.prototype.getBaseElement = function(){
	    return this.baseElement;
	};
	SVGBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new MaskElement(data,this,this.globalData);
	};

	SVGBaseElement.prototype.setMatte = function(id){
	    if(!this.matteElement){
	        return;
	    }
	    this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
	};

	SVGBaseElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.layerElement.style.display = 'none';
	        this.hidden = true;
	    }
	};

	SVGBaseElement.prototype.show = function(){
	    if(this.isVisible && !this.isTransparent){
	        this.hidden = false;
	        this.layerElement.style.display = 'block';
	    }
	};

	function IShapeElement(data,parentContainer,globalData,comp, placeholder){
	    this.shapes = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.itemsData = [];
	    this.prevViewData = [];
	    this.shapeModifiers = [];
	    this.processedElements = [];
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, IShapeElement);

	IShapeElement.prototype.identityMatrix = new Matrix();

	IShapeElement.prototype.lcEnum = {
	    '1': 'butt',
	    '2': 'round',
	    '3': 'square'
	}

	IShapeElement.prototype.ljEnum = {
	    '1': 'miter',
	    '2': 'round',
	    '3': 'butt'
	}

	IShapeElement.prototype.searchProcessedElement = function(elem){
	    var i = this.processedElements.length;
	    while(i){
	        i -= 1;
	        if(this.processedElements[i].elem === elem){
	            return this.processedElements[i].pos;
	        }
	    }
	    return 0;
	};

	IShapeElement.prototype.addProcessedElement = function(elem, pos){
	    var i = this.processedElements.length;
	    while(i){
	        i -= 1;
	        if(this.processedElements[i].elem === elem){
	            this.processedElements[i].pos = pos;
	            break;
	        }
	    }
	    if(i === 0){
	        this.processedElements.push({
	            elem: elem,
	            pos: pos
	        })
	    }
	};

	IShapeElement.prototype.buildExpressionInterface = function(){};

	IShapeElement.prototype.createElements = function(){
	    //TODO check if I can use symbol so i can set its viewBox
	    this._parent.createElements.call(this);
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement,this.dynamicProperties, 0, [], true);
	    if(!this.data.hd || this.data.td){
	        styleUnselectableDiv(this.layerElement);
	    }
	};

	IShapeElement.prototype.setGradientData = function(pathElement,arr,data){

	    var gradientId = 'gr_'+randomString(10);
	    var gfill;
	    if(arr.t === 1){
	        gfill = document.createElementNS(svgNS,'linearGradient');
	    } else {
	        gfill = document.createElementNS(svgNS,'radialGradient');
	    }
	    gfill.setAttribute('id',gradientId);
	    gfill.setAttribute('spreadMethod','pad');
	    gfill.setAttribute('gradientUnits','userSpaceOnUse');
	    var stops = [];
	    var stop, j, jLen;
	    jLen = arr.g.p*4;
	    for(j=0;j<jLen;j+=4){
	        stop = document.createElementNS(svgNS,'stop');
	        gfill.appendChild(stop);
	        stops.push(stop);
	    }
	    pathElement.setAttribute( arr.ty === 'gf' ? 'fill':'stroke','url(#'+gradientId+')');
	    this.globalData.defs.appendChild(gfill);
	    data.gf = gfill;
	    data.cst = stops;
	}

	IShapeElement.prototype.setGradientOpacity = function(arr, data, styleOb){
	    if((arr.g.k.k[0].s && arr.g.k.k[0].s.length > arr.g.p*4) || arr.g.k.k.length > arr.g.p*4){
	        var opFill;
	        var stop, j, jLen;
	        var mask = document.createElementNS(svgNS,"mask");
	        var maskElement = document.createElementNS(svgNS, 'path');
	        mask.appendChild(maskElement);
	        var opacityId = 'op_'+randomString(10);
	        var maskId = 'mk_'+randomString(10);
	        mask.setAttribute('id',maskId);
	        if(arr.t === 1){
	            opFill = document.createElementNS(svgNS,'linearGradient');
	        } else {
	            opFill = document.createElementNS(svgNS,'radialGradient');
	        }
	        opFill.setAttribute('id',opacityId);
	        opFill.setAttribute('spreadMethod','pad');
	        opFill.setAttribute('gradientUnits','userSpaceOnUse');
	        jLen = arr.g.k.k[0].s ? arr.g.k.k[0].s.length : arr.g.k.k.length;
	        var stops = [];
	        for(j=arr.g.p*4;j<jLen;j+=2){
	            stop = document.createElementNS(svgNS,'stop');
	            stop.setAttribute('stop-color','rgb(255,255,255)');
	            //stop.setAttribute('offset',Math.round(arr.y[j][0]*100)+'%');
	            //stop.setAttribute('style','stop-color:rgb(255,255,255);stop-opacity:'+arr.y[j][1]);
	            opFill.appendChild(stop);
	            stops.push(stop);
	        }
	        maskElement.setAttribute( arr.ty === 'gf' ? 'fill':'stroke','url(#'+opacityId+')');
	        this.globalData.defs.appendChild(opFill);
	        this.globalData.defs.appendChild(mask);
	        data.of = opFill;
	        data.ost = stops;
	        styleOb.msElem = maskElement;
	        return maskId;
	    }
	};

	IShapeElement.prototype.createStyleElement = function(data, level, dynamicProperties){
	    var elementData = {
	    };
	    var styleOb = {
	        data: data,
	        type: data.ty,
	        d: '',
	        ld: '',
	        lvl: level,
	        mdf: false,
	        closed: false
	    };
	    var pathElement = document.createElementNS(svgNS, "path");
	    elementData.o = PropertyFactory.getProp(this,data.o,0,0.01,dynamicProperties);
	    if(data.ty == 'st' || data.ty == 'gs') {
	        pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');
	        ////pathElement.style.strokeLinecap = this.lcEnum[data.lc] || 'round';
	        pathElement.setAttribute('stroke-linejoin',this.ljEnum[data.lj] || 'round');
	        ////pathElement.style.strokeLinejoin = this.ljEnum[data.lj] || 'round';
	        pathElement.setAttribute('fill-opacity','0');
	        ////pathElement.style.fillOpacity = 0;
	        if(data.lj == 1) {
	            pathElement.setAttribute('stroke-miterlimit',data.ml);
	            ////pathElement.style.strokeMiterlimit = data.ml;
	        }

	        elementData.w = PropertyFactory.getProp(this,data.w,0,null,dynamicProperties);
	        if(data.d){
	            var d = PropertyFactory.getDashProp(this,data.d,'svg',dynamicProperties);
	            if(!d.k){
	                pathElement.setAttribute('stroke-dasharray', d.dasharray);
	                ////pathElement.style.strokeDasharray = d.dasharray;
	                pathElement.setAttribute('stroke-dashoffset', d.dashoffset);
	                ////pathElement.style.strokeDashoffset = d.dashoffset;
	            }
	            elementData.d = d;
	        }

	    }
	    if(data.ty == 'fl' || data.ty == 'st'){
	        elementData.c = PropertyFactory.getProp(this,data.c,1,255,dynamicProperties);
	    } else {
	        elementData.g = PropertyFactory.getGradientProp(this,data.g,dynamicProperties);
	        if(data.t == 2){
	            elementData.h = PropertyFactory.getProp(this,data.h,0,0.01,dynamicProperties);
	            elementData.a = PropertyFactory.getProp(this,data.a,0,degToRads,dynamicProperties);
	        }
	        elementData.s = PropertyFactory.getProp(this,data.s,1,null,dynamicProperties);
	        elementData.e = PropertyFactory.getProp(this,data.e,1,null,dynamicProperties);
	        this.setGradientData(pathElement,data,elementData, styleOb);
	        var maskId = this.setGradientOpacity(data,elementData, styleOb);
	        if(maskId){
	            pathElement.setAttribute('mask','url(#'+maskId+')');
	        }
	    }
	    elementData.elem = pathElement;
	    //container.appendChild(pathElement);
	    if(data.r === 2) {
	        pathElement.setAttribute('fill-rule', 'evenodd');
	    }

	    if(data.ln){
	        pathElement.setAttribute('id',data.ln);
	    }
	    if(data.cl){
	        pathElement.setAttribute('class',data.cl);
	    }
	    styleOb.pElem = pathElement;
	    this.stylesList.push(styleOb);
	    elementData.style = styleOb;
	    return elementData;
	}

	IShapeElement.prototype.createGroupElement = function(data) {
	    var elementData = {
	        it: [],
	        prevViewData: []
	    };
	    var g = document.createElementNS(svgNS,'g');
	    elementData.gr = g;
	    if(data.ln){
	        elementData.gr.setAttribute('id',data.ln);
	    }
	    return elementData;
	}

	IShapeElement.prototype.createTransformElement = function(data, dynamicProperties) {
	    var elementData = {
	        transform : {
	            op: PropertyFactory.getProp(this,data.o,0,0.01,dynamicProperties),
	            mProps: PropertyFactory.getProp(this,data,2,null,dynamicProperties)
	        },
	        elements: []
	    };
	    return elementData;
	}

	IShapeElement.prototype.createShapeElement = function(data, ownTransformers, level, dynamicProperties) {
	    var elementData = {
	        elements : [],
	        caches:[],
	        styles : [],
	        transformers: ownTransformers,
	        lStr: ''
	    };
	    var ty = 4;
	    if(data.ty == 'rc'){
	        ty = 5;
	    }else if(data.ty == 'el'){
	        ty = 6;
	    }else if(data.ty == 'sr'){
	        ty = 7;
	    }
	    elementData.sh = ShapePropertyFactory.getShapeProp(this,data,ty,dynamicProperties);
	    elementData.lvl = level;
	    this.shapes.push(elementData.sh);
	    this.addShapeToModifiers(elementData);
	    return elementData;
	}

	var cont = 0;

	IShapeElement.prototype.setElementStyles = function(){
	    var j, jLen = this.stylesList.length;
	    var arr = [];
	    for(j=0;j<jLen;j+=1){
	        if(!this.stylesList[j].closed){
	            arr.push(this.stylesList[j]);
	        }
	    }
	    return arr;
	}

	IShapeElement.prototype.reloadShapes = function(){
	    this.firstFrame = true;
	    var i, len = this.itemsData.length;
	    for(i=0;i<len;i+=1){
	        this.prevViewData[i] = this.itemsData[i];
	    }
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement,this.dynamicProperties, 0, [], true);
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	    }
	    this.renderModifiers();
	}

	IShapeElement.prototype.searchShapes = function(arr,itemsData,prevViewData,container,dynamicProperties, level, transformers, render){
	    var ownTransformers = [].concat(transformers);
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownStyles = [], ownModifiers = [], styleOb, currentTransform, modifier, processedPos;
	    for(i=len;i>=0;i-=1){
	        processedPos = this.searchProcessedElement(arr[i]);
	        if(!processedPos){
	            arr[i]._render = render;
	        } else {
	            itemsData[i] = prevViewData[processedPos - 1];
	        }
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs'){
	            if(!processedPos){
	                itemsData[i] = this.createStyleElement(arr[i], level, dynamicProperties);
	            } else {
	                itemsData[i].style.closed = false;
	            }
	            if(arr[i]._render){
	                container.appendChild(itemsData[i].elem);
	            }
	            ownStyles.push(itemsData[i].style);
	        }else if(arr[i].ty == 'gr'){
	            if(!processedPos){
	                itemsData[i] = this.createGroupElement(arr[i]);
	            } else {
	                jLen = itemsData[i].it.length;
	                for(j=0;j<jLen;j+=1){
	                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
	                }
	            }
	            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,itemsData[i].gr,dynamicProperties, level + 1, ownTransformers, render);
	            if(arr[i]._render){
	                container.appendChild(itemsData[i].gr);
	            }
	        }else if(arr[i].ty == 'tr'){
	            if(!processedPos){
	                itemsData[i] = this.createTransformElement(arr[i], dynamicProperties);
	            }
	            currentTransform = itemsData[i].transform;
	            ownTransformers.push(currentTransform);
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            if(!processedPos){
	                itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level, dynamicProperties);
	            }
	            itemsData[i].elements = this.setElementStyles();

	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                modifier.init(this,arr[i],dynamicProperties);
	                itemsData[i] = modifier;
	                this.shapeModifiers.push(modifier);
	            } else {
	                modifier = itemsData[i];
	                modifier.closed = false;
	            }
	            ownModifiers.push(modifier);
	        }else if(arr[i].ty == 'rp'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                itemsData[i] = modifier;
	                modifier.init(this,arr,i,itemsData,dynamicProperties);
	                this.shapeModifiers.push(modifier);
	                render = false;
	            }else{
	                modifier = itemsData[i];
	                modifier.closed = true;
	            }
	            ownModifiers.push(modifier);
	        }
	        this.addProcessedElement(arr[i], i + 1);
	    }
	    len = ownStyles.length;
	    for(i=0;i<len;i+=1){
	        ownStyles[i].closed = true;
	    }
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};

	IShapeElement.prototype.addShapeToModifiers = function(data) {
	    var i, len = this.shapeModifiers.length;
	    for(i=0;i<len;i+=1){
	        this.shapeModifiers[i].addShape(data);
	    }
	};

	IShapeElement.prototype.renderModifiers = function() {
	    if(!this.shapeModifiers.length){
	        return;
	    }
	    var i, len = this.shapes.length;
	    for(i=0;i<len;i+=1){
	        this.shapes[i].reset();
	    }


	    len = this.shapeModifiers.length;

	    for(i=len-1;i>=0;i-=1){
	        this.shapeModifiers[i].processShapes(this.firstFrame);
	    }
	};

	IShapeElement.prototype.renderFrame = function(parentMatrix){
	    //this.reloadShapes();
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.layerElement.style.display = 'block';
	        this.hidden = false;
	    }
	    this.renderModifiers();
	    var i, len = this.stylesList.length;
	    for(i=0;i<len;i+=1){
	        this.stylesList[i].d = '';
	        this.stylesList[i].mdf = false;
	    }
	    this.renderShape(this.shapesData,this.itemsData, null);

	    for (i = 0; i < len; i += 1) {
	        if (this.stylesList[i].ld === '0') {
	            this.stylesList[i].ld = '1';
	            this.stylesList[i].pElem.style.display = 'block';
	            //this.stylesList[i].parent.appendChild(this.stylesList[i].pElem);
	        }
	        if (this.stylesList[i].mdf || this.firstFrame) {
	            this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d);
	            if(this.stylesList[i].msElem){
	                this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
	            }
	        }
	    }
	    if (this.firstFrame) {
	        this.firstFrame = false;
	    }
	};

	IShapeElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.layerElement.style.display = 'none';
	        var i, len = this.stylesList.length;
	        for(i=len-1;i>=0;i-=1){
	            if(this.stylesList[i].ld !== '0'){
	                this.stylesList[i].ld = '0';
	                this.stylesList[i].pElem.style.display = 'none';
	                if(this.stylesList[i].pElem.parentNode){
	                    this.stylesList[i].parent = this.stylesList[i].pElem.parentNode;
	                    //this.stylesList[i].pElem.parentNode.removeChild(this.stylesList[i].pElem);
	                }
	            }
	        }
	        this.hidden = true;
	    }
	};

	IShapeElement.prototype.renderShape = function(items,data, container){
	    var i, len = items.length - 1;
	    var ty;
	    for(i=len;i>=0;i-=1){
	        ty = items[i].ty;
	        if(ty == 'tr'){
	            if(this.firstFrame || data[i].transform.op.mdf && container){
	                container.setAttribute('opacity',data[i].transform.op.v);
	            }
	            if(this.firstFrame || data[i].transform.mProps.mdf && container){
	                container.setAttribute('transform',data[i].transform.mProps.v.to2dCSS());
	            }
	        }else if(ty == 'sh' || ty == 'el' || ty == 'rc' || ty == 'sr'){
	            this.renderPath(items[i],data[i]);
	        }else if(ty == 'fl'){
	            this.renderFill(items[i],data[i]);
	        }else if(ty == 'gf'){
	            this.renderGradient(items[i],data[i]);
	        }else if(ty == 'gs'){
	            this.renderGradient(items[i],data[i]);
	            this.renderStroke(items[i],data[i]);
	        }else if(ty == 'st'){
	            this.renderStroke(items[i],data[i]);
	        }else if(ty == 'gr'){
	            this.renderShape(items[i].it,data[i].it, data[i].gr);
	        }else if(ty == 'tm'){
	            //
	        }
	    }

	};

	IShapeElement.prototype.buildShapeString = function(pathNodes, length, closed, mat) {
	    var i, shapeString = '';
	    for(i = 1; i < length; i += 1) {
	        if (i === 1) {
	            shapeString += " M" + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	        }
	        shapeString += " C" + mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + mat.applyToPointStringified(pathNodes.i[i][0], pathNodes.i[i][1]) + " " + mat.applyToPointStringified(pathNodes.v[i][0], pathNodes.v[i][1]);
	    }
	    if (length === 1) {
	        shapeString += " M" + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	    }
	    if (closed && length) {
	        shapeString += " C" + mat.applyToPointStringified(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1]) + " " + mat.applyToPointStringified(pathNodes.i[0][0], pathNodes.i[0][1]) + " " + mat.applyToPointStringified(pathNodes.v[0][0], pathNodes.v[0][1]);
	        shapeString += 'z';
	    }
	    return shapeString;
	};

	IShapeElement.prototype.renderPath = function(pathData,itemData){
	    var len, i, j, jLen,pathStringTransformed,redraw,pathNodes,l, lLen = itemData.elements.length;
	    var lvl = itemData.lvl;
	    if(!pathData._render){
	        return;
	    }
	    for(l=0;l<lLen;l+=1){
	        if(itemData.elements[l].data._render){
	            redraw = itemData.sh.mdf || this.firstFrame;
	            pathStringTransformed = 'M0 0';
	            var paths = itemData.sh.paths;
	            jLen = paths._length;
	            if(itemData.elements[l].lvl < lvl){
	                var mat = this.mHelper.reset(), props;
	                var iterations = lvl - itemData.elements[l].lvl;
	                var k = itemData.transformers.length-1;
	                while(iterations > 0) {
	                    redraw = itemData.transformers[k].mProps.mdf || redraw;
	                    props = itemData.transformers[k].mProps.v.props;
	                    mat.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	                    iterations --;
	                    k --;
	                }
	                if(redraw){
	                    for(j=0;j<jLen;j+=1){
	                        pathNodes = paths.shapes[j];
	                        if(pathNodes && pathNodes._length){
	                            pathStringTransformed += this.buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
	                        }
	                    }
	                    itemData.caches[l] = pathStringTransformed;
	                } else {
	                    pathStringTransformed = itemData.caches[l];
	                }
	            } else {
	                if(redraw){
	                    for(j=0;j<jLen;j+=1){
	                        pathNodes = paths.shapes[j];
	                        if(pathNodes && pathNodes._length){
	                            pathStringTransformed += this.buildShapeString(pathNodes, pathNodes._length, pathNodes.c, this.identityMatrix);
	                        }
	                    }
	                    itemData.caches[l] = pathStringTransformed;
	                } else {
	                    pathStringTransformed = itemData.caches[l];
	                }
	            }
	            itemData.elements[l].d += pathStringTransformed;
	            itemData.elements[l].mdf = redraw || itemData.elements[l].mdf;
	        } else {
	            itemData.elements[l].mdf = true;
	        }
	    }
	};

	IShapeElement.prototype.renderFill = function(styleData,itemData){
	    var styleElem = itemData.style;

	    if(itemData.c.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('fill','rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')');
	        ////styleElem.pElem.style.fill = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
	    }
	    if(itemData.o.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('fill-opacity',itemData.o.v);
	    }
	};

	IShapeElement.prototype.renderGradient = function(styleData,itemData){
	    var gfill = itemData.gf;
	    var opFill = itemData.of;
	    var pt1 = itemData.s.v,pt2 = itemData.e.v;

	    if(itemData.o.mdf || this.firstFrame){
	        var attr = styleData.ty === 'gf' ? 'fill-opacity':'stroke-opacity';
	        itemData.elem.setAttribute(attr,itemData.o.v);
	    }
	    //clippedElement.setAttribute('transform','matrix(1,0,0,1,-100,0)');
	    if(itemData.s.mdf || this.firstFrame){
	        var attr1 = styleData.t === 1 ? 'x1':'cx';
	        var attr2 = attr1 === 'x1' ? 'y1':'cy';
	        gfill.setAttribute(attr1,pt1[0]);
	        gfill.setAttribute(attr2,pt1[1]);
	        if(opFill){
	            opFill.setAttribute(attr1,pt1[0]);
	            opFill.setAttribute(attr2,pt1[1]);
	        }
	    }
	    var stops, i, len, stop;
	    if(itemData.g.cmdf || this.firstFrame){
	        stops = itemData.cst;
	        var cValues = itemData.g.c;
	        len = stops.length;
	        for(i=0;i<len;i+=1){
	            stop = stops[i];
	            stop.setAttribute('offset',cValues[i*4]+'%');
	            stop.setAttribute('stop-color','rgb('+cValues[i*4+1]+','+cValues[i*4+2]+','+cValues[i*4+3]+')');
	        }
	    }
	    if(opFill && (itemData.g.omdf || this.firstFrame)){
	        stops = itemData.ost;
	        var oValues = itemData.g.o;
	        len = stops.length;
	        for(i=0;i<len;i+=1){
	            stop = stops[i];
	            stop.setAttribute('offset',oValues[i*2]+'%');
	            stop.setAttribute('stop-opacity',oValues[i*2+1]);
	        }
	    }
	    if(styleData.t === 1){
	        if(itemData.e.mdf  || this.firstFrame){
	            gfill.setAttribute('x2',pt2[0]);
	            gfill.setAttribute('y2',pt2[1]);
	            if(opFill){
	                opFill.setAttribute('x2',pt2[0]);
	                opFill.setAttribute('y2',pt2[1]);
	            }
	        }
	    } else {
	        var rad;
	        if(itemData.s.mdf || itemData.e.mdf || this.firstFrame){
	            rad = Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));
	            gfill.setAttribute('r',rad);
	            if(opFill){
	                opFill.setAttribute('r',rad);
	            }
	        }
	        if(itemData.e.mdf || itemData.h.mdf || itemData.a.mdf || this.firstFrame){
	            if(!rad){
	                rad = Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));
	            }
	            var ang = Math.atan2(pt2[1]-pt1[1], pt2[0]-pt1[0]);

	            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99:itemData.h.v;
	            var dist = rad*percent;
	            var x = Math.cos(ang + itemData.a.v)*dist + pt1[0];
	            var y = Math.sin(ang + itemData.a.v)*dist + pt1[1];
	            gfill.setAttribute('fx',x);
	            gfill.setAttribute('fy',y);
	            if(opFill){
	                opFill.setAttribute('fx',x);
	                opFill.setAttribute('fy',y);
	            }
	        }
	        //gfill.setAttribute('fy','200');
	    }
	};

	IShapeElement.prototype.renderStroke = function(styleData,itemData){
	    var styleElem = itemData.style;
	    //TODO fix dashes
	    var d = itemData.d;
	    var dasharray,dashoffset;
	    if(d && d.k && (d.mdf || this.firstFrame)){
	        styleElem.pElem.setAttribute('stroke-dasharray', d.dasharray);
	        ////styleElem.pElem.style.strokeDasharray = d.dasharray;
	        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset);
	        ////styleElem.pElem.style.strokeDashoffset = d.dashoffset;
	    }
	    if(itemData.c && (itemData.c.mdf || this.firstFrame)){
	        styleElem.pElem.setAttribute('stroke','rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')');
	        ////styleElem.pElem.style.stroke = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
	    }
	    if(itemData.o.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('stroke-opacity',itemData.o.v);
	    }
	    if(itemData.w.mdf || this.firstFrame){
	        styleElem.pElem.setAttribute('stroke-width',itemData.w.v);
	        if(styleElem.msElem){
	            styleElem.msElem.setAttribute('stroke-width',itemData.w.v);
	        }
	        ////styleElem.pElem.style.strokeWidth = itemData.w.v;
	    }
	};

	IShapeElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    this.shapeData = null;
	    this.itemsData = null;
	    this.parentContainer = null;
	    this.placeholder = null;
	};

	function ITextElement(data, animationItem,parentContainer,globalData){
	}
	ITextElement.prototype.init = function(){
	    this.lettersChangedFlag = true;
	    this.dynamicProperties = this.dynamicProperties || [];
	    this.textAnimator = new TextAnimatorProperty(this.data.t, this.renderType, this);
	    this.textProperty = new TextProperty(this, this.data.t, this.dynamicProperties);
	    this._parent.init.call(this);
	    this.textAnimator.searchProperties(this.dynamicProperties);
	};

	ITextElement.prototype.prepareFrame = function(num) {
	    this._parent.prepareFrame.call(this, num);
	    if(this.textProperty.mdf || this.textProperty.firstFrame) {
	        this.buildNewText();
	        this.textProperty.firstFrame = false;
	    }
	}

	ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
	    var j,jLen = shapes.length;
	    var k, kLen, pathNodes;
	    var shapeStr = '';
	    for(j=0;j<jLen;j+=1){
	        pathNodes = shapes[j].ks.k;
	        shapeStr += this.buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
	    }
	    return shapeStr;
	};

	ITextElement.prototype.updateDocumentData = function(newData, index) {
	    this.textProperty.updateDocumentData(newData, index);
	}

	ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
	    if(documentData.ps){
	        matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	    }
	    matrixHelper.translate(0,-documentData.ls,0);
	    switch(documentData.j){
	        case 1:
	            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]),0,0);
	            break;
	        case 2:
	            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber] )/2,0,0);
	            break;
	    }
	    matrixHelper.translate(xPos, yPos, 0);
	}

	ITextElement.prototype.buildColor = function(colorData) {
	    return 'rgb(' + Math.round(colorData[0]*255) + ',' + Math.round(colorData[1]*255) + ',' + Math.round(colorData[2]*255) + ')';
	}

	ITextElement.prototype.buildShapeString = IShapeElement.prototype.buildShapeString;

	ITextElement.prototype.emptyProp = new LetterProps();

	ITextElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	};
	function SVGTextElement(data,parentContainer,globalData,comp, placeholder){
	    this.textSpans = [];
	    this.renderType = 'svg';
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, SVGTextElement);

	extendPrototype(ITextElement, SVGTextElement);

	SVGTextElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);


	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }
	    if (this.data.singleShape && !this.globalData.fontManager.chars) {
	        this.textContainer = document.createElementNS(svgNS,'text');
	    }
	};

	SVGTextElement.prototype.buildNewText = function(){
	    var i, len;

	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = Array.apply(null,{length:documentData ? documentData.l.length : 0});
	    if(documentData.fc) {
	        this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
	    }else{
	        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
	    }
	    if(documentData.sc){
	        this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
	        this.layerElement.setAttribute('stroke-width', documentData.sw);
	    }
	    this.layerElement.setAttribute('font-size', documentData.s);
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(fontData.fClass){
	        this.layerElement.setAttribute('class',fontData.fClass);
	    } else {
	        this.layerElement.setAttribute('font-family', fontData.fFamily);
	        var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	        this.layerElement.setAttribute('font-style', fStyle);
	        this.layerElement.setAttribute('font-weight', fWeight);
	    }

	    var letters = documentData.l || [];
	    var usesGlyphs = this.globalData.fontManager.chars;
	    len = letters.length;
	    if(!len){
	        return;
	    }
	    var tSpan;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '', singleShape = this.data.singleShape;
	    var xPos = 0, yPos = 0, firstLine = true;
	    var trackingOffset = documentData.tr/1000*documentData.s;
	    if(singleShape && !usesGlyphs) {
	        var tElement = this.textContainer;
	        var justify = '';
	        switch(documentData.j) {
	            case 1:
	                justify = 'end';
	                break;
	            case 2:
	                justify = 'middle';
	                break;
	            case 2:
	                justify = 'start';
	                break;
	        }
	        tElement.setAttribute('text-anchor',justify);
	        tElement.setAttribute('letter-spacing',trackingOffset);
	        var textContent = documentData.t.split(String.fromCharCode(13));
	        len = textContent.length;
	        var yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
	        for ( i = 0; i < len; i += 1) {
	            tSpan = this.textSpans[i] || document.createElementNS(svgNS,'tspan');
	            tSpan.textContent = textContent[i];
	            tSpan.setAttribute('x', 0);
	            tSpan.setAttribute('y', yPos);
	            tSpan.style.display = 'inherit';
	            tElement.appendChild(tSpan);
	            this.textSpans[i] = tSpan;
	            yPos += documentData.lh;
	        }
	        
	        this.layerElement.appendChild(tElement);
	    } else {
	        var cachedSpansLength = this.textSpans.length;
	        var shapeData, charData;
	        for (i = 0; i < len; i += 1) {
	            if(!usesGlyphs || !singleShape || i === 0){
	                tSpan = cachedSpansLength > i ? this.textSpans[i] : document.createElementNS(svgNS,usesGlyphs?'path':'text');
	                if (cachedSpansLength <= i) {
	                    tSpan.setAttribute('stroke-linecap', 'butt');
	                    tSpan.setAttribute('stroke-linejoin','round');
	                    tSpan.setAttribute('stroke-miterlimit','4');
	                    this.textSpans[i] = tSpan;
	                    this.layerElement.appendChild(tSpan);
	                }
	                tSpan.style.display = 'inherit';
	            }
	            
	            matrixHelper.reset();
	            if(usesGlyphs) {
	                matrixHelper.scale(documentData.s / 100, documentData.s / 100);
	                if (singleShape) {
	                    if(letters[i].n) {
	                        xPos = -trackingOffset;
	                        yPos += documentData.yOffset;
	                        yPos += firstLine ? 1 : 0;
	                        firstLine = false;
	                    }
	                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	                    xPos += letters[i].l || 0;
	                    //xPos += letters[i].val === ' ' ? 0 : trackingOffset;
	                    xPos += trackingOffset;
	                }
	                charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	                shapeData = charData && charData.data || {};
	                shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	                if(!singleShape){
	                    tSpan.setAttribute('d',this.createPathShape(matrixHelper,shapes));
	                } else {
	                    shapeStr += this.createPathShape(matrixHelper,shapes);
	                }
	            } else {
	                tSpan.textContent = letters[i].val;
	                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            }
	            //
	        }
	        if (singleShape) {
	            tSpan.setAttribute('d',shapeStr);
	        }
	    }
	    while (i < this.textSpans.length){
	        this.textSpans[i].style.display = 'none';
	        i += 1;
	    }
	    
	    this._sizeChanged = true;
	}

	SVGTextElement.prototype.sourceRectAtTime = function(time){
	    this.prepareFrame(this.comp.renderedFrame - this.data.st);
	    this.renderLetters();
	    if(this._sizeChanged){
	        this._sizeChanged = false;
	        var textBox = this.layerElement.getBBox();
	        this.bbox = {
	            top: textBox.y,
	            left: textBox.x,
	            width: textBox.width,
	            height: textBox.height
	        }
	    }
	    return this.bbox;
	}

	SVGTextElement.prototype.renderLetters = function(){

	    if(!this.data.singleShape){
	        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	        if(this.lettersChangedFlag || this.textAnimator.lettersChangedFlag){
	            this._sizeChanged = true;
	            var  i,len;
	            var renderedLetters = this.textAnimator.renderedLetters;

	            var letters = this.textProperty.currentData.l;

	            len = letters.length;
	            var renderedLetter, textSpan;
	            for(i=0;i<len;i+=1){
	                if(letters[i].n){
	                    continue;
	                }
	                renderedLetter = renderedLetters[i];
	                textSpan = this.textSpans[i];
	                if(renderedLetter.mdf.m) {
	                    textSpan.setAttribute('transform',renderedLetter.m);
	                }
	                if(renderedLetter.mdf.o) {
	                    textSpan.setAttribute('opacity',renderedLetter.o);
	                }
	                if(renderedLetter.mdf.sw){
	                    textSpan.setAttribute('stroke-width',renderedLetter.sw);
	                }
	                if(renderedLetter.mdf.sc){
	                    textSpan.setAttribute('stroke',renderedLetter.sc);
	                }
	                if(renderedLetter.mdf.fc){
	                    textSpan.setAttribute('fill',renderedLetter.fc);
	                }
	            }
	        }
	    }
	}

	SVGTextElement.prototype.renderFrame = function(parentMatrix){

	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.show();
	    }
	    if(this.firstFrame) {
	        this.firstFrame = false;
	    }
	    this.renderLetters();
	}
	function SVGTintFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f2');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	    if(filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k){
	        var feMerge = document.createElementNS(svgNS,'feMerge');
	        filter.appendChild(feMerge);
	        var feMergeNode;
	        feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	        feMergeNode.setAttribute('in','SourceGraphic');
	        feMerge.appendChild(feMergeNode);
	        feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	        feMergeNode.setAttribute('in','f2');
	        feMerge.appendChild(feMergeNode);
	    }
	}

	SVGTintFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var colorBlack = this.filterManager.effectElements[0].p.v;
	        var colorWhite = this.filterManager.effectElements[1].p.v;
	        var opacity = this.filterManager.effectElements[2].p.v/100;
	        this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGFillFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	}
	SVGFillFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var color = this.filterManager.effectElements[2].p.v;
	        var opacity = this.filterManager.effectElements[6].p.v;
	        this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');
	    }
	};
	function SVGStrokeEffect(elem, filterManager){
	    this.initialized = false;
	    this.filterManager = filterManager;
	    this.elem = elem;
	    this.paths = [];
	}

	SVGStrokeEffect.prototype.initialize = function(){

	    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	    var path,groupPath, i, len;
	    if(this.filterManager.effectElements[1].p.v === 1){
	        len = this.elem.maskManager.masksProperties.length;
	        i = 0;
	    } else {
	        i = this.filterManager.effectElements[0].p.v - 1;
	        len = i + 1;
	    }
	    groupPath = document.createElementNS(svgNS,'g'); 
	    groupPath.setAttribute('fill','none');
	    groupPath.setAttribute('stroke-linecap','round');
	    groupPath.setAttribute('stroke-dashoffset',1);
	    for(i;i<len;i+=1){
	        path = document.createElementNS(svgNS,'path');
	        groupPath.appendChild(path);
	        this.paths.push({p:path,m:i});
	    }
	    if(this.filterManager.effectElements[10].p.v === 3){
	        var mask = document.createElementNS(svgNS,'mask');
	        var id = 'stms_' + randomString(10);
	        mask.setAttribute('id',id);
	        mask.setAttribute('mask-type','alpha');
	        mask.appendChild(groupPath);
	        this.elem.globalData.defs.appendChild(mask);
	        var g = document.createElementNS(svgNS,'g');
	        g.setAttribute('mask','url(' + locationHref + '#'+id+')');
	        if(elemChildren[0]){
	            g.appendChild(elemChildren[0]);
	        }
	        this.elem.layerElement.appendChild(g);
	        this.masker = mask;
	        groupPath.setAttribute('stroke','#fff');
	    } else if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(this.filterManager.effectElements[10].p.v === 2){
	            var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	            while(elemChildren.length){
	                this.elem.layerElement.removeChild(elemChildren[0]);
	            }
	        }
	        this.elem.layerElement.appendChild(groupPath);
	        this.elem.layerElement.removeAttribute('mask');
	        groupPath.setAttribute('stroke','#fff');
	    }
	    this.initialized = true;
	    this.pathMasker = groupPath;
	}

	SVGStrokeEffect.prototype.renderFrame = function(forceRender){
	    if(!this.initialized){
	        this.initialize();
	    }
	    var i, len = this.paths.length;
	    var mask, path;
	    for(i=0;i<len;i+=1){
	        mask = this.elem.maskManager.viewData[this.paths[i].m];
	        path = this.paths[i].p;
	        if(forceRender || this.filterManager.mdf || mask.prop.mdf){
	            path.setAttribute('d',mask.lastPath);
	        }
	        if(forceRender || this.filterManager.effectElements[9].p.mdf || this.filterManager.effectElements[4].p.mdf || this.filterManager.effectElements[7].p.mdf || this.filterManager.effectElements[8].p.mdf || mask.prop.mdf){
	            var dasharrayValue;
	            if(this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100){
	                var s = Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var e = Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var l = path.getTotalLength();
	                dasharrayValue = '0 0 0 ' + l*s + ' ';
	                var lineLength = l*(e-s);
	                var segment = 1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	                var units = Math.floor(lineLength/segment);
	                var j;
	                for(j=0;j<units;j+=1){
	                    dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100 + ' ';
	                }
	                dasharrayValue += '0 ' + l*10 + ' 0 0';
	            } else {
	                dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	            }
	            path.setAttribute('stroke-dasharray',dasharrayValue);
	        }
	    }
	    if(forceRender || this.filterManager.effectElements[4].p.mdf){
	        this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);
	    }
	    
	    if(forceRender || this.filterManager.effectElements[6].p.mdf){
	        this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);
	    }
	    if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(forceRender || this.filterManager.effectElements[3].p.mdf){
	            var color = this.filterManager.effectElements[3].p.v;
	            this.pathMasker.setAttribute('stroke','rgb('+bm_floor(color[0]*255)+','+bm_floor(color[1]*255)+','+bm_floor(color[2]*255)+')');
	        }
	    }
	};
	function SVGTritoneFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = document.createElementNS(svgNS,'feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    var feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	    filter.appendChild(feComponentTransfer);
	    this.matrixFilter = feComponentTransfer;
	    var feFuncR = document.createElementNS(svgNS,'feFuncR');
	    feFuncR.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncR);
	    this.feFuncR = feFuncR;
	    var feFuncG = document.createElementNS(svgNS,'feFuncG');
	    feFuncG.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncG);
	    this.feFuncG = feFuncG;
	    var feFuncB = document.createElementNS(svgNS,'feFuncB');
	    feFuncB.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncB);
	    this.feFuncB = feFuncB;
	}

	SVGTritoneFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var color1 = this.filterManager.effectElements[0].p.v;
	        var color2 = this.filterManager.effectElements[1].p.v;
	        var color3 = this.filterManager.effectElements[2].p.v;
	        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0]
	        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1]
	        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2]
	        this.feFuncR.setAttribute('tableValues', tableR);
	        this.feFuncG.setAttribute('tableValues', tableG);
	        this.feFuncB.setAttribute('tableValues', tableB);
	        //var opacity = this.filterManager.effectElements[2].p.v/100;
	        //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGProLevelsFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var effectElements = this.filterManager.effectElements;
	    var feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    var feFuncR, feFuncG, feFuncB;
	    
	    if(effectElements[9].p.k || effectElements[9].p.v !== 0 || effectElements[10].p.k || effectElements[10].p.v !== 1 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 0 || effectElements[13].p.k || effectElements[13].p.v !== 1){
	        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
	    }
	    if(effectElements[16].p.k || effectElements[16].p.v !== 0 || effectElements[17].p.k || effectElements[17].p.v !== 1 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 0 || effectElements[20].p.k || effectElements[20].p.v !== 1){
	        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
	    }
	    if(effectElements[23].p.k || effectElements[23].p.v !== 0 || effectElements[24].p.k || effectElements[24].p.v !== 1 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 0 || effectElements[27].p.k || effectElements[27].p.v !== 1){
	        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	    if(effectElements[30].p.k || effectElements[30].p.v !== 0 || effectElements[31].p.k || effectElements[31].p.v !== 1 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 0 || effectElements[34].p.k || effectElements[34].p.v !== 1){
	        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
	    }
	    
	    if(this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA){
	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        feComponentTransfer = document.createElementNS(svgNS,'feComponentTransfer');
	    }

	    if(effectElements[2].p.k || effectElements[2].p.v !== 0 || effectElements[3].p.k || effectElements[3].p.v !== 1 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 0 || effectElements[6].p.k || effectElements[6].p.v !== 1){

	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
	        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
	        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	}

	SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
	    var feFunc = document.createElementNS(svgNS,type);
	    feFunc.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFunc);
	    return feFunc;
	};

	SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
	    var cnt = 0;
	    var segments = 256;
	    var perc;
	    var min = Math.min(inputBlack, inputWhite);
	    var max = Math.max(inputBlack, inputWhite);
	    var table = Array.call(null,{length:segments});
	    var colorValue;
	    var pos = 0;
	    var outputDelta = outputWhite - outputBlack; 
	    var inputDelta = inputWhite - inputBlack; 
	    while(cnt <= 256) {
	        perc = cnt/256;
	        if(perc <= min){
	            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
	        } else if(perc >= max){
	            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
	        } else {
	            colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
	        }
	        table[pos++] = colorValue;
	        cnt += 256/(segments-1);
	    }
	    return table.join(' ');
	};

	SVGProLevelsFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        var val, cnt, perc, bezier;
	        var effectElements = this.filterManager.effectElements;
	        if(this.feFuncRComposed && (forceRender || effectElements[2].p.mdf || effectElements[3].p.mdf || effectElements[4].p.mdf || effectElements[5].p.mdf || effectElements[6].p.mdf)){
	            val = this.getTableValue(effectElements[2].p.v,effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v);
	            this.feFuncRComposed.setAttribute('tableValues',val);
	            this.feFuncGComposed.setAttribute('tableValues',val);
	            this.feFuncBComposed.setAttribute('tableValues',val);
	        }

	        if(this.feFuncR && (forceRender || effectElements[9].p.mdf || effectElements[10].p.mdf || effectElements[11].p.mdf || effectElements[12].p.mdf || effectElements[13].p.mdf)){
	            val = this.getTableValue(effectElements[9].p.v,effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v);
	            this.feFuncR.setAttribute('tableValues',val);
	        }

	        if(this.feFuncG && (forceRender || effectElements[16].p.mdf || effectElements[17].p.mdf || effectElements[18].p.mdf || effectElements[19].p.mdf || effectElements[20].p.mdf)){
	            val = this.getTableValue(effectElements[16].p.v,effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v);
	            this.feFuncG.setAttribute('tableValues',val);
	        }

	        if(this.feFuncB && (forceRender || effectElements[23].p.mdf || effectElements[24].p.mdf || effectElements[25].p.mdf || effectElements[26].p.mdf || effectElements[27].p.mdf)){
	            val = this.getTableValue(effectElements[23].p.v,effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v);
	            this.feFuncB.setAttribute('tableValues',val);
	        }

	        if(this.feFuncA && (forceRender || effectElements[30].p.mdf || effectElements[31].p.mdf || effectElements[32].p.mdf || effectElements[33].p.mdf || effectElements[34].p.mdf)){
	            val = this.getTableValue(effectElements[30].p.v,effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v);
	            this.feFuncA.setAttribute('tableValues',val);
	        }
	        
	    }
	};
	function SVGDropShadowEffect(filter, filterManager){
	    /*<feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <!-- stdDeviation is how much to blur -->
	  <feOffset dx="2" dy="2" result="offsetblur"/> <!-- how much to offset -->
	  <feMerge> 
	    <feMergeNode/> <!-- this contains the offset blurred image -->
	    <feMergeNode in="SourceGraphic"/> <!-- this contains the element that the filter is applied to -->
	  </feMerge>*/
	  /*<feFlood flood-color="#3D4574" flood-opacity="0.5" result="offsetColor"/>*/
	    filter.setAttribute('x','-100%');
	    filter.setAttribute('y','-100%');
	    filter.setAttribute('width','400%');
	    filter.setAttribute('height','400%');
	    this.filterManager = filterManager;

	    var feGaussianBlur = document.createElementNS(svgNS,'feGaussianBlur');
	    feGaussianBlur.setAttribute('in','SourceAlpha');
	    feGaussianBlur.setAttribute('result','drop_shadow_1');
	    feGaussianBlur.setAttribute('stdDeviation','0');
	    this.feGaussianBlur = feGaussianBlur;
	    filter.appendChild(feGaussianBlur);

	    var feOffset = document.createElementNS(svgNS,'feOffset');
	    feOffset.setAttribute('dx','25');
	    feOffset.setAttribute('dy','0');
	    feOffset.setAttribute('in','drop_shadow_1');
	    feOffset.setAttribute('result','drop_shadow_2');
	    this.feOffset = feOffset;
	    filter.appendChild(feOffset);
	    var feFlood = document.createElementNS(svgNS,'feFlood');
	    feFlood.setAttribute('flood-color','#00ff00');
	    feFlood.setAttribute('flood-opacity','1');
	    feFlood.setAttribute('result','drop_shadow_3');
	    this.feFlood = feFlood;
	    filter.appendChild(feFlood);

	    var feComposite = document.createElementNS(svgNS,'feComposite');
	    feComposite.setAttribute('in','drop_shadow_3');
	    feComposite.setAttribute('in2','drop_shadow_2');
	    feComposite.setAttribute('operator','in');
	    feComposite.setAttribute('result','drop_shadow_4');
	    filter.appendChild(feComposite);


	    var feMerge = document.createElementNS(svgNS,'feMerge');
	    filter.appendChild(feMerge);
	    var feMergeNode;
	    feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	    feMerge.appendChild(feMergeNode);
	    feMergeNode = document.createElementNS(svgNS,'feMergeNode');
	    feMergeNode.setAttribute('in','SourceGraphic');
	    this.feMergeNode = feMergeNode;
	    this.feMerge = feMerge;
	    this.originalNodeAdded = false;
	    feMerge.appendChild(feMergeNode);
	}

	SVGDropShadowEffect.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager.mdf){
	        if(forceRender || this.filterManager.effectElements[4].p.mdf){
	            this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
	        }
	        if(forceRender || this.filterManager.effectElements[0].p.mdf){
	            var col = this.filterManager.effectElements[0].p.v;
	            this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));
	        }
	        if(forceRender || this.filterManager.effectElements[1].p.mdf){
	            this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);
	        }
	        if(forceRender || this.filterManager.effectElements[2].p.mdf || this.filterManager.effectElements[3].p.mdf){
	            var distance = this.filterManager.effectElements[3].p.v
	            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads
	            var x = distance * Math.cos(angle)
	            var y = distance * Math.sin(angle)
	            this.feOffset.setAttribute('dx', x);
	            this.feOffset.setAttribute('dy', y);
	        }
	        /*if(forceRender || this.filterManager.effectElements[5].p.mdf){
	            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
	                this.feMerge.removeChild(this.feMergeNode);
	                this.originalNodeAdded = false;
	            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
	                this.feMerge.appendChild(this.feMergeNode);
	                this.originalNodeAdded = true;
	            }
	        }*/
	    }
	};
	function SVGMatte3Effect(filterElem, filterManager, elem){
	    this.initialized = false;
	    this.filterManager = filterManager;
	    this.filterElem = filterElem;
	    this.elem = elem;
	    elem.matteElement = document.createElementNS(svgNS,'g');
	    elem.matteElement.appendChild(elem.layerElement);
	    elem.matteElement.appendChild(elem.transformedElement);
	    elem.baseElement = elem.matteElement;
	}

	SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
	    var masker = document.createElementNS(svgNS,'mask');
	    masker.setAttribute('id',mask.layerId);
	    masker.setAttribute('mask-type','alpha');
	    masker.appendChild(mask.layerElement);
	    elem.setMatte(mask.layerId);
	    mask.data.hd = false;
	    var defs = elem.globalData.defs;
	    defs.appendChild(masker);
	}

	SVGMatte3Effect.prototype.initialize = function() {
	    var ind = this.filterManager.effectElements[0].p.v;
	    var i = 0, len = this.elem.comp.elements.length;
	    while(i < len) {
	    	if(this.elem.comp.elements[i].data.ind === ind) {
	    		this.setElementAsMask(this.elem, this.elem.comp.elements[i]);
	    	}
	    	i += 1;
	    }
	    this.initialized = true;
	}

	SVGMatte3Effect.prototype.renderFrame = function() {
		if(!this.initialized) {
			this.initialize();
		}
	}
	function SVGEffects(elem){
	    var i, len = elem.data.ef.length;
	    var filId = randomString(10);
	    var fil = filtersFactory.createFilter(filId);
	    var count = 0;
	    this.filters = [];
	    var filterManager;
	    for(i=0;i<len;i+=1){
	        if(elem.data.ef[i].ty === 20){
	            count += 1;
	            filterManager = new SVGTintFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 21){
	            count += 1;
	            filterManager = new SVGFillFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 22){
	            filterManager = new SVGStrokeEffect(elem, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 23){
	            count += 1;
	            filterManager = new SVGTritoneFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 24){
	            count += 1;
	            filterManager = new SVGProLevelsFilter(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 25){
	            count += 1;
	            filterManager = new SVGDropShadowEffect(fil, elem.effects.effectElements[i]);
	            this.filters.push(filterManager);
	        }else if(elem.data.ef[i].ty === 28){
	            //count += 1;
	            filterManager = new SVGMatte3Effect(fil, elem.effects.effectElements[i], elem);
	            this.filters.push(filterManager);
	        }
	    }
	    if(count){
	        elem.globalData.defs.appendChild(fil);
	        elem.layerElement.setAttribute('filter','url(' + locationHref + '#'+filId+')');
	    }
	}

	SVGEffects.prototype.renderFrame = function(firstFrame){
	    var i, len = this.filters.length;
	    for(i=0;i<len;i+=1){
	        this.filters[i].renderFrame(firstFrame);
	    }
	};
	function ICompElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.layers = data.layers;
	    this.supports3d = true;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = this.layers ? Array.apply(null,{length:this.layers.length}) : [];
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.xt){
	        this.layerElement = document.createElementNS(svgNS,'g');
	        this.buildAllItems();
	    } else if(!globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	}
	createElement(SVGBaseElement, ICompElement);

	ICompElement.prototype.hide = function(){
	    if(!this.hidden){
	        this._parent.hide.call(this);
	        var i,len = this.elements.length;
	        for( i = 0; i < len; i+=1 ){
	            if(this.elements[i]){
	                this.elements[i].hide();
	            }
	        }
	    }
	};

	ICompElement.prototype.prepareFrame = function(num){
	    this._parent.prepareFrame.call(this,num);
	    if(this.isVisible===false && !this.data.xt){
	        return;
	    }

	    if(this.tm){
	        var timeRemapped = this.tm.v;
	        if(timeRemapped === this.data.op){
	            timeRemapped = this.data.op - 1;
	        }
	        this.renderedFrame = timeRemapped;
	    } else {
	        this.renderedFrame = num/this.data.sr;
	    }
	    var i,len = this.elements.length;
	    if(!this.completeLayers){
	        this.checkLayers(this.renderedFrame);
	    }
	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
	        }
	    }
	};

	ICompElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    var i,len = this.layers.length;
	    if(renderParent===false){
	        this.hide();
	        return;
	    }

	    if(this.hidden) {
	        this.show();
	    }
	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	ICompElement.prototype.setElements = function(elems){
	    this.elements = elems;
	};

	ICompElement.prototype.getElements = function(){
	    return this.elements;
	};

	ICompElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    var i,len = this.layers.length;
	    for( i = 0; i < len; i+=1 ){
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	};

	ICompElement.prototype.checkLayers = SVGRenderer.prototype.checkLayers;
	ICompElement.prototype.buildItem = SVGRenderer.prototype.buildItem;
	ICompElement.prototype.buildAllItems = SVGRenderer.prototype.buildAllItems;
	ICompElement.prototype.buildElementParenting = SVGRenderer.prototype.buildElementParenting;
	ICompElement.prototype.createItem = SVGRenderer.prototype.createItem;
	ICompElement.prototype.createImage = SVGRenderer.prototype.createImage;
	ICompElement.prototype.createComp = SVGRenderer.prototype.createComp;
	ICompElement.prototype.createSolid = SVGRenderer.prototype.createSolid;
	ICompElement.prototype.createShape = SVGRenderer.prototype.createShape;
	ICompElement.prototype.createText = SVGRenderer.prototype.createText;
	ICompElement.prototype.createBase = SVGRenderer.prototype.createBase;
	ICompElement.prototype.appendElementInPos = SVGRenderer.prototype.appendElementInPos;
	ICompElement.prototype.checkPendingElements = SVGRenderer.prototype.checkPendingElements;
	ICompElement.prototype.addPendingElement = SVGRenderer.prototype.addPendingElement;
	function IImageElement(data,parentContainer,globalData,comp,placeholder){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp,placeholder);
	}
	createElement(SVGBaseElement, IImageElement);

	IImageElement.prototype.createElements = function(){

	    var assetPath = this.globalData.getAssetsPath(this.assetData);

	    this._parent.createElements.call(this);

	    this.innerElem = document.createElementNS(svgNS,'image');
	    this.innerElem.setAttribute('width',this.assetData.w+"px");
	    this.innerElem.setAttribute('height',this.assetData.h+"px");
	    this.innerElem.setAttribute('preserveAspectRatio','xMidYMid slice');
	    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	    this.maskedElement = this.innerElem;
	    this.layerElement.appendChild(this.innerElem);
	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }

	};

	IImageElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.show();
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	IImageElement.prototype.destroy = function(){
	    this._parent.destroy.call(this._parent);
	    this.innerElem =  null;
	};
	function ISolidElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(SVGBaseElement, ISolidElement);

	ISolidElement.prototype.createElements = function(){
	    this._parent.createElements.call(this);

	    var rect = document.createElementNS(svgNS,'rect');
	    ////rect.style.width = this.data.sw;
	    ////rect.style.height = this.data.sh;
	    ////rect.style.fill = this.data.sc;
	    rect.setAttribute('width',this.data.sw);
	    rect.setAttribute('height',this.data.sh);
	    rect.setAttribute('fill',this.data.sc);
	    this.layerElement.appendChild(rect);
	    this.innerElem = rect;
	    if(this.data.ln){
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    if(this.data.cl){
	        this.layerElement.setAttribute('class',this.data.cl);
	    }
	};

	ISolidElement.prototype.renderFrame = IImageElement.prototype.renderFrame;
	ISolidElement.prototype.destroy = IImageElement.prototype.destroy;

	var animationManager = (function(){
	    var moduleOb = {};
	    var registeredAnimations = [];
	    var initTime = 0;
	    var len = 0;
	    var idled = true;
	    var playingAnimationsNum = 0;

	    function removeElement(ev){
	        var i = 0;
	        var animItem = ev.target;
	        while(i<len) {
	            if (registeredAnimations[i].animation === animItem) {
	                registeredAnimations.splice(i, 1);
	                i -= 1;
	                len -= 1;
	                if(!animItem.isPaused){
	                    subtractPlayingCount();
	                }
	            }
	            i += 1;
	        }
	    }

	    function registerAnimation(element, animationData){
	        if(!element){
	            return null;
	        }
	        var i=0;
	        while(i<len){
	            if(registeredAnimations[i].elem == element && registeredAnimations[i].elem !== null ){
	                return registeredAnimations[i].animation;
	            }
	            i+=1;
	        }
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, element);
	        animItem.setData(element, animationData);
	        return animItem;
	    }

	    function addPlayingCount(){
	        playingAnimationsNum += 1;
	        activate();
	    }

	    function subtractPlayingCount(){
	        playingAnimationsNum -= 1;
	        if(playingAnimationsNum === 0){
	            idled = true;
	        }
	    }

	    function setupAnimation(animItem, element){
	        animItem.addEventListener('destroy',removeElement);
	        animItem.addEventListener('_active',addPlayingCount);
	        animItem.addEventListener('_idle',subtractPlayingCount);
	        registeredAnimations.push({elem: element,animation:animItem});
	        len += 1;
	    }

	    function loadAnimation(params){
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, null);
	        animItem.setParams(params);
	        return animItem;
	    }


	    function setSpeed(val,animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setSpeed(val, animation);
	        }
	    }

	    function setDirection(val, animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setDirection(val, animation);
	        }
	    }

	    function play(animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.play(animation);
	        }
	    }

	    function moveFrame (value, animation) {
	        initTime = Date.now();
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.moveFrame(value,animation);
	        }
	    }

	    function resume(nowTime) {

	        var elapsedTime = nowTime - initTime;
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.advanceTime(elapsedTime);
	        }
	        initTime = nowTime;
	        if(!idled) {
	            window.requestAnimationFrame(resume);
	        }
	    }

	    function first(nowTime){
	        initTime = nowTime;
	        window.requestAnimationFrame(resume);
	    }

	    function pause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.pause(animation);
	        }
	    }

	    function goToAndStop(value,isFrame,animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);
	        }
	    }

	    function stop(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.stop(animation);
	        }
	    }

	    function togglePause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.togglePause(animation);
	        }
	    }

	    function destroy(animation) {
	        var i;
	        for(i=(len-1);i>=0;i-=1){
	            registeredAnimations[i].animation.destroy(animation);
	        }
	    }

	    function searchAnimations(animationData, standalone, renderer){
	        var animElements = document.getElementsByClassName('bodymovin');
	        var i, len = animElements.length;
	        for(i=0;i<len;i+=1){
	            if(renderer){
	                animElements[i].setAttribute('data-bm-type',renderer);
	            }
	            registerAnimation(animElements[i], animationData);
	        }
	        if(standalone && len === 0){
	            if(!renderer){
	                renderer = 'svg';
	            }
	            var body = document.getElementsByTagName('body')[0];
	            body.innerHTML = '';
	            var div = document.createElement('div');
	            div.style.width = '100%';
	            div.style.height = '100%';
	            div.setAttribute('data-bm-type',renderer);
	            body.appendChild(div);
	            registerAnimation(div, animationData);
	        }
	    }

	    function resize(){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.resize();
	        }
	    }

	    function start(){
	        window.requestAnimationFrame(first);
	    }

	    function activate(){
	        if(idled){
	            idled = false;
	            window.requestAnimationFrame(first);
	        }
	    }

	    //start();

	    setTimeout(start,0);

	    moduleOb.registerAnimation = registerAnimation;
	    moduleOb.loadAnimation = loadAnimation;
	    moduleOb.setSpeed = setSpeed;
	    moduleOb.setDirection = setDirection;
	    moduleOb.play = play;
	    moduleOb.moveFrame = moveFrame;
	    moduleOb.pause = pause;
	    moduleOb.stop = stop;
	    moduleOb.togglePause = togglePause;
	    moduleOb.searchAnimations = searchAnimations;
	    moduleOb.resize = resize;
	    moduleOb.start = start;
	    moduleOb.goToAndStop = goToAndStop;
	    moduleOb.destroy = destroy;
	    return moduleOb;
	}());

	var AnimationItem = function () {
	    this._cbs = [];
	    this.name = '';
	    this.path = '';
	    this.isLoaded = false;
	    this.currentFrame = 0;
	    this.currentRawFrame = 0;
	    this.totalFrames = 0;
	    this.frameRate = 0;
	    this.frameMult = 0;
	    this.playSpeed = 1;
	    this.playDirection = 1;
	    this.pendingElements = 0;
	    this.playCount = 0;
	    this.prerenderFramesFlag = true;
	    this.animationData = {};
	    this.layers = [];
	    this.assets = [];
	    this.isPaused = true;
	    this.autoplay = false;
	    this.loop = true;
	    this.renderer = null;
	    this.animationID = randomString(10);
	    this.scaleMode = 'fit';
	    this.assetsPath = '';
	    this.timeCompleted = 0;
	    this.segmentPos = 0;
	    this.subframeEnabled = subframeEnabled;
	    this.segments = [];
	    this.pendingSegment = false;
	    this._idle = true;
	    this.projectInterface = ProjectInterface();
	};

	AnimationItem.prototype.setParams = function(params) {
	    var self = this;
	    if(params.context){
	        this.context = params.context;
	    }
	    if(params.wrapper || params.container){
	        this.wrapper = params.wrapper || params.container;
	    }
	    var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';
	    switch(animType){
	        case 'canvas':
	            this.renderer = new CanvasRenderer(this, params.rendererSettings);
	            break;
	        case 'svg':
	            this.renderer = new SVGRenderer(this, params.rendererSettings);
	            break;
	        case 'hybrid':
	        case 'html':
	        default:
	            this.renderer = new HybridRenderer(this, params.rendererSettings);
	            break;
	    }
	    this.renderer.setProjectInterface(this.projectInterface);
	    this.animType = animType;

	    if(params.loop === '' || params.loop === null){
	    }else if(params.loop === false){
	        this.loop = false;
	    }else if(params.loop === true){
	        this.loop = true;
	    }else{
	        this.loop = parseInt(params.loop);
	    }
	    this.autoplay = 'autoplay' in params ? params.autoplay : true;
	    this.name = params.name ? params.name :  '';
	    this.prerenderFramesFlag = 'prerender' in params ? params.prerender : true;
	    this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments :  true;
	    if(params.animationData){
	        self.configAnimation(params.animationData);
	    }else if(params.path){
	        if(params.path.substr(-4) != 'json'){
	            if (params.path.substr(-1, 1) != '/') {
	                params.path += '/';
	            }
	            params.path += 'data.json';
	        }

	        var xhr = new XMLHttpRequest();
	        if(params.path.lastIndexOf('\\') != -1){
	            this.path = params.path.substr(0,params.path.lastIndexOf('\\')+1);
	        }else{
	            this.path = params.path.substr(0,params.path.lastIndexOf('/')+1);
	        }
	        this.assetsPath = params.assetsPath;
	        this.fileName = params.path.substr(params.path.lastIndexOf('/')+1);
	        this.fileName = this.fileName.substr(0,this.fileName.lastIndexOf('.json'));
	        xhr.open('GET', params.path, true);
	        xhr.send();
	        xhr.onreadystatechange = function () {
	            if (xhr.readyState == 4) {
	                if(xhr.status == 200){
	                    self.configAnimation(JSON.parse(xhr.responseText));
	                }else{
	                    try{
	                        var response = JSON.parse(xhr.responseText);
	                        self.configAnimation(response);
	                    }catch(err){
	                    }
	                }
	            }
	        };
	    }
	};

	AnimationItem.prototype.setData = function (wrapper, animationData) {
	    var params = {
	        wrapper: wrapper,
	        animationData: animationData ? (typeof animationData  === "object") ? animationData : JSON.parse(animationData) : null
	    };
	    var wrapperAttributes = wrapper.attributes;

	    params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value :  wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
	    params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value :  wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';

	    var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value :  wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value :  wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
	    if(loop === ''){
	    }else if(loop === 'false'){
	        params.loop = false;
	    }else if(loop === 'true'){
	        params.loop = true;
	    }else{
	        params.loop = parseInt(loop);
	    }
	    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value :  wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value :  wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
	    params.autoplay = autoplay !== "false";

	    params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value :  wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value :  '';
	    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value :  wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value :  wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';

	    if(prerender === 'false'){
	        params.prerender = false;
	    }
	    this.setParams(params);
	};

	AnimationItem.prototype.includeLayers = function(data) {
	    if(data.op > this.animationData.op){
	        this.animationData.op = data.op;
	        this.totalFrames = Math.floor(data.op - this.animationData.ip);
	        this.animationData.tf = this.totalFrames;
	    }
	    var layers = this.animationData.layers;
	    var i, len = layers.length;
	    var newLayers = data.layers;
	    var j, jLen = newLayers.length;
	    for(j=0;j<jLen;j+=1){
	        i = 0;
	        while(i<len){
	            if(layers[i].id == newLayers[j].id){
	                layers[i] = newLayers[j];
	                break;
	            }
	            i += 1;
	        }
	    }
	    if(data.chars || data.fonts){
	        this.renderer.globalData.fontManager.addChars(data.chars);
	        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
	    }
	    if(data.assets){
	        len = data.assets.length;
	        for(i = 0; i < len; i += 1){
	            this.animationData.assets.push(data.assets[i]);
	        }
	    }
	    //this.totalFrames = 50;
	    //this.animationData.tf = 50;
	    this.animationData.__complete = false;
	    dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	    this.renderer.includeLayers(data.layers);
	    if(expressionsPlugin){
	        expressionsPlugin.initExpressions(this);
	    }
	    this.renderer.renderFrame(null);
	    this.loadNextSegment();
	};

	AnimationItem.prototype.loadNextSegment = function() {
	    var segments = this.animationData.segments;
	    if(!segments || segments.length === 0 || !this.autoloadSegments){
	        this.trigger('data_ready');
	        this.timeCompleted = this.animationData.tf;
	        return;
	    }
	    var segment = segments.shift();
	    this.timeCompleted = segment.time * this.frameRate;
	    var xhr = new XMLHttpRequest();
	    var self = this;
	    var segmentPath = this.path+this.fileName+'_' + this.segmentPos + '.json';
	    this.segmentPos += 1;
	    xhr.open('GET', segmentPath, true);
	    xhr.send();
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState == 4) {
	            if(xhr.status == 200){
	                self.includeLayers(JSON.parse(xhr.responseText));
	            }else{
	                try{
	                    var response = JSON.parse(xhr.responseText);
	                    self.includeLayers(response);
	                }catch(err){
	                }
	            }
	        }
	    };
	};

	AnimationItem.prototype.loadSegments = function() {
	    var segments = this.animationData.segments;
	    if(!segments) {
	        this.timeCompleted = this.animationData.tf;
	    }
	    this.loadNextSegment();
	};

	AnimationItem.prototype.configAnimation = function (animData) {
	    var _this = this;
	    if(this.renderer && this.renderer.destroyed){
	        return;
	    }
	    //console.log(JSON.parse(JSON.stringify(animData)));
	    //animData.w = Math.round(animData.w/blitter);
	    //animData.h = Math.round(animData.h/blitter);
	    this.animationData = animData;
	    this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
	    this.animationData.tf = this.totalFrames;
	    this.renderer.configAnimation(animData);
	    if(!animData.assets){
	        animData.assets = [];
	    }
	    if(animData.comps) {
	        animData.assets = animData.assets.concat(animData.comps);
	        animData.comps = null;
	    }
	    this.renderer.searchExtraCompositions(animData.assets);

	    this.layers = this.animationData.layers;
	    this.assets = this.animationData.assets;
	    this.frameRate = this.animationData.fr;
	    this.firstFrame = Math.round(this.animationData.ip);
	    this.frameMult = this.animationData.fr / 1000;
	    this.trigger('config_ready');
	    this.imagePreloader = new ImagePreloader();
	    this.imagePreloader.setAssetsPath(this.assetsPath);
	    this.imagePreloader.setPath(this.path);
	    this.imagePreloader.loadAssets(animData.assets, function(err) {
	        if(!err) {
	            _this.trigger('loaded_images');
	        }
	    });
	    this.loadSegments();
	    this.updaFrameModifier();
	    if(this.renderer.globalData.fontManager){
	        this.waitForFontsLoaded();
	    }else{
	        dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	        this.checkLoaded();
	    }
	};

	AnimationItem.prototype.waitForFontsLoaded = (function(){
	    function checkFontsLoaded(){
	        if(this.renderer.globalData.fontManager.loaded){
	            dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	            //this.renderer.buildItems(this.animationData.layers);
	            this.checkLoaded();
	        }else{
	            setTimeout(checkFontsLoaded.bind(this),20);
	        }
	    }

	    return function(){
	        checkFontsLoaded.bind(this)();
	    }
	}());

	AnimationItem.prototype.addPendingElement = function () {
	    this.pendingElements += 1;
	}

	AnimationItem.prototype.elementLoaded = function () {
	    this.pendingElements--;
	    this.checkLoaded();
	};

	AnimationItem.prototype.checkLoaded = function () {
	    if (this.pendingElements === 0) {
	        if(expressionsPlugin){
	            expressionsPlugin.initExpressions(this);
	        }
	        this.renderer.initItems();
	        setTimeout(function(){
	            this.trigger('DOMLoaded');
	        }.bind(this),0);
	        this.isLoaded = true;
	        this.gotoFrame();
	        if(this.autoplay){
	            this.play();
	        }
	    }
	};

	AnimationItem.prototype.resize = function () {
	    this.renderer.updateContainerSize();
	};

	AnimationItem.prototype.setSubframe = function(flag){
	    this.subframeEnabled = flag ? true : false;
	}

	AnimationItem.prototype.gotoFrame = function () {
	    if(this.subframeEnabled){
	        this.currentFrame = this.currentRawFrame;
	    }else{
	        this.currentFrame = Math.floor(this.currentRawFrame);
	    }

	    if(this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted){
	        this.currentFrame = this.timeCompleted;
	    }
	    this.trigger('enterFrame');
	    this.renderFrame();
	};

	AnimationItem.prototype.renderFrame = function () {
	    if(this.isLoaded === false){
	        return;
	    }
	    //console.log('this.currentFrame:',this.currentFrame + this.firstFrame);
	    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
	};

	AnimationItem.prototype.play = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.isPaused = false;
	        if(this._idle){
	            this._idle = false;
	            this.trigger('_active');
	        }
	    }
	};

	AnimationItem.prototype.pause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === false){
	        this.isPaused = true;
	        if(!this.pendingSegment){
	            this._idle = true;
	            this.trigger('_idle');
	        }
	    }
	};

	AnimationItem.prototype.togglePause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.play();
	    }else{
	        this.pause();
	    }
	};

	AnimationItem.prototype.stop = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.pause();
	    this.currentFrame = this.currentRawFrame = 0;
	    this.playCount = 0;
	    this.gotoFrame();
	};

	AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(isFrame){
	        this.setCurrentRawFrameValue(value);
	    }else{
	        this.setCurrentRawFrameValue(value * this.frameModifier);
	    }
	    this.pause();
	};

	AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
	    this.goToAndStop(value, isFrame, name);
	    this.play();
	};

	AnimationItem.prototype.advanceTime = function (value) {
	    if(this.pendingSegment){
	        this.pendingSegment = false;
	        this.adjustSegment(this.segments.shift());
	        if(this.isPaused){
	            this.play();
	        }
	        return;
	    }
	    if (this.isPaused === true || this.isLoaded === false) {
	        return;
	    }
	    this.setCurrentRawFrameValue(this.currentRawFrame + value * this.frameModifier);
	};

	AnimationItem.prototype.updateAnimation = function (perc) {
	    this.setCurrentRawFrameValue(this.totalFrames * perc);
	};

	AnimationItem.prototype.moveFrame = function (value, name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.setCurrentRawFrameValue(this.currentRawFrame+value);
	};

	AnimationItem.prototype.adjustSegment = function(arr){
	    this.playCount = 0;
	    if(arr[1] < arr[0]){
	        if(this.frameModifier > 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(-1);
	            }
	        }
	        this.totalFrames = arr[0] - arr[1];
	        this.firstFrame = arr[1];
	        this.setCurrentRawFrameValue(this.totalFrames - 0.01);
	    } else if(arr[1] > arr[0]){
	        if(this.frameModifier < 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(1);
	            }
	        }
	        this.totalFrames = arr[1] - arr[0];
	        this.firstFrame = arr[0];
	        this.setCurrentRawFrameValue(0);
	    }
	    this.trigger('segmentStart');
	};
	AnimationItem.prototype.setSegment = function (init,end) {
	    var pendingFrame = -1;
	    if(this.isPaused) {
	        if (this.currentRawFrame + this.firstFrame < init) {
	            pendingFrame = init;
	        } else if (this.currentRawFrame + this.firstFrame > end) {
	            pendingFrame = end - init - 0.01;
	        }
	    }

	    this.firstFrame = init;
	    this.totalFrames = end - init;
	    if(pendingFrame !== -1) {
	        this.goToAndStop(pendingFrame,true);
	    }
	}

	AnimationItem.prototype.playSegments = function (arr,forceFlag) {
	    if(typeof arr[0] === 'object'){
	        var i, len = arr.length;
	        for(i=0;i<len;i+=1){
	            this.segments.push(arr[i]);
	        }
	    }else{
	        this.segments.push(arr);
	    }
	    if(forceFlag){
	        this.adjustSegment(this.segments.shift());
	    }
	    if(this.isPaused){
	        this.play();
	    }
	};

	AnimationItem.prototype.resetSegments = function (forceFlag) {
	    this.segments.length = 0;
	    this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
	    if(forceFlag){
	        this.adjustSegment(this.segments.shift());
	    }
	};
	AnimationItem.prototype.checkSegments = function(){
	    if(this.segments.length){
	        this.pendingSegment = true;
	    }
	}

	AnimationItem.prototype.remove = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.renderer.destroy();
	};

	AnimationItem.prototype.destroy = function (name) {
	    if((name && this.name != name) || (this.renderer && this.renderer.destroyed)){
	        return;
	    }
	    this.renderer.destroy();
	    this.trigger('destroy');
	    this._cbs = null;
	    this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;
	};

	AnimationItem.prototype.setCurrentRawFrameValue = function(value){
	    this.currentRawFrame = value;
	    //console.log(this.totalFrames);
	    if (this.currentRawFrame >= this.totalFrames) {
	        this.checkSegments();
	        if(this.loop === false){
	            this.currentRawFrame = this.totalFrames - 0.01;
	            this.gotoFrame();
	            this.pause();
	            this.trigger('complete');
	            return;
	        }else{
	            this.trigger('loopComplete');
	            this.playCount += 1;
	            if((this.loop !== true && this.playCount == this.loop) || this.pendingSegment){
	                this.currentRawFrame = this.totalFrames - 0.01;
	                this.gotoFrame();
	                this.pause();
	                this.trigger('complete');
	                return;
	            } else {
	                this.currentRawFrame = this.currentRawFrame % this.totalFrames;
	            }
	        }
	    } else if (this.currentRawFrame < 0) {
	        this.checkSegments();
	        this.playCount -= 1;
	        if(this.playCount < 0){
	            this.playCount = 0;
	        }
	        if(this.loop === false  || this.pendingSegment){
	            this.currentRawFrame = 0;
	            this.gotoFrame();
	            this.pause();
	            this.trigger('complete');
	            return;
	        }else{
	            this.trigger('loopComplete');
	            this.currentRawFrame = (this.totalFrames + this.currentRawFrame) % this.totalFrames;
	            this.gotoFrame();
	            return;
	        }
	    }

	    this.gotoFrame();
	};

	AnimationItem.prototype.setSpeed = function (val) {
	    this.playSpeed = val;
	    this.updaFrameModifier();
	};

	AnimationItem.prototype.setDirection = function (val) {
	    this.playDirection = val < 0 ? -1 : 1;
	    this.updaFrameModifier();
	};

	AnimationItem.prototype.updaFrameModifier = function () {
	    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
	};

	AnimationItem.prototype.getPath = function () {
	    return this.path;
	};

	AnimationItem.prototype.getAssetsPath = function (assetData) {
	    var path = '';
	    if(this.assetsPath){
	        var imagePath = assetData.p;
	        if(imagePath.indexOf('images/') !== -1){
	            imagePath = imagePath.split('/')[1];
	        }
	        path = this.assetsPath + imagePath;
	    } else {
	        path = this.path;
	        path += assetData.u ? assetData.u : '';
	        path += assetData.p;
	    }
	    return path;
	};

	AnimationItem.prototype.getAssetData = function (id) {
	    var i = 0, len = this.assets.length;
	    while (i < len) {
	        if(id == this.assets[i].id){
	            return this.assets[i];
	        }
	        i += 1;
	    }
	};

	AnimationItem.prototype.hide = function () {
	    this.renderer.hide();
	};

	AnimationItem.prototype.show = function () {
	    this.renderer.show();
	};

	AnimationItem.prototype.getAssets = function () {
	    return this.assets;
	};

	AnimationItem.prototype.trigger = function(name){
	    if(this._cbs && this._cbs[name]){
	        switch(name){
	            case 'enterFrame':
	                this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
	                break;
	            case 'loopComplete':
	                this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	                break;
	            case 'complete':
	                this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));
	                break;
	            case 'segmentStart':
	                this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	                break;
	            case 'destroy':
	                this.triggerEvent(name,new BMDestroyEvent(name,this));
	                break;
	            default:
	                this.triggerEvent(name);
	        }
	    }
	    if(name === 'enterFrame' && this.onEnterFrame){
	        this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
	    }
	    if(name === 'loopComplete' && this.onLoopComplete){
	        this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	    }
	    if(name === 'complete' && this.onComplete){
	        this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));
	    }
	    if(name === 'segmentStart' && this.onSegmentStart){
	        this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	    }
	    if(name === 'destroy' && this.onDestroy){
	        this.onDestroy.call(this,new BMDestroyEvent(name,this));
	    }
	};

	AnimationItem.prototype.addEventListener = _addEventListener;
	AnimationItem.prototype.removeEventListener = _removeEventListener;
	AnimationItem.prototype.triggerEvent = _triggerEvent;

	function CanvasRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.renderConfig = {
	        clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
	        context: (config && config.context) || null,
	        progressiveLoad: (config && config.progressiveLoad) || false,
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	        className: (config && config.className) || ''
	    };
	    this.renderConfig.dpr = (config && config.dpr) || 1;
	    if (this.animationItem.wrapper) {
	        this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
	    }
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.contextData = {
	        saved : Array.apply(null,{length:15}),
	        savedOp: Array.apply(null,{length:15}),
	        cArrPos : 0,
	        cTr : new Matrix(),
	        cO : 1
	    };
	    var i, len = 15;
	    for(i=0;i<len;i+=1){
	        this.contextData.saved[i] = Array.apply(null,{length:16});
	    }
	    this.elements = [];
	    this.pendingElements = [];
	    this.transformMat = new Matrix();
	    this.completeLayers = false;
	}
	extendPrototype(BaseRenderer,CanvasRenderer);

	CanvasRenderer.prototype.createBase = function (data) {
	    return new CVBaseElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createShape = function (data) {
	    return new CVShapeElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createText = function (data) {
	    return new CVTextElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createImage = function (data) {
	    return new CVImageElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createComp = function (data) {
	    return new CVCompElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.createSolid = function (data) {
	    return new CVSolidElement(data, this, this.globalData);
	};

	CanvasRenderer.prototype.ctxTransform = function(props){
	    if(props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0){
	        return;
	    }
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);
	        return;
	    }
	    this.transformMat.cloneFromProps(props);
	    this.transformMat.transform(this.contextData.cTr.props[0],this.contextData.cTr.props[1],this.contextData.cTr.props[2],this.contextData.cTr.props[3],this.contextData.cTr.props[4],this.contextData.cTr.props[5],this.contextData.cTr.props[6],this.contextData.cTr.props[7],this.contextData.cTr.props[8],this.contextData.cTr.props[9],this.contextData.cTr.props[10],this.contextData.cTr.props[11],this.contextData.cTr.props[12],this.contextData.cTr.props[13],this.contextData.cTr.props[14],this.contextData.cTr.props[15])
	    //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	    this.contextData.cTr.cloneFromProps(this.transformMat.props);
	    var trProps = this.contextData.cTr.props;
	    this.canvasContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);
	};

	CanvasRenderer.prototype.ctxOpacity = function(op){
	    if(op === 1){
	        return;
	    }
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
	        return;
	    }
	    this.contextData.cO *= op < 0 ? 0 : op;
	    this.canvasContext.globalAlpha = this.contextData.cO;
	};

	CanvasRenderer.prototype.reset = function(){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    this.contextData.cArrPos = 0;
	    this.contextData.cTr.reset();
	    this.contextData.cO = 1;
	};

	CanvasRenderer.prototype.save = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.save();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.save();
	    }
	    var props = this.contextData.cTr.props;
	    if(this.contextData.saved[this.contextData.cArrPos] === null || this.contextData.saved[this.contextData.cArrPos] === undefined){
	        this.contextData.saved[this.contextData.cArrPos] = new Array(16);
	    }
	    var i,arr = this.contextData.saved[this.contextData.cArrPos];
	    for(i=0;i<16;i+=1){
	        arr[i] = props[i];
	    }
	    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
	    this.contextData.cArrPos += 1;
	};

	CanvasRenderer.prototype.restore = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.restore();
	    }
	    this.contextData.cArrPos -= 1;
	    var popped = this.contextData.saved[this.contextData.cArrPos];
	    var i,arr = this.contextData.cTr.props;
	    for(i=0;i<16;i+=1){
	        arr[i] = popped[i];
	    }
	    this.canvasContext.setTransform(popped[0],popped[1],popped[4],popped[5],popped[12],popped[13]);
	    popped = this.contextData.savedOp[this.contextData.cArrPos];
	    this.contextData.cO = popped;
	    this.canvasContext.globalAlpha = popped;
	};

	CanvasRenderer.prototype.configAnimation = function(animData){
	    if(this.animationItem.wrapper){
	        this.animationItem.container = document.createElement('canvas');
	        this.animationItem.container.style.width = '100%';
	        this.animationItem.container.style.height = '100%';
	        //this.animationItem.container.style.transform = 'translate3d(0,0,0)';
	        //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';
	        this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = "0px 0px 0px";
	        this.animationItem.wrapper.appendChild(this.animationItem.container);
	        this.canvasContext = this.animationItem.container.getContext('2d');
	        if(this.renderConfig.className) {
	            this.animationItem.container.setAttribute('class', this.renderConfig.className);
	        }
	    }else{
	        this.canvasContext = this.renderConfig.context;
	    }
	    this.data = animData;
	    this.globalData.canvasContext = this.canvasContext;
	    this.globalData.renderer = this;
	    this.globalData.isDashed = false;
	    this.globalData.totalFrames = Math.floor(animData.tf);
	    this.globalData.compWidth = animData.w;
	    this.globalData.compHeight = animData.h;
	    this.globalData.frameRate = animData.fr;
	    this.globalData.frameId = 0;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.layers = animData.layers;
	    this.transformCanvas = {};
	    this.transformCanvas.w = animData.w;
	    this.transformCanvas.h = animData.h;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,document.body);
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.elementLoaded = this.animationItem.elementLoaded.bind(this.animationItem);
	    this.globalData.addPendingElement = this.animationItem.addPendingElement.bind(this.animationItem);
	    this.globalData.transformCanvas = this.transformCanvas;
	    this.elements = Array.apply(null,{length:animData.layers.length});

	    this.updateContainerSize();
	};

	CanvasRenderer.prototype.updateContainerSize = function () {
	    var elementWidth,elementHeight;
	    if(this.animationItem.wrapper && this.animationItem.container){
	        elementWidth = this.animationItem.wrapper.offsetWidth;
	        elementHeight = this.animationItem.wrapper.offsetHeight;
	        this.animationItem.container.setAttribute('width',elementWidth * this.renderConfig.dpr );
	        this.animationItem.container.setAttribute('height',elementHeight * this.renderConfig.dpr);
	    }else{
	        elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
	        elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
	    }
	    var elementRel,animationRel;
	    if(this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1){
	        var par = this.renderConfig.preserveAspectRatio.split(' ');
	        var fillType = par[1] || 'meet';
	        var pos = par[0] || 'xMidYMid';
	        var xPos = pos.substr(0,4);
	        var yPos = pos.substr(4);
	        elementRel = elementWidth/elementHeight;
	        animationRel = this.transformCanvas.w/this.transformCanvas.h;
	        if(animationRel>elementRel && fillType === 'meet' || animationRel<elementRel && fillType === 'slice'){
	            this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	            this.transformCanvas.sy = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        }else{
	            this.transformCanvas.sx = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	            this.transformCanvas.sy = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	        }

	        if(xPos === 'xMid' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;
	        } else if(xPos === 'xMax' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.tx = 0;
	        }
	        if(yPos === 'YMid' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2)*this.renderConfig.dpr;
	        } else if(yPos === 'YMax' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w)))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.ty = 0;
	        }

	    }else if(this.renderConfig.preserveAspectRatio == 'none'){
	        this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        this.transformCanvas.sy = elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }else{
	        this.transformCanvas.sx = this.renderConfig.dpr;
	        this.transformCanvas.sy = this.renderConfig.dpr;
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }
	    this.transformCanvas.props = [this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];
	    var i, len = this.elements.length;
	    for(i=0;i<len;i+=1){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(this.globalData.transformCanvas);
	        }
	    }
	};

	CanvasRenderer.prototype.destroy = function () {
	    if(this.renderConfig.clearCanvas) {
	        this.animationItem.wrapper.innerHTML = '';
	    }
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = len - 1; i >= 0; i-=1) {
	        if(this.elements[i]) {
	            this.elements[i].destroy();
	        }
	    }
	    this.elements.length = 0;
	    this.globalData.canvasContext = null;
	    this.animationItem.container = null;
	    this.destroyed = true;
	};

	CanvasRenderer.prototype.renderFrame = function(num){
	    if((this.renderedFrame == num && this.renderConfig.clearCanvas === true) || this.destroyed || num === null){
	        return;
	    }
	    this.renderedFrame = num;
	    this.globalData.frameNum = num - this.animationItem.firstFrame;
	    this.globalData.frameId += 1;
	    this.globalData.projectInterface.currentFrame = num;
	    if(this.renderConfig.clearCanvas === true){
	        this.reset();
	        this.canvasContext.save();
	        //this.canvasContext.canvas.width = this.canvasContext.canvas.width;
	        this.canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w*this.transformCanvas.sx, this.transformCanvas.h*this.transformCanvas.sy);
	    }else{
	        this.save();
	    }
	    this.ctxTransform(this.transformCanvas.props);
	    this.canvasContext.beginPath();
	    this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);
	    this.canvasContext.closePath();
	    this.canvasContext.clip();

	    //console.log('--------');
	    //console.log('NEW: ',num);
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }

	    for (i = 0; i < len; i++) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    for (i = len - 1; i >= 0; i-=1) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.renderConfig.clearCanvas !== true){
	        this.restore();
	    } else {
	        this.canvasContext.restore();
	    }
	};

	CanvasRenderer.prototype.buildItem = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    var element = this.createItem(this.layers[pos], this,this.globalData);
	    elements[pos] = element;
	    element.initExpressions();
	    if(this.layers[pos].ty === 0){
	        element.resize(this.globalData.transformCanvas);
	    }
	};

	CanvasRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};

	CanvasRenderer.prototype.hide = function(){
	    this.animationItem.container.style.display = 'none';
	};

	CanvasRenderer.prototype.show = function(){
	    this.animationItem.container.style.display = 'block';
	};

	CanvasRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElementNS(svgNS,'g');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],this.globalData.comp,this.globalData);
	            comp.initExpressions();
	            //comp.compInterface = CompExpressionInterface(comp);
	            //Expressions.addLayersInterface(comp.elements, this.globalData.projectInterface);
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};

	function HybridRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1
	    };
	    this.renderConfig = {
	        className: (config && config.className) || ''
	    };
	    this.pendingElements = [];
	    this.elements = [];
	    this.threeDElements = [];
	    this.destroyed = false;
	    this.camera = null;
	    this.supports3d = true;

	}

	extendPrototype(BaseRenderer,HybridRenderer);

	HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

	HybridRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};

	HybridRenderer.prototype.appendElementInPos = function(element, pos){
	    var newDOMElement = element.getBaseElement();
	    if(!newDOMElement){
	        return;
	    }
	    var layer = this.layers[pos];
	    if(!layer.ddd || !this.supports3d){
	        var i = 0;
	        var nextDOMElement, nextLayer;
	        while(i<pos){
	            if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement){
	                nextLayer = this.elements[i];
	                nextDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
	            }
	            i += 1;
	        }
	        if(nextDOMElement){
	            if(!layer.ddd || !this.supports3d){
	                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
	            }
	        } else {
	            if(!layer.ddd || !this.supports3d){
	                this.layerElement.appendChild(newDOMElement);
	            }
	        }
	    } else {
	        this.addTo3dContainer(newDOMElement,pos);
	    }
	};


	HybridRenderer.prototype.createBase = function (data) {
	    return new SVGBaseElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createShape = function (data) {
	    if(!this.supports3d){
	        return new IShapeElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HShapeElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createText = function (data) {
	    if(!this.supports3d){
	        return new SVGTextElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HTextElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createCamera = function (data) {
	    this.camera = new HCameraElement(data, this.layerElement,this.globalData,this);
	    return this.camera;
	};

	HybridRenderer.prototype.createImage = function (data) {
	    if(!this.supports3d){
	        return new IImageElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HImageElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.createComp = function (data) {
	    if(!this.supports3d){
	        return new ICompElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HCompElement(data, this.layerElement,this.globalData,this);

	};

	HybridRenderer.prototype.createSolid = function (data) {
	    if(!this.supports3d){
	        return new ISolidElement(data, this.layerElement,this.globalData,this);
	    }
	    return new HSolidElement(data, this.layerElement,this.globalData,this);
	};

	HybridRenderer.prototype.getThreeDContainerByPos = function(pos){
	    var i = 0, len = this.threeDElements.length;
	    while(i<len) {
	        if(this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
	            return this.threeDElements[i].perspectiveElem;
	        }
	        i += 1;
	    }
	}

	HybridRenderer.prototype.createThreeDContainer = function(pos){
	    var perspectiveElem = document.createElement('div');
	    styleDiv(perspectiveElem);
	    perspectiveElem.style.width = this.globalData.compSize.w+'px';
	    perspectiveElem.style.height = this.globalData.compSize.h+'px';
	    perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = "50% 50%";
	    var container = document.createElement('div');
	    styleDiv(container);
	    container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    perspectiveElem.appendChild(container);
	    this.resizerElem.appendChild(perspectiveElem);
	    var threeDContainerData = {
	        container:container,
	        perspectiveElem:perspectiveElem,
	        startPos: pos,
	        endPos: pos
	    };
	    this.threeDElements.push(threeDContainerData);
	    return threeDContainerData;
	};

	HybridRenderer.prototype.build3dContainers = function(){
	    var i, len = this.layers.length;
	    var lastThreeDContainerData;
	    for(i=0;i<len;i+=1){
	        if(this.layers[i].ddd){
	            if(!lastThreeDContainerData){
	                lastThreeDContainerData = this.createThreeDContainer(i);
	            }
	            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
	        } else {
	            lastThreeDContainerData = null;
	        }
	    }
	};

	HybridRenderer.prototype.addTo3dContainer = function(elem,pos){
	    var i = 0, len = this.threeDElements.length;
	    while(i<len){
	        if(pos <= this.threeDElements[i].endPos){
	            var j = this.threeDElements[i].startPos;
	            var nextElement;
	            while(j<pos){
	                if(this.elements[j] && this.elements[j].getBaseElement){
	                    nextElement = this.elements[j].getBaseElement();
	                }
	                j += 1;
	            }
	            if(nextElement){
	                this.threeDElements[i].container.insertBefore(elem, nextElement);
	            } else {
	                this.threeDElements[i].container.appendChild(elem);
	            }
	            break;
	        }
	        i += 1;
	    }
	};

	HybridRenderer.prototype.configAnimation = function(animData){
	    var resizerElem = document.createElement('div');
	    var wrapper = this.animationItem.wrapper;
	    resizerElem.style.width = animData.w+'px';
	    resizerElem.style.height = animData.h+'px';
	    this.resizerElem = resizerElem;
	    styleDiv(resizerElem);
	    resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = "flat";
	    if(this.renderConfig.className) {
	      wrapper.setAttribute('class', this.renderConfig.className);
	    }
	    wrapper.appendChild(resizerElem);

	    resizerElem.style.overflow = 'hidden';
	    var svg = document.createElementNS(svgNS,'svg');
	    svg.setAttribute('width','1');
	    svg.setAttribute('height','1');
	    styleDiv(svg);
	    this.resizerElem.appendChild(svg);
	    var defs = document.createElementNS(svgNS,'defs');
	    svg.appendChild(defs);
	    this.globalData.defs = defs;
	    this.data = animData;
	    //Mask animation
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.elementLoaded = this.animationItem.elementLoaded.bind(this.animationItem);
	    this.globalData.frameId = 0;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    };
	    this.globalData.frameRate = animData.fr;
	    this.layers = animData.layers;
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts,svg);
	    this.layerElement = this.resizerElem;
	    this.build3dContainers();
	    this.updateContainerSize();
	};

	HybridRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.animationItem.container = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        this.elements[i].destroy();
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};

	HybridRenderer.prototype.updateContainerSize = function () {
	    var elementWidth = this.animationItem.wrapper.offsetWidth;
	    var elementHeight = this.animationItem.wrapper.offsetHeight;
	    var elementRel = elementWidth/elementHeight;
	    var animationRel = this.globalData.compSize.w/this.globalData.compSize.h;
	    var sx,sy,tx,ty;
	    if(animationRel>elementRel){
	        sx = elementWidth/(this.globalData.compSize.w);
	        sy = elementWidth/(this.globalData.compSize.w);
	        tx = 0;
	        ty = ((elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2);
	    }else{
	        sx = elementHeight/(this.globalData.compSize.h);
	        sy = elementHeight/(this.globalData.compSize.h);
	        tx = (elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;
	        ty = 0;
	    }
	    this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';
	};

	HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

	HybridRenderer.prototype.hide = function(){
	    this.resizerElem.style.display = 'none';
	};

	HybridRenderer.prototype.show = function(){
	    this.resizerElem.style.display = 'block';
	};

	HybridRenderer.prototype.initItems = function(){
	    this.buildAllItems();
	    if(this.camera){
	        this.camera.setup();
	    } else {
	        var cWidth = this.globalData.compSize.w;
	        var cHeight = this.globalData.compSize.h;
	        var i, len = this.threeDElements.length;
	        for(i=0;i<len;i+=1){
	            this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth,2) + Math.pow(cHeight,2)) + 'px';
	        }
	    }
	};

	HybridRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = document.createElement('div');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
	            comp.initExpressions();
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};

	function CVBaseElement(data, comp,globalData){
	    this.globalData = globalData;
	    this.data = data;
	    this.comp = comp;
	    this.canvasContext = globalData.canvasContext;
	    this.init();
	}

	createElement(BaseElement, CVBaseElement);

	CVBaseElement.prototype.createElements = function(){
	    this.checkParenting();
	};

	CVBaseElement.prototype.checkBlendMode = function(globalData){
	    if(globalData.blendMode !== this.data.bm) {
	        globalData.blendMode = this.data.bm;

	        var blendModeValue = '';
	        switch (this.data.bm) {
	            case 0:
	                blendModeValue = 'normal';
	                break;
	            case 1:
	                blendModeValue = 'multiply';
	                break;
	            case 2:
	                blendModeValue = 'screen';
	                break;
	            case 3:
	                blendModeValue = 'overlay';
	                break;
	            case 4:
	                blendModeValue = 'darken';
	                break;
	            case 5:
	                blendModeValue = 'lighten';
	                break;
	            case 6:
	                blendModeValue = 'color-dodge';
	                break;
	            case 7:
	                blendModeValue = 'color-burn';
	                break;
	            case 8:
	                blendModeValue = 'hard-light';
	                break;
	            case 9:
	                blendModeValue = 'soft-light';
	                break;
	            case 10:
	                blendModeValue = 'difference';
	                break;
	            case 11:
	                blendModeValue = 'exclusion';
	                break;
	            case 12:
	                blendModeValue = 'hue';
	                break;
	            case 13:
	                blendModeValue = 'saturation';
	                break;
	            case 14:
	                blendModeValue = 'color';
	                break;
	            case 15:
	                blendModeValue = 'luminosity';
	                break;
	        }
	        globalData.canvasContext.globalCompositeOperation = blendModeValue;
	    }
	};


	CVBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3){
	        return false;
	    }
	        this.checkBlendMode(this.data.ty === 0?this.parentGlobalData:this.globalData);

	    if(!this.isVisible){
	        return this.isVisible;
	    }
	    this.finalTransform.opMdf = this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i, len = this.hierarchy.length;
	        mat = this.finalTransform.mProp.v.props;
	        finalMat.cloneFromProps(mat);
	        for(i=0;i<len;i+=1){
	            this.finalTransform.matMdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : this.finalTransform.matMdf;
	            mat = this.hierarchy[i].finalTransform.mProp.v.props;
	            finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        }
	    }else{
	        if(!parentTransform){
	            finalMat.cloneFromProps(this.finalTransform.mProp.v.props);
	        }else{
	            mat = this.finalTransform.mProp.v.props;
	            finalMat.cloneFromProps(mat);
	        }
	    }

	    if(parentTransform){
	        mat = parentTransform.mat.props;
	        finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        this.finalTransform.opacity *= parentTransform.opacity;
	        this.finalTransform.opMdf = parentTransform.opMdf ? true : this.finalTransform.opMdf;
	        this.finalTransform.matMdf = parentTransform.matMdf ? true : this.finalTransform.matMdf
	    }

	    if(this.data.hasMask){
	        this.globalData.renderer.save(true);
	        this.maskManager.renderFrame(this.data.ty === 0?null:finalMat);
	    }
	    if(this.data.hd){
	        this.isVisible = false;
	    }
	    return this.isVisible;

	};

	CVBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new CVMaskElement(data,this,this.globalData);
	};


	CVBaseElement.prototype.destroy = function(){
	    this.canvasContext = null;
	    this.data = null;
	    this.globalData = null;
	    if(this.maskManager) {
	        this.maskManager.destroy();
	    }
	};

	CVBaseElement.prototype.mHelper = new Matrix();

	function CVCompElement(data, comp,globalData){
	    this._parent.constructor.call(this,data, comp,globalData);
	    var compGlobalData = {};
	    for(var s in globalData){
	        if(globalData.hasOwnProperty(s)){
	            compGlobalData[s] = globalData[s];
	        }
	    }
	    compGlobalData.renderer = this;
	    compGlobalData.compHeight = this.data.h;
	    compGlobalData.compWidth = this.data.w;
	    this.renderConfig = {
	        clearCanvas: true
	    };
	    this.contextData = {
	        saved : Array.apply(null,{length:15}),
	        savedOp: Array.apply(null,{length:15}),
	        cArrPos : 0,
	        cTr : new Matrix(),
	        cO : 1
	    };
	    this.completeLayers = false;
	    var i, len = 15;
	    for(i=0;i<len;i+=1){
	        this.contextData.saved[i] = Array.apply(null,{length:16});
	    }
	    this.transformMat = new Matrix();
	    this.parentGlobalData = this.globalData;
	    var cv = document.createElement('canvas');
	    //document.body.appendChild(cv);
	    compGlobalData.canvasContext = cv.getContext('2d');
	    this.canvasContext = compGlobalData.canvasContext;
	    cv.width = this.data.w;
	    cv.height = this.data.h;
	    this.canvas = cv;
	    this.globalData = compGlobalData;
	    this.layers = data.layers;
	    this.pendingElements = [];
	    this.elements = Array.apply(null,{length:this.layers.length});
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.xt || !globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	}
	createElement(CVBaseElement, CVCompElement);

	CVCompElement.prototype.ctxTransform = CanvasRenderer.prototype.ctxTransform;
	CVCompElement.prototype.ctxOpacity = CanvasRenderer.prototype.ctxOpacity;
	CVCompElement.prototype.save = CanvasRenderer.prototype.save;
	CVCompElement.prototype.restore = CanvasRenderer.prototype.restore;
	CVCompElement.prototype.reset =  function(){
	    this.contextData.cArrPos = 0;
	    this.contextData.cTr.reset();
	    this.contextData.cO = 1;
	};
	CVCompElement.prototype.resize = function(transformCanvas){
	    var maxScale = Math.max(transformCanvas.sx,transformCanvas.sy);
	    this.canvas.width = this.data.w*maxScale;
	    this.canvas.height = this.data.h*maxScale;
	    this.transformCanvas = {
	        sc:maxScale,
	        w:this.data.w*maxScale,
	        h:this.data.h*maxScale,
	        props:[maxScale,0,0,0,0,maxScale,0,0,0,0,1,0,0,0,0,1]
	    }
	    var i,len = this.elements.length;
	    for( i = 0; i < len; i+=1 ){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(transformCanvas);
	        }
	    }
	};

	CVCompElement.prototype.prepareFrame = function(num){
	    this.globalData.frameId = this.parentGlobalData.frameId;
	    this.globalData.mdf = false;
	    this._parent.prepareFrame.call(this,num);
	    if(this.isVisible===false && !this.data.xt){
	        return;
	    }
	    var timeRemapped = num;
	    if(this.tm){
	        timeRemapped = this.tm.v;
	        if(timeRemapped === this.data.op){
	            timeRemapped = this.data.op - 1;
	        }
	    }
	    this.renderedFrame = timeRemapped/this.data.sr;
	    var i,len = this.elements.length;

	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }

	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(timeRemapped/this.data.sr - this.layers[i].st);
	            if(this.elements[i].data.ty === 0 && this.elements[i].globalData.mdf){
	                this.globalData.mdf = true;
	            }
	        }
	    }
	    if(this.globalData.mdf && !this.data.xt){
	        this.canvasContext.clearRect(0, 0, this.data.w, this.data.h);
	        this.ctxTransform(this.transformCanvas.props);
	    }
	};

	CVCompElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this,parentMatrix)===false){
	        return;
	    }
	    if(this.globalData.mdf){
	        var i,len = this.layers.length;
	        for( i = len - 1; i >= 0; i -= 1 ){
	            if(this.completeLayers || this.elements[i]){
	                this.elements[i].renderFrame();
	            }
	        }
	    }
	    if(this.data.hasMask){
	        this.globalData.renderer.restore(true);
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	    this.parentGlobalData.renderer.save();
	    this.parentGlobalData.renderer.ctxTransform(this.finalTransform.mat.props);
	    this.parentGlobalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    this.parentGlobalData.renderer.canvasContext.drawImage(this.canvas,0,0,this.data.w,this.data.h);
	    this.parentGlobalData.renderer.restore();

	    if(this.globalData.mdf){
	        this.reset();
	    }
	};

	CVCompElement.prototype.setElements = function(elems){
	    this.elements = elems;
	};

	CVCompElement.prototype.getElements = function(){
	    return this.elements;
	};

	CVCompElement.prototype.destroy = function(){
	    var i,len = this.layers.length;
	    for( i = len - 1; i >= 0; i -= 1 ){
	        this.elements[i].destroy();
	    }
	    this.layers = null;
	    this.elements = null;
	    this._parent.destroy.call(this._parent);
	};
	CVCompElement.prototype.checkLayers = CanvasRenderer.prototype.checkLayers;
	CVCompElement.prototype.buildItem = CanvasRenderer.prototype.buildItem;
	CVCompElement.prototype.checkPendingElements = CanvasRenderer.prototype.checkPendingElements;
	CVCompElement.prototype.addPendingElement = CanvasRenderer.prototype.addPendingElement;
	CVCompElement.prototype.buildAllItems = CanvasRenderer.prototype.buildAllItems;
	CVCompElement.prototype.createItem = CanvasRenderer.prototype.createItem;
	CVCompElement.prototype.createImage = CanvasRenderer.prototype.createImage;
	CVCompElement.prototype.createComp = CanvasRenderer.prototype.createComp;
	CVCompElement.prototype.createSolid = CanvasRenderer.prototype.createSolid;
	CVCompElement.prototype.createShape = CanvasRenderer.prototype.createShape;
	CVCompElement.prototype.createText = CanvasRenderer.prototype.createText;
	CVCompElement.prototype.createBase = CanvasRenderer.prototype.createBase;
	CVCompElement.prototype.buildElementParenting = CanvasRenderer.prototype.buildElementParenting;
	function CVImageElement(data, comp,globalData){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data, comp,globalData);
	    this.globalData.addPendingElement();
	}
	createElement(CVBaseElement, CVImageElement);

	CVImageElement.prototype.createElements = function(){
	    var imageLoaded = function(){
	        this.globalData.elementLoaded();
	        if(this.assetData.w !== this.img.width || this.assetData.h !== this.img.height){
	            var canvas = document.createElement('canvas');
	            canvas.width = this.assetData.w;
	            canvas.height = this.assetData.h;
	            var ctx = canvas.getContext('2d');

	            var imgW = this.img.width;
	            var imgH = this.img.height;
	            var imgRel = imgW / imgH;
	            var canvasRel = this.assetData.w/this.assetData.h;
	            var widthCrop, heightCrop;
	            if(imgRel>canvasRel){
	                heightCrop = imgH;
	                widthCrop = heightCrop*canvasRel;
	            } else {
	                widthCrop = imgW;
	                heightCrop = widthCrop/canvasRel;
	            }
	            ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);
	            this.img = canvas;
	        }
	    }.bind(this);
	    var imageFailed = function(){
	        this.failed = true;
	        this.globalData.elementLoaded();
	    }.bind(this);

	    this.img = new Image();
	    this.img.addEventListener('load', imageLoaded, false);
	    this.img.addEventListener('error', imageFailed, false);
	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	    this.img.src = assetPath;

	    this._parent.createElements.call(this);

	};

	CVImageElement.prototype.renderFrame = function(parentMatrix){
	    if(this.failed){
	        return;
	    }
	    if(this._parent.renderFrame.call(this,parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    this.globalData.renderer.save();
	    var finalMat = this.finalTransform.mat.props;
	    this.globalData.renderer.ctxTransform(finalMat);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.drawImage(this.img,0,0);
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	CVImageElement.prototype.destroy = function(){
	    this.img = null;
	    this._parent.destroy.call(this._parent);
	};

	function CVMaskElement(data,element){
	    this.data = data;
	    this.element = element;
	    this.dynamicProperties = [];
	    this.masksProperties = this.data.masksProperties;
	    this.viewData = Array.apply(null,{length:this.masksProperties.length});
	    var i, len = this.masksProperties.length;
	    for (i = 0; i < len; i++) {
	        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3,this.dynamicProperties,null);
	    }
	}

	CVMaskElement.prototype.prepareFrame = function(num){
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue(num);
	        if(this.dynamicProperties[i].mdf){
	            this.element.globalData.mdf = true;
	        }
	    }
	};

	CVMaskElement.prototype.renderFrame = function (transform) {
	    var ctx = this.element.canvasContext;
	    var i, len = this.data.masksProperties.length;
	    var pt,pt2,pt3,data, hasMasks = false;
	    for (i = 0; i < len; i++) {
	        if(this.masksProperties[i].mode === 'n'){
	            continue;
	        }
	        if(hasMasks === false){
	            ctx.beginPath();
	            hasMasks = true;
	        }
	        if (this.masksProperties[i].inv) {
	            ctx.moveTo(0, 0);
	            ctx.lineTo(this.element.globalData.compWidth, 0);
	            ctx.lineTo(this.element.globalData.compWidth, this.element.globalData.compHeight);
	            ctx.lineTo(0, this.element.globalData.compHeight);
	            ctx.lineTo(0, 0);
	        }
	        data = this.viewData[i].v;
	        pt = transform ? transform.applyToPointArray(data.v[0][0],data.v[0][1],0):data.v[0];
	        ctx.moveTo(pt[0], pt[1]);
	        var j, jLen = data._length;
	        for (j = 1; j < jLen; j++) {
	            pt = transform ? transform.applyToPointArray(data.o[j - 1][0],data.o[j - 1][1],0) : data.o[j - 1];
	            pt2 = transform ? transform.applyToPointArray(data.i[j][0],data.i[j][1],0) : data.i[j];
	            pt3 = transform ? transform.applyToPointArray(data.v[j][0],data.v[j][1],0) : data.v[j];
	            ctx.bezierCurveTo(pt[0], pt[1], pt2[0], pt2[1], pt3[0], pt3[1]);
	        }
	        pt = transform ? transform.applyToPointArray(data.o[j - 1][0],data.o[j - 1][1],0) : data.o[j - 1];
	        pt2 = transform ? transform.applyToPointArray(data.i[0][0],data.i[0][1],0) : data.i[0];
	        pt3 = transform ? transform.applyToPointArray(data.v[0][0],data.v[0][1],0) : data.v[0];
	        ctx.bezierCurveTo(pt[0], pt[1], pt2[0], pt2[1], pt3[0], pt3[1]);
	    }
	    if(hasMasks){
	        ctx.clip();
	    }
	};

	CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

	CVMaskElement.prototype.destroy = function(){
	    this.element = null;
	};
	function CVShapeElement(data, comp,globalData){
	    this.shapes = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.itemsData = [];
	    this.prevViewData = [];
	    this.shapeModifiers = [];
	    this.processedElements = [];
	    this._parent.constructor.call(this,data, comp,globalData);
	}
	createElement(CVBaseElement, CVShapeElement);

	CVShapeElement.prototype.transformHelper = {opacity:1,mat:new Matrix(),matMdf:false,opMdf:false};

	CVShapeElement.prototype.dashResetter = [];

	CVShapeElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.dynamicProperties, true);
	};

	CVShapeElement.prototype.createStyleElement = function(data, dynamicProperties){
	    var styleElem = {
	        data: data,
	        type: data.ty,
	        elements: []
	    };
	    var elementData = {};
	    if(data.ty == 'fl' || data.ty == 'st'){
	        elementData.c = PropertyFactory.getProp(this,data.c,1,255,dynamicProperties);
	        if(!elementData.c.k){
	            styleElem.co = 'rgb('+bm_floor(elementData.c.v[0])+','+bm_floor(elementData.c.v[1])+','+bm_floor(elementData.c.v[2])+')';
	        }
	    }
	    elementData.o = PropertyFactory.getProp(this,data.o,0,0.01,dynamicProperties);
	    if(data.ty == 'st') {
	        styleElem.lc = this.lcEnum[data.lc] || 'round';
	        styleElem.lj = this.ljEnum[data.lj] || 'round';
	        if(data.lj == 1) {
	            styleElem.ml = data.ml;
	        }
	        elementData.w = PropertyFactory.getProp(this,data.w,0,null,dynamicProperties);
	        if(!elementData.w.k){
	            styleElem.wi = elementData.w.v;
	        }
	        if(data.d){
	            var d = PropertyFactory.getDashProp(this,data.d,'canvas',dynamicProperties);
	            elementData.d = d;
	            if(!elementData.d.k){
	                styleElem.da = elementData.d.dasharray;
	                styleElem.do = elementData.d.dashoffset;
	            }
	        }

	    } else {

	        styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
	    }
	    this.stylesList.push(styleElem);
	    elementData.style = styleElem;
	    return elementData;
	}

	CVShapeElement.prototype.createGroupElement = function(data) {
	    var elementData = {
	        it: [],
	        prevViewData: []
	    };
	    return elementData;
	}

	CVShapeElement.prototype.createTransformElement = function(data, dynamicProperties) {
	    var elementData = {
	        transform : {
	            mat: new Matrix(),
	            opacity: 1,
	            matMdf:false,
	            opMdf:false,
	            op: PropertyFactory.getProp(this,data.o,0,0.01,dynamicProperties),
	            mProps: PropertyFactory.getProp(this,data,2,null,dynamicProperties)
	        },
	        elements: []
	    };
	    return elementData;
	}

	CVShapeElement.prototype.createShapeElement = function(data, dynamicProperties) {
	    var elementData = {
	        nodes:[],
	        trNodes:[],
	        tr:[0,0,0,0,0,0]
	    };
	    var ty = 4;
	    if(data.ty == 'rc'){
	        ty = 5;
	    }else if(data.ty == 'el'){
	        ty = 6;
	    }else if(data.ty == 'sr'){
	        ty = 7;
	    }
	    elementData.sh = ShapePropertyFactory.getShapeProp(this,data,ty,dynamicProperties);
	    this.shapes.push(elementData.sh);
	    this.addShapeToModifiers(elementData);
	    jLen = this.stylesList.length;
	    var hasStrokes = false, hasFills = false;
	    for(j=0;j<jLen;j+=1){
	        if(!this.stylesList[j].closed){
	            this.stylesList[j].elements.push(elementData);
	            if(this.stylesList[j].type === 'st'){
	                hasStrokes = true;
	            }else{
	                hasFills = true;
	            }
	        }
	    }
	    elementData.st = hasStrokes;
	    elementData.fl = hasFills;
	    return elementData;
	}

	CVShapeElement.prototype.reloadShapes = function(){
	    this.firstFrame = true;
	    var i, len = this.itemsData.length;
	    for(i=0;i<len;i+=1){
	        this.prevViewData[i] = this.itemsData[i];
	    }
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.dynamicProperties, true);
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	    }
	    this.renderModifiers();
	}

	CVShapeElement.prototype.searchShapes = function(arr,itemsData, prevViewData,dynamicProperties, render){
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownArrays = [], ownModifiers = [], processedPos;
	    for(i=len;i>=0;i-=1){
	        processedPos = this.searchProcessedElement(arr[i]);
	        if(!processedPos){
	            arr[i]._render = render;
	        } else {
	            itemsData[i] = prevViewData[processedPos - 1];
	        }
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st'){
	            if(!processedPos){
	                itemsData[i] = this.createStyleElement(arr[i], dynamicProperties);
	            } else {
	                itemsData[i].style.closed = false;
	            }
	            
	            ownArrays.push(itemsData[i].style);
	        }else if(arr[i].ty == 'gr'){
	            if(!processedPos){
	                itemsData[i] = this.createGroupElement(arr[i]);
	            } else {
	                jLen = itemsData[i].it.length;
	                for(j=0;j<jLen;j+=1){
	                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
	                }
	            }
	            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,dynamicProperties, render);
	        }else if(arr[i].ty == 'tr'){
	            if(!processedPos){
	                itemsData[i] = this.createTransformElement(arr[i], dynamicProperties);
	            }
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            if(!processedPos){
	                itemsData[i] = this.createShapeElement(arr[i], dynamicProperties);
	            }
	            
	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd'){
	            if(!processedPos){
	                var modifier = ShapeModifiers.getModifier(arr[i].ty);
	                modifier.init(this,arr[i],dynamicProperties);
	                itemsData[i] = modifier;
	                this.shapeModifiers.push(modifier);
	            } else {
	                modifier = itemsData[i];
	                modifier.closed = false;
	            }
	            ownModifiers.push(modifier);
	        } else if(arr[i].ty == 'rp'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                itemsData[i] = modifier;
	                modifier.init(this,arr,i,itemsData,dynamicProperties);
	                this.shapeModifiers.push(modifier);
	                render = false;
	            }else{
	                modifier = itemsData[i];
	                modifier.closed = true;
	            }
	            ownModifiers.push(modifier);
	        }
	        this.addProcessedElement(arr[i], i + 1);
	    }
	    len = ownArrays.length;
	    for(i=0;i<len;i+=1){
	        ownArrays[i].closed = true;
	    }
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};

	CVShapeElement.prototype.addShapeToModifiers = IShapeElement.prototype.addShapeToModifiers;
	CVShapeElement.prototype.renderModifiers = IShapeElement.prototype.renderModifiers;
	CVShapeElement.prototype.lcEnum = IShapeElement.prototype.lcEnum;
	CVShapeElement.prototype.ljEnum = IShapeElement.prototype.ljEnum;
	CVShapeElement.prototype.searchProcessedElement = IShapeElement.prototype.searchProcessedElement;
	CVShapeElement.prototype.addProcessedElement = IShapeElement.prototype.addProcessedElement;

	CVShapeElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    this.transformHelper.mat.reset();
	    this.transformHelper.opacity = this.finalTransform.opacity;
	    this.transformHelper.matMdf = false;
	    this.transformHelper.opMdf = this.finalTransform.opMdf;
	    this.renderModifiers();
	    this.renderShape(this.transformHelper,null,null,true);
	    if(this.data.hasMask){
	        this.globalData.renderer.restore(true);
	    }
	};

	CVShapeElement.prototype.renderShape = function(parentTransform,items,data,isMain){
	    var i, len;
	    if(!items){
	        items = this.shapesData;
	        len = this.stylesList.length;
	        for(i=0;i<len;i+=1){
	            this.stylesList[i].d = '';
	            this.stylesList[i].mdf = false;
	        }
	    }
	    if(!data){
	        data = this.itemsData;
	    }
	    ///
	    ///
	    len = items.length - 1;
	    var groupTransform,groupMatrix;
	    groupTransform = parentTransform;
	    for(i=len;i>=0;i-=1){
	        if(items[i].ty == 'tr'){
	            groupTransform = data[i].transform;
	            var mtArr = data[i].transform.mProps.v.props;
	            groupTransform.matMdf = groupTransform.mProps.mdf;
	            groupTransform.opMdf = groupTransform.op.mdf;
	            groupMatrix = groupTransform.mat;
	            groupMatrix.cloneFromProps(mtArr);
	            if(parentTransform){
	                var props = parentTransform.mat.props;
	                groupTransform.opacity = parentTransform.opacity;
	                groupTransform.opacity *= data[i].transform.op.v;
	                groupTransform.matMdf = parentTransform.matMdf ? true : groupTransform.matMdf;
	                groupTransform.opMdf = parentTransform.opMdf ? true : groupTransform.opMdf;
	                groupMatrix.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	            }else{
	                groupTransform.opacity = groupTransform.op.o;
	            }
	        }else if(items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr'){
	            this.renderPath(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'fl'){
	            this.renderFill(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'st'){
	            this.renderStroke(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'gr'){
	            this.renderShape(groupTransform,items[i].it,data[i].it);
	        }else if(items[i].ty == 'tm'){
	            //
	        }
	    }
	    if(!isMain){
	        return;
	    }
	    len = this.stylesList.length;
	    var j, jLen, k, kLen,elems,nodes, renderer = this.globalData.renderer, ctx = this.globalData.canvasContext, type;
	    renderer.save();
	    renderer.ctxTransform(this.finalTransform.mat.props);
	    for(i=0;i<len;i+=1){
	        type = this.stylesList[i].type;
	        if((type === 'st' && this.stylesList[i].wi === 0) || !this.stylesList[i].data._render){
	            continue;
	        }
	        renderer.save();
	        elems = this.stylesList[i].elements;
	        if(type === 'st'){
	            ctx.strokeStyle = this.stylesList[i].co;
	            ctx.lineWidth = this.stylesList[i].wi;
	            ctx.lineCap = this.stylesList[i].lc;
	            ctx.lineJoin = this.stylesList[i].lj;
	            ctx.miterLimit = this.stylesList[i].ml || 0;
	        }else{
	            ctx.fillStyle = this.stylesList[i].co;
	        }
	        renderer.ctxOpacity(this.stylesList[i].coOp);
	        if(type !== 'st'){
	            ctx.beginPath();
	        }
	        jLen = elems.length;
	        for(j=0;j<jLen;j+=1){
	            if(type === 'st'){
	                ctx.beginPath();
	                if(this.stylesList[i].da){
	                    ctx.setLineDash(this.stylesList[i].da);
	                    ctx.lineDashOffset = this.stylesList[i].do;
	                    this.globalData.isDashed = true;
	                }else if(this.globalData.isDashed){
	                    ctx.setLineDash(this.dashResetter);
	                    this.globalData.isDashed = false;
	                }
	            }
	            nodes = elems[j].trNodes;
	            kLen = nodes.length;

	            for(k=0;k<kLen;k+=1){
	                if(nodes[k].t == 'm'){
	                    ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);
	                }else if(nodes[k].t == 'c'){
	                    ctx.bezierCurveTo(nodes[k].p1[0],nodes[k].p1[1],nodes[k].p2[0],nodes[k].p2[1],nodes[k].p3[0],nodes[k].p3[1]);
	                }else{
	                    ctx.closePath();
	                }
	            }
	            if(type === 'st'){
	                ctx.stroke();
	            }
	        }
	        if(type !== 'st'){
	            ctx.fill(this.stylesList[i].r);
	        }
	        renderer.restore();
	    }
	    renderer.restore();
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	CVShapeElement.prototype.renderPath = function(pathData,itemData,groupTransform){
	    var len, i, j,jLen;
	    var redraw = groupTransform.matMdf || itemData.sh.mdf || this.firstFrame;
	    if(redraw) {
	        var paths = itemData.sh.paths, groupTransformMat = groupTransform.mat;
	        jLen = paths._length;
	        var pathStringTransformed = itemData.trNodes;
	        pathStringTransformed.length = 0;
	        for(j=0;j<jLen;j+=1){
	            var pathNodes = paths.shapes[j];
	            if(pathNodes && pathNodes.v){
	                len = pathNodes._length;
	                for (i = 1; i < len; i += 1) {
	                    if (i == 1) {
	                        pathStringTransformed.push({
	                            t: 'm',
	                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                        });
	                    }
	                    pathStringTransformed.push({
	                        t: 'c',
	                        p1: groupTransformMat.applyToPointArray(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1], 0),
	                        p2: groupTransformMat.applyToPointArray(pathNodes.i[i][0], pathNodes.i[i][1], 0),
	                        p3: groupTransformMat.applyToPointArray(pathNodes.v[i][0], pathNodes.v[i][1], 0)
	                    });
	                }
	                if (len == 1) {
	                    pathStringTransformed.push({
	                        t: 'm',
	                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                    });
	                }
	                if (pathNodes.c && len) {
	                    pathStringTransformed.push({
	                        t: 'c',
	                        p1: groupTransformMat.applyToPointArray(pathNodes.o[i - 1][0], pathNodes.o[i - 1][1], 0),
	                        p2: groupTransformMat.applyToPointArray(pathNodes.i[0][0], pathNodes.i[0][1], 0),
	                        p3: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                    });
	                    pathStringTransformed.push({
	                        t: 'z'
	                    });
	                }
	                itemData.lStr = pathStringTransformed;
	            }

	        }

	        if (itemData.st) {
	            for (i = 0; i < 16; i += 1) {
	                itemData.tr[i] = groupTransform.mat.props[i];
	            }
	        }
	        itemData.trNodes = pathStringTransformed;

	    }
	};



	CVShapeElement.prototype.renderFill = function(styleData,itemData, groupTransform){
	    var styleElem = itemData.style;

	    if(itemData.c.mdf || this.firstFrame){
	        styleElem.co = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
	    }
	    if(itemData.o.mdf || groupTransform.opMdf || this.firstFrame){
	        styleElem.coOp = itemData.o.v*groupTransform.opacity;
	    }
	};

	CVShapeElement.prototype.renderStroke = function(styleData,itemData, groupTransform){
	    var styleElem = itemData.style;
	    //TODO fix dashes
	    var d = itemData.d;
	    var dasharray,dashoffset;
	    if(d && (d.mdf  || this.firstFrame)){
	        styleElem.da = d.dasharray;
	        styleElem.do = d.dashoffset;
	    }
	    if(itemData.c.mdf || this.firstFrame){
	        styleElem.co = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
	    }
	    if(itemData.o.mdf || groupTransform.opMdf || this.firstFrame){
	        styleElem.coOp = itemData.o.v*groupTransform.opacity;
	    }
	    if(itemData.w.mdf || this.firstFrame){
	        styleElem.wi = itemData.w.v;
	    }
	};


	CVShapeElement.prototype.destroy = function(){
	    this.shapesData = null;
	    this.globalData = null;
	    this.canvasContext = null;
	    this.stylesList.length = 0;
	    this.itemData.length = 0;
	    this._parent.destroy.call(this._parent);
	};


	function CVSolidElement(data, comp,globalData){
	    this._parent.constructor.call(this,data, comp,globalData);
	}
	createElement(CVBaseElement, CVSolidElement);

	CVSolidElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    this.globalData.renderer.save();
	    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.fillStyle=this.data.sc;
	    ctx.fillRect(0,0,this.data.sw,this.data.sh);
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	function CVTextElement(data, comp, globalData){
	    this.textSpans = [];
	    this.yOffset = 0;
	    this.fillColorAnim = false;
	    this.strokeColorAnim = false;
	    this.strokeWidthAnim = false;
	    this.stroke = false;
	    this.fill = false;
	    this.justifyOffset = 0;
	    this.currentRender = null;
	    this.renderType = 'canvas';
	    this.values = {
	        fill: 'rgba(0,0,0,0)',
	        stroke: 'rgba(0,0,0,0)',
	        sWidth: 0,
	        fValue: ''
	    }
	    this._parent.constructor.call(this,data,comp, globalData);
	}
	createElement(CVBaseElement, CVTextElement);

	extendPrototype(ITextElement, CVTextElement);

	CVTextElement.prototype.tHelper = document.createElement('canvas').getContext('2d');

	CVTextElement.prototype.createElements = function(){

	    this._parent.createElements.call(this);
	    //console.log('this.data: ',this.data);

	};

	CVTextElement.prototype.buildNewText = function(){
	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = Array.apply(null,{length:documentData.l ? documentData.l.length : 0});

	    var hasFill = false;
	    if(documentData.fc) {
	        hasFill = true;
	        this.values.fill = this.buildColor(documentData.fc);
	    }else{
	        this.values.fill = 'rgba(0,0,0,0)';
	    }
	    this.fill = hasFill;
	    var hasStroke = false;
	    if(documentData.sc){
	        hasStroke = true;
	        this.values.stroke = this.buildColor(documentData.sc);
	        this.values.sWidth = documentData.sw;
	    }
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    var i, len;
	    var letters = documentData.l;
	    var matrixHelper = this.mHelper;
	    this.stroke = hasStroke;
	    this.values.fValue = documentData.s + 'px '+ this.globalData.fontManager.getFontByName(documentData.f).fFamily;
	    len = documentData.t.length;
	    //this.tHelper.font = this.values.fValue;
	    var charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, singleShape = this.data.singleShape;
	    var trackingOffset = documentData.tr/1000*documentData.s;
	    var xPos = 0, yPos = 0, firstLine = true;
	    var cnt = 0;
	    for (i = 0; i < len; i += 1) {
	        charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	        shapeData = charData && charData.data || {};
	        matrixHelper.reset();
	        if(singleShape && letters[i].n) {
	            xPos = -trackingOffset;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            firstLine = false;
	        }

	        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	        jLen = shapes.length;
	        matrixHelper.scale(documentData.s/100,documentData.s/100);
	        if(singleShape){
	            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	        }
	        commands = Array.apply(null,{length:jLen})
	        for(j=0;j<jLen;j+=1){
	            kLen = shapes[j].ks.k.i.length;
	            pathNodes = shapes[j].ks.k;
	            pathArr = [];
	            for(k=1;k<kLen;k+=1){
	                if(k==1){
	                    pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	                }
	                pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));
	            }
	            pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	            commands[j] = pathArr;
	        }
	        if(singleShape){
	            xPos += letters[i].l;
	            xPos += trackingOffset;
	        }
	        if(this.textSpans[cnt]){
	            this.textSpans[cnt].elem = commands;
	        } else {
	            this.textSpans[cnt] = {elem: commands};
	        }
	        cnt +=1;
	    }
	}

	CVTextElement.prototype.renderFrame = function(parentMatrix){
	    if(this._parent.renderFrame.call(this, parentMatrix)===false){
	        return;
	    }
	    var ctx = this.canvasContext;
	    var finalMat = this.finalTransform.mat.props;
	    this.globalData.renderer.save();
	    this.globalData.renderer.ctxTransform(finalMat);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.opacity);
	    ctx.font = this.values.fValue;
	    ctx.lineCap = 'butt';
	    ctx.lineJoin = 'miter';
	    ctx.miterLimit = 4;

	    if(!this.data.singleShape){
	        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	    }

	    var  i,len, j, jLen, k, kLen;
	    var renderedLetters = this.textAnimator.renderedLetters;

	    var letters = this.textProperty.currentData.l;

	    len = letters.length;
	    var renderedLetter;
	    var lastFill = null, lastStroke = null, lastStrokeW = null, commands, pathArr;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            continue;
	        }
	        renderedLetter = renderedLetters[i];
	        if(renderedLetter){
	            this.globalData.renderer.save();
	            this.globalData.renderer.ctxTransform(renderedLetter.p);
	            this.globalData.renderer.ctxOpacity(renderedLetter.o);
	        }
	        if(this.fill){
	            if(renderedLetter && renderedLetter.fc){
	                if(lastFill !== renderedLetter.fc){
	                    lastFill = renderedLetter.fc;
	                    ctx.fillStyle = renderedLetter.fc;
	                }
	            }else if(lastFill !== this.values.fill){
	                lastFill = this.values.fill;
	                ctx.fillStyle = this.values.fill;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.fill();
	            ///ctx.fillText(this.textSpans[i].val,0,0);
	        }
	        if(this.stroke){
	            if(renderedLetter && renderedLetter.sw){
	                if(lastStrokeW !== renderedLetter.sw){
	                    lastStrokeW = renderedLetter.sw;
	                    ctx.lineWidth = renderedLetter.sw;
	                }
	            }else if(lastStrokeW !== this.values.sWidth){
	                lastStrokeW = this.values.sWidth;
	                ctx.lineWidth = this.values.sWidth;
	            }
	            if(renderedLetter && renderedLetter.sc){
	                if(lastStroke !== renderedLetter.sc){
	                    lastStroke = renderedLetter.sc;
	                    ctx.strokeStyle = renderedLetter.sc;
	                }
	            }else if(lastStroke !== this.values.stroke){
	                lastStroke = this.values.stroke;
	                ctx.strokeStyle = this.values.stroke;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.stroke();
	            ///ctx.strokeText(letters[i].val,0,0);
	        }
	        if(renderedLetter) {
	            this.globalData.renderer.restore();
	        }
	    }
	    /*if(this.data.hasMask){
	     this.globalData.renderer.restore(true);
	     }*/
	    this.globalData.renderer.restore(this.data.hasMask);
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};
	function HBaseElement(data,parentContainer,globalData,comp, placeholder){
	    this.globalData = globalData;
	    this.comp = comp;
	    this.data = data;
	    this.matteElement = null;
	    this.parentContainer = parentContainer;
	    this.layerId = placeholder ? placeholder.layerId : 'ly_'+randomString(10);
	    this.placeholder = placeholder;
	    this.init();
	};

	createElement(BaseElement, HBaseElement);
	HBaseElement.prototype.checkBlendMode = function(){

	};
	HBaseElement.prototype.setBlendMode = BaseElement.prototype.setBlendMode;

	/*HBaseElement.prototype.appendNodeToParent = function(node) {
	    if(this.data.hd){
	        return;
	    }
	    if(this.placeholder){
	        var g = this.placeholder.phElement;
	        g.parentNode.insertBefore(node, g);
	        //g.parentNode.removeChild(g);
	    }else{
	        this.parentContainer.appendChild(node);
	    }
	};*/


	HBaseElement.prototype.getBaseElement = function(){
	    return this.baseElement;
	};

	HBaseElement.prototype.createElements = function(){
	    if(this.data.hasMask){
	        this.layerElement = document.createElementNS(svgNS,'svg');
	        styleDiv(this.layerElement);
	        //this.appendNodeToParent(this.layerElement);
	        this.baseElement = this.layerElement;
	        this.maskedElement = this.layerElement;
	    }else{
	        this.layerElement = this.parentContainer;
	    }
	    this.transformedElement = this.layerElement;
	    if(this.data.ln && (this.data.ty === 4 || this.data.ty === 0)){
	        if(this.layerElement === this.parentContainer){
	            this.layerElement = document.createElementNS(svgNS,'g');
	            //this.appendNodeToParent(this.layerElement);
	            this.baseElement = this.layerElement;
	        }
	        this.layerElement.setAttribute('id',this.data.ln);
	    }
	    this.setBlendMode();
	    if(this.layerElement !== this.parentContainer){
	        this.placeholder = null;
	    }
	    this.checkParenting();
	};

	HBaseElement.prototype.renderFrame = function(parentTransform){
	    if(this.data.ty === 3){
	        return false;
	    }

	    if(this.currentFrameNum === this.lastNum || !this.isVisible){
	        return this.isVisible;
	    }
	    this.lastNum = this.currentFrameNum;

	    this.finalTransform.opMdf = this.finalTransform.op.mdf;
	    this.finalTransform.matMdf = this.finalTransform.mProp.mdf;
	    this.finalTransform.opacity = this.finalTransform.op.v;
	    if(this.firstFrame){
	        this.finalTransform.opMdf = true;
	        this.finalTransform.matMdf = true;
	    }

	    var mat;
	    var finalMat = this.finalTransform.mat;

	    if(this.hierarchy){
	        var i, len = this.hierarchy.length;

	        mat = this.finalTransform.mProp.v.props;
	        finalMat.cloneFromProps(mat);
	        for(i=0;i<len;i+=1){
	            this.finalTransform.matMdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : this.finalTransform.matMdf;
	            mat = this.hierarchy[i].finalTransform.mProp.v.props;
	            finalMat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],mat[12],mat[13],mat[14],mat[15]);
	        }
	    }else{
	        if(this.isVisible && this.finalTransform.matMdf){
	            if(!parentTransform){
	                finalMat.cloneFromProps(this.finalTransform.mProp.v.props);
	            }else{
	                mat = this.finalTransform.mProp.v.props;
	                finalMat.cloneFromProps(mat);
	            }
	        }
	    }
	    if(this.data.hasMask){
	        this.maskManager.renderFrame(finalMat);
	    }

	    if(parentTransform){
	        mat = parentTransform.mat.props;
	        finalMat.cloneFromProps(mat);
	        this.finalTransform.opacity *= parentTransform.opacity;
	        this.finalTransform.opMdf = parentTransform.opMdf ? true : this.finalTransform.opMdf;
	        this.finalTransform.matMdf = parentTransform.matMdf ? true : this.finalTransform.matMdf
	    }

	    if(this.finalTransform.matMdf){
	        this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = finalMat.toCSS();
	        this.finalMat = finalMat;
	    }
	    if(this.finalTransform.opMdf){
	        this.transformedElement.style.opacity = this.finalTransform.opacity;
	    }
	    return this.isVisible;
	};

	HBaseElement.prototype.destroy = function(){
	    this.layerElement = null;
	    this.transformedElement = null;
	    this.parentContainer = null;
	    if(this.matteElement) {
	        this.matteElement = null;
	    }
	    if(this.maskManager) {
	        this.maskManager.destroy();
	        this.maskManager = null;
	    }
	};

	HBaseElement.prototype.getDomElement = function(){
	    return this.layerElement;
	};
	HBaseElement.prototype.addMasks = function(data){
	    this.maskManager = new MaskElement(data,this,this.globalData);
	};

	HBaseElement.prototype.hide = function(){
	};

	HBaseElement.prototype.setMatte = function(){

	}

	HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
	function HSolidElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(HBaseElement, HSolidElement);

	HSolidElement.prototype.createElements = function(){
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    var cont = document.createElementNS(svgNS,'svg');
	    styleDiv(cont);
	    cont.setAttribute('width',this.data.sw);
	    cont.setAttribute('height',this.data.sh);
	    parent.appendChild(cont);
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    //this.appendNodeToParent(parent);
	    this.baseElement = parent;
	    this.innerElem = parent;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    var rect = document.createElementNS(svgNS,'rect');
	    rect.setAttribute('width',this.data.sw);
	    rect.setAttribute('height',this.data.sh);
	    rect.setAttribute('fill',this.data.sc);
	    cont.appendChild(rect);
	    if(this.data.hasMask){
	        this.maskedElement = rect;
	    }
	    this.checkParenting();
	};



	HSolidElement.prototype.hide = SVGBaseElement.prototype.hide;
	HSolidElement.prototype.show = SVGBaseElement.prototype.show;
	HSolidElement.prototype.renderFrame = IImageElement.prototype.renderFrame;
	HSolidElement.prototype.destroy = IImageElement.prototype.destroy;
	function HCompElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.layers = data.layers;
	    this.supports3d = true;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = Array.apply(null,{length:this.layers.length});
	    if(this.data.tm){
	        this.tm = PropertyFactory.getProp(this,this.data.tm,0,globalData.frameRate,this.dynamicProperties);
	    }
	    if(this.data.hasMask) {
	        this.supports3d = false;
	    }
	    if(this.data.xt){
	        this.layerElement = document.createElement('div');
	    }
	    this.buildAllItems();

	}
	createElement(HBaseElement, HCompElement);

	HCompElement.prototype.createElements = function(){
	    var divElement = document.createElement('div');
	    styleDiv(divElement);
	    if(this.data.ln){
	        divElement.setAttribute('id',this.data.ln);
	    }
	    divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
	    if(this.data.hasMask){
	        var compSvg = document.createElementNS(svgNS,'svg');
	        styleDiv(compSvg);
	        compSvg.setAttribute('width',this.data.w);
	        compSvg.setAttribute('height',this.data.h);
	        var g = document.createElementNS(svgNS,'g');
	        compSvg.appendChild(g);
	        divElement.appendChild(compSvg);
	        this.maskedElement = g;
	        this.baseElement = divElement;
	        this.layerElement = g;
	        this.transformedElement = divElement;
	    }else{
	        this.layerElement = divElement;
	        this.baseElement = this.layerElement;
	        this.transformedElement = divElement;
	    }
	    //this.appendNodeToParent(this.layerElement);
	    this.checkParenting();
	};

	HCompElement.prototype.hide = ICompElement.prototype.hide;
	HCompElement.prototype.prepareFrame = ICompElement.prototype.prepareFrame;
	HCompElement.prototype.setElements = ICompElement.prototype.setElements;
	HCompElement.prototype.getElements = ICompElement.prototype.getElements;
	HCompElement.prototype.destroy = ICompElement.prototype.destroy;

	HCompElement.prototype.renderFrame = function(parentMatrix){
	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    var i,len = this.layers.length;
	    if(renderParent===false){
	        this.hide();
	        return;
	    }

	    this.hidden = false;

	    for( i = 0; i < len; i+=1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	};

	HCompElement.prototype.checkLayers = BaseRenderer.prototype.checkLayers;
	HCompElement.prototype.buildItem = HybridRenderer.prototype.buildItem;
	HCompElement.prototype.checkPendingElements = HybridRenderer.prototype.checkPendingElements;
	HCompElement.prototype.addPendingElement = HybridRenderer.prototype.addPendingElement;
	HCompElement.prototype.buildAllItems = BaseRenderer.prototype.buildAllItems;
	HCompElement.prototype.createItem = HybridRenderer.prototype.createItem;
	HCompElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
	HCompElement.prototype.createImage = HybridRenderer.prototype.createImage;
	HCompElement.prototype.createComp = HybridRenderer.prototype.createComp;
	HCompElement.prototype.createSolid = HybridRenderer.prototype.createSolid;
	HCompElement.prototype.createShape = HybridRenderer.prototype.createShape;
	HCompElement.prototype.createText = HybridRenderer.prototype.createText;
	HCompElement.prototype.createBase = HybridRenderer.prototype.createBase;
	HCompElement.prototype.appendElementInPos = HybridRenderer.prototype.appendElementInPos;
	function HShapeElement(data,parentContainer,globalData,comp, placeholder){
	    this.shapes = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.itemsData = [];
	    this.prevViewData = [];
	    this.shapeModifiers = [];
	    this.processedElements = [];
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    };
	}
	createElement(HBaseElement, HShapeElement);
	var parent = HShapeElement.prototype._parent;
	extendPrototype(IShapeElement, HShapeElement);
	HShapeElement.prototype._parent = parent;
	HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderFrame;

	HShapeElement.prototype.createElements = function(){
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    var cont = document.createElementNS(svgNS,'svg');
	    styleDiv(cont);
	    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
	    cont.setAttribute('width',size.w);
	    cont.setAttribute('height',size.h);
	    if(this.data.hasMask){
	        var g = document.createElementNS(svgNS,'g');
	        parent.appendChild(cont);
	        cont.appendChild(g);
	        this.maskedElement = g;
	        this.layerElement = g;
	        this.shapesContainer = g;
	    }else{
	        parent.appendChild(cont);
	        this.layerElement = cont;
	        this.shapesContainer = document.createElementNS(svgNS,'g');
	        this.layerElement.appendChild(this.shapesContainer);
	    }
	    if(!this.data.hd){
	        //this.parentContainer.appendChild(parent);
	        this.baseElement = parent;
	    }
	    this.innerElem = parent;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }

	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement,this.dynamicProperties,0, [], true);
	    this.buildExpressionInterface();
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    this.shapeCont = cont;
	    if(this.data.bm !== 0){
	        this.setBlendMode();
	    }
	    this.checkParenting();
	};

	HShapeElement.prototype.renderFrame = function(parentMatrix){
	    var firstFrame = this.firstFrame;
	    this._renderShapeFrame();

	    if(this.isVisible && (this.elemMdf || firstFrame)){
	        var boundingBox = this.shapeCont.getBBox();
	        var changed = false;
	        if(this.currentBBox.w !== boundingBox.width){
	            this.currentBBox.w = boundingBox.width;
	            this.shapeCont.setAttribute('width',boundingBox.width);
	            changed = true;
	        }
	        if(this.currentBBox.h !== boundingBox.height){
	            this.currentBBox.h = boundingBox.height;
	            this.shapeCont.setAttribute('height',boundingBox.height);
	            changed = true;
	        }
	        if(changed  || this.currentBBox.x !== boundingBox.x  || this.currentBBox.y !== boundingBox.y){
	            this.currentBBox.w = boundingBox.width;
	            this.currentBBox.h = boundingBox.height;
	            this.currentBBox.x = boundingBox.x;
	            this.currentBBox.y = boundingBox.y;

	            this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	            this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	        }
	    }

	};
	function HTextElement(data,parentContainer,globalData,comp, placeholder){
	    this.textSpans = [];
	    this.textPaths = [];
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    }
	    this.renderType = 'svg';
	    this.isMasked = false;
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);

	}
	createElement(HBaseElement, HTextElement);

	extendPrototype(ITextElement, HTextElement);

	HTextElement.prototype.createElements = function(){
	    this.isMasked = this.checkMasks();
	    var parent = document.createElement('div');
	    styleDiv(parent);
	    this.layerElement = parent;
	    this.transformedElement = parent;
	    if(this.isMasked){
	        this.renderType = 'svg';
	        var cont = document.createElementNS(svgNS,'svg');
	        styleDiv(cont);
	        this.cont = cont;
	        this.compW = this.comp.data.w;
	        this.compH = this.comp.data.h;
	        cont.setAttribute('width',this.compW);
	        cont.setAttribute('height',this.compH);
	        var g = document.createElementNS(svgNS,'g');
	        cont.appendChild(g);
	        parent.appendChild(cont);
	        this.maskedElement = g;
	        this.innerElem = g;
	    } else {
	        this.renderType = 'html';
	        this.innerElem = parent;
	    }
	    this.baseElement = parent;

	    this.checkParenting();

	};

	HTextElement.prototype.buildNewText = function(){
	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = Array.apply(null,{length:this.textProperty.currentData.l ? this.textProperty.currentData.l.length : 0});
	    var innerElemStyle = this.innerElem.style;
	    innerElemStyle.color = innerElemStyle.fill = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
	    if(documentData.sc){
	        innerElemStyle.stroke = this.buildColor(documentData.sc);
	        innerElemStyle.strokeWidth = documentData.sw+'px';
	    }
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(!this.globalData.fontManager.chars){
	        innerElemStyle.fontSize = documentData.s+'px';
	        innerElemStyle.lineHeight = documentData.s+'px';
	        if(fontData.fClass){
	            this.innerElem.className = fontData.fClass;
	        } else {
	            innerElemStyle.fontFamily = fontData.fFamily;
	            var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	            innerElemStyle.fontStyle = fStyle;
	            innerElemStyle.fontWeight = fWeight;
	        }
	    }
	    var i, len;

	    var letters = documentData.l;
	    len = letters.length;
	    var tSpan,tParent,tCont;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '';
	    var cnt = 0;
	    for (i = 0;i < len ;i += 1) {
	        if(this.globalData.fontManager.chars){
	            if(!this.textPaths[cnt]){
	                tSpan = document.createElementNS(svgNS,'path');
	                tSpan.setAttribute('stroke-linecap', 'butt');
	                tSpan.setAttribute('stroke-linejoin','round');
	                tSpan.setAttribute('stroke-miterlimit','4');
	            } else {
	                tSpan = this.textPaths[cnt];
	            }
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tCont = tParent.children[0];
	                } else {

	                    tParent = document.createElement('div');
	                    tCont = document.createElementNS(svgNS,'svg');
	                    tCont.appendChild(tSpan);
	                    styleDiv(tParent);
	                }
	            }
	        }else{
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tSpan = this.textPaths[cnt];
	                } else {
	                    tParent = document.createElement('span');
	                    styleDiv(tParent);
	                    tSpan = document.createElement('span');
	                    styleDiv(tSpan);
	                    tParent.appendChild(tSpan);
	                }
	            } else {
	                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : document.createElementNS(svgNS,'text');
	            }
	        }
	        //tSpan.setAttribute('visibility', 'hidden');
	        if(this.globalData.fontManager.chars){
	            var charData = this.globalData.fontManager.getCharData(documentData.t.charAt(i), fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	            var shapeData;
	            if(charData){
	                shapeData = charData.data;
	            } else {
	                shapeData = null;
	            }
	            matrixHelper.reset();
	            if(shapeData && shapeData.shapes){
	                shapes = shapeData.shapes[0].it;
	                matrixHelper.scale(documentData.s/100,documentData.s/100);
	                shapeStr = this.createPathShape(matrixHelper,shapes);
	                tSpan.setAttribute('d',shapeStr);
	            }
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                if(shapeData && shapeData.shapes){
	                    document.body.appendChild(tCont);

	                    var boundingBox = tCont.getBBox();
	                    tCont.setAttribute('width',boundingBox.width + 2);
	                    tCont.setAttribute('height',boundingBox.height + 2);
	                    tCont.setAttribute('viewBox',(boundingBox.x-1)+' '+ (boundingBox.y-1)+' '+ (boundingBox.width+2)+' '+ (boundingBox.height+2));
	                    tCont.style.transform = tCont.style.webkitTransform = 'translate(' + (boundingBox.x-1) + 'px,' + (boundingBox.y-1) + 'px)';

	                    letters[i].yOffset = boundingBox.y-1;
	                    tParent.appendChild(tCont);

	                } else{
	                    tCont.setAttribute('width',1);
	                    tCont.setAttribute('height',1);
	                }
	            }else{
	                this.innerElem.appendChild(tSpan);
	            }
	        }else{
	            tSpan.textContent = letters[i].val;
	            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                //
	                tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,'+ -documentData.s/1.2+'px,0)';
	            } else {
	                this.innerElem.appendChild(tSpan);
	            }
	        }
	        //
	        if(!this.isMasked){
	            this.textSpans[cnt] = tParent;
	        }else{
	            this.textSpans[cnt] = tSpan;
	        }
	        this.textSpans[cnt].style.display = 'block';
	        this.textPaths[cnt] = tSpan;
	        cnt += 1;
	    }
	    while(cnt < this.textSpans.length){
	        this.textSpans[cnt].style.display = 'none';
	        cnt += 1;
	    }
	}

	HTextElement.prototype.hide = SVGTextElement.prototype.hide;

	HTextElement.prototype.renderFrame = function(parentMatrix){

	    var renderParent = this._parent.renderFrame.call(this,parentMatrix);
	    if(renderParent===false){
	        this.hide();
	        return;
	    }
	    if(this.hidden){
	        this.hidden = false;
	        this.innerElem.style.display = 'block';
	        this.layerElement.style.display = 'block';
	    }

	    if(this.data.singleShape){
	        if(!this.firstFrame && !this.lettersChangedFlag){
	            return;
	        } else {
	            // Todo Benchmark if using this is better than getBBox
	             if(this.isMasked && this.finalTransform.matMdf){
	                 this.cont.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+ -this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);
	                this.cont.style.transform = this.cont.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
	             }
	        }
	    }

	    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	    if(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag){
	        return;
	    }
	    var  i,len, count = 0;
	    var renderedLetters = this.textAnimator.renderedLetters;

	    var letters = this.textProperty.currentData.l;

	    len = letters.length;
	    var renderedLetter, textSpan, textPath;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            count += 1;
	            continue;
	        }
	        textSpan = this.textSpans[i];
	        textPath = this.textPaths[i];
	        renderedLetter = renderedLetters[count];
	        count += 1;
	        if(!this.isMasked){
	            textSpan.style.transform = textSpan.style.webkitTransform = renderedLetter.m;
	        }else{
	            textSpan.setAttribute('transform',renderedLetter.m);
	        }
	        ////textSpan.setAttribute('opacity',renderedLetter.o);
	        textSpan.style.opacity = renderedLetter.o;
	        if(renderedLetter.sw){
	            textPath.setAttribute('stroke-width',renderedLetter.sw);
	        }
	        if(renderedLetter.sc){
	            textPath.setAttribute('stroke',renderedLetter.sc);
	        }
	        if(renderedLetter.fc){
	            textPath.setAttribute('fill',renderedLetter.fc);
	            textPath.style.color = renderedLetter.fc;
	        }
	    }
	    if(this.isVisible && (this.elemMdf || this.firstFrame)){
	        if(this.innerElem.getBBox){
	            var boundingBox = this.innerElem.getBBox();

	            if(this.currentBBox.w !== boundingBox.width){
	                this.currentBBox.w = boundingBox.width;
	                this.cont.setAttribute('width',boundingBox.width);
	            }
	            if(this.currentBBox.h !== boundingBox.height){
	                this.currentBBox.h = boundingBox.height;
	                this.cont.setAttribute('height',boundingBox.height);
	            }

	            var margin = 1;
	            if(this.currentBBox.w !== (boundingBox.width + margin*2) || this.currentBBox.h !== (boundingBox.height + margin*2)  || this.currentBBox.x !== (boundingBox.x - margin)  || this.currentBBox.y !== (boundingBox.y - margin)){
	                this.currentBBox.w = boundingBox.width + margin*2;
	                this.currentBBox.h = boundingBox.height + margin*2;
	                this.currentBBox.x = boundingBox.x - margin;
	                this.currentBBox.y = boundingBox.y - margin;

	                this.cont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	                this.cont.style.transform = this.cont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	            }
	        }
	    }
	    if(this.firstFrame){
	        this.firstFrame = false;
	    }
	}
	function HImageElement(data,parentContainer,globalData,comp, placeholder){
	    this.assetData = globalData.getAssetData(data.refId);
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	}
	createElement(HBaseElement, HImageElement);

	HImageElement.prototype.createElements = function(){

	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	    var img = new Image();

	    if(this.data.hasMask){
	        var parent = document.createElement('div');
	        styleDiv(parent);
	        var cont = document.createElementNS(svgNS,'svg');
	        styleDiv(cont);
	        cont.setAttribute('width',this.assetData.w);
	        cont.setAttribute('height',this.assetData.h);
	        parent.appendChild(cont);
	        this.imageElem = document.createElementNS(svgNS,'image');
	        this.imageElem.setAttribute('width',this.assetData.w+"px");
	        this.imageElem.setAttribute('height',this.assetData.h+"px");
	        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	        cont.appendChild(this.imageElem);
	        this.layerElement = parent;
	        this.transformedElement = parent;
	        this.baseElement = parent;
	        this.innerElem = parent;
	        this.maskedElement = this.imageElem;
	    } else {
	        styleDiv(img);
	        this.layerElement = img;
	        this.baseElement = img;
	        this.innerElem = img;
	        this.transformedElement = img;
	    }
	    img.src = assetPath;
	    if(this.data.ln){
	        this.innerElem.setAttribute('id',this.data.ln);
	    }
	    this.checkParenting();
	};

	HImageElement.prototype.show = HSolidElement.prototype.show;
	HImageElement.prototype.hide = HSolidElement.prototype.hide;
	HImageElement.prototype.renderFrame = HSolidElement.prototype.renderFrame;
	HImageElement.prototype.destroy = HSolidElement.prototype.destroy;
	function HCameraElement(data,parentContainer,globalData,comp, placeholder){
	    this._parent.constructor.call(this,data,parentContainer,globalData,comp, placeholder);
	    var getProp = PropertyFactory.getProp;
	    this.pe = getProp(this,data.pe,0,0,this.dynamicProperties);
	    if(data.ks.p.s){
	        this.px = getProp(this,data.ks.p.x,1,0,this.dynamicProperties);
	        this.py = getProp(this,data.ks.p.y,1,0,this.dynamicProperties);
	        this.pz = getProp(this,data.ks.p.z,1,0,this.dynamicProperties);
	    }else{
	        this.p = getProp(this,data.ks.p,1,0,this.dynamicProperties);
	    }
	    if(data.ks.a){
	        this.a = getProp(this,data.ks.a,1,0,this.dynamicProperties);
	    }
	    if(data.ks.or.k.length && data.ks.or.k[0].to){
	        var i,len = data.ks.or.k.length;
	        for(i=0;i<len;i+=1){
	            data.ks.or.k[i].to = null;
	            data.ks.or.k[i].ti = null;
	        }
	    }
	    this.or = getProp(this,data.ks.or,1,degToRads,this.dynamicProperties);
	    this.or.sh = true;
	    this.rx = getProp(this,data.ks.rx,0,degToRads,this.dynamicProperties);
	    this.ry = getProp(this,data.ks.ry,0,degToRads,this.dynamicProperties);
	    this.rz = getProp(this,data.ks.rz,0,degToRads,this.dynamicProperties);
	    this.mat = new Matrix();
	}
	createElement(HBaseElement, HCameraElement);

	HCameraElement.prototype.setup = function() {
	    var i, len = this.comp.threeDElements.length, comp;
	    for(i=0;i<len;i+=1){
	        //[perspectiveElem,container]
	        comp = this.comp.threeDElements[i];
	        comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
	        comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = "0px 0px 0px";
	        comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    }
	};

	HCameraElement.prototype.createElements = function(){
	};

	HCameraElement.prototype.hide = function(){
	};

	HCameraElement.prototype.renderFrame = function(){
	    var mdf = this.firstFrame;
	    var i, len;
	    if(this.hierarchy){
	        len = this.hierarchy.length;
	        for(i=0;i<len;i+=1){
	            mdf = this.hierarchy[i].finalTransform.mProp.mdf ? true : mdf;
	        }
	    }
	    if(mdf || (this.p && this.p.mdf) || (this.px && (this.px.mdf || this.py.mdf || this.pz.mdf)) || this.rx.mdf || this.ry.mdf || this.rz.mdf || this.or.mdf || (this.a && this.a.mdf)) {
	        this.mat.reset();

	        if(this.p){
	            this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);
	        }else{
	            this.mat.translate(-this.px.v,-this.py.v,this.pz.v);
	        }
	        if(this.a){
	            var diffVector = [this.p.v[0]-this.a.v[0],this.p.v[1]-this.a.v[1],this.p.v[2]-this.a.v[2]];
	            var mag = Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));
	            //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
	            var lookDir = [diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];
	            var lookLengthOnXZ = Math.sqrt( lookDir[2]*lookDir[2] + lookDir[0]*lookDir[0] );
	            var m_rotationX = (Math.atan2( lookDir[1], lookLengthOnXZ ));
	            var m_rotationY = (Math.atan2( lookDir[0], -lookDir[2]));
	            this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);

	        }
	        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
	        this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);
	        this.mat.translate(0,0,this.pe.v);
	        if(this.hierarchy){
	            var mat;
	            len = this.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                mat = this.hierarchy[i].finalTransform.mProp.iv.props;
	                this.mat.transform(mat[0],mat[1],mat[2],mat[3],mat[4],mat[5],mat[6],mat[7],mat[8],mat[9],mat[10],mat[11],-mat[12],-mat[13],mat[14],mat[15]);
	            }
	        }
	        len = this.comp.threeDElements.length;
	        var comp;
	        for(i=0;i<len;i+=1){
	            comp = this.comp.threeDElements[i];
	            comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();
	        }
	    }
	    this.firstFrame = false;
	};

	HCameraElement.prototype.destroy = function(){
	};
	var Expressions = (function(){
	    var ob = {};
	    ob.initExpressions = initExpressions;


	    function initExpressions(animation){
	        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
	        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
	    }
	   return ob;
	}());

	expressionsPlugin = Expressions;

	(function addPropertyDecorator() {

	    function getStaticValueAtTime() {
	        return this.pv;
	    }

	    function loopOut(type,duration,durationFlag){
	        if(!this.k || !this.keyframes){
	            return this.pv;
	        }
	        var currentFrame = this.comp.renderedFrame;
	        var keyframes = this.keyframes;
	        var lastKeyFrame = keyframes[keyframes.length - 1].t;
	        if(currentFrame<=lastKeyFrame){
	            return this.pv;
	        }else{
	            var cycleDuration, firstKeyFrame;
	            if(!durationFlag){
	                if(!duration || duration > keyframes.length - 1){
	                    duration = keyframes.length - 1;
	                }
	                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
	                cycleDuration = lastKeyFrame - firstKeyFrame;
	            } else {
	                if(!duration){
	                    cycleDuration = Math.max(0,lastKeyFrame - this.elem.data.ip);
	                } else {
	                    cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate*duration);
	                }
	                firstKeyFrame = lastKeyFrame - cycleDuration;
	            }
	            var offsetTime = this.offsetTime || 0;
	            var i, len, ret;
	            if(type.toLowerCase() === 'pingpong') {
	                var iterations = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                if(iterations % 2 !== 0){
	                    return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) - offsetTime) / this.comp.globalData.frameRate, 0);
	                }
	            } else if(type === 'offset'){
	                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                var repeats = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                if(this.pv.length){
	                    ret = new Array(initV.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = (endV[i]-initV[i])*repeats + current[i];
	                    }
	                    return ret;
	                }
	                return (endV-initV)*repeats + current;
	            } else if(type === 'continue'){
	                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
	                if(this.pv.length){
	                    ret = new Array(lastValue.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = lastValue[i] + (lastValue[i]-nextLastValue[i])*((currentFrame - lastKeyFrame)/ this.comp.globalData.frameRate)/0.0005;
	                    }
	                    return ret;
	                }
	                return lastValue + (lastValue-nextLastValue)*(((currentFrame - lastKeyFrame))/0.001);
	            }
	            return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) - offsetTime) / this.comp.globalData.frameRate, 0);
	        }
	    }

	    function loopIn(type,duration, durationFlag) {
	        if(!this.k){
	            return this.pv;
	        }
	        var currentFrame = time*elem.comp.globalData.frameRate;
	        var keyframes = this.keyframes;
	        var firstKeyFrame = keyframes[0].t;
	        var offsetTime = this.offsetTime || 0;
	        if(currentFrame>=firstKeyFrame){
	            return this.pv;
	        }else{
	            var cycleDuration, lastKeyFrame;
	            if(!durationFlag){
	                if(!duration || duration > keyframes.length - 1){
	                    duration = keyframes.length - 1;
	                }
	                lastKeyFrame = keyframes[duration].t;
	                cycleDuration = lastKeyFrame - firstKeyFrame;
	            } else {
	                if(!duration){
	                    cycleDuration = Math.max(0,this.elem.data.op - firstKeyFrame);
	                } else {
	                    cycleDuration = Math.abs(elem.comp.globalData.frameRate*duration);
	                }
	                lastKeyFrame = firstKeyFrame + cycleDuration;
	            }
	            var i, len, ret;
	            if(type === 'pingpong') {
	                var iterations = Math.floor((firstKeyFrame - currentFrame)/cycleDuration);
	                if(iterations % 2 === 0){
	                    return this.getValueAtTime((((firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) - offsetTime) / this.comp.globalData.frameRate, 0);
	                }
	            } else if(type === 'offset'){
	                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                var repeats = Math.floor((firstKeyFrame - currentFrame)/cycleDuration)+1;
	                if(this.pv.length){
	                    ret = new Array(initV.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = current[i]-(endV[i]-initV[i])*repeats;
	                    }
	                    return ret;
	                }
	                return current-(endV-initV)*repeats;
	            } else if(type === 'continue'){
	                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
	                if(this.pv.length){
	                    ret = new Array(firstValue.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = firstValue[i] + (firstValue[i]-nextFirstValue[i])*(firstKeyFrame - currentFrame)/0.001;
	                    }
	                    return ret;
	                }
	                return firstValue + (firstValue-nextFirstValue)*(firstKeyFrame - currentFrame)/0.001;
	            }

	            return this.getValueAtTime(((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration +  firstKeyFrame) - offsetTime) / this.comp.globalData.frameRate, 0);
	        }
	    }

	    function getValueAtTime(frameNum) {
	        if(!this._cachingAtTime) {
	            this._cachingAtTime = {lastValue:-99999,lastIndex:0};
	        }
	        //console.log('this._cachingAtTime', JSON.parse(JSON.stringify(this._cachingAtTime)))
	        if(frameNum !== this._cachingAtTime.lastFrame) {
	            frameNum *= this.elem.globalData.frameRate;
	            frameNum -= this.offsetTime;
	            var i = this._caching.lastFrame < frameNum ? this._caching.lastIndex : 0;
	            var interpolationResult = this.interpolateValue(frameNum, i, this.pv, this._cachingAtTime);
	            this._cachingAtTime.lastIndex = interpolationResult.iterationIndex;
	            this._cachingAtTime.value = interpolationResult.value;
	            this._cachingAtTime.lastFrame = frameNum;
	        }
	        return this._cachingAtTime.value;

	    }

	    function getVelocityAtTime(frameNum) {
	        if(this.vel !== undefined){
	            return this.vel;
	        }
	        var delta = -0.01;
	        //frameNum += this.elem.data.st;
	        var v1 = this.getValueAtTime(frameNum);
	        var v2 = this.getValueAtTime(frameNum + delta);
	        var velocity;
	        if(v1.length){
	            velocity = Array.apply(null,{length:v1.length});
	            var i;
	            for(i=0;i<v1.length;i+=1){
	                //removing frameRate
	                //if needed, don't add it here
	                //velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
	                velocity[i] = (v2[i] - v1[i])/delta;
	            }
	        } else {
	            velocity = (v2 - v1)/delta;
	        }
	        return velocity;
	    };

	    function setGroupProperty(propertyGroup){
	        this.propertyGroup = propertyGroup;
	    }

	    function searchExpressions(elem,data,prop){
	        if(data.x){
	            prop.k = true;
	            prop.x = true;
	            if(prop.getValue) {
	                prop.getPreValue = prop.getValue;
	            }
	            prop.getValue = ExpressionManager.initiateExpression.bind(prop)(elem,data,prop);
	        }
	    }

	    function getTransformValueAtTime(time) {
	        console.log('time:', time)
	    }

	    function getTransformStaticValueAtTime(time) {

	    }

	    var TextExpressionSelectorProp = (function(){

	        function getValueProxy(index,total){
	            this.textIndex = index+1;
	            this.textTotal = total;
	            this.getValue();
	            return this.v;
	        }

	        return function TextExpressionSelectorProp(elem,data){
	            this.pv = 1;
	            this.comp = elem.comp;
	            this.elem = elem;
	            this.mult = .01;
	            this.type = 'textSelector';
	            this.textTotal = data.totalChars;
	            this.selectorValue = 100;
	            this.lastValue = [1,1,1];
	            searchExpressions.bind(this)(elem,data,this);
	            this.getMult = getValueProxy;
	            this.getVelocityAtTime = getVelocityAtTime;
	            if(this.kf){
	                this.getValueAtTime = getValueAtTime.bind(this);
	            } else {
	                this.getValueAtTime = getStaticValueAtTime.bind(this);
	            }
	            this.setGroupProperty = setGroupProperty;
	        }
	    }());


	    var propertyGetProp = PropertyFactory.getProp;
	    PropertyFactory.getProp = function(elem,data,type, mult, arr){
	        var prop = propertyGetProp(elem,data,type, mult, arr);
	        //prop.getVelocityAtTime = getVelocityAtTime;
	        //prop.loopOut = loopOut;
	        //prop.loopIn = loopIn;
	        if(type === 2) {
	            if(prop.dynamicProperties.length) {
	                prop.getValueAtTime = getTransformValueAtTime.bind(prop);
	            } else {
	                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
	            }
	        } else {
	            if(prop.kf){
	                prop.getValueAtTime = getValueAtTime.bind(prop);
	            } else {
	                prop.getValueAtTime = getStaticValueAtTime.bind(prop);
	            }
	        }
	        prop.setGroupProperty = setGroupProperty;
	        prop.loopOut = loopOut;
	        prop.loopIn = loopIn;
	        prop.getVelocityAtTime = getVelocityAtTime;
	        prop.numKeys = data.a === 1 ? data.k.length : 0;
	        var isAdded = prop.k;
	        if(data.ix !== undefined){
	            Object.defineProperty(prop,'propertyIndex',{
	                get: function(){
	                    return data.ix;
	                }
	            })
	        }
	        searchExpressions(elem,data,prop);
	        if(!isAdded && prop.x){
	            arr.push(prop);
	        }

	        return prop;
	    }

	    function getShapeValueAtTime(frameNum) {
	        if (!this._shapeValueAtTime) {
	            this._lastIndexAtTime = 0;
	            this._lastTimeAtTime = -999999;
	            this._shapeValueAtTime = shape_pool.clone(this.pv);
	        }
	        if(frameNum !== this._lastTimeAtTime) {
	            this._lastTimeAtTime = frameNum;
	            frameNum *= this.elem.globalData.frameRate;
	            var interpolationResult = this.interpolateShape(frameNum, this._lastIndexAtTime, this._shapeValueAtTime, false);
	            this._lastIndexAtTime = interpolationResult.iterationIndex;
	        }
	        return this._shapeValueAtTime;
	    }

	    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
	    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

	    ShapePropertyConstructorFunction.prototype.vertices = function(prop, time){
	        var shapePath = this.v;
	        if(time !== undefined) {
	            shapePath = this.getValueAtTime(time, 0);
	        }
	        var i, len = shapePath._length;
	        var vertices = shapePath[prop];
	        var points = shapePath.v;
	        var arr = Array.apply(null,{length:len})
	        for(i = 0; i < len; i += 1) {
	            if(prop === 'i' || prop === 'o') {
	                arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]]
	            } else {
	                arr[i] = [vertices[i][0], vertices[i][1]]
	            }
	            
	        }
	        return arr;
	    }

	    ShapePropertyConstructorFunction.prototype.points = function(time){
	        return this.vertices('v', time);
	    }

	    ShapePropertyConstructorFunction.prototype.inTangents = function(time){
	        return this.vertices('i', time);
	    }

	    ShapePropertyConstructorFunction.prototype.outTangents = function(time){
	        return this.vertices('o', time);
	    }

	    ShapePropertyConstructorFunction.prototype.isClosed = function(){
	        return this.v.c;
	    }

	    ShapePropertyConstructorFunction.prototype.pointOnPath = function(perc, time){
	        var shapePath = this.v;
	        if(time !== undefined) {
	            shapePath = this.getValueAtTime(time, 0);
	        }
	        if(!this._segmentsLength) {
	            this._segmentsLength = bez.getSegmentsLength(shapePath);
	        }

	        var segmentsLength = this._segmentsLength;
	        var lengths = segmentsLength.lengths;
	        var lengthPos = segmentsLength.totalLength * perc;
	        var i = 0, len = lengths.length;
	        var j = 0, jLen;
	        var accumulatedLength = 0;
	        var segments;
	        while(i < len) {
	            if(accumulatedLength + lengths[i].addedLength > lengthPos) {
	                segments = lengths[i].segments;
	                var initIndex = i;
	                var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
	                var segmentPerc = (lengthPos - accumulatedLength)/lengths[i].addedLength;
	                var pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i])
	                break;
	            } else {
	                accumulatedLength += lengths[i].addedLength;
	            }
	            i += 1;
	        }
	        if(!pt){
	            pt = shapePath.c ? [shapePath.v[0][0],shapePath.v[0][1]]:[shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1]]
	        }
	        return pt;
	    }

	    ShapePropertyConstructorFunction.prototype.vectorOnPath = function(perc, time, vectorType){
	        //perc doesn't use triple equality because can be a Number object, not a primitive.
	        perc = perc == 1 ? this.v.c ? 0 : 0.999 : perc;
	        var pt1 = this.pointOnPath(perc, time);
	        var pt2 = this.pointOnPath(perc + 0.001, time);
	        var xLength = pt2[0] - pt1[0];
	        var yLength = pt2[1] - pt1[1];
	        var magnitude = Math.sqrt(Math.pow(xLength,2) + Math.pow(yLength,2));
	        var unitVector = vectorType === 'tangent' ? [xLength/magnitude, yLength/magnitude] : [-yLength/magnitude, xLength/magnitude];
	        return unitVector;
	    }

	    ShapePropertyConstructorFunction.prototype.tangentOnPath = function(perc, time){
	        return this.vectorOnPath(perc, time, 'tangent');
	    }

	    ShapePropertyConstructorFunction.prototype.normalOnPath = function(perc, time){
	        return this.vectorOnPath(perc, time, 'normal');
	    }

	    ShapePropertyConstructorFunction.prototype.setGroupProperty = setGroupProperty;
	    ShapePropertyConstructorFunction.prototype.getValueAtTime = getStaticValueAtTime;

	    KeyframedShapePropertyConstructorFunction.prototype.vertices = ShapePropertyConstructorFunction.prototype.vertices;
	    KeyframedShapePropertyConstructorFunction.prototype.points = ShapePropertyConstructorFunction.prototype.points;
	    KeyframedShapePropertyConstructorFunction.prototype.inTangents = ShapePropertyConstructorFunction.prototype.inTangents;
	    KeyframedShapePropertyConstructorFunction.prototype.outTangents = ShapePropertyConstructorFunction.prototype.outTangents;
	    KeyframedShapePropertyConstructorFunction.prototype.isClosed = ShapePropertyConstructorFunction.prototype.isClosed;
	    KeyframedShapePropertyConstructorFunction.prototype.pointOnPath = ShapePropertyConstructorFunction.prototype.pointOnPath;
	    KeyframedShapePropertyConstructorFunction.prototype.vectorOnPath = ShapePropertyConstructorFunction.prototype.vectorOnPath;
	    KeyframedShapePropertyConstructorFunction.prototype.tangentOnPath = ShapePropertyConstructorFunction.prototype.tangentOnPath;
	    KeyframedShapePropertyConstructorFunction.prototype.normalOnPath = ShapePropertyConstructorFunction.prototype.normalOnPath;
	    KeyframedShapePropertyConstructorFunction.prototype.setGroupProperty = ShapePropertyConstructorFunction.prototype.setGroupProperty;
	    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;

	    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
	    ShapePropertyFactory.getShapeProp = function(elem,data,type, arr, trims){
	        var prop = propertyGetShapeProp(elem,data,type, arr, trims);
	        var isAdded = prop.k;
	        if(data.ix !== undefined){
	            Object.defineProperty(prop,'propertyIndex',{
	                get: function(){
	                    return data.ix;
	                }
	            })
	        }
	        if(type === 3){
	            searchExpressions(elem,data.pt,prop);
	        } else if(type === 4){
	            searchExpressions(elem,data.ks,prop);
	        }
	        if(!isAdded && prop.x){
	            arr.push(prop);
	        }
	        return prop;
	    }

	    var propertyGetTextProp = PropertyFactory.getTextSelectorProp;
	    PropertyFactory.getTextSelectorProp = function(elem, data,arr){
	        if(data.t === 1){
	            return new TextExpressionSelectorProp(elem, data,arr);
	        } else {
	            return propertyGetTextProp(elem,data,arr);
	        }
	    }
	}());
	(function addTextPropertyDecorator() {

	    function searchExpressions(){
	        if(this.data.d.x){
	            this.comp = this.elem.comp;
	            if(this.getValue) {
	                this.getPreValue = this.getValue;
	            }
	            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem,this.data.d,this);
	            this.getValue = this.getExpressionValue;
	            return true;
	        }
	        return false;
	    }

	    TextProperty.prototype.searchProperty = function(){
	        this.kf = this.searchExpressions() || this.data.d.k.length > 1;
	        return this.kf;
	    }

	    TextProperty.prototype.getExpressionValue = function(num){
	        this.calculateExpression();
	        if(this.mdf) {
	            this.currentData.t = this.v.toString();
	            this.completeTextData(this.currentData);
	        }
	    }

	    TextProperty.prototype.searchExpressions = searchExpressions;
	    
	}());
	var ExpressionManager = (function(){
	    var ob = {};
	    var Math = BMMath;
	    var window = null;
	    var document = null;

	    function duplicatePropertyValue(value, mult){
	        mult = mult || 1;

	        if(typeof value === 'number'  || value instanceof Number){
	            return value*mult;
	        }else if(value.i){
	            return JSON.parse(JSON.stringify(value));
	        }else{
	            var arr = Array.apply(null,{length:value.length});
	            var i, len = value.length;
	            for(i=0;i<len;i+=1){
	                arr[i]=value[i]*mult;
	            }
	            return arr;
	        }
	    }

	    function shapesEqual(shape1, shape2) {
	        if(shape1._length !== shape2._length || shape1.c !== shape2.c){
	            return false;
	        }
	        var i, len = shape1._length;
	        for(i = 0; i < len; i += 1) {
	            if(shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1]
	                || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1]
	                || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]){
	                return false;
	            }
	        }
	        return true;
	    }

	    function $bm_neg(a){
	        var tOfA = typeof a;
	        if(tOfA === 'number' || tOfA === 'boolean'  || a instanceof Number ){
	            return -a;
	        }
	        if(a.constructor === Array){
	            var i, lenA = a.length;
	            var retArr = [];
	            for(i=0;i<lenA;i+=1){
	                retArr[i] = -a[i];
	            }
	            return retArr;
	        }
	    }

	    function sum(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if(tOfA === 'string' || tOfB === 'string'){
	            return a + b;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string'  || b instanceof Number)) {
	            return a + b;
	        }
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            a[0] = a[0] + b;
	            return a;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b.constructor === Array){
	            b[0] = a + b[0];
	            return b;
	        }
	        if(a.constructor === Array && b.constructor === Array){
	            
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)){
	                    retArr[i] = a[i] + b[i];
	                }else{
	                    retArr[i] = b[i] == undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }
	    var add = sum;

	    function sub(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            if(tOfA === 'string') {
	                a = parseInt(a);
	            }
	            if(tOfB === 'string') {
	                b = parseInt(b);
	            }
	            return a - b;
	        }
	        if( a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            a[0] = a[0] - b;
	            return a;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) &&  b.constructor === Array){
	            b[0] = a - b[0];
	            return b;
	        }
	        if(a.constructor === Array && b.constructor === Array){
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if((typeof a[i] === 'number' || a[i] instanceof Number) && typeof (typeof b[i] === 'number' || b[i] instanceof Number)){
	                    retArr[i] = a[i] - b[i];
	                }else{
	                    retArr[i] = b[i] == undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }

	    function mul(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            return a * b;
	        }

	        var i, len;
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )){
	            len = a.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] * b;
	            }
	            return arr;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b.constructor === Array){
	            len = b.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a * b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }

	    function div(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number )) {
	            return a / b;
	        }
	        var i, len;
	        if(a.constructor === Array && (tOfB === 'number' || tOfB === 'boolean' || tOfB === 'string' || b instanceof Number  )){
	            len = a.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] / b;
	            }
	            return arr;
	        }
	        if((tOfA === 'number' || tOfA === 'boolean' || tOfA === 'string' || a instanceof Number ) && b.constructor === Array){
	            len = b.length;
	            arr = Array.apply(null,{length:len});
	            for(i=0;i<len;i+=1){
	                arr[i] = a / b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }
	    function mod(a,b) {
	        if(typeof a === 'string') {
	            a = parseInt(a);
	        }
	        if(typeof b === 'string') {
	            b = parseInt(b);
	        }
	        return a % b;
	    }

	    function clamp(num, min, max) {
	        if(min > max){
	            var mm = max;
	            max = min;
	            min = mm;
	        }
	        return Math.min(Math.max(num, min), max);
	    }

	    function radiansToDegrees(val) {
	        return val/degToRads;
	    }
	    var radians_to_degrees = radiansToDegrees;

	    function degreesToRadians(val) {
	        return val*degToRads;
	    }
	    var degrees_to_radians = radiansToDegrees;

	    var helperLengthArray = [0,0,0,0,0,0];

	    function length(arr1,arr2){
	        if(typeof arr1 === 'number' || arr1 instanceof Number){
	            arr2 = arr2 || 0;
	            return Math.abs(arr1 - arr2);
	        }
	        if(!arr2){
	            arr2 = helperLengthArray;
	        }
	        var i,len = Math.min(arr1.length,arr2.length);
	        var addedLength = 0;
	        for(i=0;i<len;i+=1){
	            addedLength += Math.pow(arr2[i]-arr1[i],2);
	        }
	        return Math.sqrt(addedLength);
	    }

	    function normalize(vec){
	        return div(vec, length(vec));
	    }

	    function rgbToHsl(val){
	        var r = val[0]; var g = val[1]; var b = val[2];
	        var max = Math.max(r, g, b), min = Math.min(r, g, b);
	        var h, s, l = (max + min) / 2;

	        if(max == min){
	            h = s = 0; // achromatic
	        }else{
	            var d = max - min;
	            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	            switch(max){
	                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	                case g: h = (b - r) / d + 2; break;
	                case b: h = (r - g) / d + 4; break;
	            }
	            h /= 6;
	        }

	        return [h, s, l,val[3]];
	    }
	    function hslToRgb(val){
	        var h = val[0];
	        var s = val[1];
	        var l = val[2];

	        var r, g, b;

	        if(s == 0){
	            r = g = b = l; // achromatic
	        }else{
	            function hue2rgb(p, q, t){
	                if(t < 0) t += 1;
	                if(t > 1) t -= 1;
	                if(t < 1/6) return p + (q - p) * 6 * t;
	                if(t < 1/2) return q;
	                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	                return p;
	            }

	            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	            var p = 2 * l - q;
	            r = hue2rgb(p, q, h + 1/3);
	            g = hue2rgb(p, q, h);
	            b = hue2rgb(p, q, h - 1/3);
	        }

	        return [r, g , b, val[3]];
	    }

	    function linear(t, tMin, tMax, value1, value2){
	        if(value1 === undefined || value2 === undefined){
	            return linear(t,0,1,tMin,tMax);
	        }
	        if(t <= tMin) {
	            return value1;
	        }else if(t >= tMax){
	            return value2;
	        }
	        var perc = tMax === tMin ? 0 : (t-tMin)/(tMax-tMin);
	        if(!value1.length){
	            return value1 + (value2-value1)*perc;
	        }
	        var i, len = value1.length;
	        var arr = Array.apply( null, { length: len } );
	        for(i=0;i<len;i+=1){
	            arr[i] = value1[i] + (value2[i]-value1[i])*perc;
	        }
	        return arr;
	    }
	    function random(min,max){
	        if(max === undefined){
	            if(min === undefined){
	                min = 0;
	                max = 1;
	            } else {
	                max = min;
	                min = undefined;
	            }
	        }
	        if(max.length){
	            var i, len = max.length;
	            if(!min){
	                min = Array.apply(null,{length:len});
	            }
	            var arr = Array.apply(null,{length:len});
	            var rnd = BMMath.random();
	            for(i=0;i<len;i+=1){
	                arr[i] = min[i] + rnd*(max[i]-min[i])
	            }
	            return arr;
	        }
	        if(min === undefined){
	            min = 0;
	        }
	        var rndm = BMMath.random();
	        return min + rndm*(max-min);
	    }

	    function createPath(points, inTangents, outTangents, closed) {
	        inTangents = inTangents && inTangents.length ? inTangents : points;
	        outTangents = outTangents && outTangents.length ? outTangents : points;
	        var path = shape_pool.newShape();
	        var len = points.length;
	        path.setPathData(closed, len);
	        for(i = 0; i < len; i += 1) {
	            path.setTripleAt(points[i][0],points[i][1],outTangents[i][0] + points[i][0],outTangents[i][1] + points[i][1],inTangents[i][0] + points[i][0],inTangents[i][1] + points[i][1],i,true)
	        }
	        return path
	    }

	    function initiateExpression(elem,data,property){
	        var val = data.x;
	        var needsVelocity = /velocity(?![\w\d])/.test(val);
	        var _needsRandom = val.indexOf('random') !== -1;
	        var elemType = elem.data.ty;
	        var transform,content,effect;
	        var thisComp = elem.comp;
	        var thisProperty = property;
	        elem.comp.frameDuration = 1/elem.comp.globalData.frameRate;
	        var inPoint = elem.data.ip/elem.comp.globalData.frameRate;
	        var outPoint = elem.data.op/elem.comp.globalData.frameRate;
	        var width = elem.data.sw ? elem.data.sw : 0;
	        var height = elem.data.sh ? elem.data.sh : 0;
	        var loopIn, loop_in, loopOut, loop_out;
	        var toWorld,fromWorld,fromComp,fromCompToSurface,anchorPoint,thisLayer,thisComp,mask,valueAtTime,velocityAtTime;
	        var fn = new Function();
	        //var fnStr = 'var fn = function(){'+val+';this.v = $bm_rt;}';
	        //eval(fnStr);

	        var fn = eval('[function(){' + val+';if($bm_rt.__shapeObject){this.v=shape_pool.clone($bm_rt.v);}else{this.v=$bm_rt;}}' + ']')[0];
	        var bindedFn = fn.bind(this);
	        var numKeys = property.kf ? data.k.length : 0;

	        var wiggle = function wiggle(freq,amp){
	            var i,j, len = this.pv.length ? this.pv.length : 1;
	            var addedAmps = Array.apply(null,{len:len});
	            for(j=0;j<len;j+=1){
	                addedAmps[j] = 0;
	            }
	            freq = 5;
	            var iterations = Math.floor(time*freq);
	            i = 0;
	            j = 0;
	            while(i<iterations){
	                //var rnd = BMMath.random();
	                for(j=0;j<len;j+=1){
	                    addedAmps[j] += -amp + amp*2*BMMath.random();
	                    //addedAmps[j] += -amp + amp*2*rnd;
	                }
	                i += 1;
	            }
	            //var rnd2 = BMMath.random();
	            var periods = time*freq;
	            var perc = periods - Math.floor(periods);
	            var arr = Array.apply({length:len});
	            if(len>1){
	                for(j=0;j<len;j+=1){
	                    arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*BMMath.random())*perc;
	                    //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
	                    //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
	                }
	                return arr;
	            } else {
	                return this.pv + addedAmps[0] + (-amp + amp*2*BMMath.random())*perc;
	            }
	        }.bind(this);

	        if(thisProperty.loopIn) {
	            loopIn = thisProperty.loopIn.bind(thisProperty);
	            loop_in = loopIn;
	        }

	        if(thisProperty.loopOut) {
	            loopOut = thisProperty.loopOut.bind(thisProperty);
	            loop_out = loopOut;
	        }

	        var loopInDuration = function loopInDuration(type,duration){
	            return loopIn(type,duration,true);
	        }.bind(this);

	        var loopOutDuration = function loopOutDuration(type,duration){
	            return loopOut(type,duration,true);
	        }.bind(this);

	        if(this.getValueAtTime) {
	            valueAtTime = this.getValueAtTime.bind(this);
	        }

	        if(this.getVelocityAtTime) {
	            velocityAtTime = this.getVelocityAtTime.bind(this);
	        }

	        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

	        function lookAt(elem1,elem2){
	            var fVec = [elem2[0]-elem1[0],elem2[1]-elem1[1],elem2[2]-elem1[2]];
	            var pitch = Math.atan2(fVec[0],Math.sqrt(fVec[1]*fVec[1]+fVec[2]*fVec[2]))/degToRads;
	            var yaw = -Math.atan2(fVec[1],fVec[2])/degToRads;
	            return [yaw,pitch,0];
	        };

	        function easeOut(t, val1, val2){
	            return -(val2-val1) * t*(t-2) + val1;
	        };

	        function nearestKey(time){
	            var i, len = data.k.length,index,keyTime;
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                index = 0;
	                keyTime = 0;
	            } else {
	                index = -1;
	                time *= elem.comp.globalData.frameRate;
	                if (time < data.k[0].t) {
	                    index = 1;
	                    keyTime = data.k[0].t;
	                } else {
	                    for(i=0;i<len-1;i+=1){
	                        if(time === data.k[i].t){
	                            index = i + 1;
	                            keyTime = data.k[i].t;
	                            break;
	                        }else if(time>data.k[i].t && time<data.k[i+1].t){
	                            if(time-data.k[i].t > data.k[i+1].t - time){
	                                index = i + 2;
	                                keyTime = data.k[i+1].t;
	                            } else {
	                                index = i + 1;
	                                keyTime = data.k[i].t;
	                            }
	                            break;
	                        }
	                    }
	                    if(index === -1){
	                        index = i + 1;
	                        keyTime = data.k[i].t;
	                    }
	                }
	                
	            }
	            var ob = {};
	            ob.index = index;
	            ob.time = keyTime/elem.comp.globalData.frameRate;
	            return ob;
	        };

	        function key(ind){
	            var ob, i, len;
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                throw new Error('The property has no keyframe at index ' + ind);
	            }
	            ind -= 1;
	            ob = {
	                time: data.k[ind].t/elem.comp.globalData.frameRate
	            };
	            var arr;
	            if(ind === data.k.length - 1 && !data.k[ind].h){
	                arr = data.k[ind-1].e;
	            }else{
	                arr = data.k[ind].s;
	            }
	            len = arr.length;
	            for(i=0;i<len;i+=1){
	                ob[i] = arr[i];
	            }
	            return ob;
	        };

	        function framesToTime(frames,fps){
	            if(!fps){
	                fps = elem.comp.globalData.frameRate;
	            }
	            return frames/fps;
	        };

	        function timeToFrames(t,fps){
	            if(!t && t !== 0){
	                t = time;
	            }
	            if(!fps){
	                fps = elem.comp.globalData.frameRate;
	            }
	            return t*fps;
	        };

	        function seedRandom(seed){
	            BMMath.seedrandom(randSeed + seed);
	        };

	        function sourceRectAtTime() {
	            return elem.sourceRectAtTime();
	        }

	        var time,velocity, value,textIndex,textTotal,selectorValue;
	        var index = elem.data.ind;
	        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	        var parent;
	        var randSeed = Math.floor(Math.random()*1000000);
	        function executeExpression(){
	            if(_needsRandom){
	                seedRandom(randSeed);
	            }
	            if(this.frameExpressionId === elem.globalData.frameId && this.type !== 'textSelector'){
	                return;
	            }
	            if(this.lock){
	                this.v = duplicatePropertyValue(this.pv,this.mult);
	                return true;
	            }
	            if(this.type === 'textSelector'){
	                textIndex = this.textIndex;
	                textTotal = this.textTotal;
	                selectorValue = this.selectorValue;
	            }
	            if(!thisLayer){
	                thisLayer = elem.layerInterface;
	                thisComp = elem.comp.compInterface;
	                toWorld = thisLayer.toWorld.bind(thisLayer);
	                fromWorld = thisLayer.fromWorld.bind(thisLayer);
	                fromComp = thisLayer.fromComp.bind(thisLayer);
	                mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer):null;
	                fromCompToSurface = fromComp;
	            }
	            if(!transform){
	                transform = elem.layerInterface("ADBE Transform Group");
	                anchorPoint = transform.anchorPoint;
	            }
	            
	            if(elemType === 4 && !content){
	                content = thisLayer("ADBE Root Vectors Group");
	            }
	            if(!effect){
	                effect = thisLayer(4);
	            }
	            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	            if(hasParent && !parent){
	                parent = elem.hierarchy[0].layerInterface;
	            }
	            this.lock = true;
	            if(this.getPreValue){
	                this.getPreValue();
	            }
	            value = this.pv;
	            time = this.comp.renderedFrame/this.comp.globalData.frameRate;
	            if(needsVelocity){
	                velocity = velocityAtTime(time);
	            }
	            bindedFn();
	            this.frameExpressionId = elem.globalData.frameId;
	            var i,len;
	            if(this.mult){
	                if(typeof this.v === 'number' || this.v instanceof Number || this.v instanceof String || typeof this.v === 'string'){
	                    this.v *= this.mult;
	                }else if(this.v.length === 1){
	                    this.v = this.v[0] * this.mult;
	                }else{
	                    len = this.v.length;
	                    if(value === this.v){
	                        this.v = len === 2 ? [value[0],value[1]] : [value[0],value[1],value[2]];
	                    }
	                    for(i = 0; i < len; i += 1){
	                        this.v[i] *= this.mult;
	                    }
	                }
	            }
	            if(this.v.length === 1){
	                this.v = this.v[0];
	            }
	            if(typeof this.v === 'number' || this.v instanceof Number || this.v instanceof String || typeof this.v === 'string'){
	                if(this.lastValue !== this.v){
	                    this.lastValue = this.v;
	                    this.mdf = true;
	                }
	            }else if( this.v._length){
	                if(!shapesEqual(this.v,this.localShapeCollection.shapes[0])){
	                    this.mdf = true;
	                    this.localShapeCollection.releaseShapes();
	                    this.localShapeCollection.addShape(shape_pool.clone(this.v));
	                }
	            }else{
	                len = this.v.length;
	                for(i = 0; i < len; i += 1){
	                    if(this.v[i] !== this.lastValue[i]){
	                        this.lastValue[i] = this.v[i];
	                        this.mdf = true;
	                    }
	                }
	            }
	            this.lock = false;
	        }
	        return executeExpression;
	    };

	    ob.initiateExpression = initiateExpression;
	    return ob;
	}());
	var ShapeExpressionInterface = (function(){
	    var ob = {
	        createShapeInterface:createShapeInterface,
	        createGroupInterface:createGroupInterface,
	        createTrimInterface:createTrimInterface,
	        createStrokeInterface:createStrokeInterface,
	        createTransformInterface:createTransformInterface,
	        createEllipseInterface:createEllipseInterface,
	        createStarInterface:createStarInterface,
	        createRectInterface:createRectInterface,
	        createRoundedInterface:createRoundedInterface,
	        createRepatearInterface:createRepatearInterface,
	        createPathInterface:createPathInterface,
	        createFillInterface:createFillInterface
	    };
	    function createShapeInterface(shapes,view,propertyGroup){
	        return shapeInterfaceFactory(shapes,view,propertyGroup);
	    }
	    function createGroupInterface(shapes,view,propertyGroup){
	        return groupInterfaceFactory(shapes,view,propertyGroup);
	    }
	    function createFillInterface(shape,view,propertyGroup){
	        return fillInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createStrokeInterface(shape,view,propertyGroup){
	        return strokeInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createTrimInterface(shape,view,propertyGroup){
	        return trimInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createTransformInterface(shape,view,propertyGroup){
	        return transformInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createEllipseInterface(shape,view,propertyGroup){
	        return ellipseInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createStarInterface(shape,view,propertyGroup){
	        return starInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRectInterface(shape,view,propertyGroup){
	        return rectInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRoundedInterface(shape,view,propertyGroup){
	        return roundedInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createRepatearInterface(shape,view,propertyGroup){
	        return repeaterInterfaceFactory(shape,view,propertyGroup);
	    }
	    function createPathInterface(shape,view,propertyGroup){
	        return pathInterfaceFactory(shape,view,propertyGroup);
	    }

	    function iterateElements(shapes,view, propertyGroup){
	        var arr = [];
	        var i, len = shapes ? shapes.length : 0;
	        for(i=0;i<len;i+=1){
	            if(shapes[i].ty == 'gr'){
	                arr.push(ShapeExpressionInterface.createGroupInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'fl'){
	                arr.push(ShapeExpressionInterface.createFillInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'st'){
	                arr.push(ShapeExpressionInterface.createStrokeInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tm'){
	                arr.push(ShapeExpressionInterface.createTrimInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tr'){
	                //arr.push(ShapeExpressionInterface.createTransformInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'el'){
	                arr.push(ShapeExpressionInterface.createEllipseInterface(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'sr'){
	                arr.push(ShapeExpressionInterface.createStarInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'sh'){
	                arr.push(ShapeExpressionInterface.createPathInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rc'){
	                arr.push(ShapeExpressionInterface.createRectInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rd'){
	                arr.push(ShapeExpressionInterface.createRoundedInterface(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rp'){
	                arr.push(ShapeExpressionInterface.createRepatearInterface(shapes[i],view[i],propertyGroup));
	            } else{
	                //console.log(shapes[i].ty);
	            }
	        }
	        return arr;
	    }

	    var shapeInterfaceFactory = (function(){
	        return function(shapes,view,propertyGroup){
	            var interfaces;
	            function _interfaceFunction(value){
	                if(typeof value === 'number'){
	                    return interfaces[value-1];
	                } else {
	                    var i = 0, len = interfaces.length;
	                    while(i<len){
	                        if(interfaces[i]._name === value){
	                            return interfaces[i];
	                        }
	                        i+=1;
	                    }
	                }
	            }
	            _interfaceFunction.propertyGroup = propertyGroup;
	            interfaces = iterateElements(shapes, view, _interfaceFunction);
	            return _interfaceFunction;
	        }
	    }());

	    var contentsInterfaceFactory = (function(){
	       return function(shape,view, propertyGroup){
	           var interfaces;
	           var interfaceFunction = function _interfaceFunction(value){
	               var i = 0, len = interfaces.length;
	                while(i<len){
	                    if(interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value){
	                       return interfaces[i];
	                    }
	                    i+=1;
	                }
	                if(typeof value === 'number'){
	                   return interfaces[value-1];
	                }
	           };
	           interfaceFunction.propertyGroup = function(val){
	               if(val === 1){
	                   return interfaceFunction;
	               } else{
	                   return propertyGroup(val-1);
	               }
	           };
	           interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
	           interfaceFunction.numProperties = interfaces.length;
	           interfaceFunction.propertyIndex = shape.cix;

	           return interfaceFunction;
	       }
	    }());

	    var groupInterfaceFactory = (function(){
	        return function(shape,view, propertyGroup){
	            var interfaceFunction = function _interfaceFunction(value){
	                switch(value){
	                    case 'ADBE Vectors Group':
	                    case 'Contents':
	                    case 2:
	                        return interfaceFunction.content;
	                    case 'ADBE Vector Transform Group':
	                    case 3:
	                    default:
	                        return interfaceFunction.transform;
	                }
	            }
	            interfaceFunction.propertyGroup = function(val){
	                if(val === 1){
	                    return interfaceFunction;
	                } else{
	                    return propertyGroup(val-1);
	                }
	            };
	            var content = contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);
	            var transformInterface = ShapeExpressionInterface.createTransformInterface(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);
	            interfaceFunction.content = content;
	            interfaceFunction.transform = transformInterface;
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            //interfaceFunction.content = interfaceFunction;
	            interfaceFunction.numProperties = shape.np;
	            interfaceFunction.propertyIndex = shape.ix;
	            interfaceFunction.nm = shape.nm;
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var fillInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){

	            function interfaceFunction(val){
	                if(val === 'Color' || val === 'color'){
	                    return interfaceFunction.color;
	                } else if(val === 'Opacity' || val === 'opacity'){
	                    return interfaceFunction.opacity;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'color', {
	                get: function(){
	                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.o, 100);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });

	            view.c.setGroupProperty(propertyGroup);
	            view.o.setGroupProperty(propertyGroup);
	            return interfaceFunction;
	        }
	    }());

	    var strokeInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val === 1){
	                    return ob;
	                } else{
	                    return propertyGroup(val-1);
	                }
	            };
	            function _dashPropertyGroup(val){
	                if(val === 1){
	                    return dashOb;
	                } else{
	                    return _propertyGroup(val-1);
	                }
	            };
	            function addPropertyToDashOb(i) {
	                Object.defineProperty(dashOb, shape.d[i].nm, {
	                    get: function(){
	                        return ExpressionValue(view.d.dataProps[i].p)
	                    }
	                });
	            }
	            var i, len = shape.d ? shape.d.length : 0;
	            var dashOb = {}
	            for (i = 0; i < len; i += 1) {
	                addPropertyToDashOb(i);
	                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
	            }

	            function interfaceFunction(val){
	                if(val === 'Color' || val === 'color'){
	                    return interfaceFunction.color;
	                } else if(val === 'Opacity' || val === 'opacity'){
	                    return interfaceFunction.opacity;
	                } else if(val === 'Stroke Width' || val === 'stroke width'){
	                    return interfaceFunction.strokeWidth;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'color', {
	                get: function(){
	                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.o, 100);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'strokeWidth', {
	                get: function(){
	                    return ExpressionValue(view.w);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'dash', {
	                get: function(){
	                    return dashOb;
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });

	            view.c.setGroupProperty(_propertyGroup);
	            view.o.setGroupProperty(_propertyGroup);
	            view.w.setGroupProperty(_propertyGroup);
	            return interfaceFunction;
	        }
	    }());

	    var trimInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;

	            view.s.setGroupProperty(_propertyGroup);
	            view.e.setGroupProperty(_propertyGroup);
	            view.o.setGroupProperty(_propertyGroup);

	            function interfaceFunction(val){
	                if(val === shape.e.ix || val === 'End' || val === 'end'){
	                    return interfaceFunction.end;
	                }
	                if(val === shape.s.ix){
	                    return interfaceFunction.start;
	                }
	                if(val === shape.o.ix){
	                    return interfaceFunction.offset;
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;
	            Object.defineProperty(interfaceFunction, 'start', {
	                get: function(){
	                    return ExpressionValue(view.s, 1 / view.s.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'end', {
	                get: function(){
	                    return ExpressionValue(view.e, 1 / view.e.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'offset', {
	                get: function(){
	                    return ExpressionValue(view.o);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var transformInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            view.transform.mProps.o.setGroupProperty(_propertyGroup);
	            view.transform.mProps.p.setGroupProperty(_propertyGroup);
	            view.transform.mProps.a.setGroupProperty(_propertyGroup);
	            view.transform.mProps.s.setGroupProperty(_propertyGroup);
	            view.transform.mProps.r.setGroupProperty(_propertyGroup);
	            if(view.transform.mProps.sk){
	                view.transform.mProps.sk.setGroupProperty(_propertyGroup);
	                view.transform.mProps.sa.setGroupProperty(_propertyGroup);
	            }
	            view.transform.op.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.a.ix === value){
	                    return interfaceFunction.anchorPoint;
	                }
	                if(shape.o.ix === value){
	                    return interfaceFunction.opacity;
	                }
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.rotation;
	                }
	                if(shape.s.ix === value){
	                    return interfaceFunction.scale;
	                }
	                if(shape.sk && shape.sk.ix === value){
	                    return interfaceFunction.skew;
	                }
	                if(shape.sa && shape.sa.ix === value){
	                    return interfaceFunction.skewAxis;
	                }
	                if(value === 'Opacity') {
	                    return interfaceFunction.opacity;
	                }
	                if(value === 'Position') {
	                    return interfaceFunction.position;
	                }
	                if(value === 'Anchor Point') {
	                    return interfaceFunction.anchorPoint;
	                }
	                if(value === 'Scale') {
	                    return interfaceFunction.scale;
	                }
	                if(value === 'Rotation' || value === 'ADBE Vector Rotation') {
	                    return interfaceFunction.rotation;
	                }
	                if(value === 'Skew') {
	                    return interfaceFunction.skew;
	                }
	                if(value === 'Skew Axis') {
	                    return interfaceFunction.skewAxis;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'opacity', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.o, 1/view.transform.mProps.o.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'anchorPoint', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.a);
	                }
	            });
	            var scaleArray = [];
	            Object.defineProperty(interfaceFunction, 'scale', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.s, 1 / view.transform.mProps.s.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'rotation', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.r, 1 / view.transform.mProps.r.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'skew', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.sk);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'skewAxis', {
	                get: function(){
	                    return ExpressionValue(view.transform.mProps.sa);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.ty = 'tr';
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var ellipseInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            interfaceFunction.propertyIndex = shape.ix;
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            prop.s.setGroupProperty(_propertyGroup);
	            prop.p.setGroupProperty(_propertyGroup);
	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.s.ix === value){
	                    return interfaceFunction.size;
	                }
	            }
	            Object.defineProperty(interfaceFunction, 'size', {
	                get: function(){
	                    return ExpressionValue(prop.s);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var starInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.or.setGroupProperty(_propertyGroup);
	            prop.os.setGroupProperty(_propertyGroup);
	            prop.pt.setGroupProperty(_propertyGroup);
	            prop.p.setGroupProperty(_propertyGroup);
	            prop.r.setGroupProperty(_propertyGroup);
	            if(shape.ir){
	                prop.ir.setGroupProperty(_propertyGroup);
	                prop.is.setGroupProperty(_propertyGroup);
	            }

	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.rotation;
	                }
	                if(shape.pt.ix === value){
	                    return interfaceFunction.points;
	                }
	                if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){
	                    return interfaceFunction.outerRadius;
	                }
	                if(shape.os.ix === value){
	                    return interfaceFunction.outerRoundness;
	                }
	                if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){
	                    return interfaceFunction.innerRadius;
	                }
	                if(shape.is && shape.is.ix === value){
	                    return interfaceFunction.innerRoundness;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'rotation', {
	                get: function(){
	                    return ExpressionValue(prop.r, 1 / prop.r.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'points', {
	                get: function(){
	                    return ExpressionValue(prop.pt);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'outerRadius', {
	                get: function(){
	                    return ExpressionValue(prop.or);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'outerRoundness', {
	                get: function(){
	                    return ExpressionValue(prop.os);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'innerRadius', {
	                get: function(){
	                    if(!prop.ir){
	                        return 0;
	                    }
	                    return ExpressionValue(prop.ir);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'innerRoundness', {
	                get: function(){
	                    if(!prop.is){
	                        return 0;
	                    }
	                    return ExpressionValue(prop.is, 1 / prop.is.mult);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var rectInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.p.setGroupProperty(_propertyGroup);
	            prop.s.setGroupProperty(_propertyGroup);
	            prop.r.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.p.ix === value){
	                    return interfaceFunction.position;
	                }
	                if(shape.r.ix === value){
	                    return interfaceFunction.roundness;
	                }
	                if(shape.s.ix === value || value === 'Size'){
	                    return interfaceFunction.size;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'position', {
	                get: function(){
	                    return ExpressionValue(prop.p);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'roundness', {
	                get: function(){
	                    return ExpressionValue(prop.r);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'size', {
	                get: function(){
	                    return ExpressionValue(prop.s);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var roundedInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.rd.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.r.ix === value || 'Round Corners 1' === value){
	                    return interfaceFunction.radius;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'radius', {
	                get: function(){
	                    return ExpressionValue(prop.rd);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var repeaterInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            var prop = view;
	            interfaceFunction.propertyIndex = shape.ix;
	            prop.c.setGroupProperty(_propertyGroup);
	            prop.o.setGroupProperty(_propertyGroup);

	            function interfaceFunction(value){
	                if(shape.c.ix === value || 'Copies' === value){
	                    return interfaceFunction.copies;
	                } else if(shape.o.ix === value || 'Offset' === value){
	                    return interfaceFunction.offset;
	                }

	            }
	            Object.defineProperty(interfaceFunction, 'copies', {
	                get: function(){
	                    return ExpressionValue(prop.c);
	                }
	            });

	            Object.defineProperty(interfaceFunction, 'offset', {
	                get: function(){
	                    return ExpressionValue(prop.o);
	                }
	            });

	            Object.defineProperty(interfaceFunction, '_name', {
	                get: function(){
	                    return shape.nm;
	                }
	            });
	            interfaceFunction.mn = shape.mn;
	            return interfaceFunction;
	        }
	    }());

	    var pathInterfaceFactory = (function(){
	        return function(shape,view,propertyGroup){
	            var prop = view.sh;
	            function _propertyGroup(val){
	                if(val == 1){
	                    return interfaceFunction;
	                } else {
	                    return propertyGroup(--val);
	                }
	            }
	            prop.setGroupProperty(_propertyGroup);

	            function interfaceFunction(val){
	                if(val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2){
	                    return interfaceFunction.path;
	                }
	            }

	            Object.defineProperty(interfaceFunction, 'path', {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop;
	                    //return shape_pool.clone(prop.v);
	                }
	            });
	            Object.defineProperty(interfaceFunction, 'shape', {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop;
	                    //return shape_pool.clone(prop.v);
	                }
	            });
	            Object.defineProperty(interfaceFunction, '_name', { value: shape.nm });
	            Object.defineProperty(interfaceFunction, 'ix', { value: shape.ix });
	            Object.defineProperty(interfaceFunction, 'mn', { value: shape.mn });
	            return interfaceFunction;
	        }
	    }());


	    return ob;
	}())

	var TextExpressionInterface = (function(){
		return function(elem){
	        var _prevValue, _sourceText;
	        function _thisLayerFunction(){
	        }
	        Object.defineProperty(_thisLayerFunction, "sourceText", {
	            get: function(){
	                var stringValue = elem.textProperty.currentData.t;
	                if(elem.textProperty.currentData.t !== _prevValue) {
	                    elem.textProperty.currentData.t = _prevValue;
	                    _sourceText = new String(stringValue);
	                    //If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
	                    _sourceText.value = stringValue ? stringValue : new String(stringValue);
	                }
	                return _sourceText;
	            }
	        });
	        return _thisLayerFunction;
	    }
	}())
	var LayerExpressionInterface = (function (){
	    function toWorld(arr, time){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        var transformMat;
	        if(time) {
	            //Todo implement value at time on transform properties
	            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
	            transformMat = this._elem.finalTransform.mProp;
	        } else {
	            transformMat = this._elem.finalTransform.mProp;
	        }
	        transformMat.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	        }
	        return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	    }
	    function fromWorld(arr, time){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        var transformMat;
	        if(time) {
	            //Todo implement value at time on transform properties
	            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
	            transformMat = this._elem.finalTransform.mProp;
	        } else {
	            transformMat = this._elem.finalTransform.mProp;
	        }
	        transformMat.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.inversePoint(arr);
	        }
	        return toWorldMat.inversePoint(arr);
	    }
	    function fromComp(arr){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.inversePoint(arr);
	        }
	        return toWorldMat.inversePoint(arr);
	    }


	    return function(elem){

	        var transformInterface = TransformExpressionInterface(elem.transform);

	        function _registerMaskInterface(maskManager){
	            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
	        }
	        function _registerEffectsInterface(effects){
	            _thisLayerFunction.effect = effects;
	        }

	        function _thisLayerFunction(name){
	            switch(name){
	                case "ADBE Root Vectors Group":
	                case "Contents":
	                case 2:
	                    return _thisLayerFunction.shapeInterface;
	                case 1:
	                case 6:
	                case "Transform":
	                case "transform":
	                case "ADBE Transform Group":
	                    return transformInterface;
	                case 4:
	                case "ADBE Effect Parade":
	                    return _thisLayerFunction.effect;
	            }
	        }
	        _thisLayerFunction.toWorld = toWorld;
	        _thisLayerFunction.fromWorld = fromWorld;
	        _thisLayerFunction.toComp = toWorld;
	        _thisLayerFunction.fromComp = fromComp;
	        _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
	        _thisLayerFunction._elem = elem;
	        Object.defineProperty(_thisLayerFunction, 'hasParent', {
	            get: function(){
	                return !!elem.hierarchy;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, 'parent', {
	            get: function(){
	                return elem.hierarchy[0].layerInterface;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, "rotation", {
	            get: function(){
	                return transformInterface.rotation;
	            }
	        });
	        Object.defineProperty(_thisLayerFunction, "scale", {
	            get: function () {
	                return transformInterface.scale;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "position", {
	            get: function () {
	                return transformInterface.position;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "anchorPoint", {
	            get: function () {
	                return transformInterface.anchorPoint;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "transform", {
	            get: function () {
	                return transformInterface;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "width", {
	            get: function () {
	                if(elem.data.ty === 0) {
	                    return elem.data.w
	                }
	                return 100;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "height", {
	            get: function () {
	                if(elem.data.ty === 0) {
	                    return elem.data.h
	                }
	                return 100;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "source", {
	            get: function () {
	                return elem.data.refId;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "index", {
	            get: function () {
	                return elem.data.ind;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "_name", { value:elem.data.nm });
	        Object.defineProperty(_thisLayerFunction, "content", {
	            get: function(){
	                return _thisLayerFunction.shapeInterface;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "active", {
	            get: function(){
	                return elem.isVisible;
	            }
	        });

	        Object.defineProperty(_thisLayerFunction, "text", {
	            get: function(){
	                return _thisLayerFunction.textInterface;
	            }
	        });

	        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
	        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
	        return _thisLayerFunction;
	    }
	}());

	var CompExpressionInterface = (function (){
	    return function(comp){
	        function _thisLayerFunction(name){
	            var i=0, len = comp.layers.length;
	            while(i<len){
	                if(comp.layers[i].nm === name || comp.layers[i].ind === name){
	                    return comp.elements[i].layerInterface;
	                }
	                i += 1;
	            }
	            return {active:false}
	        }
	        Object.defineProperty(_thisLayerFunction, "_name", { value:comp.data.nm });
	        _thisLayerFunction.layer = _thisLayerFunction;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.height = comp.globalData.compSize.h;
	        _thisLayerFunction.width = comp.globalData.compSize.w;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.frameDuration = 1/comp.globalData.frameRate;
	        return _thisLayerFunction;
	    }
	}());
	var TransformExpressionInterface = (function (){
	    return function(transform){
	        function _thisFunction(name){
	            switch(name){
	                case "scale":
	                case "Scale":
	                case "ADBE Scale":
	                case 6:
	                    return _thisFunction.scale;
	                case "rotation":
	                case "Rotation":
	                case "ADBE Rotation":
	                case "ADBE Rotate Z":
	                case 10:
	                    return _thisFunction.rotation;
	                case "position":
	                case "Position":
	                case "ADBE Position":
	                case 2:
	                    return transform.position;
	                case "anchorPoint":
	                case "AnchorPoint":
	                case "Anchor Point":
	                case "ADBE AnchorPoint":
	                case 1:
	                    return _thisFunction.anchorPoint;
	                case "opacity":
	                case "Opacity":
	                case 11:
	                    return _thisFunction.opacity;
	            }
	        }

	        Object.defineProperty(_thisFunction, "rotation", {
	            get: function(){
	                return transform.rotation;
	            }
	        });
	        Object.defineProperty(_thisFunction, "scale", {
	            get: function () {
	                return transform.scale;
	            }
	        });

	        Object.defineProperty(_thisFunction, "position", {
	            get: function () {
	                return transform.position;
	            }
	        });

	        Object.defineProperty(_thisFunction, "xPosition", {
	            get: function () {
	                return transform.xPosition;
	            }
	        });

	        Object.defineProperty(_thisFunction, "yPosition", {
	            get: function () {
	                return transform.yPosition;
	            }
	        });

	        Object.defineProperty(_thisFunction, "anchorPoint", {
	            get: function () {
	                return transform.anchorPoint;
	            }
	        });

	        Object.defineProperty(_thisFunction, "opacity", {
	            get: function () {
	                return transform.opacity;
	            }
	        });

	        Object.defineProperty(_thisFunction, "skew", {
	            get: function () {
	                return transform.skew;
	            }
	        });

	        Object.defineProperty(_thisFunction, "skewAxis", {
	            get: function () {
	                return transform.skewAxis;
	            }
	        });

	        return _thisFunction;
	    }
	}());
	var ProjectInterface = (function (){

	    function registerComposition(comp){
	        this.compositions.push(comp);
	    }

	    return function(){
	        function _thisProjectFunction(name){
	            var i = 0, len = this.compositions.length;
	            while(i<len){
	                if(this.compositions[i].data && this.compositions[i].data.nm === name){
	                    if(this.compositions[i].prepareFrame) {
	                        this.compositions[i].prepareFrame(this.currentFrame);
	                    }
	                    return this.compositions[i].compInterface;
	                }
	                i+=1;
	            }
	        }

	        _thisProjectFunction.compositions = [];
	        _thisProjectFunction.currentFrame = 0;

	        _thisProjectFunction.registerComposition = registerComposition;



	        return _thisProjectFunction;
	    }
	}());
	var EffectsExpressionInterface = (function (){
	    var ob = {
	        createEffectsInterface: createEffectsInterface
	    };

	    function createEffectsInterface(elem, propertyGroup){
	        if(elem.effects){

	            var effectElements = [];
	            var effectsData = elem.data.ef;
	            var i, len = elem.effects.effectElements.length;
	            for(i=0;i<len;i+=1){
	                effectElements.push(createGroupInterface(effectsData[i],elem.effects.effectElements[i],propertyGroup,elem));
	            }

	            return function(name){
	                var effects = elem.data.ef, i = 0, len = effects.length;
	                while(i<len) {
	                    if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                        return effectElements[i];
	                    }
	                    i += 1;
	                }
	            }
	        }
	    }

	    function createGroupInterface(data,elements, propertyGroup, elem){
	        var effectElements = [];
	        var i, len = data.ef.length;
	        for(i=0;i<len;i+=1){
	            if(data.ef[i].ty === 5){
	                effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],elements.effectElements[i].propertyGroup, elem));
	            } else {
	                effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty, elem, _propertyGroup));
	            }
	        }

	        function _propertyGroup(val) {
	            if(val === 1){
	               return groupInterface;
	            } else{
	               return propertyGroup(val-1);
	            }
	        }

	        var groupInterface = function(name){
	            var effects = data.ef, i = 0, len = effects.length;
	            while(i<len) {
	                if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                    if(effects[i].ty === 5){
	                        return effectElements[i];
	                    } else {
	                        return effectElements[i]();
	                    }
	                }
	                i += 1;
	            }
	            return effectElements[0]();
	        }

	        groupInterface.propertyGroup = _propertyGroup;

	        if(data.mn === 'ADBE Color Control'){
	            Object.defineProperty(groupInterface, 'color', {
	                get: function(){
	                    return effectElements[0]();
	                }
	            });
	        }
	        Object.defineProperty(groupInterface, 'numProperties', {
	            get: function(){
	                return data.np;
	            }
	        });
	        groupInterface.active = data.en !== 0;
	        return groupInterface
	    }

	    function createValueInterface(element, type, elem, propertyGroup){
	        function interfaceFunction(){
	            if(type === 10){
	                return elem.comp.compInterface(element.p.v);
	            }
	            return ExpressionValue(element.p);
	        }

	        if(element.p.setGroupProperty) {
	            element.p.setGroupProperty(propertyGroup);
	        }

	        return interfaceFunction;
	    }

	    return ob;

	}());
	var MaskManagerInterface = (function(){

		function MaskInterface(mask, data){
			this._mask = mask;
			this._data = data;
		}
		Object.defineProperty(MaskInterface.prototype, 'maskPath', {
	        get: function(){
	                if(this._mask.prop.k){
	                    this._mask.prop.getValue();
	                }
	                return this._mask.prop;
	            }
	        });

		var MaskManager = function(maskManager, elem){
			var _maskManager = maskManager;
			var _elem = elem;
			var _masksInterfaces = Array.apply(null,{length: maskManager.viewData.length});
			var i, len = maskManager.viewData.length;
			for(i = 0; i < len; i += 1) {
				_masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
			}

			var maskFunction = function(name){
				i = 0;
			    while(i<len){
			        if(maskManager.masksProperties[i].nm === name){
			            return _masksInterfaces[i];
			        }
			        i += 1;
			    }
			}
			return maskFunction
		}
		return MaskManager
	}())


	var ExpressionValue = (function() {
		return function(elementProp, mult, type) {
	        var expressionValue, arrayValue;

			if (elementProp.k) {
	            elementProp.getValue();
	        }
	        var i, len, arrValue;
	        if (type) {
	        	if(type === 'color') {
	        		len = 4;
			        expressionValue = Array.apply(null, {length: len});
			        arrValue = Array.apply(null, {length: len});
			        for (i = 0; i < len; i += 1) {
			            expressionValue[i] = arrValue[i] = (mult && i < 3) ? elementProp.v[i] * mult : 1;
			        }
		        	expressionValue.value = arrValue;
	        	}
	        } else if (typeof elementProp.v === 'number' || elementProp.v instanceof Number){
	            expressionValue = mult ? new Number(elementProp.v * mult) : new Number(elementProp.v);
	            expressionValue.value = mult ? elementProp.v * mult : elementProp.v;
	        } else {
	        	len = elementProp.v.length;
		        expressionValue = Array.apply(null, {length: len});
		        arrValue = Array.apply(null, {length: len});
		        for (i = 0; i < len; i += 1) {
		            expressionValue[i] = arrValue[i] = mult ? elementProp.v[i] * mult : elementProp.v[i];
		        }
		        expressionValue.value = arrValue;
	        }
	        
	        expressionValue.numKeys = elementProp.keyframes ? elementProp.keyframes.length : 0;
	        expressionValue.key = function(pos) {
	            if (!expressionValue.numKeys) {
	                return 0;
	            } else {
	                return elementProp.keyframes[pos-1].t;
	            }
	        };
	        expressionValue.valueAtTime = elementProp.getValueAtTime;
	        expressionValue.propertyGroup = elementProp.propertyGroup;
	        return expressionValue;
		}
	}())
	function SliderEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function AngleEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function ColorEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,dynamicProperties);
	}
	function PointEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,dynamicProperties);
	}
	function LayerIndexEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function MaskIndexEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function CheckboxEffect(data,elem, dynamicProperties){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,dynamicProperties);
	}
	function NoValueEffect(){
	    this.p = {};
	}
	function EffectsManager(data,element,dynamicProperties){
	    var effects = data.ef;
	    this.effectElements = [];
	    var i,len = effects.length;
	    var effectItem;
	    for(i=0;i<len;i++) {
	        effectItem = new GroupEffect(effects[i],element,dynamicProperties);
	        this.effectElements.push(effectItem);
	    }
	}

	function GroupEffect(data,element,dynamicProperties){
	    this.dynamicProperties = [];
	    this.init(data,element,this.dynamicProperties);
	    if(this.dynamicProperties.length){
	        dynamicProperties.push(this);
	    }
	}

	GroupEffect.prototype.getValue = function(){
	    this.mdf = false;
	    var i, len = this.dynamicProperties.length;
	    for(i=0;i<len;i+=1){
	        this.dynamicProperties[i].getValue();
	        this.mdf = this.dynamicProperties[i].mdf ? true : this.mdf;
	    }
	};

	GroupEffect.prototype.init = function(data,element,dynamicProperties){
	    this.data = data;
	    this.mdf = false;
	    this.effectElements = [];
	    var i, len = this.data.ef.length;
	    var eff, effects = this.data.ef;
	    for(i=0;i<len;i+=1){
	        switch(effects[i].ty){
	            case 0:
	                eff = new SliderEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 1:
	                eff = new AngleEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 2:
	                eff = new ColorEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 3:
	                eff = new PointEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 4:
	            case 7:
	                eff = new CheckboxEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 10:
	                eff = new LayerIndexEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 11:
	                eff = new MaskIndexEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 5:
	                eff = new EffectsManager(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	            case 6:
	                eff = new NoValueEffect(effects[i],element,dynamicProperties);
	                this.effectElements.push(eff);
	                break;
	        }
	    }
	};
	    var bodymovinjs = {};

	    function setLocationHref (href) {
	        locationHref = href;
	    }
	    function play(animation){
	        animationManager.play(animation);
	    }

	    function pause(animation) {
	        animationManager.pause(animation);
	    }

	    function togglePause(animation) {
	        animationManager.togglePause(animation);
	    }

	    function setSpeed(value, animation) {
	        animationManager.setSpeed(value, animation);
	    }

	    function setDirection(value, animation) {
	        animationManager.setDirection(value, animation);
	    }

	    function stop(animation) {
	        animationManager.stop(animation);
	    }

	    function moveFrame(value) {
	        animationManager.moveFrame(value);
	    }

	    function searchAnimations() {
	        if (standalone === true) {
	            animationManager.searchAnimations(animationData, standalone, renderer);
	        } else {
	            animationManager.searchAnimations();
	        }
	    }

	    function registerAnimation(elem) {
	        return animationManager.registerAnimation(elem);
	    }

	    function resize() {
	        animationManager.resize();
	    }

	    function start() {
	        animationManager.start();
	    }

	    function goToAndStop(val, isFrame, animation) {
	        animationManager.goToAndStop(val, isFrame, animation);
	    }

	    function setSubframeRendering(flag) {
	        subframeEnabled = flag;
	    }

	    function loadAnimation(params) {
	        if (standalone === true) {
	            params.animationData = JSON.parse(animationData);
	        }
	        return animationManager.loadAnimation(params);
	    }

	    function destroy(animation) {
	        return animationManager.destroy(animation);
	    }

	    function setQuality(value) {
	        if (typeof value === 'string') {
	            switch (value) {
	                case 'high':
	                    defaultCurveSegments = 200;
	                    break;
	                case 'medium':
	                    defaultCurveSegments = 50;
	                    break;
	                case 'low':
	                    defaultCurveSegments = 10;
	                    break;
	            }
	        } else if (!isNaN(value) && value > 1) {
	            defaultCurveSegments = value;
	        }
	        if (defaultCurveSegments >= 50) {
	            roundValues(false);
	        } else {
	            roundValues(true);
	        }
	    }

	    function inBrowser() {
	        return typeof navigator !== 'undefined';
	    }

	    function installPlugin(type, plugin) {
	        if (type === 'expressions') {
	            expressionsPlugin = plugin;
	        }
	    }

	    function getFactory(name) {
	        switch (name) {
	            case "propertyFactory":
	                return PropertyFactory;
	            case "shapePropertyFactory":
	                return ShapePropertyFactory;
	            case "matrix":
	                return Matrix;
	        }
	    }
	    bodymovinjs.play = play;
	    bodymovinjs.pause = pause;
	    bodymovinjs.setLocationHref = setLocationHref;
	    bodymovinjs.togglePause = togglePause;
	    bodymovinjs.setSpeed = setSpeed;
	    bodymovinjs.setDirection = setDirection;
	    bodymovinjs.stop = stop;
	    bodymovinjs.moveFrame = moveFrame;
	    bodymovinjs.searchAnimations = searchAnimations;
	    bodymovinjs.registerAnimation = registerAnimation;
	    bodymovinjs.loadAnimation = loadAnimation;
	    bodymovinjs.setSubframeRendering = setSubframeRendering;
	    bodymovinjs.resize = resize;
	    bodymovinjs.start = start;
	    bodymovinjs.goToAndStop = goToAndStop;
	    bodymovinjs.destroy = destroy;
	    bodymovinjs.setQuality = setQuality;
	    bodymovinjs.inBrowser = inBrowser;
	    bodymovinjs.installPlugin = installPlugin;
	    bodymovinjs.__getFactory = getFactory;
	    bodymovinjs.version = '4.13.0';

	    function checkReady() {
	        if (document.readyState === "complete") {
	            clearInterval(readyStateCheckInterval);
	            searchAnimations();
	        }
	    }

	    function getQueryVariable(variable) {
	        var vars = queryString.split('&');
	        for (var i = 0; i < vars.length; i++) {
	            var pair = vars[i].split('=');
	            if (decodeURIComponent(pair[0]) == variable) {
	                return decodeURIComponent(pair[1]);
	            }
	        }
	    }
	    var standalone = '__[STANDALONE]__';
	    var animationData = '__[ANIMATIONDATA]__';
	    var renderer = '';
	    if (standalone) {
	        var scripts = document.getElementsByTagName('script');
	        var index = scripts.length - 1;
	        var myScript = scripts[index] || {
	            src: ''
	        };
	        var queryString = myScript.src.replace(/^[^\?]+\??/, '');
	        renderer = getQueryVariable('renderer');
	    }
	    var readyStateCheckInterval = setInterval(checkReady, 100);
	    return bodymovinjs;
	}));

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = whenProperty;

	var _get2 = __webpack_require__(495);

	var _get3 = _interopRequireDefault(_get2);

	var _SWatcher = __webpack_require__(620);

	var _SWatcher2 = _interopRequireDefault(_SWatcher);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Resolve a promise when the wanted property on the passed object exist or pass the check function provided
	 *
	 * @name 		whenProperty
	 * @param 		{Object} 					object 				The object on which to monitor the property
	 * @param 		{String} 					property 			The property to monitor
	 * @param 		{Function} 					[checkFn=null] 		An optional function to check the property. The promise is resolved when this function return true
	 * @return 		(Promise) 										The promise that will be resolved when the property exist on the object (and that it passes the checkFn)
	 *
	 * @example 	js
	 * import whenProperty from 'sugarcss/js/utils/objects/whenProperty'
	 *
	 * const myObj = {
	 *  	title : 'Hello'
	 * };
	 *
	 * whenProperty(myObj, 'title').then((value) => {
	 * 		// the object has a title property now
	 * });
	 *
	 * // with a checkFn
	 * whenProperty(myObj, 'title', (newVal, oldVal) => {
	 * 		// when the property is 'Hello World'
	 * 		return newVal === 'Hello World';
	 * }).then((value) => {
	 * 		// do something with your Hello World
	 * });
	 *
	 * setTimeout(() => {
	 * 		// this will resolve the promise
	 * 		myObj.title = 'Hello World';
	 * },1000);
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function whenProperty(object, property) {
	  var checkFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  return new Promise(function (resolve, reject) {

	    var value = (0, _get3.default)(object, property);
	    if (value) {
	      if (checkFn && checkFn(value, value)) {
	        resolve(value);
	        return;
	      } else if (!checkFn) {
	        resolve(value);
	        return;
	      }
	    }

	    var watcher = new _SWatcher2.default();
	    var ok = false;
	    watcher.watch(object, property, function (newVal, oldVal) {
	      if (ok) return;
	      if (checkFn && checkFn(newVal, oldVal)) {
	        ok = true;
	        resolve(newVal);
	        watcher.destroy();
	      } else if (!checkFn) {
	        ok = true;
	        resolve(value);
	        watcher.destroy();
	      }
	    });
	  });
	}

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _constructorName = __webpack_require__(621);

	var _constructorName2 = _interopRequireDefault(_constructorName);

	var _get2 = __webpack_require__(495);

	var _get3 = _interopRequireDefault(_get2);

	var _set2 = __webpack_require__(622);

	var _set3 = _interopRequireDefault(_set2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @name 		SWatcher
	 * This class allows you to easily monitor some object properties and get the new and old value of it
	 *
	 * @example 	js
	 * // create the watcher instance
	 * const watcher = new SWatcher();
	 *
	 * // object to watch
	 * let myObject = {
	 * 		title : 'Hello World'
	 * };
	 *
	 * // watch the object
	 * watcher.watch(myObject, 'title', (newVal, oldVal) => {
	 *  	// do something when the title changes
	 * });
	 *
	 * // update the title
	 * myObject.title = 'Hello Universe';
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	var SWatcher = function () {

		/**
	  * @constructor
	  */
		function SWatcher() {
			_classCallCheck(this, SWatcher);

			this._watchStack = {};
		}

		/**
	  * Destroy the watcher
	  */


		/**
	  * Watch stack
	  * @type 		{Object}
	  */


		_createClass(SWatcher, [{
			key: 'destroy',
			value: function destroy() {
				// destroy the watchStack
				this._watchStack = {};
			}

			/**
	   * Internal implementation of the defineProp
	   * @param 		{Object} 	obj 		The object to watch
	   * @param 		{String} 	property 	The property of the object to watch
	   * @param 		{Mixed} 	value 		The initial value of the property
	   * @param 		{String} 	objPath 	The object property path to watch
	   */

		}, {
			key: '_defineProp',
			value: function _defineProp(obj, property, value, objPath) {
				var _this2 = this;

				var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;


				// do not define multiple time the description
				if (this._watchStack[objPath]) return;

				// store the current value
				var val = value;
				var currentDescriptor = Object.getOwnPropertyDescriptor(obj.prototype || obj, property);

				// custom setter check
				var _set = function _set(value) {
					// descriptor
					if (currentDescriptor && currentDescriptor.set) {
						var ret = currentDescriptor.set(value);
						if (ret) {
							val = ret;
						} else {
							val = currentDescriptor.get();
						}
					} else {
						val = value;
					}

					// apply the proxy for arrays, etc...
					val = _this2._applyProxy(val, objPath, function (newVal) {
						val = newVal;
					});
				};

				// set the value
				_set(value);

				// make sure we have the good currentDescriptor
				var d = Object.getOwnPropertyDescriptor(obj, property);
				Object.defineProperty(obj, property, {
					get: function get() {
						var _val = val;
						if (currentDescriptor && currentDescriptor.get) {
							_val = currentDescriptor.get();
						}
						if (descriptor && descriptor.get) {
							_val = descriptor.get(_val);
						}
						return _val;
					},
					set: function set(v) {
						var oldValue = val;
						if (descriptor && descriptor.set) {
							v = descriptor.set(v);
						}
						// internal set to use the good setter
						_set(v);
						// _notify of new update
						_this2._notify(objPath, val, oldValue);
					},
					configurable: descriptor && descriptor.configurable !== undefined ? descriptor.configurable : currentDescriptor && currentDescriptor.configurable !== undefined ? currentDescriptor.configurable : false,
					enumarable: descriptor && descriptor.enumarable !== undefined ? descriptor.enumarable : currentDescriptor && currentDescriptor.enumarable !== undefined ? currentDescriptor.enumarable : true
					// writable : currentDescriptor && currentDescriptor.writable !== undefined ? currentDescriptor.writable : true
				});
			}

			/**
	   * Override some array methods to be able to notify of changes
	   * @param 		{Array} 	array 			The array to process
	   * @param 		{Array} 	methods 		The methods to override
	   * @param 		{String} 	objPath 		The object property path to watch
	   * @param 		{Function} 	setValueCb 		A callback function that will set the updated value
	   */

		}, {
			key: '_overrideArrayMethod',
			value: function _overrideArrayMethod(array, methods, objPath, setValueCb) {
				var _this = this;

				// grab the old value
				var oldVal = array.slice(0);

				// loop on each methods to override
				methods.forEach(function (method) {
					array[method] = function () {
						// array items info object
						var updateInfo = {
							type: Array,
							method: method
						};
						if (method === 'push' || method === 'unshift' || method === 'concat') {
							updateInfo.addedItems = Array.prototype.slice.call(arguments);
						} else if (method === 'pop') {
							updateInfo.removedItems = [oldVal[oldVal.length - 1]];
						} else if (method === 'shift') {
							updateInfo.removedItems = [oldVal[0]];
						}
						// @TODO Check and add missed methods to watch array
						// apply the push
						var ret = Array.prototype[method].apply(this, arguments);
						// set value callback
						setValueCb(this);
						// _notify
						_this._notify(objPath, this, oldVal, updateInfo);
						// return the new value
						return ret;
					};
				});
			}

			/**
	   * Apply a proxy on the variable to detect changes
	   * on arrays, etc...
	   * @param 		{Mixed} 	value 		The value on which to apply the proxy
	   * @param 		{String} 	objPath 	The object property path to watch
	   * @param 		{Function} 	setValueCb 	A function that will be responsible to set the new value intarnally
	   * @return 		{Mixed} 				Return the value
	   */

		}, {
			key: '_applyProxy',
			value: function _applyProxy(value, objPath, setValueCb) {
				// if is an array
				if (value instanceof Array) {
					// override methods
					this._overrideArrayMethod(value, ['push', 'splice', 'pop', 'shift', 'unshift', 'reverse', 'sort', 'concat'], objPath, setValueCb);
				}
				return value;
			}

			/**
	   * Watch something on an object
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: 'watch',
			value: function watch(object, path, cb) {
				var _this3 = this;

				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// split the path by ',' to watch multiple properties
				if (typeof path === 'string') {
					path = path.split(',');
				}
				if (!path instanceof Array) {
					throw "The 'path' parameter has to be an array...";
				}
				// loop on each path to watch
				path.forEach(function (p) {
					_this3._watch(object, p.trim(), cb, descriptor);
				});
			}

			/**
	   * Internal watch$
	   * @param 		{Object} 		object 		The object to watch
	   * @param 		{String} 		path 		The property path to watch on the object
	   * @param 		{Function} 		cb 			The callback called when the property is updated
	   */

		}, {
			key: '_watch',
			value: function _watch(object, path, cb) {
				var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				// check if the path parameter has already a descriptor
				var split = path.split('.');
				var obj = object;
				var property = null;
				if (split.length > 1) {
					property = split.pop();
					obj = (0, _get3.default)(object, split.join('.'));
				} else {
					property = split[0];
				}
				var currentValue = null;
				currentValue = (0, _get3.default)(object, path);

				// if is undefined, create the value at null
				if (obj === undefined || currentValue === undefined) {
					(0, _set3.default)(obj, path, null);
					// _set(this, split.join('.'),null);
					// throw `It's not possible to watch the property ${path} cause it does not exist...`;
				};

				// define the property proxy
				this._defineProp(obj, property, currentValue, path, descriptor);

				// register new watch
				if (!this._watchStack[path]) {
					this._watchStack[path] = [];
				}
				this._watchStack[path].push(cb);
			}

			/**
	   * Tell that something has changed
	   * @param 		{String} 		path 		The object property path that has been updated
	   * @param 		{Mixed} 		newValue 	The new property value
	   * @param 		{Mixed} 		oldValue 	The old property value
	   * @param 		{Object} 		[updateInfo=null] 	An object that add information about the update like addedItems for array, etc...
	   */

		}, {
			key: '_notify',
			value: function _notify(path, newValue, oldValue) {
				var updateInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

				if (this._watchStack[path] !== undefined && newValue !== oldValue) {
					this._watchStack[path].forEach(function (cb) {
						cb(newValue, oldValue, updateInfo);
					});
				}
			}
		}]);

		return SWatcher;
	}();

	exports.default = SWatcher;

/***/ }),
/* 621 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = constructorName;
	/**
	 * Return the constructor name of the passed object
	 *
	 * @name 		constructorName
	 * @param 		{Object} 			obj 		The object to get the constructor name from
	 * @return 		{String}						The constructor name
	 *
	 * @example 	js
	 * class MyCoolClass {
	 * 		// class implementation...
	 * }
	 * const myObj = new MyCoolClass();
	 * console.log(constructorName(myObj)); => MyCoolClass
	 *
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function constructorName(obj) {
	  var funcNameRegex = /function (.{1,})\(/;

	  var res = funcNameRegex.exec(obj.toString());
	  if (res && res[1]) return res[1];

	  var results = funcNameRegex.exec(obj.constructor.toString());
	  return results && results.length > 1 ? results[1] : "";
	}

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSet = __webpack_require__(623);

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	module.exports = set;


/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(544),
	    castPath = __webpack_require__(497),
	    isIndex = __webpack_require__(475),
	    isObject = __webpack_require__(427),
	    toKey = __webpack_require__(505);

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	module.exports = baseSet;


/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SITypedComponent = __webpack_require__(625);

	var _SITypedComponent2 = _interopRequireDefault(_SITypedComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SITypedComponent2.default.define('s-i-typed', _SITypedComponent2.default);

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _ityped = __webpack_require__(626);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @name 		SITypedComponent
	 * @extends 	SWebComponent
	 * Webcomponent wrapper around the freaking cool iTyped micro library to create nice typewriter effect.
	 *
	 * @example 	html
	 * Hello <s-i-typed strings="['Univers']" loop="true">World</s-i-typed>
	 * @see 		https://github.com/luisvinicius167/ityped
	 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
	 */

	var SITypedComponent = function (_SWebComponent) {
		_inherits(SITypedComponent, _SWebComponent);

		function SITypedComponent() {
			_classCallCheck(this, SITypedComponent);

			return _possibleConstructorReturn(this, (SITypedComponent.__proto__ || Object.getPrototypeOf(SITypedComponent)).apply(this, arguments));
		}

		_createClass(SITypedComponent, [{
			key: 'shouldComponentAcceptProp',


			/**
	   * Should component accept prop
	   * @definition 		SWebComponent.shouldComponentAcceptProp
	   * @protected
	   */
			value: function shouldComponentAcceptProp(prop) {
				return true;
			}

			/**
	   * Component will mount
	   * @definition 		SWebComponent.componentWillMount
	   * @protected
	   */

		}, {
			key: 'componentWillMount',
			value: function componentWillMount() {
				_get(SITypedComponent.prototype.__proto__ || Object.getPrototypeOf(SITypedComponent.prototype), 'componentWillMount', this).call(this);
			}

			/**
	   * Mount component
	   * @definition 		SWebComponent.componentMount
	   * @protected
	   */

		}, {
			key: 'componentMount',
			value: function componentMount() {
				_get(SITypedComponent.prototype.__proto__ || Object.getPrototypeOf(SITypedComponent.prototype), 'componentMount', this).call(this);

				this.props.strings.unshift(this.innerHTML);
				this.innerHTML = '';

				// init the iTyped library
				(0, _ityped.init)(this, this.props);
			}
		}], [{
			key: 'defaultCss',


			/**
	   * Css
	   * @protected
	   */
			value: function defaultCss(componentName, componentNameDash) {
				return '\n\t\t\t@keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@-webkit-keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@-moz-keyframes s-i-typed-blink {\n\t\t\t\t100% {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t.ityped-cursor {\n\t\t\t\tfont-size: 1em;\n\t\t\t\topacity: 1;\n\t\t\t\t-webkit-animation: s-i-typed-blink 0.3s infinite;\n\t\t\t\t-moz-animation: s-i-typed-blink 0.3s infinite;\n\t\t\t\tanimation: s-i-typed-blink 0.3s infinite;\n\t\t\t\tanimation-direction: alternate;\n\t\t\t}\n\t\t\t' + componentNameDash + ' {\n\t\t\t}\n\t\t';
			}
		}, {
			key: 'defaultProps',


			/**
	   * Default props
	   * @definition 		SWebComponent.defaultProps
	   * @protected
	   */
			get: function get() {
				return {
					/**
	     * Accept all the settings of the iTyped library
	     * @type 	{Object}
	     * @prop
	     * @name 	iTyped
	     * @see 	https://github.com/luisvinicius167/ityped
	     */

					/**
	     * Set the strings to pass through
	     * @prop
	     * @type 		{Array}
	     */
					strings: []
				};
			}
		}]);

		return SITypedComponent;
	}(_SWebComponent3.default);

	exports.default = SITypedComponent;

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a};!function(a,b){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"===("undefined"==typeof exports?"undefined":_typeof(exports))?module.exports={init:b.init,destroy:b.destroy}:a.ityped=b}(this,function(a){function b(a){var b=a;return b.strings=a.strings||["Put your string here...","and Enjoy!"],b.typeSpeed=a.typeSpeed||100,b.backSpeed=a.backSpeed||50,b.backDelay=a.backDelay||500,b.startDelay=a.startDelay||500,b.showCursor=a.showCursor,b.loop=a.loop||!1,void 0===b.showCursor&&(b.showCursor=!0),Promise.resolve(b)}function c(a,c){a="string"==typeof a?document.querySelector(a):a,b(c).then(function(b){m=b,a._props=m,m.showCursor&&d(a,m.cursorChar||"|"),e(a)})}function d(a,b){var c=n.cloneNode();a.insertAdjacentElement("afterend",c),c.textContent=b}function e(a){l(a._props.strings,function(b,c,d){var e=a._props.typeSpeed*b.length-1;a._props.backSpeed<a._props.typeSpeed?e-=(a._props.typeSpeed-a._props.backSpeed)*b.length:a._props.backSpeed>a._props.typeSpeed&&(e+=(a._props.backSpeed-a._props.typeSpeed)*b.length);var f=this.async(),g=a._props.strings.length;h(a,b,c,g).then(function(){setTimeout(function(){f()},e)})},function(){a._props.loop&&e(a)})}function f(a,b){return new Promise(function(c,d){for(var e=0,f=0;f<b.length;f++)!function(d){var f=d,h=b.length;setTimeout(function(d){g(a,b.charAt(f)),++e===h-1&&c()},a._props.typeSpeed*d)}(f)})}function g(a,b){a.innerHTML+=b}function h(a,b,c,d){return new Promise(function(e,g){f(a,b).then(function(){setTimeout(function(){j(a,b,c,d).then(function(){setTimeout(function(){e()},a._props.startDelay)})},a._props.backDelay)})})}function i(a,b,c,d){for(var e=c;e>0;e--)!function(e){var f=e,g=c;setTimeout(function(e){a.innerHTML=b.substring(0,c-f),g--,1===f&&d()},a._props.backSpeed*e)}(e)}function j(a,b,c,d){return new Promise(function(e,f){var g=b.length;c+1===d?a._props.loop?a._props.loop&&i(a,b,g,e):(void 0!==a._props.onFinished&&"function"==typeof a._props.onFinished&&a._props.onFinished(),a.innerHTML=b):c+1!==d&&i(a,b,g,e)})}function k(a){a._props.onFinished=function(){}}var l=function(a,b,c){var d=-1,e=a.length>>>0;!function f(g){var h,i=g===!1;do{++d}while(!(d in a)&&d!==e);if(i||d===e)return void(c&&c(!i,a));g=b.call({async:function(){return h=!0,f}},a[d],d,a),h||f(g)}()},m=void 0,n=document.createElement("span");return n.classList.add("ityped-cursor"),n.textContent="|",{init:c,destroy:k}}());

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SResponsiveImgComponent = __webpack_require__(628);

	var _SResponsiveImgComponent2 = _interopRequireDefault(_SResponsiveImgComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SResponsiveImgComponent2.default.define('s-responsive-img', _SResponsiveImgComponent2.default, 'img');

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _sNativeWebComponent = __webpack_require__(534);

	var _sNativeWebComponent2 = _interopRequireDefault(_sNativeWebComponent);

	var _debounce = __webpack_require__(629);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// store the properties by name
	var __responsiveProperties = {};

	/**
	 * Provide a nice way to make images responsive without using srcset and sizes attributes.
	 * Register a preset first
	 * ```js
	 * SResponsiveImgComponent.registerPreset('banner', {
	 *   widths: [{
	 *     width: 340,
	 *     name: 'mobile',
	 *     pixelRatios: [1,2]
	 *   }, {
	 *     width: 640,
	 *     name: 'tablet',
	 *     pixelRatios: [1,2]
	 *   }, {
	 *     width: 1280,
	 *     name: 'desktop',
	 *     pixelRatios: [1,2]
	 *   }],
	 *   computeSrc: (src, widthObj) => {
	 *     return src + `?auto=compress&w={width}&fit=crop&fm=png&dpr={pixelRatio}`
	 *   }
	 * })
	 * ```
	 * @example    html
	 * <img lazy-src="https://assets.imgix.net/hp/snowshoe.jpg" is="s-responsive-img" preset="banner" />
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */

	var SResponsiveImgComponent = function (_native) {
	  _inherits(SResponsiveImgComponent, _native);

	  function SResponsiveImgComponent() {
	    _classCallCheck(this, SResponsiveImgComponent);

	    return _possibleConstructorReturn(this, (SResponsiveImgComponent.__proto__ || Object.getPrototypeOf(SResponsiveImgComponent)).apply(this, arguments));
	  }

	  _createClass(SResponsiveImgComponent, [{
	    key: 'componentMount',


	    /**
	     * Mount component
	     * @definition    SWebComponent.componentMount
	     */
	    value: function componentMount() {
	      _get(SResponsiveImgComponent.prototype.__proto__ || Object.getPrototypeOf(SResponsiveImgComponent.prototype), 'componentMount', this).call(this);

	      // get the original src
	      this._originalSrc = this.getAttribute('src') || this.getAttribute('data-src') || this.getAttribute('lazy-src');

	      // stop here if the image has no src
	      if (!this._originalSrc) return;

	      // check if has a responsive properties name
	      if (this.props.preset && __responsiveProperties[this.props.preset]) {
	        // merge the props
	        this.props = _extends({}, this.props, __responsiveProperties[this.props.preset]);
	      }

	      // throttle the window resize function to avoid to much
	      // calls
	      this._onWindowResize = (0, _debounce2.default)(this.__onWindowResize.bind(this), 500);

	      // listen for window resize
	      window.addEventListener('resize', this._onWindowResize);

	      // first resize
	      this.__onWindowResize();
	    }

	    /**
	     * Component unmount
	     * @definition    SWebComponent.componentUnmount
	     */

	  }, {
	    key: 'componentUnmount',
	    value: function componentUnmount() {
	      _get(SResponsiveImgComponent.prototype.__proto__ || Object.getPrototypeOf(SResponsiveImgComponent.prototype), 'componentUnmount', this).call(this);
	      // stop listening for window resize
	      window.removeEventListener('resize', this._onWindowResize);
	    }

	    /**
	     * Component will receive prop
	     * @definition    SWebComponent.componentWillReceiveProp
	     */

	  }, {
	    key: 'componentWillReceiveProp',
	    value: function componentWillReceiveProp(name, newVal, oldVal) {
	      switch (name) {
	        case 'lazySrc':
	        case 'dataSrc':
	          if (!newVal) return;
	          if (!newVal.toString().match(/^[a-zA-Z0-9_/]/)) return;
	          // save the new original src
	          this._originalSrc = newVal;
	          // apply the new src
	          this._applySrc();
	          break;
	      }
	    }

	    /**
	     * Apply the good src to the image
	     * @return    {void}
	     */

	  }, {
	    key: '_applySrc',
	    value: function _applySrc() {
	      // calculate the width of the image
	      var imageWidth = this.offsetWidth;
	      var appliedWidth = this.props.widths[0] || 0;

	      // grab the best available width
	      for (var i = 0; i < this.props.widths.length; i++) {
	        var widthObj = this.props.widths[i];
	        appliedWidth = widthObj;
	        if (imageWidth < widthObj.width) {
	          // that mean that the image is larger
	          // that the current applied width
	          // so we stop the loop
	          break;
	        }
	      }

	      // make sure we have a name
	      if (!appliedWidth.name) {
	        appliedWidth.name = appliedWidth.width.toString();
	      }

	      // set the exactWidth property
	      appliedWidth.exactWidth = imageWidth;

	      // check pixel ratios
	      if (window.devicePixelRatio && appliedWidth.pixelRatios) {
	        if (appliedWidth.pixelRatios.indexOf(window.devicePixelRatio) !== -1) {
	          appliedWidth.pixelRatio = window.devicePixelRatio;
	        } else {
	          appliedWidth.pixelRatio = 1;
	        }
	      } else {
	        appliedWidth.pixelRatio = 1;
	      }

	      // conpute the src
	      var src = this._computeSrc(appliedWidth);

	      // load and set the src
	      this._loadAndSetSrc(src);
	    }

	    /**
	     * Load the new image and set the src
	     * @param    {String}    src    The src to set
	     * @return    {void}
	     */

	  }, {
	    key: '_loadAndSetSrc',
	    value: function _loadAndSetSrc(src) {
	      var _this2 = this;

	      // load the new image
	      var img = new window.Image();
	      img.onload = function () {
	        // set the new src
	        _this2.setAttribute('src', src);
	      };
	      img.src = src;
	    }

	    /**
	     * Compute the new src
	     * @param    {Object}    widthObj    The width object that will be applied
	     * @return    {String}    The new src to apply
	     */

	  }, {
	    key: '_computeSrc',
	    value: function _computeSrc(widthObj) {
	      // store the new src
	      var src = this._originalSrc;
	      // check if has a computeSrc setting
	      if (this.props.computeSrc) {
	        src = this.props.computeSrc.apply(this, [src, widthObj]);
	      }
	      // compute the tokens
	      src = src.replace(/\{[a-zA-Z0-9_-]+\}/g, function (match) {
	        var key = match.replace('{', '').replace('}', '');
	        if (widthObj[key]) {
	          return widthObj[key];
	        }
	        return match;
	      });

	      // return the computed src
	      return src;
	    }

	    /**
	     * When the window is resized
	     * @param    {Event}    e    The event
	     * @return    {void}
	     */

	  }, {
	    key: '__onWindowResize',
	    value: function __onWindowResize(e) {
	      // apply the good image src
	      this._applySrc();
	    }
	  }], [{
	    key: 'registerPreset',

	    /**
	     * Register an image responsive properties by preset name
	     * @param    {String}    preset    The responsive properties preset name
	     * @param    {Object}    options    The responsive properties options
	     */
	    value: function registerPreset(preset, options) {
	      __responsiveProperties[preset] = options;
	    }

	    /**
	     * Default props
	     * @definition    SWebComponent.defaultProps
	     */

	  }, {
	    key: 'defaultCss',


	    /**
	     * Default css
	     * @protected
	     */
	    value: function defaultCss(componentName, componentNameDash) {
	      return '\n      img[is="' + componentNameDash + '"] {\n        width: 100%;\n      }\n    ';
	    }
	  }, {
	    key: 'defaultProps',
	    get: function get() {
	      return {

	        /**
	         * Specify a registered preset to use as properties
	         * @prop
	         * @type    {String}
	         */
	        preset: null,

	        /**
	         * Store the available widths object for this image in an array.
	         * A width object has to be shaped like so at least:
	         * ```
	         * {
	         *   width: 1200,
	         *   name: 'tablet'
	         * }
	         * ```
	         * @type    {String|Array}
	         */
	        widths: [],

	        /**
	         * Data src to delay the download of the image. Same as lazySrc
	         * @prop
	         * @type    {String}
	         */
	        dataSrc: null,

	        /**
	         * Lazy src to delay the download of the image. Same as dataSrc.
	         * @prop
	         * @type    {String}
	         */
	        lazySrc: null,

	        /**
	         * Specify a function that will compute the src before applying it.
	         * Will have as parameters the original src and the best suited width object.
	         * @prop
	         * @type    {Function}
	         */
	        computeSrc: null
	      };
	    }
	  }]);

	  return SResponsiveImgComponent;
	}((0, _sNativeWebComponent2.default)(window.HTMLImageElement));

	exports.default = SResponsiveImgComponent;

/***/ }),
/* 629 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = debounce;
	/**
	 * This utils function allows you to make sure that a function that will normally be called
	 * several times, for example during a scroll event, to be called only once after
	 * the delay passed
	 *
	 * @name 			debounce
	 * @example 		js
	 * const myDebouncedFn = debounce(() => {
	 * 		// my function content that will be
	 * 		// executed only once after the 1 second delay
	 * }, 1000);
	 *
	 * document.addEventListener('scroll', (e) => {
	 * 		// call my debounced function
	 * 		myDebouncedFn();
	 * });
	 *
	 * @author 			Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	function debounce(fn, delay) {
	  var timer = null;
	  return function () {
	    var context = this,
	        args = arguments;
	    clearTimeout(timer);
	    timer = setTimeout(function () {
	      fn.apply(context, args);
	    }, delay);
	  };
	}

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _SCharactersSlideshowComponent = _interopRequireDefault(__webpack_require__(631));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _default = _SCharactersSlideshowComponent.default.define("s-characters-slideshow", _SCharactersSlideshowComponent.default);

	exports.default = _default;

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _SWebComponent2 = _interopRequireDefault(__webpack_require__(533));

	var _STimer = _interopRequireDefault(__webpack_require__(605));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

	function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	/**
	 * Create a nice "slideshow" of sentences with a cool "split flap" random characters like effect
	 *
	 * @example    html
	 * <s-characters-slideshow values="['Hello World','How are you universe']"></s-characters-slideshow>
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 */
	var SCharactersSlideshowComponent =
	/*#__PURE__*/
	function (_SWebComponent) {
	  _inherits(SCharactersSlideshowComponent, _SWebComponent);

	  function SCharactersSlideshowComponent() {
	    _classCallCheck(this, SCharactersSlideshowComponent);

	    return _possibleConstructorReturn(this, _getPrototypeOf(SCharactersSlideshowComponent).apply(this, arguments));
	  }

	  _createClass(SCharactersSlideshowComponent, [{
	    key: "componentMount",

	    /**
	     * Mount component
	     * @definition    SWebComponent.componentMount
	     * @protected
	     */
	    value: function componentMount() {
	      var _this = this;

	      _get(_getPrototypeOf(SCharactersSlideshowComponent.prototype), "componentMount", this).call(this);

	      var values = this.props.values;

	      var _values = _slicedToArray(values, 1),
	          firstValue = _values[0]; // set the first value


	      this.innerHTML = firstValue; // init current slide idx

	      this._currentSlideIdx = 0; // create a timer for the slideshow

	      this._sliderTimer = new _STimer.default(this.props.timeout, {
	        tickCount: 1
	      }); // when the slideshow is complete

	      this._sliderTimer.onComplete(function () {
	        // go to next
	        _this.next();
	      }); // play


	      this.play();
	    }
	    /**
	     * Component will receive prop
	     * @definition    SWebComponent.componentWillReceiveProp
	     * @protected
	     */

	  }, {
	    key: "componentWillReceiveProp",
	    value: function componentWillReceiveProp(name, newVal, oldVal) {
	      _get(_getPrototypeOf(SCharactersSlideshowComponent.prototype), "componentWillReceiveProp", this).call(this, name, newVal, oldVal);

	      switch (name) {
	        case "timeout":
	          this._sliderTimer.duration(newVal);

	          break;

	        default:
	          // do nothing by default
	          break;
	      }
	    }
	    /**
	     * Play
	     */

	  }, {
	    key: "play",
	    value: function play() {
	      // start the timer
	      this._sliderTimer.start(); // track is playing flag


	      this._isPlaying = true;
	    }
	    /**
	     * Pause
	     */

	  }, {
	    key: "pause",
	    value: function pause() {
	      // pause the timer
	      this._sliderTimer.pause(); // track the is playing flag


	      this._isPlaying = false;
	    }
	    /**
	     * Stop
	     */

	  }, {
	    key: "stop",
	    value: function stop() {
	      // stop the timer
	      this._sliderTimer.stop(); // track the is playing flag


	      this._isPlaying = false;
	    }
	    /**
	     * Go to the next slide
	     */

	  }, {
	    key: "next",
	    value: function next() {
	      var _this2 = this;

	      // handle loop property
	      if (this._currentSlideIdx + 1 >= this.props.values.length && !this.props.loop) {
	        // stop
	        this.stop(); // stop here

	        return;
	      } // get the "from" sentence


	      var fromSentence = this.props.values[this._currentSlideIdx]; // update the currentSlideIdx

	      this._currentSlideIdx = this._currentSlideIdx + 1 >= this.props.values.length ? 0 : this._currentSlideIdx + 1; // get the "to" sentence

	      var toSentence = this.props.values[this._currentSlideIdx]; // switch

	      this.switch(fromSentence, toSentence, function () {
	        if (_this2._isPlaying) {
	          _this2._sliderTimer.start();
	        }
	      });
	    }
	    /**
	     * Go to the previous slide
	     */

	  }, {
	    key: "previous",
	    value: function previous() {
	      var _this3 = this;

	      // handle loop property
	      if (this._currentSlideIdx - 1 < 0 && !this.props.loop) {
	        // stop
	        this.stop(); // stop here

	        return;
	      } // get the "from" sentence


	      var fromSentence = this.props.values[this._currentSlideIdx]; // update the currentSlideIdx

	      this._currentSlideIdx = this._currentSlideIdx - 1 < 0 ? this.props.values.length - 1 : this._currentSlideIdx - 1; // get the "to" sentence

	      var toSentence = this.props.values[this._currentSlideIdx]; // switch

	      this.switch(fromSentence, toSentence, function () {
	        if (_this3._isPlaying) {
	          _this3._sliderTimer.start();
	        }
	      });
	    }
	    /**
	     * Switch from a sentence to another
	     * @param    {String}    fromSentence    The from sentence
	     * @param    {String}    toSentence    The to sentence
	     * @param    {Function}    completeCb    The callbacl to call when the switch is finished
	     */

	  }, {
	    key: "switch",
	    value: function _switch(fromSentence, toSentence, completeCb) {
	      var _this4 = this;

	      // switch characters
	      this._switch(fromSentence, toSentence, function (splits) {
	        var newLine = splits.map(function (character) {
	          if (character === undefined) return "<span class=\"".concat(_this4.componentNameDash, "__character\">&nbsp;</span>");
	          return character;
	        }).join("");
	        _this4.innerHTML = newLine;
	      }, function (splits) {
	        _this4.innerHTML = splits.join("").trim();
	        if (completeCb) completeCb(splits);
	      });
	    }
	    /**
	     * Split the text into an array
	     *
	     * Hello World
	     * How are you unierse?
	     *
	     */

	  }, {
	    key: "_switch",
	    value: function _switch(from, to) {
	      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var completeCb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var fromSplits = from.split("");
	      var toSplits = to.split("");
	      var largeLength = fromSplits.length > toSplits.length ? fromSplits.length : toSplits.length;
	      var characters = this.props.characters.split("");
	      var newSplits = [];

	      for (var i = 0; i < largeLength; i += 1) {
	        newSplits.push(fromSplits[i]);
	      }

	      var newSplitsIdx = [];

	      for (var _i2 = 0; _i2 < largeLength; _i2 += 1) {
	        newSplitsIdx.push(_i2);
	      }

	      var toSplitsIdx = [];

	      for (var _i3 = 0; _i3 < largeLength; _i3 += 1) {
	        toSplitsIdx.push(_i3);
	      }

	      var tickId = 0;
	      var timer = new _STimer.default(this.props.duration, {
	        tickCount: largeLength * 2
	      });
	      timer.onTick(function () {
	        if (tickId < largeLength) {
	          // phase 1, transform to characters
	          // pick a slot in the newSplitsIdx stack
	          var randomIdx = newSplitsIdx[Math.round(Math.random() * (newSplitsIdx.length - 1))]; // remove the idx from the stack

	          newSplitsIdx.splice(newSplitsIdx.indexOf(randomIdx), 1); // set a random character in the newSplits at the randomIdx idx

	          newSplits[randomIdx] = characters[Math.round(Math.random() * (characters.length - 1))];
	        } else {
	          // phase 2, transform into the new text
	          // pick a slot in the newSplitsIdx stack
	          var _randomIdx = toSplitsIdx[Math.round(Math.random() * (toSplitsIdx.length - 1))]; // remove the idx from the stack

	          toSplitsIdx.splice(toSplitsIdx.indexOf(_randomIdx), 1); // grab the new character

	          newSplits[_randomIdx] = toSplits[_randomIdx] ? toSplits[_randomIdx] : null;
	        } // callback


	        if (cb) cb(newSplits); // update tickId

	        tickId += 1;
	      });
	      timer.onComplete(function () {
	        if (completeCb) completeCb(newSplits);
	      });
	      timer.start();
	    }
	  }], [{
	    key: "defaultCss",

	    /**
	     * Css
	     * @protected
	     */
	    value: function defaultCss(componentName, componentNameDash) {
	      return "\n      ".concat(componentNameDash, " {\n        display : inline-block;\n      }\n    ");
	    }
	  }, {
	    key: "defaultProps",

	    /**
	     * Default props
	     * @definition    SWebComponent.defaultProps
	     * @protected
	     */
	    get: function get() {
	      return {
	        /**
	         * Specify the values to use as sentences
	         * @prop
	         * @type    {Array<String>}
	         */
	        values: ["Hello world", "How are you universe"],

	        /**
	         * Specify the transition characters to use
	         * @prop
	         * @type    {Array<String>}
	         */
	        characters: "+*/#%&§?-_",

	        /**
	         * Specify the transition duration in ms
	         * @prop
	         * @type    {Integer}
	         */
	        duration: 500,

	        /**
	         * Specify the timeout between two characters "slide"
	         * @prop
	         * @type    {Integer}
	         */
	        timeout: 4000,

	        /**
	         * Specify if the slider has to loop over the values or not
	         * @prop
	         * @type    {Boolean}
	         */
	        loop: true
	      };
	    }
	  }]);

	  return SCharactersSlideshowComponent;
	}(_SWebComponent2.default);

	exports.default = SCharactersSlideshowComponent;

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _SIconComponent = _interopRequireDefault(__webpack_require__(633));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _default = _SIconComponent.default.define("s-icon", _SIconComponent.default);

	exports.default = _default;

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _SWebComponent2 = _interopRequireDefault(__webpack_require__(533));

	var _axios = _interopRequireDefault(__webpack_require__(634));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

	function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var Component =
	/*#__PURE__*/
	function (_SWebComponent) {
	  _inherits(Component, _SWebComponent);

	  function Component() {
	    _classCallCheck(this, Component);

	    return _possibleConstructorReturn(this, _getPrototypeOf(Component).apply(this, arguments));
	  }

	  _createClass(Component, [{
	    key: "componentMount",

	    /**
	     * Mount component
	     * @definition    SWebComponent.componentMount
	     * @protected
	     */
	    value: function componentMount() {
	      var _this = this;

	      _get(_getPrototypeOf(Component.prototype), "componentMount", this).call(this); // load library depending on driver


	      this._injectLibraryDependingOnDriver(); // generate icon html


	      this._generateIconHtmlDependingOnDriver().then(function (html) {
	        // inject the html
	        _this._injectIcon(html);
	      }); // apply default attributes on icon


	      this._applyDefaultAttributes();
	    }
	    /**
	     * Apply default attributes on the component like aria-hidden, etc...
	     */

	  }, {
	    key: "_applyDefaultAttributes",
	    value: function _applyDefaultAttributes() {
	      // aria hidden
	      this.setAttribute('aria-hidden', true);
	    }
	    /**
	     * Generate the icon html depending on the driver
	     */

	  }, {
	    key: "_generateIconHtmlDependingOnDriver",
	    value: function _generateIconHtmlDependingOnDriver() {
	      switch (this.props.driver) {
	        case 'fonticon':
	          return Promise.resolve("<i class=\"".concat(this.props.iconsPrefix).concat(this.props.icon, "\" aria-hidden></i>"));

	        case 'img':
	          return Promise.resolve("<img src=\"".concat(this.props.iconsPath, "/").concat(this.props.icon, ".svg\" alt=\"").concat(this.props.title, "\">"));

	        case 'fontawesome':
	          return Promise.resolve("<i class=\"".concat(this.props.icon, "\" aria-hidden></i>"));

	        case 'material':
	          return Promise.resolve("<i class=\"material-icons\" aria-hidden>".concat(this.props.icon, "</i>"));

	        case 'foundation':
	          return Promise.resolve("<i class=\"fi-".concat(this.props.icon, "\" aria-hidden></i>"));

	        case 'svg':
	        default:
	          return Promise.resolve(this._loadSvgIcon());
	      }
	    }
	    /**
	     * Inject library depending on the driver
	     */

	  }, {
	    key: "_injectLibraryDependingOnDriver",
	    value: function _injectLibraryDependingOnDriver() {
	      switch (this.props.driver) {
	        case 'fontawesome':
	          {
	            var fontawesomeElm = document.querySelector('link#s-fontawesome');
	            if (fontawesomeElm) return;
	            var linkFontawesomeElm = document.createElement('link');
	            linkFontawesomeElm.setAttribute('id', 's-fontawesome');
	            linkFontawesomeElm.setAttribute('rel', 'stylesheet');
	            linkFontawesomeElm.setAttribute('href', this.props.fontawesomeCssUrl);
	            linkFontawesomeElm.setAttribute('integrity', this.props.fontawesomeCssIntegrity);
	            linkFontawesomeElm.setAttribute('crossorigin', 'anonymous');
	            document.head.appendChild(linkFontawesomeElm);
	            break;
	          }

	        case 'material':
	          {
	            var materialElm = document.querySelector('link#s-material');
	            if (materialElm) return;
	            var linkMaterialElm = document.createElement('link');
	            linkMaterialElm.setAttribute('id', 's-material');
	            linkMaterialElm.setAttribute('href', 'https://fonts.googleapis.com/icon?family=Material+Icons');
	            linkMaterialElm.setAttribute('rel', 'stylesheet');
	            document.head.appendChild(linkMaterialElm);
	            break;
	          }

	        case 'foundation':
	          {
	            var foundationElm = document.querySelector('link#s-foundation');
	            if (foundationElm) return;
	            var foundationLinkElm = document.createElement('link');
	            foundationLinkElm.setAttribute('id', 's-foundation');
	            foundationLinkElm.setAttribute('href', this.props.fondationCssUrl);
	            foundationLinkElm.setAttribute('rel', 'stylesheet');
	            document.head.appendChild(foundationLinkElm);
	            break;
	          }

	        default:
	          // do nothing by default
	          break;
	      }
	    }
	    /**
	     * Load the svg icon
	     */

	  }, {
	    key: "_loadSvgIcon",
	    value: function _loadSvgIcon() {
	      var _this2 = this;

	      return new Promise(function (resolve) {
	        _axios.default.get("".concat(_this2.props.iconsPath, "/").concat(_this2.props.icon, ".svg")).then(function (response) {
	          var domParser = new DOMParser();
	          var docElm = domParser.parseFromString(response.data, 'text/html');
	          var svgElm = docElm.querySelector('svg');
	          svgElm.setAttribute('aria-hidden', true);
	          resolve(svgElm.outerHTML);
	        });
	      });
	    }
	    /**
	     * Inject icon
	     * @param    {String}    iconHtml    The html of the icon to inject
	     */

	  }, {
	    key: "_injectIcon",
	    value: function _injectIcon(iconHtml) {
	      // replace the html
	      this.innerHTML = iconHtml;
	    }
	    /**
	     * Component will receive prop
	     * @definition    SWebComponent.componentWillReceiveProp
	     * @protected
	     */

	  }, {
	    key: "componentWillReceiveProp",
	    value: function componentWillReceiveProp(name, newVal, oldVal) {
	      var _this3 = this;

	      _get(_getPrototypeOf(Component.prototype), "componentWillReceiveProp", this).call(this, name, newVal, oldVal);

	      switch (name) {
	        case 'icon':
	          {
	            // inject the new icon
	            this._generateIconHtmlDependingOnDriver().then(function (html) {
	              _this3._injectIcon(html);
	            });

	            break;
	          }

	        case 'driver':
	          {
	            // inject library depending on driver
	            this._injectLibraryDependingOnDriver();

	            break;
	          }

	        case 'title':
	          {
	            if (this.props.driver === 'img') {
	              this.querySelector('img').setAttribute('alt', newVal);
	            }

	            break;
	          }

	        default:
	          // do nothing by default
	          break;
	      }
	    }
	  }], [{
	    key: "defaultCss",

	    /**
	     * Css
	     * @protected
	     */
	    value: function defaultCss(componentName, componentNameDash) {
	      return "\n      ".concat(componentNameDash, " {\n        display : inline-block;\n        font-size: 1em;\n        vertical-align: middle;\n        text-rendering: auto;\n        -webkit-font-smoothing: antialiased;\n      }\n      ").concat(componentNameDash, " img,\n      ").concat(componentNameDash, " svg {\n        width: auto; height: 1em;\n      }\n    ");
	    }
	  }, {
	    key: "defaultProps",

	    /**
	     * Default props
	     * @definition    SWebComponent.defaultProps
	     * @protected
	     */
	    get: function get() {
	      return {
	        /**
	         * Specify the icon to display. If the icon file is `my-icon.svg`,
	         * the icon parameter will be just `my-icon`.
	         * @prop
	         * @type    {String}
	         */
	        icon: null,

	        /**
	         * Specify the driver to use. It can be:
	         * - `fonticon` : Use a font icon set
	         * - `img` : Use an img tag to load the svg icon
	         * - `svg` : Inline the svg directly in the page
	         * - 'fontawesome` : Using fontawesome icons.
	         * - `material` : Using google material icons.
	         * @prop
	         * @type    {String}
	         */
	        driver: 'svg',

	        /**
	         * Specify the path to the icons folder relative to the document root of your project
	         * @prop
	         * @type    {String}
	         */
	        iconsPath: '/dist/icons',

	        /**
	         * Specify the icon prefix to use when using the `fonticon` driver
	         * @prop
	         * @type    {String}
	         */
	        iconsPrefix: 'icon-',

	        /**
	         * Specify a title for the icon that will be also used as alt of the image when using img driver
	         * @prop
	         * @type    {String}
	         */
	        title: null,

	        /**
	         * Specify the fontawesome icons css url to use
	         * @prop
	         * @type    {String}
	         */
	        fontawesomeCssUrl: 'https://use.fontawesome.com/releases/v5.7.1/css/all.css',

	        /**
	         * Specify the fontawesome icons css integrity checksum
	         * @prop
	         * @type    {String}
	         */
	        fontawesomeCssIntegrity: 'sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr',

	        /**
	         * Specify the fondation icons css url to use
	         * @prop
	         * @type    {String}
	         */
	        fondationCssUrl: 'https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/foundation-icons.css'
	      };
	    }
	  }]);

	  return Component;
	}(_SWebComponent2.default);

	exports.default = Component;

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(635);

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);
	var bind = __webpack_require__(637);
	var Axios = __webpack_require__(639);
	var defaults = __webpack_require__(640);

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(657);
	axios.CancelToken = __webpack_require__(658);
	axios.isCancel = __webpack_require__(654);

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(659);

	module.exports = axios;

	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var bind = __webpack_require__(637);
	var isBuffer = __webpack_require__(638);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 637 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 638 */
/***/ (function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(640);
	var utils = __webpack_require__(636);
	var InterceptorManager = __webpack_require__(651);
	var dispatchRequest = __webpack_require__(652);

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }

	  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
	  config.method = config.method.toLowerCase();

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	module.exports = Axios;


/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(636);
	var normalizeHeaderName = __webpack_require__(641);

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(642);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(642);
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	module.exports = defaults;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(347)))

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(636);
	var settle = __webpack_require__(643);
	var buildURL = __webpack_require__(646);
	var parseHeaders = __webpack_require__(647);
	var isURLSameOrigin = __webpack_require__(648);
	var createError = __webpack_require__(644);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(649);

	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;

	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(650);

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(347)))

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var createError = __webpack_require__(644);

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};


/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var enhanceError = __webpack_require__(645);

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};


/***/ }),
/* 645 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.request = request;
	  error.response = response;
	  return error;
	};


/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};


/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};


/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;

	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 649 */
/***/ (function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;


/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));

	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }

	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }

	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }

	        if (secure === true) {
	          cookie.push('secure');
	        }

	        document.cookie = cookie.join('; ');
	      },

	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },

	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	module.exports = InterceptorManager;


/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);
	var transformData = __webpack_require__(653);
	var isCancel = __webpack_require__(654);
	var defaults = __webpack_require__(640);
	var isAbsoluteURL = __webpack_require__(655);
	var combineURLs = __webpack_require__(656);

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};


/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(636);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};


/***/ }),
/* 654 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ }),
/* 655 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ }),
/* 656 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};


/***/ }),
/* 657 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	module.exports = Cancel;


/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Cancel = __webpack_require__(657);

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	module.exports = CancelToken;


/***/ }),
/* 659 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SLayersTransitionComponent = __webpack_require__(661);

	var _SLayersTransitionComponent2 = _interopRequireDefault(_SLayersTransitionComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _SLayersTransitionComponent2.default.define('s-layers-transition', _SLayersTransitionComponent2.default);

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SWebComponent2 = __webpack_require__(533);

	var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

	var _gsap = __webpack_require__(662);

	var _dispatchEvent = __webpack_require__(340);

	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

	var _debounce = __webpack_require__(629);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Create a nice layered transition for your webapp with fully customizable look and feel.
	 * @example    html
	 * <s-layers-transition layers="[{color:'#ff0000',side:'left'},{color:'#00ff00',side:'right'}]"></s-layers-transition>
	 *
	 * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	 * @see    https://ddd.ge    Inspiration source
	 */
	var SLayersTransitionComponent = function (_SWebComponent) {
	  _inherits(SLayersTransitionComponent, _SWebComponent);

	  function SLayersTransitionComponent() {
	    _classCallCheck(this, SLayersTransitionComponent);

	    return _possibleConstructorReturn(this, (SLayersTransitionComponent.__proto__ || Object.getPrototypeOf(SLayersTransitionComponent)).apply(this, arguments));
	  }

	  _createClass(SLayersTransitionComponent, [{
	    key: 'componentWillMount',


	    /**
	     * Component will mount
	     * @definition    SWebComponent.componentWillMount
	     * @protected
	     */
	    value: function componentWillMount() {
	      var _this2 = this;

	      _get(SLayersTransitionComponent.prototype.__proto__ || Object.getPrototypeOf(SLayersTransitionComponent.prototype), 'componentWillMount', this).call(this);

	      // flags
	      this._isTransitionIn = false;
	      this._isTransitionOut = false;

	      // layers
	      this._layers = [];

	      // create a canvas to draw in
	      this.$canvasElm = document.createElement('canvas');
	      this.appendChild(this.$canvasElm);

	      // set the layers
	      this.props.layers.forEach(function (layer) {
	        _this2._addLayer(layer.color, layer.side);
	      });

	      // listen for resize through transitionend event
	      this.addEventListener('transitionend', (0, _debounce2.default)(function (e) {
	        // set points
	        _this2._setPointPositionAndCanvasSize();
	      }, 100));
	    }

	    /**
	     * Set points position and canvas size
	     */

	  }, {
	    key: '_setPointPositionAndCanvasSize',
	    value: function _setPointPositionAndCanvasSize() {
	      var _this3 = this;

	      var _ref = [this.offsetWidth, this.offsetHeight],
	          w = _ref[0],
	          h = _ref[1];
	      // set canvas size

	      this.$canvasElm.width = w;
	      this.$canvasElm.height = h;
	      // loop on each layers
	      this._layers.forEach(function (layer) {
	        if (_this3._isTransitionIn) {
	          layer.points[2] = { x: w, y: h };
	          layer.points[3] = { x: 0, y: h };
	        } else if (_this3._isTransitionOut) {
	          layer.points[0] = { x: 0, y: 0 };
	          layer.points[1] = { x: w, y: 0 };
	        } else {
	          layer.points[0] = { x: 0, y: h };
	          layer.points[1] = { x: w, y: h };
	          layer.points[2] = { x: w, y: h };
	          layer.points[3] = { x: 0, y: h };
	        }
	      });
	    }

	    /**
	     * Component will receive prop
	     * @definition    SWebComponent.componentWillReceiveProp
	     * @protected
	     */

	  }, {
	    key: 'componentWillReceiveProp',
	    value: function componentWillReceiveProp(name, newVal, oldVal) {
	      var _this4 = this;

	      switch (name) {
	        case 'layers':
	          this._layers = [];
	          // set the layers
	          this.props.layers.forEach(function (layer) {
	            _this4._addLayer(layer.color, layer.side);
	          });
	          break;
	      }
	    }

	    /**
	     * Add a layer to be drawn
	     * @param    {String}    color    The color of the layer
	     * @param    {String}    side    The side of the layer. Can be `left` of `right`
	     * @private
	     * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	     */

	  }, {
	    key: '_addLayer',
	    value: function _addLayer(color) {
	      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
	      var _ref2 = [this.offsetWidth, this.offsetHeight],
	          w = _ref2[0],
	          h = _ref2[1];

	      this._layers.push({
	        color: color,
	        side: side,
	        points: [{ x: 0, y: h }, { x: w, y: h }, { x: w, y: h }, { x: 0, y: h }]
	      });
	    }

	    /**
	     * Animate the transition in
	     * @param    {Function}    onComplete    A callback when the transition is finished
	     * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	     */

	  }, {
	    key: 'animateIn',
	    value: function animateIn(_onComplete) {
	      var _this5 = this;

	      return new Promise(function (resolve, reject) {
	        // add the active class
	        _this5.classList.add('active');
	        // flag
	        _this5._isTransitionIn = true;

	        setTimeout(function () {
	          var ctx = _this5.$canvasElm.getContext('2d');
	          var _ref3 = [_this5.offsetWidth, _this5.offsetHeight],
	              w = _ref3[0],
	              h = _ref3[1];

	          _this5.$canvasElm.width = w;
	          _this5.$canvasElm.height = h;
	          ctx.globalCompositeOperation = 'add';

	          var tl = new _gsap.TimelineMax({
	            onComplete: function onComplete() {
	              // flag
	              _this5._isTransitionIn = false;
	              // callback
	              _onComplete && _onComplete(_this5);
	              // promise
	              resolve(_this5);
	              /**
	               * @event
	               * @name    in:complete
	               * Event dispatched when the transition in is completed
	               */
	              (0, _dispatchEvent2.default)(_this5, 'in:complete');
	            },
	            onUpdate: function onUpdate() {
	              ctx.clearRect(0, 0, w, h);

	              _this5._layers.forEach(function (layer, i) {
	                ctx.beginPath();
	                ctx.moveTo(layer.points[0].x, layer.points[0].y);
	                ctx.lineTo(layer.points[1].x, layer.points[1].y);
	                ctx.lineTo(layer.points[2].x, layer.points[2].y);
	                ctx.lineTo(layer.points[3].x, layer.points[3].y);
	                ctx.closePath();
	                ctx.fillStyle = layer.color;
	                ctx.fill();
	              });
	            }
	          });

	          var d = _this5.props.duration;

	          _this5._layers.forEach(function (layer, i) {
	            if (layer.side === 'left') {
	              tl.insert(new _gsap.TweenMax(layer.points[0], d, { y: 0, ease: _gsap.Expo.easeInOut }), _this5.props.delay * i);
	              tl.insert(new _gsap.TweenMax(layer.points[1], d + _this5.props.secondPointDelay, { y: 0, ease: _gsap.Expo.easeInOut }), _this5.props.delay * i);
	            } else {
	              tl.insert(new _gsap.TweenMax(layer.points[1], d, { y: 0, ease: _gsap.Expo.easeInOut }), _this5.props.delay * i);
	              tl.insert(new _gsap.TweenMax(layer.points[0], d + _this5.props.secondPointDelay, { y: 0, ease: _gsap.Expo.easeInOut }), _this5.props.delay * i);
	            }
	          });
	        });
	      });
	    }

	    /**
	     * Animate the transition out
	     * @param    {Function}    onComplete    A callback when the transition is finished
	     * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
	     */

	  }, {
	    key: 'animateOut',
	    value: function animateOut(_onComplete2) {
	      var _this6 = this;

	      return new Promise(function (resolve, reject) {
	        // flag
	        _this6._isTransitionOut = true;

	        setTimeout(function () {
	          // avoid flickering
	          var ctx = _this6.$canvasElm.getContext('2d');
	          var _ref4 = [_this6.offsetWidth, _this6.offsetHeight],
	              w = _ref4[0],
	              h = _ref4[1];

	          _this6.$canvasElm.width = w;
	          _this6.$canvasElm.height = h;
	          ctx.globalCompositeOperation = 'add';

	          var tl = new _gsap.TimelineMax({
	            onComplete: function onComplete() {
	              // flag
	              _this6._isTransitionOut = false;
	              // remove the active class
	              _this6.classList.remove('active');
	              // reset points
	              _this6._layers.forEach(function (layer) {
	                layer.points = [{ x: 0, y: h }, { x: w, y: h }, { x: w, y: h }, { x: 0, y: h }];
	              });
	              // callback
	              _onComplete2 && _onComplete2(_this6);
	              // promise
	              resolve(_this6);
	              /**
	              * @event
	              * @name    out:complete
	              * Event dispatched when the transition out is completed
	              */
	              (0, _dispatchEvent2.default)(_this6, 'out:complete');
	            },
	            onUpdate: function onUpdate() {
	              ctx.clearRect(0, 0, w, h);

	              _this6._layers.forEach(function (layer) {
	                ctx.beginPath();
	                ctx.moveTo(layer.points[0].x, layer.points[0].y);
	                ctx.lineTo(layer.points[1].x, layer.points[1].y);
	                ctx.lineTo(layer.points[2].x, layer.points[2].y);
	                ctx.lineTo(layer.points[3].x, layer.points[3].y);
	                ctx.closePath();
	                ctx.fillStyle = layer.color;
	                ctx.fill();
	              });
	            }
	          });

	          var d = _this6.props.duration;

	          _this6._layers.forEach(function (layer, i) {
	            if (layer.side === 'left') {
	              tl.insert(new _gsap.TweenMax(layer.points[2], d, { y: 0, ease: _gsap.Expo.easeInOut }), _this6.props.delay * (_this6._layers.length - 1) - _this6.props.delay * i);
	              tl.insert(new _gsap.TweenMax(layer.points[3], d + _this6.props.secondPointDelay, { y: 0, ease: _gsap.Expo.easeInOut }), _this6.props.delay * (_this6._layers.length - 1) - _this6.props.delay * i);
	            } else {
	              tl.insert(new _gsap.TweenMax(layer.points[2], d + _this6.props.secondPointDelay, { y: 0, ease: _gsap.Expo.easeInOut }), _this6.props.delay * (_this6._layers.length - 1) - _this6.props.delay * i);
	              tl.insert(new _gsap.TweenMax(layer.points[3], d, { y: 0, ease: _gsap.Expo.easeInOut }), _this6.props.delay * (_this6._layers.length - 1) - _this6.props.delay * i);
	            }
	          });
	        }, 10);
	      });
	    }
	  }], [{
	    key: 'defaultCss',


	    /**
	     * Css
	     * @protected
	     */
	    value: function defaultCss(componentName, componentNameDash) {
	      return '\n      ' + componentNameDash + ' {\n        display: block;\n        pointer-events: none;\n        transition: width 0.01s linear 0s, height 0.01s linear 0s;\n      }\n      ' + componentNameDash + '.active {\n        pointer-events: all;\n      }\n    ';
	    }
	  }, {
	    key: 'defaultProps',

	    /**
	     * Default props
	     * @definition    SWebComponent.defaultProps
	     * @protected
	     */
	    get: function get() {
	      return {

	        /**
	         * Specify the delay in second between each layers animations
	         * @prop
	         * @type    {Number}
	         */
	        delay: 0.2,

	        /**
	         * Specify the duration of 1 layer animation in second
	         * @prop
	         * @type    {Number}
	         */
	        duration: 0.6,

	        /**
	         * Specify the delay of the second point. This will create the slope in the animation
	         * @prop
	         * @type    {Number}
	         */
	        secondPointDelay: 0.15,

	        /**
	         * Set the layers. One layer in composed of:
	         * ```js
	         * {
	         *  color: '#ff0000',
	         *  side: 'left' // or right
	         * }
	         * ```
	         *
	         * @prop
	         * @type    {Array<Object>}
	         */
	        layers: [{
	          color: '#242c2f',
	          side: 'left'
	        }, {
	          color: '#f2bc2b',
	          side: 'right'
	        }]

	      };
	    }
	  }]);

	  return SLayersTransitionComponent;
	}(_SWebComponent3.default);

	exports.default = SLayersTransitionComponent;

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * VERSION: 2.1.0
	 * DATE: 2019-02-15
	 * UPDATES AND DOCS AT: http://greensock.com
	 * 
	 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
	 *
	 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
	 * This work is subject to the terms at http://greensock.com/standard-license or for
	 * Club GreenSock members, the software agreement that was issued with your membership.
	 * 
	 * @author: Jack Doyle, jack@greensock.com
	 **/
	/* eslint-disable */
	var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
	(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

		"use strict";

		_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

			var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					var b = [],
						l = a.length,
						i;
					for (i = 0; i !== l; b.push(a[i++]));
					return b;
				},
				_applyCycle = function(vars, targets, i) {
					var alt = vars.cycle,
						p, val;
					for (p in alt) {
						val = alt[p];
						vars[p] = (typeof(val) === "function") ? val(i, targets[i], targets) : val[i % val.length];
					}
					delete vars.cycle;
				},
				//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
				_distribute = function(v) {
					if (typeof(v) === "function") {
						return v;
					}
					var vars = isNaN(v) ? v : {n:1, from:(v < 0) ? ((v = -v) && "end") : 0}, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
						ease = vars.ease,
						from = vars.from || 0,
						base = vars.base || 0,
						cache = {},
						isFromKeyword = isNaN(from),
						axis = vars.axis,
						ratio = {center:0.5, end:1}[from] || 0;
					return function(i, target, a) {
						var l = (a || vars).length,
							distances = cache[l],
							originX, originY, x, y, d, j, max, min, wrap;
						if (!distances) {
							wrap = (vars.grid === "auto") ? 0 : (vars.grid || [Infinity])[0];
							if (!wrap) {
								max = -Infinity;
								while (max < (max = a[wrap++].getBoundingClientRect().left) && wrap < l) { }
								wrap--;
							}
							distances = cache[l] = [];
							originX = isFromKeyword ? (Math.min(wrap, l) * ratio) - 0.5 : from % wrap;
							originY = isFromKeyword ? l * ratio / wrap - 0.5 : (from / wrap) | 0;
							max = 0;
							min = Infinity;
							for (j = 0; j < l; j++) {
								x = (j % wrap) - originX;
								y = originY - ((j / wrap) | 0);
								distances[j] = d = !axis ? Math.sqrt(x * x + y * y) : Math.abs((axis === "y") ? y : x);
								if (d > max) {
									max = d;
								}
								if (d < min) {
									min = d;
								}
							}
							distances.max = max - min;
							distances.min = min;
							distances.v = vars.n ? l * (v || 0) : vars.amount;
						}
						l = (distances[i] - distances.min) / distances.max;
						return base + (ease ? ease.getRatio(l) : l) * distances.v;
					};
				},
				TweenMax = function(target, duration, vars) {
					TweenLite.call(this, target, duration, vars);
					this._cycle = 0;
					this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
					this._repeat = this.vars.repeat || 0;
					this._repeatDelay = this.vars.repeatDelay || 0;
					if (this._repeat) {
						this._uncache(true); //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
					}
					this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
				},
				_tinyNum = 0.00000001,
				TweenLiteInternals = TweenLite._internals,
				_isSelector = TweenLiteInternals.isSelector,
				_isArray = TweenLiteInternals.isArray,
				p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
				_blankArray = [];

			TweenMax.version = "2.1.0";
			p.constructor = TweenMax;
			p.kill()._gc = false;
			TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
			TweenMax.getTweensOf = TweenLite.getTweensOf;
			TweenMax.lagSmoothing = TweenLite.lagSmoothing;
			TweenMax.ticker = TweenLite.ticker;
			TweenMax.render = TweenLite.render;
			TweenMax.distribute = _distribute;

			p.invalidate = function() {
				this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._yoyoEase = null;
				this._uncache(true);
				return TweenLite.prototype.invalidate.call(this);
			};
			
			p.updateTo = function(vars, resetDuration) {
				var self = this,
					curRatio = self.ratio,
					immediate = self.vars.immediateRender || vars.immediateRender,
					p;
				if (resetDuration && self._startTime < self._timeline._time) {
					self._startTime = self._timeline._time;
					self._uncache(false);
					if (self._gc) {
						self._enabled(true, false);
					} else {
						self._timeline.insert(self, self._startTime - self._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
					}
				}
				for (p in vars) {
					self.vars[p] = vars[p];
				}
				if (self._initted || immediate) {
					if (resetDuration) {
						self._initted = false;
						if (immediate) {
							self.render(0, true, true);
						}
					} else {
						if (self._gc) {
							self._enabled(true, false);
						}
						if (self._notifyPluginsOfEnabled && self._firstPT) {
							TweenLite._onPluginEvent("_onDisable", self); //in case a plugin like MotionBlur must perform some cleanup tasks
						}
						if (self._time / self._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards.
							var prevTime = self._totalTime;
							self.render(0, true, false);
							self._initted = false;
							self.render(prevTime, true, false);
						} else {
							self._initted = false;
							self._init();
							if (self._time > 0 || immediate) {
								var inv = 1 / (1 - curRatio),
									pt = self._firstPT, endValue;
								while (pt) {
									endValue = pt.s + pt.c;
									pt.c *= inv;
									pt.s = endValue - pt.c;
									pt = pt._next;
								}
							}
						}
					}
				}
				return self;
			};
					
			p.render = function(time, suppressEvents, force) {
				if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
					this.invalidate();
				}
				var self = this,
					totalDur = (!self._dirty) ? self._totalDuration : self.totalDuration(),
					prevTime = self._time,
					prevTotalTime = self._totalTime,
					prevCycle = self._cycle,
					duration = self._duration,
					prevRawPrevTime = self._rawPrevTime,
					isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
				if (time >= totalDur - _tinyNum && time >= 0) { //to work around occasional floating point math artifacts.
					self._totalTime = totalDur;
					self._cycle = self._repeat;
					if (self._yoyo && (self._cycle & 1) !== 0) {
						self._time = 0;
						self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;
					} else {
						self._time = duration;
						self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;
					}
					if (!self._reversed) {
						isComplete = true;
						callback = "onComplete";
						force = (force || self._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					}
					if (duration === 0) if (self._initted || !self.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (self._startTime === self._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
							time = 0;
						}
						if (prevRawPrevTime < 0 || (time <= 0 && time >= -_tinyNum) || (prevRawPrevTime === _tinyNum && self.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
							force = true;
							if (prevRawPrevTime > _tinyNum) {
								callback = "onReverseComplete";
							}
						}
						self._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
					
				} else if (time < _tinyNum) { //to work around occasional floating point math artifacts, round super small values to 0.
					self._totalTime = self._time = self._cycle = 0;
					self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;
					if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
						callback = "onReverseComplete";
						isComplete = self._reversed;
					}
					if (time > -_tinyNum) {
						time = 0;
					} else if (time < 0) {
						self._active = false;
						if (duration === 0) if (self._initted || !self.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
							if (prevRawPrevTime >= 0) {
								force = true;
							}
							self._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						}
					}
					if (!self._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
						force = true;
					}
				} else {
					self._totalTime = self._time = time;
					if (self._repeat !== 0) {
						cycleDuration = duration + self._repeatDelay;
						self._cycle = (self._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
						if (self._cycle !== 0) if (self._cycle === self._totalTime / cycleDuration && prevTotalTime <= time) {
							self._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						self._time = self._totalTime - (self._cycle * cycleDuration);
						if (self._yoyo) if ((self._cycle & 1) !== 0) {
							self._time = duration - self._time;
							yoyoEase = self._yoyoEase || self.vars.yoyoEase; //note: we don't set this._yoyoEase in _init() like we do other properties because it's TweenMax-specific and doing it here allows us to optimize performance (most tweens don't have a yoyoEase). Note that we also must skip the this.ratio calculation further down right after we _init() in this function, because we're doing it here.
							if (yoyoEase) {
								if (!self._yoyoEase) {
									if (yoyoEase === true && !self._initted) { //if it's not initted and yoyoEase is true, this._ease won't have been populated yet so we must discern it here.
										yoyoEase = self.vars.ease;
										self._yoyoEase = yoyoEase = !yoyoEase ? TweenLite.defaultEase : (yoyoEase instanceof Ease) ? yoyoEase : (typeof(yoyoEase) === "function") ? new Ease(yoyoEase, self.vars.easeParams) : Ease.map[yoyoEase] || TweenLite.defaultEase;
									} else {
										self._yoyoEase = yoyoEase = (yoyoEase === true) ? self._ease : (yoyoEase instanceof Ease) ? yoyoEase : Ease.map[yoyoEase];
									}
								}
								self.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - self._time) / duration) : 0;
							}
						}
						if (self._time > duration) {
							self._time = duration;
						} else if (self._time < 0) {
							self._time = 0;
						}
					}
					if (self._easeType && !yoyoEase) {
						r = self._time / duration;
						type = self._easeType;
						pow = self._easePower;
						if (type === 1 || (type === 3 && r >= 0.5)) {
							r = 1 - r;
						}
						if (type === 3) {
							r *= 2;
						}
						if (pow === 1) {
							r *= r;
						} else if (pow === 2) {
							r *= r * r;
						} else if (pow === 3) {
							r *= r * r * r;
						} else if (pow === 4) {
							r *= r * r * r * r;
						}
						self.ratio = (type === 1) ? 1 - r : (type === 2) ? r : (self._time / duration < 0.5) ? r / 2 : 1 - (r / 2);

					} else if (!yoyoEase) {
						self.ratio = self._ease.getRatio(self._time / duration);
					}
					
				}
					
				if (prevTime === self._time && !force && prevCycle === self._cycle) {
					if (prevTotalTime !== self._totalTime) if (self._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
						self._callback("onUpdate");
					}
					return;
				} else if (!self._initted) {
					self._init();
					if (!self._initted || self._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
						return;
					} else if (!force && self._firstPT && ((self.vars.lazy !== false && self._duration) || (self.vars.lazy && !self._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
						self._time = prevTime;
						self._totalTime = prevTotalTime;
						self._rawPrevTime = prevRawPrevTime;
						self._cycle = prevCycle;
						TweenLiteInternals.lazyTweens.push(self);
						self._lazy = [time, suppressEvents];
						return;
					}
					//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
					if (self._time && !isComplete && !yoyoEase) {
						self.ratio = self._ease.getRatio(self._time / duration);
					} else if (isComplete && this._ease._calcEnd && !yoyoEase) {
						self.ratio = self._ease.getRatio((self._time === 0) ? 0 : 1);
					}
				}
				if (self._lazy !== false) {
					self._lazy = false;
				}

				if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {
					self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
				}
				if (prevTotalTime === 0) {
					if (self._initted === 2 && time > 0) {
						self._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
					}
					if (self._startAt) {
						if (time >= 0) {
							self._startAt.render(time, true, force);
						} else if (!callback) {
							callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
						}
					}
					if (self.vars.onStart) if (self._totalTime !== 0 || duration === 0) if (!suppressEvents) {
						self._callback("onStart");
					}
				}
				
				pt = self._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](pt.c * self.ratio + pt.s);
					} else {
						pt.t[pt.p] = pt.c * self.ratio + pt.s;
					}
					pt = pt._next;
				}
				
				if (self._onUpdate) {
					if (time < 0) if (self._startAt && self._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
						self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
					}
					if (!suppressEvents) if (self._totalTime !== prevTotalTime || callback) {
						self._callback("onUpdate");
					}
				}
				if (self._cycle !== prevCycle) if (!suppressEvents) if (!self._gc) if (self.vars.onRepeat) {
					self._callback("onRepeat");
				}
				if (callback) if (!self._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
					if (time < 0 && self._startAt && !self._onUpdate && self._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
						self._startAt.render(time, true, force);
					}
					if (isComplete) {
						if (self._timeline.autoRemoveChildren) {
							self._enabled(false, false);
						}
						self._active = false;
					}
					if (!suppressEvents && self.vars[callback]) {
						self._callback(callback);
					}
					if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
						self._rawPrevTime = 0;
					}
				}
			};
			
	//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
			
			TweenMax.to = function(target, duration, vars) {
				return new TweenMax(target, duration, vars);
			};
			
			TweenMax.from = function(target, duration, vars) {
				vars.runBackwards = true;
				vars.immediateRender = (vars.immediateRender != false);
				return new TweenMax(target, duration, vars);
			};
			
			TweenMax.fromTo = function(target, duration, fromVars, toVars) {
				toVars.startAt = fromVars;
				toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
				return new TweenMax(target, duration, toVars);
			};

			TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				var a = [],
					staggerFunc = _distribute(vars.stagger || stagger),
					cycle = vars.cycle,
					fromCycle = (vars.startAt || _blankArray).cycle,
					l, copy, i, p;
				if (!_isArray(targets)) {
					if (typeof(targets) === "string") {
						targets = TweenLite.selector(targets) || targets;
					}
					if (_isSelector(targets)) {
						targets = _slice(targets);
					}
				}
				targets = targets || [];
				l = targets.length - 1;
				for (i = 0; i <= l; i++) {
					copy = {};
					for (p in vars) {
						copy[p] = vars[p];
					}
					if (cycle) {
						_applyCycle(copy, targets, i);
						if (copy.duration != null) {
							duration = copy.duration;
							delete copy.duration;
						}
					}
					if (fromCycle) {
						fromCycle = copy.startAt = {};
						for (p in vars.startAt) {
							fromCycle[p] = vars.startAt[p];
						}
						_applyCycle(copy.startAt, targets, i);
					}
					copy.delay = staggerFunc(i, targets[i], targets) + (copy.delay || 0);
					if (i === l && onCompleteAll) {
						copy.onComplete = function() {
							if (vars.onComplete) {
								vars.onComplete.apply(vars.onCompleteScope || this, arguments);
							}
							onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
						};
					}
					a[i] = new TweenMax(targets[i], duration, copy);
				}
				return a;
			};
			
			TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				vars.runBackwards = true;
				vars.immediateRender = (vars.immediateRender != false);
				return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
			};
			
			TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				toVars.startAt = fromVars;
				toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
				return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
			};
					
			TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
				return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
			};
			
			TweenMax.set = function(target, vars) {
				return new TweenMax(target, 0, vars);
			};
			
			TweenMax.isTweening = function(target) {
				return (TweenLite.getTweensOf(target, true).length > 0);
			};
			
			var _getChildrenOf = function(timeline, includeTimelines) {
					var a = [],
						cnt = 0,
						tween = timeline._first;
					while (tween) {
						if (tween instanceof TweenLite) {
							a[cnt++] = tween;
						} else {
							if (includeTimelines) {
								a[cnt++] = tween;
							}
							a = a.concat(_getChildrenOf(tween, includeTimelines));
							cnt = a.length;
						}
						tween = tween._next;
					}
					return a;
				}, 
				getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
					return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
				};
			
			TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
				if (tweens == null) {
					tweens = true;
				}
				if (delayedCalls == null) {
					delayedCalls = true;
				}
				var a = getAllTweens((timelines != false)),
					l = a.length,
					allTrue = (tweens && delayedCalls && timelines),
					isDC, tween, i;
				for (i = 0; i < l; i++) {
					tween = a[i];
					if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
						if (complete) {
							tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
						} else {
							tween._enabled(false, false);
						}
					}
				}
			};
			
			TweenMax.killChildTweensOf = function(parent, complete) {
				if (parent == null) {
					return;
				}
				var tl = TweenLiteInternals.tweenLookup,
					a, curParent, p, i, l;
				if (typeof(parent) === "string") {
					parent = TweenLite.selector(parent) || parent;
				}
				if (_isSelector(parent)) {
					parent = _slice(parent);
				}
				if (_isArray(parent)) {
					i = parent.length;
					while (--i > -1) {
						TweenMax.killChildTweensOf(parent[i], complete);
					}
					return;
				}
				a = [];
				for (p in tl) {
					curParent = tl[p].target.parentNode;
					while (curParent) {
						if (curParent === parent) {
							a = a.concat(tl[p].tweens);
						}
						curParent = curParent.parentNode;
					}
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					if (complete) {
						a[i].totalTime(a[i].totalDuration());
					}
					a[i]._enabled(false, false);
				}
			};

			var _changePause = function(pause, tweens, delayedCalls, timelines) {
				tweens = (tweens !== false);
				delayedCalls = (delayedCalls !== false);
				timelines = (timelines !== false);
				var a = getAllTweens(timelines),
					allTrue = (tweens && delayedCalls && timelines),
					i = a.length,
					isDC, tween;
				while (--i > -1) {
					tween = a[i];
					if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
						tween.paused(pause);
					}
				}
			};
			
			TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
				_changePause(true, tweens, delayedCalls, timelines);
			};
			
			TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
				_changePause(false, tweens, delayedCalls, timelines);
			};

			TweenMax.globalTimeScale = function(value) {
				var tl = Animation._rootTimeline,
					t = TweenLite.ticker.time;
				if (!arguments.length) {
					return tl._timeScale;
				}
				value = value || _tinyNum; //can't allow zero because it'll throw the math off
				tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
				tl = Animation._rootFramesTimeline;
				t = TweenLite.ticker.frame;
				tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
				tl._timeScale = Animation._rootTimeline._timeScale = value;
				return value;
			};
			
		
	//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
			
			p.progress = function(value, suppressEvents) {
				return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
			};
			
			p.totalProgress = function(value, suppressEvents) {
				return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
			};
			
			p.time = function(value, suppressEvents) {
				if (!arguments.length) {
					return this._time;
				}
				if (this._dirty) {
					this.totalDuration();
				}
				var duration = this._duration,
					cycle = this._cycle,
					cycleDur = cycle * (duration * this._repeatDelay);
				if (value > duration) {
					value = duration;
				}
				return this.totalTime((this._yoyo && (cycle & 1)) ? duration - value + cycleDur : this._repeat ? value + cycleDur : value, suppressEvents);
			};

			p.duration = function(value) {
				if (!arguments.length) {
					return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
				}
				return Animation.prototype.duration.call(this, value);
			};

			p.totalDuration = function(value) {
				if (!arguments.length) {
					if (this._dirty) {
						//instead of Infinity, we use 999999999999 so that we can accommodate reverses
						this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
						this._dirty = false;
					}
					return this._totalDuration;
				}
				return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
			};
			
			p.repeat = function(value) {
				if (!arguments.length) {
					return this._repeat;
				}
				this._repeat = value;
				return this._uncache(true);
			};
			
			p.repeatDelay = function(value) {
				if (!arguments.length) {
					return this._repeatDelay;
				}
				this._repeatDelay = value;
				return this._uncache(true);
			};
			
			p.yoyo = function(value) {
				if (!arguments.length) {
					return this._yoyo;
				}
				this._yoyo = value;
				return this;
			};
			
			
			return TweenMax;
			
		}, true);








	/*
	 * ----------------------------------------------------------------
	 * TimelineLite
	 * ----------------------------------------------------------------
	 */
		_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

			var TimelineLite = function(vars) {
					SimpleTimeline.call(this, vars);
					var self = this,
						v = self.vars,
						val, p;
					self._labels = {};
					self.autoRemoveChildren = !!v.autoRemoveChildren;
					self.smoothChildTiming = !!v.smoothChildTiming;
					self._sortChildren = true;
					self._onUpdate = v.onUpdate;
					for (p in v) {
						val = v[p];
						if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
							v[p] = self._swapSelfInParams(val);
						}
					}
					if (_isArray(v.tweens)) {
						self.add(v.tweens, 0, v.align, v.stagger);
					}
				},
				_tinyNum = 0.00000001,
				TweenLiteInternals = TweenLite._internals,
				_internals = TimelineLite._internals = {},
				_isSelector = TweenLiteInternals.isSelector,
				_isArray = TweenLiteInternals.isArray,
				_lazyTweens = TweenLiteInternals.lazyTweens,
				_lazyRender = TweenLiteInternals.lazyRender,
				_globals = _gsScope._gsDefine.globals,
				_copy = function(vars) {
					var copy = {}, p;
					for (p in vars) {
						copy[p] = vars[p];
					}
					return copy;
				},
				_applyCycle = function(vars, targets, i) {
					var alt = vars.cycle,
						p, val;
					for (p in alt) {
						val = alt[p];
						vars[p] = (typeof(val) === "function") ? val(i, targets[i], targets) : val[i % val.length];
					}
					delete vars.cycle;
				},
				_pauseCallback = _internals.pauseCallback = function() {},
				_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					var b = [],
						l = a.length,
						i;
					for (i = 0; i !== l; b.push(a[i++]));
					return b;
				},
				_defaultImmediateRender = function(tl, toVars, fromVars, defaultFalse) { //default to immediateRender:true unless otherwise set in toVars, fromVars or if defaultFalse is passed in as true
					var ir = "immediateRender";
					if (!(ir in toVars)) {
						toVars[ir] = !(tl._paused || (fromVars && fromVars[ir] === false) || defaultFalse);
					}
					return toVars;
				},
				//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
				_distribute = function(v) {
					if (typeof(v) === "function") {
						return v;
					}
					var vars = isNaN(v) ? v : {n:1, from:(v < 0) ? ((v = -v) && "end") : 0}, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
						ease = vars.ease,
						from = vars.from || 0,
						base = vars.base || 0,
						cache = {},
						isFromKeyword = isNaN(from),
						axis = vars.axis,
						ratio = {center:0.5, end:1}[from] || 0;
					return function(i, target, a) {
						var l = (a || vars).length,
							distances = cache[l],
							originX, originY, x, y, d, j, max, min, wrap;
						if (!distances) {
							wrap = (vars.grid === "auto") ? 0 : (vars.grid || [Infinity])[0];
							if (!wrap) {
								max = -Infinity;
								while (max < (max = a[wrap++].getBoundingClientRect().left) && wrap < l) { }
								wrap--;
							}
							distances = cache[l] = [];
							originX = isFromKeyword ? (Math.min(wrap, l) * ratio) - 0.5 : from % wrap;
							originY = isFromKeyword ? l * ratio / wrap - 0.5 : (from / wrap) | 0;
							max = 0;
							min = Infinity;
							for (j = 0; j < l; j++) {
								x = (j % wrap) - originX;
								y = originY - ((j / wrap) | 0);
								distances[j] = d = !axis ? Math.sqrt(x * x + y * y) : Math.abs((axis === "y") ? y : x);
								if (d > max) {
									max = d;
								}
								if (d < min) {
									min = d;
								}
							}
							distances.max = max - min;
							distances.min = min;
							distances.v = vars.n ? l * (v || 0) : vars.amount;
						}
						l = (distances[i] - distances.min) / distances.max;
						return base + (ease ? ease.getRatio(l) : l) * distances.v;
					};
				},
				p = TimelineLite.prototype = new SimpleTimeline();

			TimelineLite.version = "2.1.0";
			TimelineLite.distribute = _distribute;
			p.constructor = TimelineLite;
			p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

			/* might use later...
			//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
			function localToGlobal(time, animation) {
				while (animation) {
					time = (time / animation._timeScale) + animation._startTime;
					animation = animation.timeline;
				}
				return time;
			}

			//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
			function globalToLocal(time, animation) {
				var scale = 1;
				time -= localToGlobal(0, animation);
				while (animation) {
					scale *= animation._timeScale;
					animation = animation.timeline;
				}
				return time * scale;
			}
			*/

			p.to = function(target, duration, vars, position) {
				var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
				return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
			};

			p.from = function(target, duration, vars, position) {
				return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, _defaultImmediateRender(this, vars)), position);
			};

			p.fromTo = function(target, duration, fromVars, toVars, position) {
				var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
				toVars = _defaultImmediateRender(this, toVars, fromVars);
				return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
			};

			p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
					staggerFunc = _distribute(vars.stagger || stagger),
					startAt = vars.startAt,
					cycle = vars.cycle,
					copy, i;
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				targets = targets || [];
				if (_isSelector(targets)) { //if the targets object is a selector, translate it into an array.
					targets = _slice(targets);
				}
				for (i = 0; i < targets.length; i++) {
					copy = _copy(vars);
					if (startAt) {
						copy.startAt = _copy(startAt);
						if (startAt.cycle) {
							_applyCycle(copy.startAt, targets, i);
						}
					}
					if (cycle) {
						_applyCycle(copy, targets, i);
						if (copy.duration != null) {
							duration = copy.duration;
							delete copy.duration;
						}
					}
					tl.to(targets[i], duration, copy, staggerFunc(i, targets[i], targets));
				}
				return this.add(tl, position);
			};

			p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				vars.runBackwards = true;
				return this.staggerTo(targets, duration, _defaultImmediateRender(this, vars), stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
			};

			p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
				toVars.startAt = fromVars;
				return this.staggerTo(targets, duration, _defaultImmediateRender(this, toVars, fromVars), stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
			};

			p.call = function(callback, params, scope, position) {
				return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
			};

			p.set = function(target, vars, position) {
				return this.add( new TweenLite(target, 0, _defaultImmediateRender(this, vars, null, true)), position);
			};

			TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
				vars = vars || {};
				if (vars.smoothChildTiming == null) {
					vars.smoothChildTiming = true;
				}
				var tl = new TimelineLite(vars),
					root = tl._timeline,
					hasNegativeStart, time,	tween, next;
				if (ignoreDelayedCalls == null) {
					ignoreDelayedCalls = true;
				}
				root._remove(tl, true);
				tl._startTime = 0;
				tl._rawPrevTime = tl._time = tl._totalTime = root._time;
				tween = root._first;
				while (tween) {
					next = tween._next;
					if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
						time = tween._startTime - tween._delay;
						if (time < 0) {
							hasNegativeStart = 1;
						}
						tl.add(tween, time);
					}
					tween = next;
				}
				root.add(tl, 0);
				if (hasNegativeStart) { //calling totalDuration() will force the adjustment necessary to shift the children forward so none of them start before zero, and moves the timeline backwards the same amount, so the playhead is still aligned where it should be globally, but the timeline doesn't have illegal children that start before zero.
					tl.totalDuration();
				}
				return tl;
			};

			p.add = function(value, position, align, stagger) {
				var self = this,
					curTime, l, i, child, tl, beforeRawTime;
				if (typeof(position) !== "number") {
					position = self._parseTimeOrLabel(position, 0, true, value);
				}
				if (!(value instanceof Animation)) {
					if ((value instanceof Array) || (value && value.push && _isArray(value))) {
						align = align || "normal";
						stagger = stagger || 0;
						curTime = position;
						l = value.length;
						for (i = 0; i < l; i++) {
							if (_isArray(child = value[i])) {
								child = new TimelineLite({tweens:child});
							}
							self.add(child, curTime);
							if (typeof(child) !== "string" && typeof(child) !== "function") {
								if (align === "sequence") {
									curTime = child._startTime + (child.totalDuration() / child._timeScale);
								} else if (align === "start") {
									child._startTime -= child.delay();
								}
							}
							curTime += stagger;
						}
						return self._uncache(true);
					} else if (typeof(value) === "string") {
						return self.addLabel(value, position);
					} else if (typeof(value) === "function") {
						value = TweenLite.delayedCall(0, value);
					} else {
						throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
					}
				}

				SimpleTimeline.prototype.add.call(self, value, position);

				if (value._time || (!value._duration && value._initted)) { //in case, for example, the _startTime is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
					curTime = (self.rawTime() - value._startTime) * value._timeScale;
					if (!value._duration || Math.abs(Math.max(0, Math.min(value.totalDuration(), curTime))) - value._totalTime > 0.00001) {
						value.render(curTime, false, false);
					}
				}

				//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
				if (self._gc || self._time === self._duration) if (!self._paused) if (self._duration < self.duration()) {
					//in case any of the ancestors had completed but should now be enabled...
					tl = self;
					beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
					while (tl._timeline) {
						if (beforeRawTime && tl._timeline.smoothChildTiming) {
							tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
						} else if (tl._gc) {
							tl._enabled(true, false);
						}
						tl = tl._timeline;
					}
				}

				return self;
			};

			p.remove = function(value) {
				if (value instanceof Animation) {
					this._remove(value, false);
					var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
					value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
					return this;
				} else if (value instanceof Array || (value && value.push && _isArray(value))) {
					var i = value.length;
					while (--i > -1) {
						this.remove(value[i]);
					}
					return this;
				} else if (typeof(value) === "string") {
					return this.removeLabel(value);
				}
				return this.kill(null, value);
			};

			p._remove = function(tween, skipDisable) {
				SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
				var last = this._last;
				if (!last) {
					this._time = this._totalTime = this._duration = this._totalDuration = 0;
				} else if (this._time > this.duration()) {
					this._time = this._duration;
					this._totalTime = this._totalDuration;
				}
				return this;
			};

			p.append = function(value, offsetOrLabel) {
				return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
			};

			p.insert = p.insertMultiple = function(value, position, align, stagger) {
				return this.add(value, position || 0, align, stagger);
			};

			p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
				return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
			};

			p.addLabel = function(label, position) {
				this._labels[label] = this._parseTimeOrLabel(position);
				return this;
			};

			p.addPause = function(position, callback, params, scope) {
				var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
				t.vars.onComplete = t.vars.onReverseComplete = callback;
				t.data = "isPause";
				this._hasPause = true;
				return this.add(t, position);
			};

			p.removeLabel = function(label) {
				delete this._labels[label];
				return this;
			};

			p.getLabelTime = function(label) {
				return (this._labels[label] != null) ? this._labels[label] : -1;
			};

			p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
				var clippedDuration, i;
				//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
				if (ignore instanceof Animation && ignore.timeline === this) {
					this.remove(ignore);
				} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
					i = ignore.length;
					while (--i > -1) {
						if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
							this.remove(ignore[i]);
						}
					}
				}
				clippedDuration = (typeof(timeOrLabel) === "number" && !offsetOrLabel) ? 0 : (this.duration() > 99999999999) ? this.recent().endTime(false) : this._duration; //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
				if (typeof(offsetOrLabel) === "string") {
					return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
				}
				offsetOrLabel = offsetOrLabel || 0;
				if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
					i = timeOrLabel.indexOf("=");
					if (i === -1) {
						if (this._labels[timeOrLabel] == null) {
							return appendIfAbsent ? (this._labels[timeOrLabel] = clippedDuration + offsetOrLabel) : offsetOrLabel;
						}
						return this._labels[timeOrLabel] + offsetOrLabel;
					}
					offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
					timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : clippedDuration;
				} else if (timeOrLabel == null) {
					timeOrLabel = clippedDuration;
				}
				return Number(timeOrLabel) + offsetOrLabel;
			};

			p.seek = function(position, suppressEvents) {
				return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
			};

			p.stop = function() {
				return this.paused(true);
			};

			p.gotoAndPlay = function(position, suppressEvents) {
				return this.play(position, suppressEvents);
			};

			p.gotoAndStop = function(position, suppressEvents) {
				return this.pause(position, suppressEvents);
			};

			p.render = function(time, suppressEvents, force) {
				if (this._gc) {
					this._enabled(true, false);
				}
				var self = this,
					prevTime = self._time,
					totalDur = (!self._dirty) ? self._totalDuration : self.totalDuration(),
					prevStart = self._startTime,
					prevTimeScale = self._timeScale,
					prevPaused = self._paused,
					tween, isComplete, next, callback, internalForce, pauseTween, curTime, pauseTime;
				if (prevTime !== self._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
					time += self._time - prevTime;
				}
				if (time >= totalDur - _tinyNum && time >= 0) { //to work around occasional floating point math artifacts.
					self._totalTime = self._time = totalDur;
					if (!self._reversed) if (!self._hasPausedChild()) {
						isComplete = true;
						callback = "onComplete";
						internalForce = !!self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
						if (self._duration === 0) if ((time <= 0 && time >= -_tinyNum) || self._rawPrevTime < 0 || self._rawPrevTime === _tinyNum) if (self._rawPrevTime !== time && self._first) {
							internalForce = true;
							if (self._rawPrevTime > _tinyNum) {
								callback = "onReverseComplete";
							}
						}
					}
					self._rawPrevTime = (self._duration || !suppressEvents || time || self._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

				} else if (time < _tinyNum) { //to work around occasional floating point math artifacts, round super small values to 0.
					self._totalTime = self._time = 0;
					if (time > -_tinyNum) {
						time = 0;
					}
					if (prevTime !== 0 || (self._duration === 0 && self._rawPrevTime !== _tinyNum && (self._rawPrevTime > 0 || (time < 0 && self._rawPrevTime >= 0)))) {
						callback = "onReverseComplete";
						isComplete = self._reversed;
					}
					if (time < 0) {
						self._active = false;
						if (self._timeline.autoRemoveChildren && self._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
							internalForce = isComplete = true;
							callback = "onReverseComplete";
						} else if (self._rawPrevTime >= 0 && self._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
							internalForce = true;
						}
						self._rawPrevTime = time;
					} else {
						self._rawPrevTime = (self._duration || !suppressEvents || time || self._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
							tween = self._first;
							while (tween && tween._startTime === 0) {
								if (!tween._duration) {
									isComplete = false;
								}
								tween = tween._next;
							}
						}
						time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
						if (!self._initted) {
							internalForce = true;
						}
					}

				} else {

					if (self._hasPause && !self._forcingPlayhead && !suppressEvents) {
						if (time >= prevTime) {
							tween = self._first;
							while (tween && tween._startTime <= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && self._rawPrevTime === 0)) {
									pauseTween = tween;
								}
								tween = tween._next;
							}
						} else {
							tween = self._last;
							while (tween && tween._startTime >= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
									pauseTween = tween;
								}
								tween = tween._prev;
							}
						}
						if (pauseTween) {
							self._time = self._totalTime = time = pauseTween._startTime;
							pauseTime = self._startTime + (time / self._timeScale);
						}
					}

					self._totalTime = self._time = self._rawPrevTime = time;
				}
				if ((self._time === prevTime || !self._first) && !force && !internalForce && !pauseTween) {
					return;
				} else if (!self._initted) {
					self._initted = true;
				}

				if (!self._active) if (!self._paused && self._time !== prevTime && time > 0) {
					self._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
				}

				if (prevTime === 0) if (self.vars.onStart) if (self._time !== 0 || !self._duration) if (!suppressEvents) {
					self._callback("onStart");
				}

				curTime = self._time;
				if (curTime >= prevTime) {
					tween = self._first;
					while (tween) {
						next = tween._next; //record it here because the value could change after rendering...
						if (curTime !== self._time || (self._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							break;
						} else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
							if (pauseTween === tween) {
								self.pause();
								self._pauseTime = pauseTime; //so that when we resume(), it's starting from exactly the right spot (the pause() method uses the rawTime for the parent, but that may be a bit too far ahead)
							}
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
							}
						}
						tween = next;
					}
				} else {
					tween = self._last;
					while (tween) {
						next = tween._prev; //record it here because the value could change after rendering...
						if (curTime !== self._time || (self._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							break;
						} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
							if (pauseTween === tween) {
								pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
								while (pauseTween && pauseTween.endTime() > self._time) {
									pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
									pauseTween = pauseTween._prev;
								}
								pauseTween = null;
								self.pause();
								self._pauseTime = pauseTime; //so that when we resume(), it's starting from exactly the right spot (the pause() method uses the rawTime for the parent, but that may be a bit too far ahead)
							}
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
							}
						}
						tween = next;
					}
				}

				if (self._onUpdate) if (!suppressEvents) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					self._callback("onUpdate");
				}

				if (callback) if (!self._gc) if (prevStart === self._startTime || prevTimeScale !== self._timeScale) if (self._time === 0 || totalDur >= self.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
					if (isComplete) {
						if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
							_lazyRender();
						}
						if (self._timeline.autoRemoveChildren) {
							self._enabled(false, false);
						}
						self._active = false;
					}
					if (!suppressEvents && self.vars[callback]) {
						self._callback(callback);
					}
				}
			};

			p._hasPausedChild = function() {
				var tween = this._first;
				while (tween) {
					if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
						return true;
					}
					tween = tween._next;
				}
				return false;
			};

			p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
				ignoreBeforeTime = ignoreBeforeTime || -9999999999;
				var a = [],
					tween = this._first,
					cnt = 0;
				while (tween) {
					if (tween._startTime < ignoreBeforeTime) {
						//do nothing
					} else if (tween instanceof TweenLite) {
						if (tweens !== false) {
							a[cnt++] = tween;
						}
					} else {
						if (timelines !== false) {
							a[cnt++] = tween;
						}
						if (nested !== false) {
							a = a.concat(tween.getChildren(true, tweens, timelines));
							cnt = a.length;
						}
					}
					tween = tween._next;
				}
				return a;
			};

			p.getTweensOf = function(target, nested) {
				var disabled = this._gc,
					a = [],
					cnt = 0,
					tweens, i;
				if (disabled) {
					this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
				}
				tweens = TweenLite.getTweensOf(target);
				i = tweens.length;
				while (--i > -1) {
					if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
						a[cnt++] = tweens[i];
					}
				}
				if (disabled) {
					this._enabled(false, true);
				}
				return a;
			};

			p.recent = function() {
				return this._recent;
			};

			p._contains = function(tween) {
				var tl = tween.timeline;
				while (tl) {
					if (tl === this) {
						return true;
					}
					tl = tl.timeline;
				}
				return false;
			};

			p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
				ignoreBeforeTime = ignoreBeforeTime || 0;
				var tween = this._first,
					labels = this._labels,
					p;
				while (tween) {
					if (tween._startTime >= ignoreBeforeTime) {
						tween._startTime += amount;
					}
					tween = tween._next;
				}
				if (adjustLabels) {
					for (p in labels) {
						if (labels[p] >= ignoreBeforeTime) {
							labels[p] += amount;
						}
					}
				}
				return this._uncache(true);
			};

			p._kill = function(vars, target) {
				if (!vars && !target) {
					return this._enabled(false, false);
				}
				var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
					i = tweens.length,
					changed = false;
				while (--i > -1) {
					if (tweens[i]._kill(vars, target)) {
						changed = true;
					}
				}
				return changed;
			};

			p.clear = function(labels) {
				var tweens = this.getChildren(false, true, true),
					i = tweens.length;
				this._time = this._totalTime = 0;
				while (--i > -1) {
					tweens[i]._enabled(false, false);
				}
				if (labels !== false) {
					this._labels = {};
				}
				return this._uncache(true);
			};

			p.invalidate = function() {
				var tween = this._first;
				while (tween) {
					tween.invalidate();
					tween = tween._next;
				}
				return Animation.prototype.invalidate.call(this);;
			};

			p._enabled = function(enabled, ignoreTimeline) {
				if (enabled === this._gc) {
					var tween = this._first;
					while (tween) {
						tween._enabled(enabled, true);
						tween = tween._next;
					}
				}
				return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
			};

			p.totalTime = function(time, suppressEvents, uncapped) {
				this._forcingPlayhead = true;
				var val = Animation.prototype.totalTime.apply(this, arguments);
				this._forcingPlayhead = false;
				return val;
			};

			p.duration = function(value) {
				if (!arguments.length) {
					if (this._dirty) {
						this.totalDuration(); //just triggers recalculation
					}
					return this._duration;
				}
				if (this.duration() !== 0 && value !== 0) {
					this.timeScale(this._duration / value);
				}
				return this;
			};

			p.totalDuration = function(value) {
				if (!arguments.length) {
					if (this._dirty) {
						var max = 0,
							self = this,
							tween = self._last,
							prevStart = 999999999999,
							prev, end;
						while (tween) {
							prev = tween._prev; //record it here in case the tween changes position in the sequence...
							if (tween._dirty) {
								tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
							}
							if (tween._startTime > prevStart && self._sortChildren && !tween._paused && !self._calculatingDuration) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
								self._calculatingDuration = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add(), like _parseTimeOrLabel().
								self.add(tween, tween._startTime - tween._delay);
								self._calculatingDuration = 0;
							} else {
								prevStart = tween._startTime;
							}
							if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
								max -= tween._startTime;
								if (self._timeline.smoothChildTiming) {
									self._startTime += tween._startTime / self._timeScale;
									self._time -= tween._startTime;
									self._totalTime -= tween._startTime;
									self._rawPrevTime -= tween._startTime;
								}
								self.shiftChildren(-tween._startTime, false, -9999999999);
								prevStart = 0;
							}
							end = tween._startTime + (tween._totalDuration / tween._timeScale);
							if (end > max) {
								max = end;
							}
							tween = prev;
						}
						self._duration = self._totalDuration = max;
						self._dirty = false;
					}
					return this._totalDuration;
				}
				return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
			};

			p.paused = function(value) {
				if (value === false && this._paused) { //if there's a pause directly at the spot from where we're unpausing, skip it.
					var tween = this._first;
					while (tween) {
						if (tween._startTime === this._time && tween.data === "isPause") {
							tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
						}
						tween = tween._next;
					}
				}
				return Animation.prototype.paused.apply(this, arguments);
			};

			p.usesFrames = function() {
				var tl = this._timeline;
				while (tl._timeline) {
					tl = tl._timeline;
				}
				return (tl === Animation._rootFramesTimeline);
			};

			p.rawTime = function(wrapRepeats) {
				return (wrapRepeats && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
			};

			return TimelineLite;

		}, true);








		
		
		
		
		
	/*
	 * ----------------------------------------------------------------
	 * TimelineMax
	 * ----------------------------------------------------------------
	 */
		_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

			var TimelineMax = function(vars) {
					TimelineLite.call(this, vars);
					this._repeat = this.vars.repeat || 0;
					this._repeatDelay = this.vars.repeatDelay || 0;
					this._cycle = 0;
					this._yoyo = !!this.vars.yoyo;
					this._dirty = true;
				},
				_tinyNum = 0.00000001,
				TweenLiteInternals = TweenLite._internals,
				_lazyTweens = TweenLiteInternals.lazyTweens,
				_lazyRender = TweenLiteInternals.lazyRender,
				_globals = _gsScope._gsDefine.globals,
				_easeNone = new Ease(null, null, 1, 0),
				p = TimelineMax.prototype = new TimelineLite();

			p.constructor = TimelineMax;
			p.kill()._gc = false;
			TimelineMax.version = "2.1.0";

			p.invalidate = function() {
				this._yoyo = !!this.vars.yoyo;
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._uncache(true);
				return TimelineLite.prototype.invalidate.call(this);
			};

			p.addCallback = function(callback, position, params, scope) {
				return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
			};

			p.removeCallback = function(callback, position) {
				if (callback) {
					if (position == null) {
						this._kill(null, callback);
					} else {
						var a = this.getTweensOf(callback, false),
							i = a.length,
							time = this._parseTimeOrLabel(position);
						while (--i > -1) {
							if (a[i]._startTime === time) {
								a[i]._enabled(false, false);
							}
						}
					}
				}
				return this;
			};

			p.removePause = function(position) {
				return this.removeCallback(TimelineLite._internals.pauseCallback, position);
			};

			p.tweenTo = function(position, vars) {
				vars = vars || {};
				var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false, lazy:false},
					Engine = (vars.repeat && _globals.TweenMax) || TweenLite,
					duration, p, t;
				for (p in vars) {
					copy[p] = vars[p];
				}
				copy.time = this._parseTimeOrLabel(position);
				duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
				t = new Engine(this, duration, copy);
				copy.onStart = function() {
					t.target.paused(true);
					if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
						t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale ).render(t.time(), true, true); //render() right away to ensure that things look right, especially in the case of .tweenTo(0).
					}
					if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
						vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don't use t._callback("onStart") or it'll point to the copy.onStart and we'll get a recursion error.
					}
				};
				return t;
			};

			p.tweenFromTo = function(fromPosition, toPosition, vars) {
				vars = vars || {};
				fromPosition = this._parseTimeOrLabel(fromPosition);
				vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
				vars.immediateRender = (vars.immediateRender !== false);
				var t = this.tweenTo(toPosition, vars);
				t.isFromTo = 1; //to ensure we don't mess with the duration in the onStart (we've got the start and end values here, so lock it in)
				return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
			};

			p.render = function(time, suppressEvents, force) {
				if (this._gc) {
					this._enabled(true, false);
				}
				var self = this,
					prevTime = self._time,
					totalDur = (!self._dirty) ? self._totalDuration : self.totalDuration(),
					dur = self._duration,
					prevTotalTime = self._totalTime,
					prevStart = self._startTime,
					prevTimeScale = self._timeScale,
					prevRawPrevTime = self._rawPrevTime,
					prevPaused = self._paused,
					prevCycle = self._cycle,
					tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime, pauseTime;
				if (prevTime !== self._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
					time += self._time - prevTime;
				}
				if (time >= totalDur - _tinyNum && time >= 0) { //to work around occasional floating point math artifacts.
					if (!self._locked) {
						self._totalTime = totalDur;
						self._cycle = self._repeat;
					}
					if (!self._reversed) if (!self._hasPausedChild()) {
						isComplete = true;
						callback = "onComplete";
						internalForce = !!self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
						if (self._duration === 0) if ((time <= 0 && time >= -_tinyNum) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && self._first) {
							internalForce = true;
							if (prevRawPrevTime > _tinyNum) {
								callback = "onReverseComplete";
							}
						}
					}
					self._rawPrevTime = (self._duration || !suppressEvents || time || self._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (self._yoyo && (self._cycle & 1)) {
						self._time = time = 0;
					} else {
						self._time = dur;
						time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
					}

				} else if (time < _tinyNum) { //to work around occasional floating point math artifacts, round super small values to 0.
					if (!self._locked) {
						self._totalTime = self._cycle = 0;
					}
					self._time = 0;
					if (time > -_tinyNum) {
						time = 0;
					}
					if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !self._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
						callback = "onReverseComplete";
						isComplete = self._reversed;
					}
					if (time < 0) {
						self._active = false;
						if (self._timeline.autoRemoveChildren && self._reversed) {
							internalForce = isComplete = true;
							callback = "onReverseComplete";
						} else if (prevRawPrevTime >= 0 && self._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
							internalForce = true;
						}
						self._rawPrevTime = time;
					} else {
						self._rawPrevTime = (dur || !suppressEvents || time || self._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
							tween = self._first;
							while (tween && tween._startTime === 0) {
								if (!tween._duration) {
									isComplete = false;
								}
								tween = tween._next;
							}
						}
						time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
						if (!self._initted) {
							internalForce = true;
						}
					}

				} else {
					if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
						internalForce = true;
					}
					self._time = self._rawPrevTime = time;
					if (!self._locked) {
						self._totalTime = time;
						if (self._repeat !== 0) {
							cycleDuration = dur + self._repeatDelay;
							self._cycle = (self._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
							if (self._cycle) if (self._cycle === self._totalTime / cycleDuration && prevTotalTime <= time) {
								self._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
							}
							self._time = self._totalTime - (self._cycle * cycleDuration);
							if (self._yoyo) if (self._cycle & 1) {
								self._time = dur - self._time;
							}
							if (self._time > dur) {
								self._time = dur;
								time = dur + 0.0001; //to avoid occasional floating point rounding error
							} else if (self._time < 0) {
								self._time = time = 0;
							} else {
								time = self._time;
							}
						}
					}

					if (self._hasPause && !self._forcingPlayhead && !suppressEvents) {
						time = self._time;
						if (time >= prevTime || (self._repeat && prevCycle !== self._cycle)) {
							tween = self._first;
							while (tween && tween._startTime <= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && self._rawPrevTime === 0)) {
									pauseTween = tween;
								}
								tween = tween._next;
							}
						} else {
							tween = self._last;
							while (tween && tween._startTime >= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
									pauseTween = tween;
								}
								tween = tween._prev;
							}
						}
						if (pauseTween) {
							pauseTime = self._startTime + (pauseTween._startTime / self._timeScale);
							if (pauseTween._startTime < dur) {
								self._time = self._rawPrevTime = time = pauseTween._startTime;
								self._totalTime = time + (self._cycle * (self._totalDuration + self._repeatDelay));
							}
						}
					}

				}

				if (self._cycle !== prevCycle) if (!self._locked) {
					/*
					make sure children at the end/beginning of the timeline are rendered properly. If, for example,
					a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
					would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
					could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
					we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
					ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
					*/
					var backwards = (self._yoyo && (prevCycle & 1) !== 0),
						wrap = (backwards === (self._yoyo && (self._cycle & 1) !== 0)),
						recTotalTime = self._totalTime,
						recCycle = self._cycle,
						recRawPrevTime = self._rawPrevTime,
						recTime = self._time;

					self._totalTime = prevCycle * dur;
					if (self._cycle < prevCycle) {
						backwards = !backwards;
					} else {
						self._totalTime += dur;
					}
					self._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

					self._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
					self._cycle = prevCycle;
					self._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
					prevTime = (backwards) ? 0 : dur;
					self.render(prevTime, suppressEvents, (dur === 0));
					if (!suppressEvents) if (!self._gc) {
						if (self.vars.onRepeat) {
							self._cycle = recCycle; //in case the onRepeat alters the playhead or invalidates(), we shouldn't stay locked or use the previous cycle.
							self._locked = false;
							self._callback("onRepeat");
						}
					}
					if (prevTime !== self._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
						return;
					}
					if (wrap) {
						self._cycle = prevCycle; //if there's an onRepeat, we reverted this above, so make sure it's set properly again. We also unlocked in that scenario, so reset that too.
						self._locked = true;
						prevTime = (backwards) ? dur + 0.0001 : -0.0001;
						self.render(prevTime, true, false);
					}
					self._locked = false;
					if (self._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
						return;
					}
					self._time = recTime;
					self._totalTime = recTotalTime;
					self._cycle = recCycle;
					self._rawPrevTime = recRawPrevTime;
				}

				if ((self._time === prevTime || !self._first) && !force && !internalForce && !pauseTween) {
					if (prevTotalTime !== self._totalTime) if (self._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
						self._callback("onUpdate");
					}
					return;
				} else if (!self._initted) {
					self._initted = true;
				}

				if (!self._active) if (!self._paused && self._totalTime !== prevTotalTime && time > 0) {
					self._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
				}

				if (prevTotalTime === 0) if (self.vars.onStart) if (self._totalTime !== 0 || !self._totalDuration) if (!suppressEvents) {
					self._callback("onStart");
				}

				curTime = self._time;
				if (curTime >= prevTime) {
					tween = self._first;
					while (tween) {
						next = tween._next; //record it here because the value could change after rendering...
						if (curTime !== self._time || (self._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							break;
						} else if (tween._active || (tween._startTime <= self._time && !tween._paused && !tween._gc)) {
							if (pauseTween === tween) {
								self.pause();
								self._pauseTime = pauseTime; //so that when we resume(), it's starting from exactly the right spot (the pause() method uses the rawTime for the parent, but that may be a bit too far ahead)
							}
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
							}
						}
						tween = next;
					}
				} else {
					tween = self._last;
					while (tween) {
						next = tween._prev; //record it here because the value could change after rendering...
						if (curTime !== self._time || (self._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							break;
						} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
							if (pauseTween === tween) {
								pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
								while (pauseTween && pauseTween.endTime() > self._time) {
									pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
									pauseTween = pauseTween._prev;
								}
								pauseTween = null;
								self.pause();
								self._pauseTime = pauseTime; //so that when we resume(), it's starting from exactly the right spot (the pause() method uses the rawTime for the parent, but that may be a bit too far ahead)
							}
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
							}
						}
						tween = next;
					}
				}

				if (self._onUpdate) if (!suppressEvents) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					self._callback("onUpdate");
				}
				if (callback) if (!self._locked) if (!self._gc) if (prevStart === self._startTime || prevTimeScale !== self._timeScale) if (self._time === 0 || totalDur >= self.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
					if (isComplete) {
						if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
							_lazyRender();
						}
						if (self._timeline.autoRemoveChildren) {
							self._enabled(false, false);
						}
						self._active = false;
					}
					if (!suppressEvents && self.vars[callback]) {
						self._callback(callback);
					}
				}
			};

			p.getActive = function(nested, tweens, timelines) {
				var a = [],
					all = this.getChildren(nested || (nested == null), tweens || (nested == null), !!timelines),
					cnt = 0,
					l = all.length,
					i, tween;
				for (i = 0; i < l; i++) {
					tween = all[i];
					if (tween.isActive()) {
						a[cnt++] = tween;
					}
				}
				return a;
			};


			p.getLabelAfter = function(time) {
				if (!time) if (time !== 0) { //faster than isNan()
					time = this._time;
				}
				var labels = this.getLabelsArray(),
					l = labels.length,
					i;
				for (i = 0; i < l; i++) {
					if (labels[i].time > time) {
						return labels[i].name;
					}
				}
				return null;
			};

			p.getLabelBefore = function(time) {
				if (time == null) {
					time = this._time;
				}
				var labels = this.getLabelsArray(),
					i = labels.length;
				while (--i > -1) {
					if (labels[i].time < time) {
						return labels[i].name;
					}
				}
				return null;
			};

			p.getLabelsArray = function() {
				var a = [],
					cnt = 0,
					p;
				for (p in this._labels) {
					a[cnt++] = {time:this._labels[p], name:p};
				}
				a.sort(function(a,b) {
					return a.time - b.time;
				});
				return a;
			};

			p.invalidate = function() {
				this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat
				return TimelineLite.prototype.invalidate.call(this);
			};


	//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

			p.progress = function(value, suppressEvents) {
				return (!arguments.length) ? (this._time / this.duration()) || 0 : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
			};

			p.totalProgress = function(value, suppressEvents) {
				return (!arguments.length) ? (this._totalTime / this.totalDuration()) || 0 : this.totalTime( this.totalDuration() * value, suppressEvents);
			};

			p.totalDuration = function(value) {
				if (!arguments.length) {
					if (this._dirty) {
						TimelineLite.prototype.totalDuration.call(this); //just forces refresh
						//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
						this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					}
					return this._totalDuration;
				}
				return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
			};

			p.time = function(value, suppressEvents) {
				if (!arguments.length) {
					return this._time;
				}
				if (this._dirty) {
					this.totalDuration();
				}
				var duration = this._duration,
					cycle = this._cycle,
					cycleDur = cycle * (duration * this._repeatDelay);
				if (value > duration) {
					value = duration;
				}
				return this.totalTime((this._yoyo && (cycle & 1)) ? duration - value + cycleDur : this._repeat ? value + cycleDur : value, suppressEvents);
			};

			p.repeat = function(value) {
				if (!arguments.length) {
					return this._repeat;
				}
				this._repeat = value;
				return this._uncache(true);
			};

			p.repeatDelay = function(value) {
				if (!arguments.length) {
					return this._repeatDelay;
				}
				this._repeatDelay = value;
				return this._uncache(true);
			};

			p.yoyo = function(value) {
				if (!arguments.length) {
					return this._yoyo;
				}
				this._yoyo = value;
				return this;
			};

			p.currentLabel = function(value) {
				if (!arguments.length) {
					return this.getLabelBefore(this._time + _tinyNum);
				}
				return this.seek(value, true);
			};

			return TimelineMax;

		}, true);
		




		
		
		
		
		

		
	/*
	 * ----------------------------------------------------------------
	 * BezierPlugin
	 * ----------------------------------------------------------------
	 */
		(function() {

			var _RAD2DEG = 180 / Math.PI,
				_r1 = [],
				_r2 = [],
				_r3 = [],
				_corProps = {},
				_globals = _gsScope._gsDefine.globals,
				Segment = function(a, b, c, d) {
					if (c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
						c = d - (d - b) / 1000000;
					}
					if (a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
						b = a + (c - a) / 1000000;
					}
					this.a = a;
					this.b = b;
					this.c = c;
					this.d = d;
					this.da = d - a;
					this.ca = c - a;
					this.ba = b - a;
				},
				_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
				cubicToQuadratic = function(a, b, c, d) {
					var q1 = {a:a},
						q2 = {},
						q3 = {},
						q4 = {c:d},
						mab = (a + b) / 2,
						mbc = (b + c) / 2,
						mcd = (c + d) / 2,
						mabc = (mab + mbc) / 2,
						mbcd = (mbc + mcd) / 2,
						m8 = (mbcd - mabc) / 8;
					q1.b = mab + (a - mab) / 4;
					q2.b = mabc + m8;
					q1.c = q2.a = (q1.b + q2.b) / 2;
					q2.c = q3.a = (mabc + mbcd) / 2;
					q3.b = mbcd - m8;
					q4.b = mcd + (d - mcd) / 4;
					q3.c = q4.a = (q3.b + q4.b) / 2;
					return [q1, q2, q3, q4];
				},
				_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
					var l = a.length - 1,
						ii = 0,
						cp1 = a[0].a,
						i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
					for (i = 0; i < l; i++) {
						seg = a[ii];
						p1 = seg.a;
						p2 = seg.d;
						p3 = a[ii+1].d;

						if (correlate) {
							r1 = _r1[i];
							r2 = _r2[i];
							tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
							m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
							m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
							mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
						} else {
							m1 = p2 - (p2 - p1) * curviness * 0.5;
							m2 = p2 + (p3 - p2) * curviness * 0.5;
							mm = p2 - (m1 + m2) / 2;
						}
						m1 += mm;
						m2 += mm;

						seg.c = cp2 = m1;
						if (i !== 0) {
							seg.b = cp1;
						} else {
							seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
						}

						seg.da = p2 - p1;
						seg.ca = cp2 - p1;
						seg.ba = cp1 - p1;

						if (quad) {
							qb = cubicToQuadratic(p1, cp1, cp2, p2);
							a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
							ii += 4;
						} else {
							ii++;
						}

						cp1 = m2;
					}
					seg = a[ii];
					seg.b = cp1;
					seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
					seg.da = seg.d - seg.a;
					seg.ca = seg.c - seg.a;
					seg.ba = cp1 - seg.a;
					if (quad) {
						qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
					}
				},
				_parseAnchors = function(values, p, correlate, prepend) {
					var a = [],
						l, i, p1, p2, p3, tmp;
					if (prepend) {
						values = [prepend].concat(values);
						i = values.length;
						while (--i > -1) {
							if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
								values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
							}
						}
					}
					l = values.length - 2;
					if (l < 0) {
						a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
						return a;
					}
					for (i = 0; i < l; i++) {
						p1 = values[i][p];
						p2 = values[i+1][p];
						a[i] = new Segment(p1, 0, 0, p2);
						if (correlate) {
							p3 = values[i+2][p];
							_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
							_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
						}
					}
					a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
					return a;
				},
				bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
					var obj = {},
						props = [],
						first = prepend || values[0],
						i, p, a, j, r, l, seamless, last;
					correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
					if (curviness == null) {
						curviness = 1;
					}
					for (p in values[0]) {
						props.push(p);
					}
					//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
					if (values.length > 1) {
						last = values[values.length - 1];
						seamless = true;
						i = props.length;
						while (--i > -1) {
							p = props[i];
							if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
								seamless = false;
								break;
							}
						}
						if (seamless) {
							values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
							if (prepend) {
								values.unshift(prepend);
							}
							values.push(values[1]);
							prepend = values[values.length - 3];
						}
					}
					_r1.length = _r2.length = _r3.length = 0;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
						obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
					}
					i = _r1.length;
					while (--i > -1) {
						_r1[i] = Math.sqrt(_r1[i]);
						_r2[i] = Math.sqrt(_r2[i]);
					}
					if (!basic) {
						i = props.length;
						while (--i > -1) {
							if (_corProps[p]) {
								a = obj[props[i]];
								l = a.length - 1;
								for (j = 0; j < l; j++) {
									r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
									_r3[j] = (_r3[j] || 0) + r * r;
								}
							}
						}
						i = _r3.length;
						while (--i > -1) {
							_r3[i] = Math.sqrt(_r3[i]);
						}
					}
					i = props.length;
					j = quadratic ? 4 : 1;
					while (--i > -1) {
						p = props[i];
						a = obj[p];
						_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
						if (seamless) {
							a.splice(0, j);
							a.splice(a.length - j, j);
						}
					}
					return obj;
				},
				_parseBezierData = function(values, type, prepend) {
					type = type || "soft";
					var obj = {},
						inc = (type === "cubic") ? 3 : 2,
						soft = (type === "soft"),
						props = [],
						a, b, c, d, cur, i, j, l, p, cnt, tmp;
					if (soft && prepend) {
						values = [prepend].concat(values);
					}
					if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
					for (p in values[0]) {
						props.push(p);
					}
					i = props.length;
					while (--i > -1) {
						p = props[i];
						obj[p] = cur = [];
						cnt = 0;
						l = values.length;
						for (j = 0; j < l; j++) {
							a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
							if (soft) if (j > 1) if (j < l - 1) {
								cur[cnt++] = (a + cur[cnt-2]) / 2;
							}
							cur[cnt++] = a;
						}
						l = cnt - inc + 1;
						cnt = 0;
						for (j = 0; j < l; j += inc) {
							a = cur[j];
							b = cur[j+1];
							c = cur[j+2];
							d = (inc === 2) ? 0 : cur[j+3];
							cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
						}
						cur.length = cnt;
					}
					return obj;
				},
				_addCubicLengths = function(a, steps, resolution) {
					var inc = 1 / resolution,
						j = a.length,
						d, d1, s, da, ca, ba, p, i, inv, bez, index;
					while (--j > -1) {
						bez = a[j];
						s = bez.a;
						da = bez.d - s;
						ca = bez.c - s;
						ba = bez.b - s;
						d = d1 = 0;
						for (i = 1; i <= resolution; i++) {
							p = inc * i;
							inv = 1 - p;
							d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
							index = j * resolution + i - 1;
							steps[index] = (steps[index] || 0) + d * d;
						}
					}
				},
				_parseLengthData = function(obj, resolution) {
					resolution = resolution >> 0 || 6;
					var a = [],
						lengths = [],
						d = 0,
						total = 0,
						threshold = resolution - 1,
						segments = [],
						curLS = [], //current length segments array
						p, i, l, index;
					for (p in obj) {
						_addCubicLengths(obj[p], a, resolution);
					}
					l = a.length;
					for (i = 0; i < l; i++) {
						d += Math.sqrt(a[i]);
						index = i % resolution;
						curLS[index] = d;
						if (index === threshold) {
							total += d;
							index = (i / resolution) >> 0;
							segments[index] = curLS;
							lengths[index] = total;
							d = 0;
							curLS = [];
						}
					}
					return {length:total, lengths:lengths, segments:segments};
				},



				BezierPlugin = _gsScope._gsDefine.plugin({
						propName: "bezier",
						priority: -1,
						version: "1.3.8",
						API: 2,
						global:true,

						//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
						init: function(target, vars, tween) {
							this._target = target;
							if (vars instanceof Array) {
								vars = {values:vars};
							}
							this._func = {};
							this._mod = {};
							this._props = [];
							this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
							var values = vars.values || [],
								first = {},
								second = values[0],
								autoRotate = vars.autoRotate || tween.vars.orientToBezier,
								p, isFunc, i, j, prepend;

							this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
							for (p in second) {
								this._props.push(p);
							}

							i = this._props.length;
							while (--i > -1) {
								p = this._props[i];

								this._overwriteProps.push(p);
								isFunc = this._func[p] = (typeof(target[p]) === "function");
								first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
								if (!prepend) if (first[p] !== values[0][p]) {
									prepend = first;
								}
							}
							this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
							this._segCount = this._beziers[p].length;

							if (this._timeRes) {
								var ld = _parseLengthData(this._beziers, this._timeRes);
								this._length = ld.length;
								this._lengths = ld.lengths;
								this._segments = ld.segments;
								this._l1 = this._li = this._s1 = this._si = 0;
								this._l2 = this._lengths[0];
								this._curSeg = this._segments[0];
								this._s2 = this._curSeg[0];
								this._prec = 1 / this._curSeg.length;
							}

							if ((autoRotate = this._autoRotate)) {
								this._initialRotations = [];
								if (!(autoRotate[0] instanceof Array)) {
									this._autoRotate = autoRotate = [autoRotate];
								}
								i = autoRotate.length;
								while (--i > -1) {
									for (j = 0; j < 3; j++) {
										p = autoRotate[i][j];
										this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
									}
									p = autoRotate[i][2];
									this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
									this._overwriteProps.push(p);
								}
							}
							this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
							return true;
						},

						//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
						set: function(v) {
							var segments = this._segCount,
								func = this._func,
								target = this._target,
								notStart = (v !== this._startRatio),
								curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
							if (!this._timeRes) {
								curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
								t = (v - (curIndex * (1 / segments))) * segments;
							} else {
								lengths = this._lengths;
								curSeg = this._curSeg;
								v *= this._length;
								i = this._li;
								//find the appropriate segment (if the currently cached one isn't correct)
								if (v > this._l2 && i < segments - 1) {
									l = segments - 1;
									while (i < l && (this._l2 = lengths[++i]) <= v) {	}
									this._l1 = lengths[i-1];
									this._li = i;
									this._curSeg = curSeg = this._segments[i];
									this._s2 = curSeg[(this._s1 = this._si = 0)];
								} else if (v < this._l1 && i > 0) {
									while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
									if (i === 0 && v < this._l1) {
										this._l1 = 0;
									} else {
										i++;
									}
									this._l2 = lengths[i];
									this._li = i;
									this._curSeg = curSeg = this._segments[i];
									this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
									this._s2 = curSeg[this._si];
								}
								curIndex = i;
								//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
								v -= this._l1;
								i = this._si;
								if (v > this._s2 && i < curSeg.length - 1) {
									l = curSeg.length - 1;
									while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
									this._s1 = curSeg[i-1];
									this._si = i;
								} else if (v < this._s1 && i > 0) {
									while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
									if (i === 0 && v < this._s1) {
										this._s1 = 0;
									} else {
										i++;
									}
									this._s2 = curSeg[i];
									this._si = i;
								}
								t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
							}
							inv = 1 - t;

							i = this._props.length;
							while (--i > -1) {
								p = this._props[i];
								b = this._beziers[p][curIndex];
								val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
								if (this._mod[p]) {
									val = this._mod[p](val, target);
								}
								if (func[p]) {
									target[p](val);
								} else {
									target[p] = val;
								}
							}

							if (this._autoRotate) {
								var ar = this._autoRotate,
									b2, x1, y1, x2, y2, add, conv;
								i = ar.length;
								while (--i > -1) {
									p = ar[i][2];
									add = ar[i][3] || 0;
									conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
									b = this._beziers[ar[i][0]];
									b2 = this._beziers[ar[i][1]];

									if (b && b2) { //in case one of the properties got overwritten.
										b = b[curIndex];
										b2 = b2[curIndex];

										x1 = b.a + (b.b - b.a) * t;
										x2 = b.b + (b.c - b.b) * t;
										x1 += (x2 - x1) * t;
										x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

										y1 = b2.a + (b2.b - b2.a) * t;
										y2 = b2.b + (b2.c - b2.b) * t;
										y1 += (y2 - y1) * t;
										y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

										val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

										if (this._mod[p]) {
											val = this._mod[p](val, target); //for modProps
										}

										if (func[p]) {
											target[p](val);
										} else {
											target[p] = val;
										}
									}
								}
							}
						}
				}),
				p = BezierPlugin.prototype;


			BezierPlugin.bezierThrough = bezierThrough;
			BezierPlugin.cubicToQuadratic = cubicToQuadratic;
			BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
			BezierPlugin.quadraticToCubic = function(a, b, c) {
				return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
			};

			BezierPlugin._cssRegister = function() {
				var CSSPlugin = _globals.CSSPlugin;
				if (!CSSPlugin) {
					return;
				}
				var _internals = CSSPlugin._internals,
					_parseToProxy = _internals._parseToProxy,
					_setPluginRatio = _internals._setPluginRatio,
					CSSPropTween = _internals.CSSPropTween;
				_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
					if (e instanceof Array) {
						e = {values:e};
					}
					plugin = new BezierPlugin();
					var values = e.values,
						l = values.length - 1,
						pluginValues = [],
						v = {},
						i, p, data;
					if (l < 0) {
						return pt;
					}
					for (i = 0; i <= l; i++) {
						data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
						pluginValues[i] = data.end;
					}
					for (p in e) {
						v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
					}
					v.values = pluginValues;
					pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
					pt.data = data;
					pt.plugin = plugin;
					pt.setRatio = _setPluginRatio;
					if (v.autoRotate === 0) {
						v.autoRotate = true;
					}
					if (v.autoRotate && !(v.autoRotate instanceof Array)) {
						i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
						v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
					}
					if (v.autoRotate) {
						if (!cssp._transform) {
							cssp._enableTransforms(false);
						}
						data.autoRotate = cssp._target._gsTransform;
						data.proxy.rotation = data.autoRotate.rotation || 0;
						cssp._overwriteProps.push("rotation");
					}
					plugin._onInitTween(data.proxy, v, cssp._tween);
					return pt;
				}});
			};

			p._mod = function(lookup) {
				var op = this._overwriteProps,
					i = op.length,
					val;
				while (--i > -1) {
					val = lookup[op[i]];
					if (val && typeof(val) === "function") {
						this._mod[op[i]] = val;
					}
				}
			};

			p._kill = function(lookup) {
				var a = this._props,
					p, i;
				for (p in this._beziers) {
					if (p in lookup) {
						delete this._beziers[p];
						delete this._func[p];
						i = a.length;
						while (--i > -1) {
							if (a[i] === p) {
								a.splice(i, 1);
							}
						}
					}
				}
				a = this._autoRotate;
				if (a) {
					i = a.length;
					while (--i > -1) {
						if (lookup[a[i][2]]) {
							a.splice(i, 1);
						}
					}
				}
				return this._super._kill.call(this, lookup);
			};

		}());






		
		
		
		
		
		
		
		
	/*
	 * ----------------------------------------------------------------
	 * CSSPlugin
	 * ----------------------------------------------------------------
	 */
		_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

			/** @constructor **/
			var CSSPlugin = function() {
					TweenPlugin.call(this, "css");
					this._overwriteProps.length = 0;
					this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
				},
				_globals = _gsScope._gsDefine.globals,
				_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
				_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
				_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
				_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
				_specialProps = {},
				p = CSSPlugin.prototype = new TweenPlugin("css");

			p.constructor = CSSPlugin;
			CSSPlugin.version = "2.1.0";
			CSSPlugin.API = 2;
			CSSPlugin.defaultTransformPerspective = 0;
			CSSPlugin.defaultSkewType = "compensated";
			CSSPlugin.defaultSmoothOrigin = true;
			p = "px"; //we'll reuse the "p" variable to keep file size down
			CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


			var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
				_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
				_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
				_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
				_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
				_opacityExp = /opacity *= *([^)]*)/i,
				_opacityValExp = /opacity:([^;]*)/i,
				_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
				_rgbhslExp = /^(rgb|hsl)/,
				_capsExp = /([A-Z])/g,
				_camelExp = /-([a-z])/gi,
				_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
				_camelFunc = function(s, g) { return g.toUpperCase(); },
				_horizExp = /(?:Left|Right|Width)/i,
				_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
				_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
				_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
				_complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
				_DEG2RAD = Math.PI / 180,
				_RAD2DEG = 180 / Math.PI,
				_forcePT = {},
				_dummyElement = {style:{}},
				_doc = _gsScope.document || {createElement: function() {return _dummyElement;}},
				_createElement = function(type, ns) {
					return (ns && _doc.createElementNS) ? _doc.createElementNS(ns, type) : _doc.createElement(type);
				},
				_tempDiv = _createElement("div"),
				_tempImg = _createElement("img"),
				_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
				_agent = (_gsScope.navigator || {}).userAgent || "",
				_autoRound,
				_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

				_isSafari,
				_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
				_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
				_ieVers,
				_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
					var i = _agent.indexOf("Android"),
						a = _createElement("a");
					_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i+8, 2)) > 3));
					_isSafariLT6 = (_isSafari && (parseFloat(_agent.substr(_agent.indexOf("Version/")+8, 2)) < 6));
					_isFirefox = (_agent.indexOf("Firefox") !== -1);
					if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
						_ieVers = parseFloat( RegExp.$1 );
					}
					if (!a) {
						return false;
					}
					a.style.cssText = "top:1px;opacity:.55;";
					return /^0.55/.test(a.style.opacity);
				}()),
				_getIEOpacity = function(v) {
					return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
				},
				_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
					if (_gsScope.console) {
						console.log(s);
					}
				},
				_target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
				_index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

				_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
				_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

				// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
				_checkPropPrefix = function(p, e) {
					e = e || _tempDiv;
					var s = e.style,
						a, i;
					if (s[p] !== undefined) {
						return p;
					}
					p = p.charAt(0).toUpperCase() + p.substr(1);
					a = ["O","Moz","ms","Ms","Webkit"];
					i = 5;
					while (--i > -1 && s[a[i]+p] === undefined) { }
					if (i >= 0) {
						_prefix = (i === 3) ? "ms" : a[i];
						_prefixCSS = "-" + _prefix.toLowerCase() + "-";
						return _prefix + p;
					}
					return null;
				},

				_computedStyleScope = (typeof(window) !== "undefined" ? window : _doc.defaultView || {getComputedStyle:function() {}}),
				_getComputedStyle = function(e) {
					return _computedStyleScope.getComputedStyle(e); //to avoid errors in Microsoft Edge, we need to call getComputedStyle() from a specific scope, typically window.
				},

				/**
				 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
				 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
				 *
				 * @param {!Object} t Target element whose style property you want to query
				 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
				 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
				 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
				 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
				 * @return {?string} The current property value
				 */
				_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
					var rv;
					if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
						return _getIEOpacity(t);
					}
					if (!calc && t.style[p]) {
						rv = t.style[p];
					} else if ((cs = cs || _getComputedStyle(t))) {
						rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
					} else if (t.currentStyle) {
						rv = t.currentStyle[p];
					}
					return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
				},

				/**
				 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
				 * @param {!Object} t Target element
				 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
				 * @param {!number} v Value
				 * @param {string=} sfx Suffix (like "px" or "%" or "em")
				 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
				 * @return {number} value in pixels
				 */
				_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
					if (sfx === "px" || (!sfx && p !== "lineHeight")) { return v; }
					if (sfx === "auto" || !v) { return 0; }
					var horiz = _horizExp.test(p),
						node = t,
						style = _tempDiv.style,
						neg = (v < 0),
						precise = (v === 1),
						pix, cache, time;
					if (neg) {
						v = -v;
					}
					if (precise) {
						v *= 100;
					}
					if (p === "lineHeight" && !sfx) { //special case of when a simple lineHeight (without a unit) is used. Set it to the value, read back the computed value, and then revert.
						cache = _getComputedStyle(t).lineHeight;
						t.style.lineHeight = v;
						pix = parseFloat(_getComputedStyle(t).lineHeight);
						t.style.lineHeight = cache;
					} else if (sfx === "%" && p.indexOf("border") !== -1) {
						pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
					} else {
						style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
						if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
							node = t.parentNode || _doc.body;
							if (_getStyle(node, "display").indexOf("flex") !== -1) { //Edge and IE11 have a bug that causes offsetWidth to report as 0 if the container has display:flex and the child is position:relative. Switching to position: absolute solves it.
								style.position = "absolute";
							}
							cache = node._gsCache;
							time = TweenLite.ticker.frame;
							if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
								return cache.width * v / 100;
							}
							style[(horiz ? "width" : "height")] = v + sfx;
						} else {
							style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
						}
						node.appendChild(_tempDiv);
						pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
						node.removeChild(_tempDiv);
						if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
							cache = node._gsCache = node._gsCache || {};
							cache.time = time;
							cache.width = pix / v * 100;
						}
						if (pix === 0 && !recurse) {
							pix = _convertToPixels(t, p, v, sfx, true);
						}
					}
					if (precise) {
						pix /= 100;
					}
					return neg ? -pix : pix;
				},
				_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
					if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
					var dim = ((p === "left") ? "Left" : "Top"),
						v = _getStyle(t, "margin" + dim, cs);
					return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
				},

				// @private returns at object containing ALL of the style properties in camelCase and their associated values.
				_getAllStyles = function(t, cs) {
					var s = {},
						i, tr, p;
					if ((cs = cs || _getComputedStyle(t, null))) {
						if ((i = cs.length)) {
							while (--i > -1) {
								p = cs[i];
								if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
									s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
								}
							}
						} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
							for (i in cs) {
								if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
									s[i] = cs[i];
								}
							}
						}
					} else if ((cs = t.currentStyle || t.style)) {
						for (i in cs) {
							if (typeof(i) === "string" && s[i] === undefined) {
								s[i.replace(_camelExp, _camelFunc)] = cs[i];
							}
						}
					}
					if (!_supportsOpacity) {
						s.opacity = _getIEOpacity(t);
					}
					tr = _getTransform(t, cs, false);
					s.rotation = tr.rotation;
					s.skewX = tr.skewX;
					s.scaleX = tr.scaleX;
					s.scaleY = tr.scaleY;
					s.x = tr.x;
					s.y = tr.y;
					if (_supports3D) {
						s.z = tr.z;
						s.rotationX = tr.rotationX;
						s.rotationY = tr.rotationY;
						s.scaleZ = tr.scaleZ;
					}
					if (s.filters) {
						delete s.filters;
					}
					return s;
				},

				// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
				_cssDif = function(t, s1, s2, vars, forceLookup) {
					var difs = {},
						style = t.style,
						val, p, mpt;
					for (p in s2) {
						if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
							difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
							if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
								mpt = new MiniPropTween(style, p, style[p], mpt);
							}
						}
					}
					if (vars) {
						for (p in vars) { //copy properties (except className)
							if (p !== "className") {
								difs[p] = vars[p];
							}
						}
					}
					return {difs:difs, firstMPT:mpt};
				},
				_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
				_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

				/**
				 * @private Gets the width or height of an element
				 * @param {!Object} t Target element
				 * @param {!string} p Property name ("width" or "height")
				 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
				 * @return {number} Dimension (in pixels)
				 */
				_getDimension = function(t, p, cs) {
					if ((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
						return (cs || _getComputedStyle(t))[p] || 0;
					} else if (t.getCTM && _isSVG(t)) {
						return t.getBBox()[p] || 0;
					}
					var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
						a = _dimensions[p],
						i = a.length;
					cs = cs || _getComputedStyle(t, null);
					while (--i > -1) {
						v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
						v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
					}
					return v;
				},

				// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
				_parsePosition = function(v, recObj) {
					if (v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
						return v + " ";
					}
					if (v == null || v === "") {
						v = "0 0";
					}
					var a = v.split(" "),
						x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
						y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
						i;
					if (a.length > 3 && !recObj) { //multiple positions
						a = v.split(", ").join(",").split(",");
						v = [];
						for (i = 0; i < a.length; i++) {
							v.push(_parsePosition(a[i]));
						}
						return v.join(",");
					}
					if (y == null) {
						y = (x === "center") ? "50%" : "0";
					} else if (y === "center") {
						y = "50%";
					}
					if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
						x = "50%";
					}
					v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
					if (recObj) {
						recObj.oxp = (x.indexOf("%") !== -1);
						recObj.oyp = (y.indexOf("%") !== -1);
						recObj.oxr = (x.charAt(1) === "=");
						recObj.oyr = (y.charAt(1) === "=");
						recObj.ox = parseFloat(x.replace(_NaNExp, ""));
						recObj.oy = parseFloat(y.replace(_NaNExp, ""));
						recObj.v = v;
					}
					return recObj || v;
				},

				/**
				 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
				 * @param {(number|string)} e End value which is typically a string, but could be a number
				 * @param {(number|string)} b Beginning value which is typically a string but could be a number
				 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
				 */
				_parseChange = function(e, b) {
					if (typeof(e) === "function") {
						e = e(_index, _target);
					}
					return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
				},

				/**
				 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
				 * @param {Object} v Value to be parsed
				 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
				 * @return {number} Parsed value
				 */
				_parseVal = function(v, d) {
					if (typeof(v) === "function") {
						v = v(_index, _target);
					}
					var isRelative = (typeof(v) === "string" && v.charAt(1) === "=");
					if (typeof(v) === "string" && v.charAt(v.length - 2) === "v") { //convert vw and vh into px-equivalents.
						v = (isRelative ? v.substr(0, 2) : 0) + (window["inner" + ((v.substr(-2) === "vh") ? "Height" : "Width")] * (parseFloat(isRelative ? v.substr(2) : v) / 100));
					}
					return (v == null) ? d : isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
				},

				/**
				 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
				 * @param {Object} v Value to be parsed
				 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
				 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
				 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
				 * @return {number} parsed angle in radians
				 */
				_parseAngle = function(v, d, p, directionalEnd) {
					var min = 0.000001,
						cap, split, dif, result, isRelative;
					if (typeof(v) === "function") {
						v = v(_index, _target);
					}
					if (v == null) {
						result = d;
					} else if (typeof(v) === "number") {
						result = v;
					} else {
						cap = 360;
						split = v.split("_");
						isRelative = (v.charAt(1) === "=");
						dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
						if (split.length) {
							if (directionalEnd) {
								directionalEnd[p] = d + dif;
							}
							if (v.indexOf("short") !== -1) {
								dif = dif % cap;
								if (dif !== dif % (cap / 2)) {
									dif = (dif < 0) ? dif + cap : dif - cap;
								}
							}
							if (v.indexOf("_cw") !== -1 && dif < 0) {
								dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
							} else if (v.indexOf("ccw") !== -1 && dif > 0) {
								dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
							}
						}
						result = d + dif;
					}
					if (result < min && result > -min) {
						result = 0;
					}
					return result;
				},

				_colorLookup = {aqua:[0,255,255],
					lime:[0,255,0],
					silver:[192,192,192],
					black:[0,0,0],
					maroon:[128,0,0],
					teal:[0,128,128],
					blue:[0,0,255],
					navy:[0,0,128],
					white:[255,255,255],
					fuchsia:[255,0,255],
					olive:[128,128,0],
					yellow:[255,255,0],
					orange:[255,165,0],
					gray:[128,128,128],
					purple:[128,0,128],
					green:[0,128,0],
					red:[255,0,0],
					pink:[255,192,203],
					cyan:[0,255,255],
					transparent:[255,255,255,0]},

				_hue = function(h, m1, m2) {
					h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
					return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
				},

				/**
				 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
				 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
				 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
				 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
				 */
				_parseColor = CSSPlugin.parseColor = function(v, toHSL) {
					var a, r, g, b, h, s, l, max, min, d, wasHSL;
					if (!v) {
						a = _colorLookup.black;
					} else if (typeof(v) === "number") {
						a = [v >> 16, (v >> 8) & 255, v & 255];
					} else {
						if (v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
							v = v.substr(0, v.length - 1);
						}
						if (_colorLookup[v]) {
							a = _colorLookup[v];
						} else if (v.charAt(0) === "#") {
							if (v.length === 4) { //for shorthand like #9F0
								r = v.charAt(1);
								g = v.charAt(2);
								b = v.charAt(3);
								v = "#" + r + r + g + g + b + b;
							}
							v = parseInt(v.substr(1), 16);
							a = [v >> 16, (v >> 8) & 255, v & 255];
						} else if (v.substr(0, 3) === "hsl") {
							a = wasHSL = v.match(_numExp);
							if (!toHSL) {
								h = (Number(a[0]) % 360) / 360;
								s = Number(a[1]) / 100;
								l = Number(a[2]) / 100;
								g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
								r = l * 2 - g;
								if (a.length > 3) {
									a[3] = Number(a[3]);
								}
								a[0] = _hue(h + 1 / 3, r, g);
								a[1] = _hue(h, r, g);
								a[2] = _hue(h - 1 / 3, r, g);
							} else if (v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
								return v.match(_relNumExp);
							}
						} else {
							a = v.match(_numExp) || _colorLookup.transparent;
						}
						a[0] = Number(a[0]);
						a[1] = Number(a[1]);
						a[2] = Number(a[2]);
						if (a.length > 3) {
							a[3] = Number(a[3]);
						}
					}
					if (toHSL && !wasHSL) {
						r = a[0] / 255;
						g = a[1] / 255;
						b = a[2] / 255;
						max = Math.max(r, g, b);
						min = Math.min(r, g, b);
						l = (max + min) / 2;
						if (max === min) {
							h = s = 0;
						} else {
							d = max - min;
							s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
							h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
							h *= 60;
						}
						a[0] = (h + 0.5) | 0;
						a[1] = (s * 100 + 0.5) | 0;
						a[2] = (l * 100 + 0.5) | 0;
					}
					return a;
				},
				_formatColors = function(s, toHSL) {
					var colors = s.match(_colorExp) || [],
						charIndex = 0,
						parsed = "",
						i, color, temp;
					if (!colors.length) {
						return s;
					}
					for (i = 0; i < colors.length; i++) {
						color = colors[i];
						temp = s.substr(charIndex, s.indexOf(color, charIndex)-charIndex);
						charIndex += temp.length + color.length;
						color = _parseColor(color, toHSL);
						if (color.length === 3) {
							color.push(1);
						}
						parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
					}
					return parsed + s.substr(charIndex);
				},
				_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

			for (p in _colorLookup) {
				_colorExp += "|" + p + "\\b";
			}
			_colorExp = new RegExp(_colorExp+")", "gi");

			CSSPlugin.colorStringFilter = function(a) {
				var combined = a[0] + " " + a[1],
					toHSL;
				if (_colorExp.test(combined)) {
					toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
					a[0] = _formatColors(a[0], toHSL);
					a[1] = _formatColors(a[1], toHSL);
				}
				_colorExp.lastIndex = 0;
			};

			if (!TweenLite.defaultStringFilter) {
				TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
			}

			/**
			 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
			 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
			 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
			 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
			 * @return {Function} formatter function
			 */
			var _getFormatter = function(dflt, clr, collapsible, multi) {
					if (dflt == null) {
						return function(v) {return v;};
					}
					var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
						dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
						pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
						sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
						delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
						numVals = dVals.length,
						dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
						formatter;
					if (!numVals) {
						return function(v) {return v;};
					}
					if (clr) {
						formatter = function(v) {
							var color, vals, i, a;
							if (typeof(v) === "number") {
								v += dSfx;
							} else if (multi && _commasOutsideParenExp.test(v)) {
								a = v.replace(_commasOutsideParenExp, "|").split("|");
								for (i = 0; i < a.length; i++) {
									a[i] = formatter(a[i]);
								}
								return a.join(",");
							}
							color = (v.match(_colorExp) || [dColor])[0];
							vals = v.split(color).join("").match(_valuesExp) || [];
							i = vals.length;
							if (numVals > i--) {
								while (++i < numVals) {
									vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
								}
							}
							return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
						};
						return formatter;

					}
					formatter = function(v) {
						var vals, a, i;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						vals = v.match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + sfx;
					};
					return formatter;
				},

				/**
				 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
				 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
				 * @return {Function} a formatter function
				 */
				_getEdgeParser = function(props) {
					props = props.split(",");
					return function(t, e, p, cssp, pt, plugin, vars) {
						var a = (e + "").split(" "),
							i;
						vars = {};
						for (i = 0; i < 4; i++) {
							vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
						}
						return cssp.parse(t, vars, pt, plugin);
					};
				},

				// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
				_setPluginRatio = _internals._setPluginRatio = function(v) {
					this.plugin.setRatio(v);
					var d = this.data,
						proxy = d.proxy,
						mpt = d.firstMPT,
						min = 0.000001,
						val, pt, i, str, p;
					while (mpt) {
						val = proxy[mpt.v];
						if (mpt.r) {
							val = mpt.r(val);
						} else if (val < min && val > -min) {
							val = 0;
						}
						mpt.t[mpt.p] = val;
						mpt = mpt._next;
					}
					if (d.autoRotate) {
						d.autoRotate.rotation = d.mod ? d.mod.call(this._tween, proxy.rotation, this.t, this._tween) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
					}
					//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
					if (v === 1 || v === 0) {
						mpt = d.firstMPT;
						p = (v === 1) ? "e" : "b";
						while (mpt) {
							pt = mpt.t;
							if (!pt.type) {
								pt[p] = pt.s + pt.xs0;
							} else if (pt.type === 1) {
								str = pt.xs0 + pt.s + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt[p] = str;
							}
							mpt = mpt._next;
						}
					}
				},

				/**
				 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
				 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
				 * @param {!string} p property name
				 * @param {(number|string|object)} v value
				 * @param {MiniPropTween=} next next MiniPropTween in the linked list
				 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
				 */
				MiniPropTween = function(t, p, v, next, r) {
					this.t = t;
					this.p = p;
					this.v = v;
					this.r = r;
					if (next) {
						next._prev = this;
						this._next = next;
					}
				},

				/**
				 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
				 * This method returns an object that has the following properties:
				 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
				 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
				 *  - firstMPT: the first MiniPropTween in the linked list
				 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
				 * @param {!Object} t target object to be tweened
				 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
				 * @param {!CSSPlugin} cssp The CSSPlugin instance
				 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
				 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
				 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
				 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
				 */
				_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
					var bpt = pt,
						start = {},
						end = {},
						transform = cssp._transform,
						oldForce = _forcePT,
						i, p, xp, mpt, firstPT;
					cssp._transform = null;
					_forcePT = vars;
					pt = firstPT = cssp.parse(t, vars, pt, plugin);
					_forcePT = oldForce;
					//break off from the linked list so the new ones are isolated.
					if (shallow) {
						cssp._transform = transform;
						if (bpt) {
							bpt._prev = null;
							if (bpt._prev) {
								bpt._prev._next = null;
							}
						}
					}
					while (pt && pt !== bpt) {
						if (pt.type <= 1) {
							p = pt.p;
							end[p] = pt.s + pt.c;
							start[p] = pt.s;
							if (!shallow) {
								mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
								pt.c = 0;
							}
							if (pt.type === 1) {
								i = pt.l;
								while (--i > 0) {
									xp = "xn" + i;
									p = pt.p + "_" + xp;
									end[p] = pt.data[xp];
									start[p] = pt[xp];
									if (!shallow) {
										mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
									}
								}
							}
						}
						pt = pt._next;
					}
					return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
				},



				/**
				 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
				 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
				 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
				 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
				 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
				 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
				 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
				 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
				 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
				 * @param {number} s Starting numeric value
				 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
				 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
				 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
				 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
				 * @param {boolean=} r If true, the value(s) should be rounded
				 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
				 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
				 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
				 */
				CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
					this.t = t; //target
					this.p = p; //property
					this.s = s; //starting value
					this.c = c; //change value
					this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
					if (!(t instanceof CSSPropTween)) {
						_overwriteProps.push(this.n);
					}
					this.r = !r ? r : (typeof(r) === "function") ? r : Math.round; //round (boolean)
					this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
					if (pr) {
						this.pr = pr;
						_hasPriority = true;
					}
					this.b = (b === undefined) ? s : b;
					this.e = (e === undefined) ? s + c : e;
					if (next) {
						this._next = next;
						next._prev = this;
					}
				},

				_addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
					var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
					pt.b = start;
					pt.e = pt.xs0 = end;
					return pt;
				},

				/**
				 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
				 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
				 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
				 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
				 *
				 * @param {!Object} t Target whose property will be tweened
				 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
				 * @param {string} b Beginning value
				 * @param {string} e Ending value
				 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
				 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
				 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
				 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
				 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
				 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
				 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
				 */
				_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
					//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
					b = b || dflt || "";
					if (typeof(e) === "function") {
						e = e(_index, _target);
					}
					pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
					e += ""; //ensures it's a string
					if (clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
						e = [b, e];
						CSSPlugin.colorStringFilter(e);
						b = e[0];
						e = e[1];
					}
					var ba = b.split(", ").join(",").split(" "), //beginning array
						ea = e.split(", ").join(",").split(" "), //ending array
						l = ba.length,
						autoRound = (_autoRound !== false),
						i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
					if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
						if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) { //keep rgb(), rgba(), hsl(), and hsla() values together! (remember, we're splitting on spaces)
							ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
							ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
						} else {
							ba = ba.join(" ").split(",").join(", ").split(" ");
							ea = ea.join(" ").split(",").join(", ").split(" ");
						}
						l = ba.length;
					}
					if (l !== ea.length) {
						//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
						ba = (dflt || "").split(" ");
						l = ba.length;
					}
					pt.plugin = plugin;
					pt.setRatio = setRatio;
					_colorExp.lastIndex = 0;
					for (i = 0; i < l; i++) {
						bv = ba[i];
						ev = ea[i] + "";
						bn = parseFloat(bv);
						//if the value begins with a number (most common). It's fine if it has a suffix like px
						if (bn || bn === 0) {
							pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1) ? Math.round : false, true);

						//if the value is a color
						} else if (clrs && _colorExp.test(bv)) {
							str = ev.indexOf(")") + 1;
							str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
							useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
							temp = ev; //original string value so we can look for any prefix later.
							bv = _parseColor(bv, useHSL);
							ev = _parseColor(ev, useHSL);
							hasAlpha = (bv.length + ev.length > 6);
							if (hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
								pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
								pt.e = pt.e.split(ea[i]).join("transparent");
							} else {
								if (!_supportsOpacity) { //old versions of IE don't support rgba().
									hasAlpha = false;
								}
								if (useHSL) {
									pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
										.appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
										.appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
								} else {
									pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", Math.round, true)
										.appendXtra("", bv[1], ev[1] - bv[1], ",", Math.round)
										.appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), Math.round);
								}

								if (hasAlpha) {
									bv = (bv.length < 4) ? 1 : bv[3];
									pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
								}
							}
							_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

						} else {
							bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

							//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
							if (!bnums) {
								pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

							//loop through all the numbers that are found and construct the extra values on the pt.
							} else {
								enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
								if (!enums || enums.length !== bnums.length) {
									//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
									return pt;
								}
								ni = 0;
								for (xi = 0; xi < bnums.length; xi++) {
									cv = bnums[xi];
									temp = bv.indexOf(cv, ni);
									pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px") ? Math.round : false, (xi === 0));
									ni = temp + cv.length;
								}
								pt["xs" + pt.l] += bv.substr(ni);
							}
						}
					}
					//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
					if (e.indexOf("=") !== -1) if (pt.data) {
						str = pt.xs0 + pt.data.s;
						for (i = 1; i < pt.l; i++) {
							str += pt["xs" + i] + pt.data["xn" + i];
						}
						pt.e = str + pt["xs" + i];
					}
					if (!pt.l) {
						pt.type = -1;
						pt.xs0 = pt.e;
					}
					return pt.xfirst || pt;
				},
				i = 9;


			p = CSSPropTween.prototype;
			p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
			while (--i > 0) {
				p["xn" + i] = 0;
				p["xs" + i] = "";
			}
			p.xs0 = "";
			p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


			/**
			 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
			 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
			 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
			 * @param {string=} pfx Prefix (if any)
			 * @param {!number} s Starting value
			 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
			 * @param {string=} sfx Suffix (if any)
			 * @param {boolean=} r Round (if true).
			 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
			 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
			 */
			p.appendXtra = function(pfx, s, c, sfx, r, pad) {
				var pt = this,
					l = pt.l;
				pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
				if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
					pt["xs" + l] += s + (sfx || "");
					return pt;
				}
				pt.l++;
				pt.type = pt.setRatio ? 2 : 1;
				pt["xs" + pt.l] = sfx || "";
				if (l > 0) {
					pt.data["xn" + l] = s + c;
					pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
					pt["xn" + l] = s;
					if (!pt.plugin) {
						pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
						pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
					}
					return pt;
				}
				pt.data = {s:s + c};
				pt.rxp = {};
				pt.s = s;
				pt.c = c;
				pt.r = r;
				return pt;
			};

			/**
			 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
			 * @param {!string} p Property name (like "boxShadow" or "throwProps")
			 * @param {Object=} options An object containing any of the following configuration options:
			 *                      - defaultValue: the default value
			 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
			 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
			 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
			 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
			 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
			 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
			 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
			 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
			 */
			var SpecialProp = function(p, options) {
					options = options || {};
					this.p = options.prefix ? _checkPropPrefix(p) || p : p;
					_specialProps[p] = _specialProps[this.p] = this;
					this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
					if (options.parser) {
						this.parse = options.parser;
					}
					this.clrs = options.color;
					this.multi = options.multi;
					this.keyword = options.keyword;
					this.dflt = options.defaultValue;
					this.allowFunc = options.allowFunc;
					this.pr = options.priority || 0;
				},

				//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
				_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
					if (typeof(options) !== "object") {
						options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
					}
					var a = p.split(","),
						d = options.defaultValue,
						i, temp;
					defaults = defaults || [d];
					for (i = 0; i < a.length; i++) {
						options.prefix = (i === 0 && options.prefix);
						options.defaultValue = defaults[i] || d;
						temp = new SpecialProp(a[i], options);
					}
				},

				//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
				_registerPluginProp = _internals._registerPluginProp = function(p) {
					if (!_specialProps[p]) {
						var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
						_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
							var pluginClass = _globals.com.greensock.plugins[pluginName];
							if (!pluginClass) {
								_log("Error: " + pluginName + " js file not loaded.");
								return pt;
							}
							pluginClass._cssRegister();
							return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
						}});
					}
				};


			p = SpecialProp.prototype;

			/**
			 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
			 * @param {!Object} t target element
			 * @param {(string|number|object)} b beginning value
			 * @param {(string|number|object)} e ending (destination) value
			 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
			 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
			 * @return {CSSPropTween=} First CSSPropTween in the linked list
			 */
			p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
				var kwd = this.keyword,
					i, ba, ea, l, bi, ei;
				//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
				if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
					ba = b.replace(_commasOutsideParenExp, "|").split("|");
					ea = e.replace(_commasOutsideParenExp, "|").split("|");
				} else if (kwd) {
					ba = [b];
					ea = [e];
				}
				if (ea) {
					l = (ea.length > ba.length) ? ea.length : ba.length;
					for (i = 0; i < l; i++) {
						b = ba[i] = ba[i] || this.dflt;
						e = ea[i] = ea[i] || this.dflt;
						if (kwd) {
							bi = b.indexOf(kwd);
							ei = e.indexOf(kwd);
							if (bi !== ei) {
								if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
									ba[i] = ba[i].split(kwd).join("");
								} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
									ba[i] += " " + kwd;
								}
							}
						}
					}
					b = ba.join(", ");
					e = ea.join(", ");
				}
				return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
			};

			/**
			 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
			 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
			 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
			 * @param {!Object} t Target object whose property is being tweened
			 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
			 * @param {!string} p Property name
			 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
			 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
			 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
			 * @param {Object=} vars Original vars object that contains the data for parsing.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
			 */
			p.parse = function(t, e, p, cssp, pt, plugin, vars) {
				return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
			};

			/**
			 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
			 *  1) Target object whose property should be tweened (typically a DOM element)
			 *  2) The end/destination value (could be a string, number, object, or whatever you want)
			 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
			 *
			 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
			 *
			 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
			 *      var start = target.style.width;
			 *      return function(ratio) {
			 *              target.style.width = (start + value * ratio) + "px";
			 *              console.log("set width to " + target.style.width);
			 *          }
			 * }, 0);
			 *
			 * Then, when I do this tween, it will trigger my special property:
			 *
			 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
			 *
			 * In the example, of course, we're just changing the width, but you can do anything you want.
			 *
			 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
			 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
			 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
			 */
			CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
				_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
					var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
					rv.plugin = plugin;
					rv.setRatio = onInitTween(t, e, cssp._tween, p);
					return rv;
				}, priority:priority});
			};






			//transform-related methods and properties
			CSSPlugin.useSVGTransformAttr = true; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
			var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
				_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
				_transformPropCSS = _prefixCSS + "transform",
				_transformOriginProp = _checkPropPrefix("transformOrigin"),
				_supports3D = (_checkPropPrefix("perspective") !== null),
				Transform = _internals.Transform = function() {
					this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
					this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
				},
				_SVGElement = _gsScope.SVGElement,
				_useSVGTransformAttr,
				//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

				_createSVG = function(type, container, attributes) {
					var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
						reg = /([a-z])([A-Z])/g,
						p;
					for (p in attributes) {
						element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
					}
					container.appendChild(element);
					return element;
				},
				_docElement = _doc.documentElement || {},
				_forceSVGTransformAttr = (function() {
					//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
					var force = _ieVers || (/Android/i.test(_agent) && !_gsScope.chrome),
						svg, rect, width;
					if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
						svg = _createSVG("svg", _docElement);
						rect = _createSVG("rect", svg, {width:100, height:50, x:100});
						width = rect.getBoundingClientRect().width;
						rect.style[_transformOriginProp] = "50% 50%";
						rect.style[_transformProp] = "scaleX(0.5)";
						force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
						_docElement.removeChild(svg);
					}
					return force;
				})(),
				_parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
					var tm = e._gsTransform,
						m = _getMatrix(e, true),
						v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
					if (tm) {
						xOriginOld = tm.xOrigin; //record the original values before we alter them.
						yOriginOld = tm.yOrigin;
					}
					if (!absolute || (v = absolute.split(" ")).length < 2) {
						b = e.getBBox();
						if (b.x === 0 && b.y === 0 && b.width + b.height === 0) { //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
							b = {x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width:0, height:0};
						}
						local = _parsePosition(local).split(" ");
						v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
							 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
					}
					decoratee.xOrigin = xOrigin = parseFloat(v[0]);
					decoratee.yOrigin = yOrigin = parseFloat(v[1]);
					if (absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
						a = m[0];
						b = m[1];
						c = m[2];
						d = m[3];
						tx = m[4];
						ty = m[5];
						determinant = (a * d - b * c);
						if (determinant) { //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
							x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
							y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
							xOrigin = decoratee.xOrigin = v[0] = x;
							yOrigin = decoratee.yOrigin = v[1] = y;
						}
					}
					if (tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
						if (skipRecord) {
							decoratee.xOffset = tm.xOffset;
							decoratee.yOffset = tm.yOffset;
							tm = decoratee;
						}
						if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
							x = xOrigin - xOriginOld;
							y = yOrigin - yOriginOld;
							//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
							//tm.x -= x - (x * m[0] + y * m[2]);
							//tm.y -= y - (x * m[1] + y * m[3]);
							tm.xOffset += (x * m[0] + y * m[2]) - x;
							tm.yOffset += (x * m[1] + y * m[3]) - y;
						} else {
							tm.xOffset = tm.yOffset = 0;
						}
					}
					if (!skipRecord) {
						e.setAttribute("data-svg-origin", v.join(" "));
					}
				},
				_getBBoxHack = function(swapIfPossible) { //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
					var svg = _createElement("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
						oldParent = this.parentNode,
						oldSibling = this.nextSibling,
						oldCSS = this.style.cssText,
						bbox;
					_docElement.appendChild(svg);
					svg.appendChild(this);
					this.style.display = "block";
					if (swapIfPossible) {
						try {
							bbox = this.getBBox();
							this._originalGetBBox = this.getBBox;
							this.getBBox = _getBBoxHack;
						} catch (e) { }
					} else if (this._originalGetBBox) {
						bbox = this._originalGetBBox();
					}
					if (oldSibling) {
						oldParent.insertBefore(this, oldSibling);
					} else {
						oldParent.appendChild(this);
					}
					_docElement.removeChild(svg);
					this.style.cssText = oldCSS;
					return bbox;
				},
				_getBBox = function(e) {
					try {
						return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
					} catch (error) {
						return _getBBoxHack.call(e, true);
					}
				},
				_isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
					return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
				},
				_identity2DMatrix = [1,0,0,1,0,0],
				_getMatrix = function(e, force2D) {
					var tm = e._gsTransform || new Transform(),
						rnd = 100000,
						style = e.style,
						isDefault, s, m, n, dec, nextSibling, parent;
					if (_transformProp) {
						s = _getStyle(e, _transformPropCSS, null, true);
					} else if (e.currentStyle) {
						//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
						s = e.currentStyle.filter.match(_ieGetMatrixExp);
						s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
					}
					isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
					if (_transformProp && isDefault && !e.offsetParent) { //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
						//browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
						n = style.display;
						style.display = "block";
						parent = e.parentNode;
						if (!parent || !e.offsetParent) {
							dec = 1; //flag
							nextSibling = e.nextSibling;
							_docElement.appendChild(e); //we must add it to the DOM in order to get values properly
						}
						s = _getStyle(e, _transformPropCSS, null, true);
						isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
						if (n) {
							style.display = n;
						} else {
							_removeProp(style, "display");
						}
						if (dec) {
							if (nextSibling) {
								parent.insertBefore(e, nextSibling);
							} else if (parent) {
								parent.appendChild(e);
							} else {
								_docElement.removeChild(e);
							}
						}
					}
					if (tm.svg || (e.getCTM && _isSVG(e))) {
						if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
							s = style[_transformProp];
							isDefault = 0;
						}
						m = e.getAttribute("transform");
						if (isDefault && m) {
							m = e.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
							s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
							isDefault = 0;
						}
					}
					if (isDefault) {
						return _identity2DMatrix;
					}
					//split the matrix values out into an array (m for matrix)
					m = (s || "").match(_numExp) || [];
					i = m.length;
					while (--i > -1) {
						n = Number(m[i]);
						m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
					}
					return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
				},

				/**
				 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
				 * @param {!Object} t target element
				 * @param {Object=} cs computed style object (optional)
				 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
				 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
				 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
				 */
				_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
					if (t._gsTransform && rec && !parse) {
						return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
					}
					var tm = rec ? t._gsTransform || new Transform() : new Transform(),
						invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
						min = 0.00002,
						rnd = 100000,
						zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
						defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
						m, i, scaleX, scaleY, rotation, skewX;

					tm.svg = !!(t.getCTM && _isSVG(t));
					if (tm.svg) {
						_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
						_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
					}
					m = _getMatrix(t);
					if (m !== _identity2DMatrix) {

						if (m.length === 16) {
							//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
							var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
								a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
								a13 = m[8], a23 = m[9], a33 = m[10],
								a14 = m[12], a24 = m[13], a34 = m[14],
								a43 = m[11],
								angle = Math.atan2(a32, a33),
								t1, t2, t3, t4, cos, sin;
							//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
							if (tm.zOrigin) {
								a34 = -tm.zOrigin;
								a14 = a13*a34-m[12];
								a24 = a23*a34-m[13];
								a34 = a33*a34+tm.zOrigin-m[14];
							}
							//note for possible future consolidation: rotationX: Math.atan2(a32, a33), rotationY: Math.atan2(-a31, Math.sqrt(a33 * a33 + a32 * a32)), rotation: Math.atan2(a21, a11), skew: Math.atan2(a12, a22). However, it doesn't seem to be quite as reliable as the full-on backwards rotation procedure.
							tm.rotationX = angle * _RAD2DEG;
							//rotationX
							if (angle) {
								cos = Math.cos(-angle);
								sin = Math.sin(-angle);
								t1 = a12*cos+a13*sin;
								t2 = a22*cos+a23*sin;
								t3 = a32*cos+a33*sin;
								a13 = a12*-sin+a13*cos;
								a23 = a22*-sin+a23*cos;
								a33 = a32*-sin+a33*cos;
								a43 = a42*-sin+a43*cos;
								a12 = t1;
								a22 = t2;
								a32 = t3;
							}
							//rotationY
							angle = Math.atan2(-a31, a33);
							tm.rotationY = angle * _RAD2DEG;
							if (angle) {
								cos = Math.cos(-angle);
								sin = Math.sin(-angle);
								t1 = a11*cos-a13*sin;
								t2 = a21*cos-a23*sin;
								t3 = a31*cos-a33*sin;
								a23 = a21*sin+a23*cos;
								a33 = a31*sin+a33*cos;
								a43 = a41*sin+a43*cos;
								a11 = t1;
								a21 = t2;
								a31 = t3;
							}
							//rotationZ
							angle = Math.atan2(a21, a11);
							tm.rotation = angle * _RAD2DEG;
							if (angle) {
								cos = Math.cos(angle);
								sin = Math.sin(angle);
								t1 = a11*cos+a21*sin;
								t2 = a12*cos+a22*sin;
								t3 = a13*cos+a23*sin;
								a21 = a21*cos-a11*sin;
								a22 = a22*cos-a12*sin;
								a23 = a23*cos-a13*sin;
								a11 = t1;
								a12 = t2;
								a13 = t3;
							}

							if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
								tm.rotationX = tm.rotation = 0;
								tm.rotationY = 180 - tm.rotationY;
							}

							//skewX
							angle = Math.atan2(a12, a22);

							//scales
							tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5) | 0) / rnd;
							tm.scaleY = ((Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5) | 0) / rnd;
							tm.scaleZ = ((Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5) | 0) / rnd;
							a11 /= tm.scaleX;
							a12 /= tm.scaleY;
							a21 /= tm.scaleX;
							a22 /= tm.scaleY;
							if (Math.abs(angle) > min) {
								tm.skewX = angle * _RAD2DEG;
								a12 = 0; //unskews
								if (tm.skewType !== "simple") {
									tm.scaleY *= 1 / Math.cos(angle); //by default, we compensate the scale based on the skew so that the element maintains a similar proportion when skewed, so we have to alter the scaleY here accordingly to match the default (non-adjusted) skewing that CSS does (stretching more and more as it skews).
								}

							} else {
								tm.skewX = 0;
							}

							/* //for testing purposes
							var transform = "matrix3d(",
								comma = ",",
								zero = "0";
							a13 /= tm.scaleZ;
							a23 /= tm.scaleZ;
							a31 /= tm.scaleX;
							a32 /= tm.scaleY;
							a33 /= tm.scaleZ;
							transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
							transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
							transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
							transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
							transform += a14 + comma + a24 + comma + a34 + comma + (tm.perspective ? (1 + (-a34 / tm.perspective)) : 1) + ")";
							console.log(transform);
							document.querySelector(".test").style[_transformProp] = transform;
							*/

							tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
							tm.x = a14;
							tm.y = a24;
							tm.z = a34;
							if (tm.svg) {
								tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
								tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
							}

						} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
							var k = (m.length >= 6),
								a = k ? m[0] : 1,
								b = m[1] || 0,
								c = m[2] || 0,
								d = k ? m[3] : 1;
							tm.x = m[4] || 0;
							tm.y = m[5] || 0;
							scaleX = Math.sqrt(a * a + b * b);
							scaleY = Math.sqrt(d * d + c * c);
							rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
							skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
							tm.scaleX = scaleX;
							tm.scaleY = scaleY;
							tm.rotation = rotation;
							tm.skewX = skewX;
							if (_supports3D) {
								tm.rotationX = tm.rotationY = tm.z = 0;
								tm.perspective = defaultTransformPerspective;
								tm.scaleZ = 1;
							}
							if (tm.svg) {
								tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
								tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
							}
						}
						if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
							if (invX) {
								tm.scaleX *= -1;
								tm.skewX += (tm.rotation <= 0) ? 180 : -180;
								tm.rotation += (tm.rotation <= 0) ? 180 : -180;
							} else {
								tm.scaleY *= -1;
								tm.skewX += (tm.skewX <= 0) ? 180 : -180;
							}
						}
						tm.zOrigin = zOrigin;
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
						for (i in tm) {
							if (tm[i] < min) if (tm[i] > -min) {
								tm[i] = 0;
							}
						}
					}
					//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
					if (rec) {
						t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
						if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
							if (_useSVGTransformAttr && t.style[_transformProp]) {
								TweenLite.delayedCall(0.001, function(){ //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
									_removeProp(t.style, _transformProp);
								});
							} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
								TweenLite.delayedCall(0.001, function(){
									t.removeAttribute("transform");
								});
							}
						}
					}
					return tm;
				},

				//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
				_setIETransformRatio = function(v) {
					var t = this.data, //refers to the element's _gsTransform object
						ang = -t.rotation * _DEG2RAD,
						skew = ang + t.skewX * _DEG2RAD,
						rnd = 100000,
						a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
						b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
						c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
						d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
						style = this.t.style,
						cs = this.t.currentStyle,
						filters, val;
					if (!cs) {
						return;
					}
					val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
					b = -c;
					c = -val;
					filters = cs.filter;
					style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
					var w = this.t.offsetWidth,
						h = this.t.offsetHeight,
						clip = (cs.position !== "absolute"),
						m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
						ox = t.x + (w * t.xPercent / 100),
						oy = t.y + (h * t.yPercent / 100),
						dx, dy;

					//if transformOrigin is being used, adjust the offset x and y
					if (t.ox != null) {
						dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
						dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
						ox += dx - (dx * a + dy * b);
						oy += dy - (dx * c + dy * d);
					}

					if (!clip) {
						m += ", sizingMethod='auto expand')";
					} else {
						dx = (w / 2);
						dy = (h / 2);
						//translate to ensure that transformations occur around the correct origin (default is center).
						m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
					}
					if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
						style.filter = filters.replace(_ieSetMatrixExp, m);
					} else {
						style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
					}

					//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
					if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
						style.removeAttribute("filter");
					}

					//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
					if (!clip) {
						var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
							marg, prop, dif;
						dx = t.ieOffsetX || 0;
						dy = t.ieOffsetY || 0;
						t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
						t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
						for (i = 0; i < 4; i++) {
							prop = _margins[i];
							marg = cs[prop];
							//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
							val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
							if (val !== t[prop]) {
								dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
							} else {
								dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
							}
							style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
						}
					}
				},

				/* translates a super small decimal to a string WITHOUT scientific notation
				_safeDecimal = function(n) {
					var s = (n < 0 ? -n : n) + "",
						a = s.split("e-");
					return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
				},
				*/

				_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
					var t = this.data, //refers to the element's _gsTransform object
						style = this.t.style,
						angle = t.rotation,
						rotationX = t.rotationX,
						rotationY = t.rotationY,
						sx = t.scaleX,
						sy = t.scaleY,
						sz = t.scaleZ,
						x = t.x,
						y = t.y,
						z = t.z,
						isSVG = t.svg,
						perspective = t.perspective,
						force3D = t.force3D,
						skewY = t.skewY,
						skewX = t.skewX,
						t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
						zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
					if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
						skewX += skewY;
						angle += skewY;
					}

					//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
					if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

						//2D
						if (angle || skewX || isSVG) {
							angle *= _DEG2RAD;
							skew = skewX * _DEG2RAD;
							rnd = 100000;
							a11 = Math.cos(angle) * sx;
							a21 = Math.sin(angle) * sx;
							a12 = Math.sin(angle - skew) * -sy;
							a22 = Math.cos(angle - skew) * sy;
							if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
								t1 = Math.tan(skew - skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a12 *= t1;
								a22 *= t1;
								if (skewY) {
									t1 = Math.tan(skewY * _DEG2RAD);
									t1 = Math.sqrt(1 + t1 * t1);
									a11 *= t1;
									a21 *= t1;
								}
							}
							if (isSVG) {
								x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
								y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
								if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
									min = this.t.getBBox();
									x += t.xPercent * 0.01 * min.width;
									y += t.yPercent * 0.01 * min.height;
								}
								min = 0.000001;
								if (x < min) if (x > -min) {
									x = 0;
								}
								if (y < min) if (y > -min) {
									y = 0;
								}
							}
							transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
							if (isSVG && _useSVGTransformAttr) {
								this.t.setAttribute("transform", "matrix(" + transform);
							} else {
								//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
								style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
							}
						} else {
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
						}
						return;

					}
					if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
						min = 0.0001;
						if (sx < min && sx > -min) {
							sx = sz = 0.00002;
						}
						if (sy < min && sy > -min) {
							sy = sz = 0.00002;
						}
						if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
							perspective = 0;
						}
					}
					if (angle || skewX) {
						angle *= _DEG2RAD;
						cos = a11 = Math.cos(angle);
						sin = a21 = Math.sin(angle);
						if (skewX) {
							angle -= skewX * _DEG2RAD;
							cos = Math.cos(angle);
							sin = Math.sin(angle);
							if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
								t1 = Math.tan((skewX - skewY) * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								cos *= t1;
								sin *= t1;
								if (t.skewY) {
									t1 = Math.tan(skewY * _DEG2RAD);
									t1 = Math.sqrt(1 + t1 * t1);
									a11 *= t1;
									a21 *= t1;
								}
							}
						}
						a12 = -sin;
						a22 = cos;

					} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
						return;
					} else {
						a11 = a22 = 1;
						a12 = a21 = 0;
					}
					// KEY  INDEX   AFFECTS a[row][column]
					// a11  0       rotation, rotationY, scaleX
					// a21  1       rotation, rotationY, scaleX
					// a31  2       rotationY, scaleX
					// a41  3       rotationY, scaleX
					// a12  4       rotation, skewX, rotationX, scaleY
					// a22  5       rotation, skewX, rotationX, scaleY
					// a32  6       rotationX, scaleY
					// a42  7       rotationX, scaleY
					// a13  8       rotationY, rotationX, scaleZ
					// a23  9       rotationY, rotationX, scaleZ
					// a33  10      rotationY, rotationX, scaleZ
					// a43  11      rotationY, rotationX, perspective, scaleZ
					// a14  12      x, zOrigin, svgOrigin
					// a24  13      y, zOrigin, svgOrigin
					// a34  14      z, zOrigin
					// a44  15
					// rotation: Math.atan2(a21, a11)
					// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
					// rotationX: Math.atan2(a32, a33)
					a33 = 1;
					a13 = a23 = a31 = a32 = a41 = a42 = 0;
					a43 = (perspective) ? -1 / perspective : 0;
					zOrigin = t.zOrigin;
					min = 0.000001; //threshold below which browsers use scientific notation which won't work.
					comma = ",";
					zero = "0";
					angle = rotationY * _DEG2RAD;
					if (angle) {
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						a31 = -sin;
						a41 = a43*-sin;
						a13 = a11*sin;
						a23 = a21*sin;
						a33 = cos;
						a43 *= cos;
						a11 *= cos;
						a21 *= cos;
					}
					angle = rotationX * _DEG2RAD;
					if (angle) {
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						t1 = a12*cos+a13*sin;
						t2 = a22*cos+a23*sin;
						a32 = a33*sin;
						a42 = a43*sin;
						a13 = a12*-sin+a13*cos;
						a23 = a22*-sin+a23*cos;
						a33 = a33*cos;
						a43 = a43*cos;
						a12 = t1;
						a22 = t2;
					}
					if (sz !== 1) {
						a13*=sz;
						a23*=sz;
						a33*=sz;
						a43*=sz;
					}
					if (sy !== 1) {
						a12*=sy;
						a22*=sy;
						a32*=sy;
						a42*=sy;
					}
					if (sx !== 1) {
						a11*=sx;
						a21*=sx;
						a31*=sx;
						a41*=sx;
					}

					if (zOrigin || isSVG) {
						if (zOrigin) {
							x += a13*-zOrigin;
							y += a23*-zOrigin;
							z += a33*-zOrigin+zOrigin;
						}
						if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
						}
						if (x < min && x > -min) {
							x = zero;
						}
						if (y < min && y > -min) {
							y = zero;
						}
						if (z < min && z > -min) {
							z = 0; //don't use string because we calculate perspective later and need the number.
						}
					}

					//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
					transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
					transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
					transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
					if (rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
						transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
						transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
					} else {
						transform += ",0,0,0,0,1,0,";
					}
					transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

					style[_transformProp] = transform;
				};

			p = Transform.prototype;
			p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
			p.scaleX = p.scaleY = p.scaleZ = 1;

			_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {parser:function(t, e, parsingProp, cssp, pt, plugin, vars) {
				if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
				cssp._lastParsedTransform = vars;
				var scaleFunc = (vars.scale && typeof(vars.scale) === "function") ? vars.scale : 0; //if there's a function-based "scale" value, swap in the resulting numeric value temporarily. Otherwise, if it's called for both scaleX and scaleY independently, they may not match (like if the function uses Math.random()).
				if (scaleFunc) {
					vars.scale = scaleFunc(_index, t);
				}
				var originalGSTransform = t._gsTransform,
					style = t.style,
					min = 0.000001,
					i = _transformProps.length,
					v = vars,
					endRotations = {},
					transformOriginString = "transformOrigin",
					m1 = _getTransform(t, _cs, true, v.parseTransform),
					orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
					m2, copy, has3D, hasChange, dr, x, y, matrix, p;
				m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
				cssp._transform = m1;
				if ("rotationZ" in v) {
					v.rotation = v.rotationZ;
				}
				if (orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
					copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
					copy[_transformProp] = orig;
					copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
					copy.position = "absolute";
					if (orig.indexOf("%") !== -1) { //%-based translations will fail unless we set the width/height to match the original target...
						copy.width = _getStyle(t, "width");
						copy.height = _getStyle(t, "height");
					}
					_doc.body.appendChild(_tempDiv);
					m2 = _getTransform(_tempDiv, null, false);
					if (m1.skewType === "simple") { //the default _getTransform() reports the skewX/scaleY as if skewType is "compensated", thus we need to adjust that here if skewType is "simple".
						m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
					}
					if (m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
						x = m1.xOrigin;
						y = m1.yOrigin;
						m2.x -= m1.xOffset;
						m2.y -= m1.yOffset;
						if (v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
							orig = {};
							_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
							x = orig.xOrigin;
							y = orig.yOrigin;
							m2.x -= orig.xOffset - m1.xOffset;
							m2.y -= orig.yOffset - m1.yOffset;
						}
						if (x || y) {
							matrix = _getMatrix(_tempDiv, true);
							m2.x -= x - (x * matrix[0] + y * matrix[2]);
							m2.y -= y - (x * matrix[1] + y * matrix[3]);
						}
					}
					_doc.body.removeChild(_tempDiv);
					if (!m2.perspective) {
						m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
					}
					if (v.xPercent != null) {
						m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
					}
					if (v.yPercent != null) {
						m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
					}
				} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
					m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
						scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
						scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
						x:_parseVal(v.x, m1.x),
						y:_parseVal(v.y, m1.y),
						z:_parseVal(v.z, m1.z),
						xPercent:_parseVal(v.xPercent, m1.xPercent),
						yPercent:_parseVal(v.yPercent, m1.yPercent),
						perspective:_parseVal(v.transformPerspective, m1.perspective)};
					dr = v.directionalRotation;
					if (dr != null) {
						if (typeof(dr) === "object") {
							for (copy in dr) {
								v[copy] = dr[copy];
							}
						} else {
							v.rotation = dr;
						}
					}
					if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
						m2.x = 0;
						m2.xPercent = _parseVal(v.x, m1.xPercent);
					}
					if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
						m2.y = 0;
						m2.yPercent = _parseVal(v.y, m1.yPercent);
					}

					m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : m1.rotation, m1.rotation, "rotation", endRotations);
					if (_supports3D) {
						m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
						m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
					}
					m2.skewX = _parseAngle(v.skewX, m1.skewX);
					m2.skewY = _parseAngle(v.skewY, m1.skewY);
				}
				if (_supports3D && v.force3D != null) {
					m1.force3D = v.force3D;
					hasChange = true;
				}

				has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
				if (!has3D && v.scale != null) {
					m2.scaleZ = 1; //no need to tween scaleZ.
				}

				while (--i > -1) {
					p = _transformProps[i];
					orig = m2[p] - m1[p];
					if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
						hasChange = true;
						pt = new CSSPropTween(m1, p, m1[p], orig, pt);
						if (p in endRotations) {
							pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
						}
						pt.xs0 = 0; //ensures the value stays numeric in setRatio()
						pt.plugin = plugin;
						cssp._overwriteProps.push(pt.n);
					}
				}

				orig = (typeof(v.transformOrigin) === "function") ? v.transformOrigin(_index, _target) : v.transformOrigin;
				if (m1.svg && (orig || v.svgOrigin)) {
					x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
					y = m1.yOffset;
					_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
					pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
					pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
					if (x !== m1.xOffset || y !== m1.yOffset) {
						pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
						pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
					}
					orig = "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
				}
				if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
					if (_transformProp) {
						hasChange = true;
						p = _transformOriginProp;
						if (!orig) {
							orig = (_getStyle(t, p, _cs, false, "50% 50%") + "").split(" ");
							orig = orig[0] + " " + orig[1] + " " + m1.zOrigin + "px";
						}
						orig += "";
						pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
						pt.b = style[p];
						pt.plugin = plugin;
						if (_supports3D) {
							copy = m1.zOrigin;
							orig = orig.split(" ");
							m1.zOrigin = ((orig.length > 2) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
							pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
							pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
							pt.b = copy;
							pt.xs0 = pt.e = m1.zOrigin;
						} else {
							pt.xs0 = pt.e = orig;
						}

						//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
					} else {
						_parsePosition(orig + "", m1);
					}
				}
				if (hasChange) {
					cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
				}
				if (scaleFunc) {
					vars.scale = scaleFunc;
				}
				return pt;
			}, allowFunc:true, prefix:true});

			_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});
			_registerComplexSpecialProp("clipPath", {defaultValue:"inset(0px)", prefix:true, multi:true, formatter:_getFormatter("inset(0px 0px 0px 0px)", false, true)});

			_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
				e = this.format(e);
				var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
					style = t.style,
					ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
				w = parseFloat(t.offsetWidth);
				h = parseFloat(t.offsetHeight);
				ea1 = e.split(" ");
				for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
					if (this.p.indexOf("border")) { //older browsers used a prefix
						props[i] = _checkPropPrefix(props[i]);
					}
					bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
					if (bs.indexOf(" ") !== -1) {
						bs2 = bs.split(" ");
						bs = bs2[0];
						bs2 = bs2[1];
					}
					es = es2 = ea1[i];
					bn = parseFloat(bs);
					bsfx = bs.substr((bn + "").length);
					rel = (es.charAt(1) === "=");
					if (rel) {
						en = parseInt(es.charAt(0)+"1", 10);
						es = es.substr(2);
						en *= parseFloat(es);
						esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
					} else {
						en = parseFloat(es);
						esfx = es.substr((en + "").length);
					}
					if (esfx === "") {
						esfx = _suffixMap[p] || bsfx;
					}
					if (esfx !== bsfx) {
						hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
						vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
						if (esfx === "%") {
							bs = (hn / w * 100) + "%";
							bs2 = (vn / h * 100) + "%";
						} else if (esfx === "em") {
							em = _convertToPixels(t, "borderLeft", 1, "em");
							bs = (hn / em) + "em";
							bs2 = (vn / em) + "em";
						} else {
							bs = hn + "px";
							bs2 = vn + "px";
						}
						if (rel) {
							es = (parseFloat(bs) + en) + esfx;
							es2 = (parseFloat(bs2) + en) + esfx;
						}
					}
					pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
				}
				return pt;
			}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
			_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
				return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
			}, prefix:true, formatter:_getFormatter("0px 0px", false, true)});
			_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
				var bp = "background-position",
					cs = (_cs || _getComputedStyle(t, null)),
					bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
					es = this.format(e),
					ba, ea, i, pct, overlap, src;
				if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
					src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
					if (src && src !== "none") {
						ba = bs.split(" ");
						ea = es.split(" ");
						_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
						i = 2;
						while (--i > -1) {
							bs = ba[i];
							pct = (bs.indexOf("%") !== -1);
							if (pct !== (ea[i].indexOf("%") !== -1)) {
								overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
								ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
							}
						}
						bs = ba.join(" ");
					}
				}
				return this.parseComplex(t.style, bs, es, pt, plugin);
			}, formatter:_parsePosition});
			_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:function(v) {
				v += ""; //ensure it's a string
				return (v.substr(0,2) === "co") ? v : _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong). Also remember that it could be "cover" or "contain" which we can't tween but should be able to set.
			}});
			_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
			_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
			_registerComplexSpecialProp("transformStyle", {prefix:true});
			_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
			_registerComplexSpecialProp("userSelect", {prefix:true});
			_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
			_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
			_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
				var b, cs, delim;
				if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
					cs = t.currentStyle;
					delim = _ieVers < 8 ? " " : ",";
					b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
					e = this.format(e).split(",").join(delim);
				} else {
					b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
					e = this.format(e);
				}
				return this.parseComplex(t.style, b, e, pt, plugin);
			}});
			_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
			_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
			_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
				var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
					end = this.format(e).split(" "),
					esfx = end[0].replace(_suffixExp, "");
				if (esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
					bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
				}
				return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
				}, color:true, formatter:function(v) {
					var a = v.split(" ");
					return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
				}});
			_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
			_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
				var s = t.style,
					prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
				return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
			}});

			//opacity-related
			var _setIEOpacityRatio = function(v) {
					var t = this.t, //refers to the element's style property
						filters = t.filter || _getStyle(this.data, "filter") || "",
						val = (this.s + this.c * v) | 0,
						skip;
					if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
						if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
							t.removeAttribute("filter");
							skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
						} else {
							t.filter = filters.replace(_alphaFilterExp, "");
							skip = true;
						}
					}
					if (!skip) {
						if (this.xn1) {
							t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
						}
						if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
							if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
								t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
							}
						} else {
							t.filter = filters.replace(_opacityExp, "opacity=" + val);
						}
					}
				};
			_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
				var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
					style = t.style,
					isAutoAlpha = (p === "autoAlpha");
				if (typeof(e) === "string" && e.charAt(1) === "=") {
					e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
				}
				if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
					b = 0;
				}
				if (_supportsOpacity) {
					pt = new CSSPropTween(style, "opacity", b, e - b, pt);
				} else {
					pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
					pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
					style.zoom = 1; //helps correct an IE issue.
					pt.type = 2;
					pt.b = "alpha(opacity=" + pt.s + ")";
					pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
					pt.data = t;
					pt.plugin = plugin;
					pt.setRatio = _setIEOpacityRatio;
				}
				if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
					pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
					pt.xs0 = "inherit";
					cssp._overwriteProps.push(pt.n);
					cssp._overwriteProps.push(p);
				}
				return pt;
			}});


			var _removeProp = function(s, p) {
					if (p) {
						if (s.removeProperty) {
							if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
								p = "-" + p;
							}
							s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
						} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
							s.removeAttribute(p);
						}
					}
				},
				_setClassNameRatio = function(v) {
					this.t._gsClassPT = this;
					if (v === 1 || v === 0) {
						this.t.setAttribute("class", (v === 0) ? this.b : this.e);
						var mpt = this.data, //first MiniPropTween
							s = this.t.style;
						while (mpt) {
							if (!mpt.v) {
								_removeProp(s, mpt.p);
							} else {
								s[mpt.p] = mpt.v;
							}
							mpt = mpt._next;
						}
						if (v === 1 && this.t._gsClassPT === this) {
							this.t._gsClassPT = null;
						}
					} else if (this.t.getAttribute("class") !== this.e) {
						this.t.setAttribute("class", this.e);
					}
				};
			_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
					cssText = t.style.cssText,
					difData, bs, cnpt, cnptLookup, mpt;
				pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClassNameRatio;
				pt.pr = -11;
				_hasPriority = true;
				pt.b = b;
				bs = _getAllStyles(t, _cs);
				//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
				cnpt = t._gsClassPT;
				if (cnpt) {
					cnptLookup = {};
					mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
					while (mpt) {
						cnptLookup[mpt.p] = 1;
						mpt = mpt._next;
					}
					cnpt.setRatio(1);
				}
				t._gsClassPT = pt;
				pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
				return pt;
			}});


			var _setClearPropsRatio = function(v) {
				if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
					var s = this.t.style,
						transformParse = _specialProps.transform.parse,
						a, p, i, clearTransform, transform;
					if (this.e === "all") {
						s.cssText = "";
						clearTransform = true;
					} else {
						a = this.e.split(" ").join("").split(",");
						i = a.length;
						while (--i > -1) {
							p = a[i];
							if (_specialProps[p]) {
								if (_specialProps[p].parse === transformParse) {
									clearTransform = true;
								} else {
									p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
								}
							}
							_removeProp(s, p);
						}
					}
					if (clearTransform) {
						_removeProp(s, _transformProp);
						transform = this.t._gsTransform;
						if (transform) {
							if (transform.svg) {
								this.t.removeAttribute("data-svg-origin");
								this.t.removeAttribute("transform");
							}
							delete this.t._gsTransform;
						}
					}

				}
			};
			_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
				pt = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClearPropsRatio;
				pt.e = e;
				pt.pr = -10;
				pt.data = cssp._tween;
				_hasPriority = true;
				return pt;
			}});

			p = "bezier,throwProps,physicsProps,physics2D".split(",");
			i = p.length;
			while (i--) {
				_registerPluginProp(p[i]);
			}








			p = CSSPlugin.prototype;
			p._firstPT = p._lastParsedTransform = p._transform = null;

			//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
			p._onInitTween = function(target, vars, tween, index) {
				if (!target.nodeType) { //css is only for dom elements
					return false;
				}
				this._target = _target = target;
				this._tween = tween;
				this._vars = vars;
				_index = index;
				_autoRound = vars.autoRound;
				_hasPriority = false;
				_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
				_cs = _getComputedStyle(target, "");
				_overwriteProps = this._overwriteProps;
				var style = target.style,
					v, pt, pt2, first, last, next, zIndex, tpt, threeD;
				if (_reqSafariFix) if (style.zIndex === "") {
					v = _getStyle(target, "zIndex", _cs);
					if (v === "auto" || v === "") {
						//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
						this._addLazySet(style, "zIndex", 0);
					}
				}

				if (typeof(vars) === "string") {
					first = style.cssText;
					v = _getAllStyles(target, _cs);
					style.cssText = first + ";" + vars;
					v = _cssDif(target, v, _getAllStyles(target)).difs;
					if (!_supportsOpacity && _opacityValExp.test(vars)) {
						v.opacity = parseFloat( RegExp.$1 );
					}
					vars = v;
					style.cssText = first;
				}

				if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
					this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
				} else {
					this._firstPT = pt = this.parse(target, vars, null);
				}

				if (this._transformType) {
					threeD = (this._transformType === 3);
					if (!_transformProp) {
						style.zoom = 1; //helps correct an IE issue.
					} else if (_isSafari) {
						_reqSafariFix = true;
						//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
						if (style.zIndex === "") {
							zIndex = _getStyle(target, "zIndex", _cs);
							if (zIndex === "auto" || zIndex === "") {
								this._addLazySet(style, "zIndex", 0);
							}
						}
						//Setting WebkitBackfaceVisibility corrects 3 bugs:
						// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
						// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
						// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
						//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
						if (_isSafariLT6) {
							this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
						}
					}
					pt2 = pt;
					while (pt2 && pt2._next) {
						pt2 = pt2._next;
					}
					tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
					this._linkCSSP(tpt, null, pt2);
					tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
					tpt.data = this._transform || _getTransform(target, _cs, true);
					tpt.tween = tween;
					tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
					_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
				}

				if (_hasPriority) {
					//reorders the linked list in order of pr (priority)
					while (pt) {
						next = pt._next;
						pt2 = first;
						while (pt2 && pt2.pr > pt.pr) {
							pt2 = pt2._next;
						}
						if ((pt._prev = pt2 ? pt2._prev : last)) {
							pt._prev._next = pt;
						} else {
							first = pt;
						}
						if ((pt._next = pt2)) {
							pt2._prev = pt;
						} else {
							last = pt;
						}
						pt = next;
					}
					this._firstPT = first;
				}
				return true;
			};


			p.parse = function(target, vars, pt, plugin) {
				var style = target.style,
					p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
				for (p in vars) {
					es = vars[p]; //ending value string
					sp = _specialProps[p]; //SpecialProp lookup.
					if (typeof(es) === "function" && !(sp && sp.allowFunc)) {
						es = es(_index, _target);
					}
					if (sp) {
						pt = sp.parse(target, es, p, this, pt, plugin, vars);
					} else if (p.substr(0,2) === "--") { //for tweening CSS variables (which always start with "--"). To maximize performance and simplicity, we bypass CSSPlugin altogether and just add a normal property tween to the tween instance itself.
						this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
						continue;
					} else {
						bs = _getStyle(target, p, _cs) + "";
						isStr = (typeof(es) === "string");
						if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
							if (!isStr) {
								es = _parseColor(es);
								es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
							}
							pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

						} else if (isStr && _complexExp.test(es)) {
							pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

						} else {
							bn = parseFloat(bs);
							bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

							if (bs === "" || bs === "auto") {
								if (p === "width" || p === "height") {
									bn = _getDimension(target, p, _cs);
									bsfx = "px";
								} else if (p === "left" || p === "top") {
									bn = _calculateOffset(target, p, _cs);
									bsfx = "px";
								} else {
									bn = (p !== "opacity") ? 0 : 1;
									bsfx = "";
								}
							}

							rel = (isStr && es.charAt(1) === "=");
							if (rel) {
								en = parseInt(es.charAt(0) + "1", 10);
								es = es.substr(2);
								en *= parseFloat(es);
								esfx = es.replace(_suffixExp, "");
							} else {
								en = parseFloat(es);
								esfx = isStr ? es.replace(_suffixExp, "") : "";
							}

							if (esfx === "") {
								esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
							}

							es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
							//if the beginning/ending suffixes don't match, normalize them...
							if (bsfx !== esfx) if (esfx !== "" || p === "lineHeight") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
								bn = _convertToPixels(target, p, bn, bsfx);
								if (esfx === "%") {
									bn /= _convertToPixels(target, p, 100, "%") / 100;
									if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
										bs = bn + "%";
									}

								} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
									bn /= _convertToPixels(target, p, 1, esfx);

								//otherwise convert to pixels.
								} else if (esfx !== "px") {
									en = _convertToPixels(target, p, en, esfx);
									esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
								}
								if (rel) if (en || en === 0) {
									es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
								}
							}

							if (rel) {
								en += bn;
							}

							if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
								pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
								pt.xs0 = esfx;
								//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
							} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
								_log("invalid " + p + " tween value: " + vars[p]);
							} else {
								pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
								pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
								//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
							}
						}
					}
					if (plugin) if (pt && !pt.plugin) {
						pt.plugin = plugin;
					}
				}
				return pt;
			};


			//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
			p.setRatio = function(v) {
				var pt = this._firstPT,
					min = 0.000001,
					val, str, i;
				//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
				if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
					while (pt) {
						if (pt.type !== 2) {
							if (pt.r && pt.type !== -1) {
								val = pt.r(pt.s + pt.c);
								if (!pt.type) {
									pt.t[pt.p] = val + pt.xs0;
								} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
									i = pt.l;
									str = pt.xs0 + val + pt.xs1;
									for (i = 1; i < pt.l; i++) {
										str += pt["xn"+i] + pt["xs"+(i+1)];
									}
									pt.t[pt.p] = str;
								}
							} else {
								pt.t[pt.p] = pt.e;
							}
						} else {
							pt.setRatio(v);
						}
						pt = pt._next;
					}

				} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
					while (pt) {
						val = pt.c * v + pt.s;
						if (pt.r) {
							val = pt.r(val);
						} else if (val < min) if (val > -min) {
							val = 0;
						}
						if (!pt.type) {
							pt.t[pt.p] = val + pt.xs0;
						} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
							i = pt.l;
							if (i === 2) {
								pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
							} else if (i === 3) {
								pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
							} else if (i === 4) {
								pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
							} else if (i === 5) {
								pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
							} else {
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt.t[pt.p] = str;
							}

						} else if (pt.type === -1) { //non-tweening value
							pt.t[pt.p] = pt.xs0;

						} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
							pt.setRatio(v);
						}
						pt = pt._next;
					}

				//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
				} else {
					while (pt) {
						if (pt.type !== 2) {
							pt.t[pt.p] = pt.b;
						} else {
							pt.setRatio(v);
						}
						pt = pt._next;
					}
				}
			};

			/**
			 * @private
			 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
			 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
			 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
			 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
			 * doesn't have any transform-related properties of its own. You can call this method as many times as you
			 * want and it won't create duplicate CSSPropTweens.
			 *
			 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
			 */
			p._enableTransforms = function(threeD) {
				this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
				this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
			};

			var lazySet = function(v) {
				this.t[this.p] = this.e;
				this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
			};
			/** @private Gives us a way to set a value on the first render (and only the first render). **/
			p._addLazySet = function(t, p, v) {
				var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
				pt.e = v;
				pt.setRatio = lazySet;
				pt.data = this;
			};

			/** @private **/
			p._linkCSSP = function(pt, next, prev, remove) {
				if (pt) {
					if (next) {
						next._prev = pt;
					}
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
						remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
					}
					if (prev) {
						prev._next = pt;
					} else if (!remove && this._firstPT === null) {
						this._firstPT = pt;
					}
					pt._next = next;
					pt._prev = prev;
				}
				return pt;
			};

			p._mod = function(lookup) {
				var pt = this._firstPT;
				while (pt) {
					if (typeof(lookup[pt.p]) === "function") { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally.
						pt.r = lookup[pt.p];
					}
					pt = pt._next;
				}
			};

			//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
			p._kill = function(lookup) {
				var copy = lookup,
					pt, p, xfirst;
				if (lookup.autoAlpha || lookup.alpha) {
					copy = {};
					for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
						copy[p] = lookup[p];
					}
					copy.opacity = 1;
					if (copy.autoAlpha) {
						copy.visibility = 1;
					}
				}
				if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
					xfirst = pt.xfirst;
					if (xfirst && xfirst._prev) {
						this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
					} else if (xfirst === this._firstPT) {
						this._firstPT = pt._next;
					}
					if (pt._next) {
						this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
					}
					this._classNamePT = null;
				}
				pt = this._firstPT;
				while (pt) {
					if (pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
						pt.plugin._kill(lookup);
						p = pt.plugin;
					}
					pt = pt._next;
				}
				return TweenPlugin.prototype._kill.call(this, copy);
			};



			//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
			var _getChildStyles = function(e, props, targets) {
					var children, i, child, type;
					if (e.slice) {
						i = e.length;
						while (--i > -1) {
							_getChildStyles(e[i], props, targets);
						}
						return;
					}
					children = e.childNodes;
					i = children.length;
					while (--i > -1) {
						child = children[i];
						type = child.type;
						if (child.style) {
							props.push(_getAllStyles(child));
							if (targets) {
								targets.push(child);
							}
						}
						if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
							_getChildStyles(child, props, targets);
						}
					}
				};

			/**
			 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
			 * and then compares the style properties of all the target's child elements at the tween's start and end, and
			 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
			 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
			 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
			 * is because it creates entirely new tweens that may have completely different targets than the original tween,
			 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
			 * and it would create other problems. For example:
			 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
			 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
			 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
			 *
			 * @param {Object} target object to be tweened
			 * @param {number} Duration in seconds (or frames for frames-based tweens)
			 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
			 * @return {Array} An array of TweenLite instances
			 */
			CSSPlugin.cascadeTo = function(target, duration, vars) {
				var tween = TweenLite.to(target, duration, vars),
					results = [tween],
					b = [],
					e = [],
					targets = [],
					_reservedProps = TweenLite._internals.reservedProps,
					i, difs, p, from;
				target = tween._targets || tween.target;
				_getChildStyles(target, b, targets);
				tween.render(duration, true, true);
				_getChildStyles(target, e);
				tween.render(0, true, true);
				tween._enabled(true);
				i = targets.length;
				while (--i > -1) {
					difs = _cssDif(targets[i], b[i], e[i]);
					if (difs.firstMPT) {
						difs = difs.difs;
						for (p in vars) {
							if (_reservedProps[p]) {
								difs[p] = vars[p];
							}
						}
						from = {};
						for (p in difs) {
							from[p] = b[i][p];
						}
						results.push(TweenLite.fromTo(targets[i], duration, from, difs));
					}
				}
				return results;
			};

			TweenPlugin.activate([CSSPlugin]);
			return CSSPlugin;

		}, true);

		
		
		
		
		
		
		
		
		
		
	/*
	 * ----------------------------------------------------------------
	 * RoundPropsPlugin
	 * ----------------------------------------------------------------
	 */
		(function() {

			var RoundPropsPlugin = _gsScope._gsDefine.plugin({
					propName: "roundProps",
					version: "1.7.0",
					priority: -1,
					API: 2,

					//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, value, tween) {
						this._tween = tween;
						return true;
					}

				}),
				_getRoundFunc = function(v) { //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
					var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()
					return function(n) {
						return ((Math.round(n / v) * v * p) | 0) / p;
					};
				},
				_roundLinkedList = function(node, mod) {
					while (node) {
						if (!node.f && !node.blob) {
							node.m = mod || Math.round;
						}
						node = node._next;
					}
				},
				p = RoundPropsPlugin.prototype;

			p._onInitAllProps = function() {
				var tween = this._tween,
					rp = tween.vars.roundProps,
					lookup = {},
					rpt = tween._propLookup.roundProps,
					pt, next, i, p;
				if (typeof(rp) === "object" && !rp.push) {
					for (p in rp) {
						lookup[p] = _getRoundFunc(rp[p]);
					}
				} else {
					if (typeof(rp) === "string") {
						rp = rp.split(",");
					}
					i = rp.length;
					while (--i > -1) {
						lookup[rp[i]] = Math.round;
					}
				}

				for (p in lookup) {
					pt = tween._firstPT;
					while (pt) {
						next = pt._next; //record here, because it may get removed
						if (pt.pg) {
							pt.t._mod(lookup);
						} else if (pt.n === p) {
							if (pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
								_roundLinkedList(pt.t._firstPT, lookup[p]);
							} else {
								this._add(pt.t, p, pt.s, pt.c, lookup[p]);
								//remove from linked list
								if (next) {
									next._prev = pt._prev;
								}
								if (pt._prev) {
									pt._prev._next = next;
								} else if (tween._firstPT === pt) {
									tween._firstPT = next;
								}
								pt._next = pt._prev = null;
								tween._propLookup[p] = rpt;
							}
						}
						pt = next;
					}
				}
				return false;
			};

			p._add = function(target, p, s, c, mod) {
				this._addTween(target, p, s, s + c, p, mod || Math.round);
				this._overwriteProps.push(p);
			};

		}());










	/*
	 * ----------------------------------------------------------------
	 * AttrPlugin
	 * ----------------------------------------------------------------
	 */

		(function() {

			_gsScope._gsDefine.plugin({
				propName: "attr",
				API: 2,
				version: "0.6.1",

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween, index) {
					var p, end;
					if (typeof(target.setAttribute) !== "function") {
						return false;
					}
					for (p in value) {
						end = value[p];
						if (typeof(end) === "function") {
							end = end(index, target);
						}
						this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
						this._overwriteProps.push(p);
					}
					return true;
				}

			});

		}());










	/*
	 * ----------------------------------------------------------------
	 * DirectionalRotationPlugin
	 * ----------------------------------------------------------------
	 */
		_gsScope._gsDefine.plugin({
			propName: "directionalRotation",
			version: "0.3.1",
			API: 2,

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function(target, value, tween, index) {
				if (typeof(value) !== "object") {
					value = {rotation:value};
				}
				this.finals = {};
				var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
					min = 0.000001,
					p, v, start, end, dif, split;
				for (p in value) {
					if (p !== "useRadians") {
						end = value[p];
						if (typeof(end) === "function") {
							end = end(index, target);
						}
						split = (end + "").split("_");
						v = split[0];
						start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
						end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
						dif = end - start;
						if (split.length) {
							v = split.join("_");
							if (v.indexOf("short") !== -1) {
								dif = dif % cap;
								if (dif !== dif % (cap / 2)) {
									dif = (dif < 0) ? dif + cap : dif - cap;
								}
							}
							if (v.indexOf("_cw") !== -1 && dif < 0) {
								dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
							} else if (v.indexOf("ccw") !== -1 && dif > 0) {
								dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
							}
						}
						if (dif > min || dif < -min) {
							this._addTween(target, p, start, start + dif, p);
							this._overwriteProps.push(p);
						}
					}
				}
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function(ratio) {
				var pt;
				if (ratio !== 1) {
					this._super.setRatio.call(this, ratio);
				} else {
					pt = this._firstPT;
					while (pt) {
						if (pt.f) {
							pt.t[pt.p](this.finals[pt.p]);
						} else {
							pt.t[pt.p] = this.finals[pt.p];
						}
						pt = pt._next;
					}
				}
			}

		})._autoCSS = true;







		
		
		
		
	/*
	 * ----------------------------------------------------------------
	 * EasePack
	 * ----------------------------------------------------------------
	 */
		_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
			
			var w = (_gsScope.GreenSockGlobals || _gsScope),
				gs = w.com.greensock,
				_2PI = Math.PI * 2,
				_HALF_PI = Math.PI / 2,
				_class = gs._class,
				_create = function(n, f) {
					var C = _class("easing." + n, function(){}, true),
						p = C.prototype = new Ease();
					p.constructor = C;
					p.getRatio = f;
					return C;
				},
				_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
				_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
					var C = _class("easing."+name, {
						easeOut:new EaseOut(),
						easeIn:new EaseIn(),
						easeInOut:new EaseInOut()
					}, true);
					_easeReg(C, name);
					return C;
				},
				EasePoint = function(time, value, next) {
					this.t = time;
					this.v = value;
					if (next) {
						this.next = next;
						next.prev = this;
						this.c = next.v - value;
						this.gap = next.t - time;
					}
				},

				//Back
				_createBack = function(n, f) {
					var C = _class("easing." + n, function(overshoot) {
							this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
							this._p2 = this._p1 * 1.525;
						}, true),
						p = C.prototype = new Ease();
					p.constructor = C;
					p.getRatio = f;
					p.config = function(overshoot) {
						return new C(overshoot);
					};
					return C;
				},

				Back = _wrap("Back",
					_createBack("BackOut", function(p) {
						return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
					}),
					_createBack("BackIn", function(p) {
						return p * p * ((this._p1 + 1) * p - this._p1);
					}),
					_createBack("BackInOut", function(p) {
						return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
					})
				),


				//SlowMo
				SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
					power = (power || power === 0) ? power : 0.7;
					if (linearRatio == null) {
						linearRatio = 0.7;
					} else if (linearRatio > 1) {
						linearRatio = 1;
					}
					this._p = (linearRatio !== 1) ? power : 0;
					this._p1 = (1 - linearRatio) / 2;
					this._p2 = linearRatio;
					this._p3 = this._p1 + this._p2;
					this._calcEnd = (yoyoMode === true);
				}, true),
				p = SlowMo.prototype = new Ease(),
				SteppedEase, ExpoScaleEase, RoughEase, _createElastic;

			p.constructor = SlowMo;
			p.getRatio = function(p) {
				var r = p + (0.5 - p) * this._p;
				if (p < this._p1) {
					return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
				} else if (p > this._p3) {
					return this._calcEnd ? (p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p) : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p); //added p === 1 ? 0 to avoid floating point rounding errors from affecting the final value, like 1 - 0.7 = 0.30000000000000004 instead of 0.3
				}
				return this._calcEnd ? 1 : r;
			};
			SlowMo.ease = new SlowMo(0.7, 0.7);

			p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
				return new SlowMo(linearRatio, power, yoyoMode);
			};


			//SteppedEase
			SteppedEase = _class("easing.SteppedEase", function(steps, immediateStart) {
					steps = steps || 1;
					this._p1 = 1 / steps;
					this._p2 = steps + (immediateStart ? 0 : 1);
					this._p3 = immediateStart ? 1 : 0;
				}, true);
			p = SteppedEase.prototype = new Ease();
			p.constructor = SteppedEase;
			p.getRatio = function(p) {
				if (p < 0) {
					p = 0;
				} else if (p >= 1) {
					p = 0.999999999;
				}
				return (((this._p2 * p) | 0) + this._p3) * this._p1;
			};
			p.config = SteppedEase.config = function(steps, immediateStart) {
				return new SteppedEase(steps, immediateStart);
			};

			//ExpoScaleEase
			ExpoScaleEase = _class("easing.ExpoScaleEase", function(start, end, ease) {
				this._p1 = Math.log(end / start);
				this._p2 = end - start;
				this._p3 = start;
				this._ease = ease;
			}, true);
			p = ExpoScaleEase.prototype = new Ease();
			p.constructor = ExpoScaleEase;
			p.getRatio = function(p) {
				if (this._ease) {
					p = this._ease.getRatio(p);
				}
				return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
			};
			p.config = ExpoScaleEase.config = function(start, end, ease) {
				return new ExpoScaleEase(start, end, ease);
			};


			//RoughEase
			RoughEase = _class("easing.RoughEase", function(vars) {
				vars = vars || {};
				var taper = vars.taper || "none",
					a = [],
					cnt = 0,
					points = (vars.points || 20) | 0,
					i = points,
					randomize = (vars.randomize !== false),
					clamp = (vars.clamp === true),
					template = (vars.template instanceof Ease) ? vars.template : null,
					strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
					x, y, bump, invX, obj, pnt;
				while (--i > -1) {
					x = randomize ? Math.random() : (1 / points) * i;
					y = template ? template.getRatio(x) : x;
					if (taper === "none") {
						bump = strength;
					} else if (taper === "out") {
						invX = 1 - x;
						bump = invX * invX * strength;
					} else if (taper === "in") {
						bump = x * x * strength;
					} else if (x < 0.5) {  //"both" (start)
						invX = x * 2;
						bump = invX * invX * 0.5 * strength;
					} else {				//"both" (end)
						invX = (1 - x) * 2;
						bump = invX * invX * 0.5 * strength;
					}
					if (randomize) {
						y += (Math.random() * bump) - (bump * 0.5);
					} else if (i % 2) {
						y += bump * 0.5;
					} else {
						y -= bump * 0.5;
					}
					if (clamp) {
						if (y > 1) {
							y = 1;
						} else if (y < 0) {
							y = 0;
						}
					}
					a[cnt++] = {x:x, y:y};
				}
				a.sort(function(a, b) {
					return a.x - b.x;
				});

				pnt = new EasePoint(1, 1, null);
				i = points;
				while (--i > -1) {
					obj = a[i];
					pnt = new EasePoint(obj.x, obj.y, pnt);
				}

				this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
			}, true);
			p = RoughEase.prototype = new Ease();
			p.constructor = RoughEase;
			p.getRatio = function(p) {
				var pnt = this._prev;
				if (p > pnt.t) {
					while (pnt.next && p >= pnt.t) {
						pnt = pnt.next;
					}
					pnt = pnt.prev;
				} else {
					while (pnt.prev && p <= pnt.t) {
						pnt = pnt.prev;
					}
				}
				this._prev = pnt;
				return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
			};
			p.config = function(vars) {
				return new RoughEase(vars);
			};
			RoughEase.ease = new RoughEase();


			//Bounce
			_wrap("Bounce",
				_create("BounceOut", function(p) {
					if (p < 1 / 2.75) {
						return 7.5625 * p * p;
					} else if (p < 2 / 2.75) {
						return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
					} else if (p < 2.5 / 2.75) {
						return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
					}
					return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}),
				_create("BounceIn", function(p) {
					if ((p = 1 - p) < 1 / 2.75) {
						return 1 - (7.5625 * p * p);
					} else if (p < 2 / 2.75) {
						return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
					} else if (p < 2.5 / 2.75) {
						return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
					}
					return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
				}),
				_create("BounceInOut", function(p) {
					var invert = (p < 0.5);
					if (invert) {
						p = 1 - (p * 2);
					} else {
						p = (p * 2) - 1;
					}
					if (p < 1 / 2.75) {
						p = 7.5625 * p * p;
					} else if (p < 2 / 2.75) {
						p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
					} else if (p < 2.5 / 2.75) {
						p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
					} else {
						p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
					}
					return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
				})
			);


			//CIRC
			_wrap("Circ",
				_create("CircOut", function(p) {
					return Math.sqrt(1 - (p = p - 1) * p);
				}),
				_create("CircIn", function(p) {
					return -(Math.sqrt(1 - (p * p)) - 1);
				}),
				_create("CircInOut", function(p) {
					return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
				})
			);


			//Elastic
			_createElastic = function(n, f, def) {
				var C = _class("easing." + n, function(amplitude, period) {
						this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
						this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
						this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
						this._p2 = _2PI / this._p2; //precalculate to optimize
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(amplitude, period) {
					return new C(amplitude, period);
				};
				return C;
			};
			_wrap("Elastic",
				_createElastic("ElasticOut", function(p) {
					return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
				}, 0.3),
				_createElastic("ElasticIn", function(p) {
					return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
				}, 0.3),
				_createElastic("ElasticInOut", function(p) {
					return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
				}, 0.45)
			);


			//Expo
			_wrap("Expo",
				_create("ExpoOut", function(p) {
					return 1 - Math.pow(2, -10 * p);
				}),
				_create("ExpoIn", function(p) {
					return Math.pow(2, 10 * (p - 1)) - 0.001;
				}),
				_create("ExpoInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
				})
			);


			//Sine
			_wrap("Sine",
				_create("SineOut", function(p) {
					return Math.sin(p * _HALF_PI);
				}),
				_create("SineIn", function(p) {
					return -Math.cos(p * _HALF_PI) + 1;
				}),
				_create("SineInOut", function(p) {
					return -0.5 * (Math.cos(Math.PI * p) - 1);
				})
			);

			_class("easing.EaseLookup", {
					find:function(s) {
						return Ease.map[s];
					}
				}, true);

			//register the non-standard eases
			_easeReg(w.SlowMo, "SlowMo", "ease,");
			_easeReg(RoughEase, "RoughEase", "ease,");
			_easeReg(SteppedEase, "SteppedEase", "ease,");

			return Back;
			
		}, true);


	});

	if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











	/*
	 * ----------------------------------------------------------------
	 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
	 * ----------------------------------------------------------------
	 */
	(function(window, moduleName) {

			"use strict";
			var _exports = {},
				_doc = window.document,
				_globals = window.GreenSockGlobals = window.GreenSockGlobals || window,
				existingModule = _globals[moduleName];
			if (existingModule) {
				if (typeof(module) !== "undefined" && module.exports) { //node
					module.exports = existingModule;
				}
				return existingModule; //in case the core set of classes is already loaded, don't instantiate twice.
			}
			var _namespace = function(ns) {
					var a = ns.split("."),
						p = _globals, i;
					for (i = 0; i < a.length; i++) {
						p[a[i]] = p = p[a[i]] || {};
					}
					return p;
				},
				gs = _namespace("com.greensock"),
				_tinyNum = 0.00000001,
				_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					var b = [],
						l = a.length,
						i;
					for (i = 0; i !== l; b.push(a[i++])) {}
					return b;
				},
				_emptyFunc = function() {},
				_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
					var toString = Object.prototype.toString,
						array = toString.call([]);
					return function(obj) {
						return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
					};
				}()),
				a, i, p, _ticker, _tickerActive,
				_defLookup = {},

				/**
				 * @constructor
				 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
				 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
				 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
				 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
				 *
				 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
				 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
				 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
				 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
				 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
				 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
				 * sandbox the banner one like:
				 *
				 * <script>
				 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
				 * </script>
				 * <script src="js/greensock/v1.7/TweenMax.js"></script>
				 * <script>
				 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
				 * </script>
				 * <script src="js/greensock/v1.6/TweenMax.js"></script>
				 * <script>
				 *     gs.TweenLite.to(...); //would use v1.7
				 *     TweenLite.to(...); //would use v1.6
				 * </script>
				 *
				 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
				 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
				 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
				 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
				 */
				Definition = function(ns, dependencies, func, global) {
					this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
					_defLookup[ns] = this;
					this.gsClass = null;
					this.func = func;
					var _classes = [];
					this.check = function(init) {
						var i = dependencies.length,
							missing = i,
							cur, a, n, cl;
						while (--i > -1) {
							if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
								_classes[i] = cur.gsClass;
								missing--;
							} else if (init) {
								cur.sc.push(this);
							}
						}
						if (missing === 0 && func) {
							a = ("com.greensock." + ns).split(".");
							n = a.pop();
							cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

							//exports to multiple environments
							if (global) {
								_globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
								if (typeof(module) !== "undefined" && module.exports) { //node
									if (ns === moduleName) {
										module.exports = _exports[moduleName] = cl;
										for (i in _exports) {
											cl[i] = _exports[i];
										}
									} else if (_exports[moduleName]) {
										_exports[moduleName][n] = cl;
									}
								} else if (true){ //AMD
									!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return cl; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
								}
							}
							for (i = 0; i < this.sc.length; i++) {
								this.sc[i].check();
							}
						}
					};
					this.check(true);
				},

				//used to create Definition instances (which basically registers a class that has dependencies).
				_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
					return new Definition(ns, dependencies, func, global);
				},

				//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
				_class = gs._class = function(ns, func, global) {
					func = func || function() {};
					_gsDefine(ns, [], function(){ return func; }, global);
					return func;
				};

			_gsDefine.globals = _globals;



	/*
	 * ----------------------------------------------------------------
	 * Ease
	 * ----------------------------------------------------------------
	 */
			var _baseParams = [0, 0, 1, 1],
				Ease = _class("easing.Ease", function(func, extraParams, type, power) {
					this._func = func;
					this._type = type || 0;
					this._power = power || 0;
					this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
				}, true),
				_easeMap = Ease.map = {},
				_easeReg = Ease.register = function(ease, names, types, create) {
					var na = names.split(","),
						i = na.length,
						ta = (types || "easeIn,easeOut,easeInOut").split(","),
						e, name, j, type;
					while (--i > -1) {
						name = na[i];
						e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
						j = ta.length;
						while (--j > -1) {
							type = ta[j];
							_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
						}
					}
				};

			p = Ease.prototype;
			p._calcEnd = false;
			p.getRatio = function(p) {
				if (this._func) {
					this._params[0] = p;
					return this._func.apply(null, this._params);
				}
				var t = this._type,
					pw = this._power,
					r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
				if (pw === 1) {
					r *= r;
				} else if (pw === 2) {
					r *= r * r;
				} else if (pw === 3) {
					r *= r * r * r;
				} else if (pw === 4) {
					r *= r * r * r * r;
				}
				return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
			};

			//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
			a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
			i = a.length;
			while (--i > -1) {
				p = a[i]+",Power"+i;
				_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
				_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
				_easeReg(new Ease(null,null,3,i), p, "easeInOut");
			}
			_easeMap.linear = gs.easing.Linear.easeIn;
			_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


	/*
	 * ----------------------------------------------------------------
	 * EventDispatcher
	 * ----------------------------------------------------------------
	 */
			var EventDispatcher = _class("events.EventDispatcher", function(target) {
				this._listeners = {};
				this._eventTarget = target || this;
			});
			p = EventDispatcher.prototype;

			p.addEventListener = function(type, callback, scope, useParam, priority) {
				priority = priority || 0;
				var list = this._listeners[type],
					index = 0,
					listener, i;
				if (this === _ticker && !_tickerActive) {
					_ticker.wake();
				}
				if (list == null) {
					this._listeners[type] = list = [];
				}
				i = list.length;
				while (--i > -1) {
					listener = list[i];
					if (listener.c === callback && listener.s === scope) {
						list.splice(i, 1);
					} else if (index === 0 && listener.pr < priority) {
						index = i + 1;
					}
				}
				list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			};

			p.removeEventListener = function(type, callback) {
				var list = this._listeners[type], i;
				if (list) {
					i = list.length;
					while (--i > -1) {
						if (list[i].c === callback) {
							list.splice(i, 1);
							return;
						}
					}
				}
			};

			p.dispatchEvent = function(type) {
				var list = this._listeners[type],
					i, t, listener;
				if (list) {
					i = list.length;
					if (i > 1) {
						list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
					}
					t = this._eventTarget;
					while (--i > -1) {
						listener = list[i];
						if (listener) {
							if (listener.up) {
								listener.c.call(listener.s || t, {type:type, target:t});
							} else {
								listener.c.call(listener.s || t);
							}
						}
					}
				}
			};


	/*
	 * ----------------------------------------------------------------
	 * Ticker
	 * ----------------------------------------------------------------
	 */
	 		var _reqAnimFrame = window.requestAnimationFrame,
				_cancelAnimFrame = window.cancelAnimationFrame,
				_getTime = Date.now || function() {return new Date().getTime();},
				_lastUpdate = _getTime();

			//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
			a = ["ms","moz","webkit","o"];
			i = a.length;
			while (--i > -1 && !_reqAnimFrame) {
				_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
				_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
			}

			_class("Ticker", function(fps, useRAF) {
				var _self = this,
					_startTime = _getTime(),
					_useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
					_lagThreshold = 500,
					_adjustedLag = 33,
					_tickWord = "tick", //helps reduce gc burden
					_fps, _req, _id, _gap, _nextTime,
					_tick = function(manual) {
						var elapsed = _getTime() - _lastUpdate,
							overlap, dispatch;
						if (elapsed > _lagThreshold) {
							_startTime += elapsed - _adjustedLag;
						}
						_lastUpdate += elapsed;
						_self.time = (_lastUpdate - _startTime) / 1000;
						overlap = _self.time - _nextTime;
						if (!_fps || overlap > 0 || manual === true) {
							_self.frame++;
							_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
							dispatch = true;
						}
						if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
							_id = _req(_tick);
						}
						if (dispatch) {
							_self.dispatchEvent(_tickWord);
						}
					};

				EventDispatcher.call(_self);
				_self.time = _self.frame = 0;
				_self.tick = function() {
					_tick(true);
				};

				_self.lagSmoothing = function(threshold, adjustedLag) {
					if (!arguments.length) { //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
						return (_lagThreshold < 1 / _tinyNum);
					}
					_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
					_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
				};

				_self.sleep = function() {
					if (_id == null) {
						return;
					}
					if (!_useRAF || !_cancelAnimFrame) {
						clearTimeout(_id);
					} else {
						_cancelAnimFrame(_id);
					}
					_req = _emptyFunc;
					_id = null;
					if (_self === _ticker) {
						_tickerActive = false;
					}
				};

				_self.wake = function(seamless) {
					if (_id !== null) {
						_self.sleep();
					} else if (seamless) {
						_startTime += -_lastUpdate + (_lastUpdate = _getTime());
					} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
						_lastUpdate = _getTime() - _lagThreshold + 5;
					}
					_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
					if (_self === _ticker) {
						_tickerActive = true;
					}
					_tick(2);
				};

				_self.fps = function(value) {
					if (!arguments.length) {
						return _fps;
					}
					_fps = value;
					_gap = 1 / (_fps || 60);
					_nextTime = this.time + _gap;
					_self.wake();
				};

				_self.useRAF = function(value) {
					if (!arguments.length) {
						return _useRAF;
					}
					_self.sleep();
					_useRAF = value;
					_self.fps(_fps);
				};
				_self.fps(fps);

				//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
				setTimeout(function() {
					if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
						_self.useRAF(false);
					}
				}, 1500);
			});

			p = gs.Ticker.prototype = new gs.events.EventDispatcher();
			p.constructor = gs.Ticker;


	/*
	 * ----------------------------------------------------------------
	 * Animation
	 * ----------------------------------------------------------------
	 */
			var Animation = _class("core.Animation", function(duration, vars) {
					this.vars = vars = vars || {};
					this._duration = this._totalDuration = duration || 0;
					this._delay = Number(vars.delay) || 0;
					this._timeScale = 1;
					this._active = !!vars.immediateRender;
					this.data = vars.data;
					this._reversed = !!vars.reversed;

					if (!_rootTimeline) {
						return;
					}
					if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
						_ticker.wake();
					}

					var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
					tl.add(this, tl._time);

					if (this.vars.paused) {
						this.paused(true);
					}
				});

			_ticker = Animation.ticker = new gs.Ticker();
			p = Animation.prototype;
			p._dirty = p._gc = p._initted = p._paused = false;
			p._totalTime = p._time = 0;
			p._rawPrevTime = -1;
			p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
			p._paused = false;


			//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
			var _checkTimeout = function() {
					if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) { //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
						_ticker.wake();
					}
					var t = setTimeout(_checkTimeout, 2000);
					if (t.unref) {
						// allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
						t.unref();
					}
				};
			_checkTimeout();


			p.play = function(from, suppressEvents) {
				if (from != null) {
					this.seek(from, suppressEvents);
				}
				return this.reversed(false).paused(false);
			};

			p.pause = function(atTime, suppressEvents) {
				if (atTime != null) {
					this.seek(atTime, suppressEvents);
				}
				return this.paused(true);
			};

			p.resume = function(from, suppressEvents) {
				if (from != null) {
					this.seek(from, suppressEvents);
				}
				return this.paused(false);
			};

			p.seek = function(time, suppressEvents) {
				return this.totalTime(Number(time), suppressEvents !== false);
			};

			p.restart = function(includeDelay, suppressEvents) {
				return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
			};

			p.reverse = function(from, suppressEvents) {
				if (from != null) {
					this.seek((from || this.totalDuration()), suppressEvents);
				}
				return this.reversed(true).paused(false);
			};

			p.render = function(time, suppressEvents, force) {
				//stub - we override this method in subclasses.
			};

			p.invalidate = function() {
				this._time = this._totalTime = 0;
				this._initted = this._gc = false;
				this._rawPrevTime = -1;
				if (this._gc || !this.timeline) {
					this._enabled(true);
				}
				return this;
			};

			p.isActive = function() {
				var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
					startTime = this._startTime,
					rawTime;
				return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - _tinyNum));
			};

			p._enabled = function (enabled, ignoreTimeline) {
				if (!_tickerActive) {
					_ticker.wake();
				}
				this._gc = !enabled;
				this._active = this.isActive();
				if (ignoreTimeline !== true) {
					if (enabled && !this.timeline) {
						this._timeline.add(this, this._startTime - this._delay);
					} else if (!enabled && this.timeline) {
						this._timeline._remove(this, true);
					}
				}
				return false;
			};


			p._kill = function(vars, target) {
				return this._enabled(false, false);
			};

			p.kill = function(vars, target) {
				this._kill(vars, target);
				return this;
			};

			p._uncache = function(includeSelf) {
				var tween = includeSelf ? this : this.timeline;
				while (tween) {
					tween._dirty = true;
					tween = tween.timeline;
				}
				return this;
			};

			p._swapSelfInParams = function(params) {
				var i = params.length,
					copy = params.concat();
				while (--i > -1) {
					if (params[i] === "{self}") {
						copy[i] = this;
					}
				}
				return copy;
			};

			p._callback = function(type) {
				var v = this.vars,
					callback = v[type],
					params = v[type + "Params"],
					scope = v[type + "Scope"] || v.callbackScope || this,
					l = params ? params.length : 0;
				switch (l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
					case 0: callback.call(scope); break;
					case 1: callback.call(scope, params[0]); break;
					case 2: callback.call(scope, params[0], params[1]); break;
					default: callback.apply(scope, params);
				}
			};

	//----Animation getters/setters --------------------------------------------------------

			p.eventCallback = function(type, callback, params, scope) {
				if ((type || "").substr(0,2) === "on") {
					var v = this.vars;
					if (arguments.length === 1) {
						return v[type];
					}
					if (callback == null) {
						delete v[type];
					} else {
						v[type] = callback;
						v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
						v[type + "Scope"] = scope;
					}
					if (type === "onUpdate") {
						this._onUpdate = callback;
					}
				}
				return this;
			};

			p.delay = function(value) {
				if (!arguments.length) {
					return this._delay;
				}
				if (this._timeline.smoothChildTiming) {
					this.startTime( this._startTime + value - this._delay );
				}
				this._delay = value;
				return this;
			};

			p.duration = function(value) {
				if (!arguments.length) {
					this._dirty = false;
					return this._duration;
				}
				this._duration = this._totalDuration = value;
				this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
				if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
					this.totalTime(this._totalTime * (value / this._duration), true);
				}
				return this;
			};

			p.totalDuration = function(value) {
				this._dirty = false;
				return (!arguments.length) ? this._totalDuration : this.duration(value);
			};

			p.time = function(value, suppressEvents) {
				if (!arguments.length) {
					return this._time;
				}
				if (this._dirty) {
					this.totalDuration();
				}
				return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
			};

			p.totalTime = function(time, suppressEvents, uncapped) {
				if (!_tickerActive) {
					_ticker.wake();
				}
				if (!arguments.length) {
					return this._totalTime;
				}
				if (this._timeline) {
					if (time < 0 && !uncapped) {
						time += this.totalDuration();
					}
					if (this._timeline.smoothChildTiming) {
						if (this._dirty) {
							this.totalDuration();
						}
						var totalDuration = this._totalDuration,
							tl = this._timeline;
						if (time > totalDuration && !uncapped) {
							time = totalDuration;
						}
						this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
						if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
							this._uncache(false);
						}
						//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
						if (tl._timeline) {
							while (tl._timeline) {
								if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
									tl.totalTime(tl._totalTime, true);
								}
								tl = tl._timeline;
							}
						}
					}
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._totalTime !== time || this._duration === 0) {
						if (_lazyTweens.length) {
							_lazyRender();
						}
						this.render(time, suppressEvents, false);
						if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
							_lazyRender();
						}
					}
				}
				return this;
			};

			p.progress = p.totalProgress = function(value, suppressEvents) {
				var duration = this.duration();
				return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
			};

			p.startTime = function(value) {
				if (!arguments.length) {
					return this._startTime;
				}
				if (value !== this._startTime) {
					this._startTime = value;
					if (this.timeline) if (this.timeline._sortChildren) {
						this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
					}
				}
				return this;
			};

			p.endTime = function(includeRepeats) {
				return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
			};

			p.timeScale = function(value) {
				if (!arguments.length) {
					return this._timeScale;
				}
				var pauseTime, t;
				value = value || _tinyNum; //can't allow zero because it'll throw the math off
				if (this._timeline && this._timeline.smoothChildTiming) {
					pauseTime = this._pauseTime;
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
					this._startTime = t - ((t - this._startTime) * this._timeScale / value);
				}
				this._timeScale = value;
				t = this.timeline;
				while (t && t.timeline) { //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
					t._dirty = true;
					t.totalDuration();
					t = t.timeline;
				}
				return this;
			};

			p.reversed = function(value) {
				if (!arguments.length) {
					return this._reversed;
				}
				if (value != this._reversed) {
					this._reversed = value;
					this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
				}
				return this;
			};

			p.paused = function(value) {
				if (!arguments.length) {
					return this._paused;
				}
				var tl = this._timeline,
					raw, elapsed;
				if (value != this._paused) if (tl) {
					if (!_tickerActive && !value) {
						_ticker.wake();
					}
					raw = tl.rawTime();
					elapsed = raw - this._pauseTime;
					if (!value && tl.smoothChildTiming) {
						this._startTime += elapsed;
						this._uncache(false);
					}
					this._pauseTime = value ? raw : null;
					this._paused = value;
					this._active = this.isActive();
					if (!value && elapsed !== 0 && this._initted && this.duration()) {
						raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
						this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
					}
				}
				if (this._gc && !value) {
					this._enabled(true, false);
				}
				return this;
			};


	/*
	 * ----------------------------------------------------------------
	 * SimpleTimeline
	 * ----------------------------------------------------------------
	 */
			var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
				Animation.call(this, 0, vars);
				this.autoRemoveChildren = this.smoothChildTiming = true;
			});

			p = SimpleTimeline.prototype = new Animation();
			p.constructor = SimpleTimeline;
			p.kill()._gc = false;
			p._first = p._last = p._recent = null;
			p._sortChildren = false;

			p.add = p.insert = function(child, position, align, stagger) {
				var prevTween, st;
				child._startTime = Number(position || 0) + child._delay;
				if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
					child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
				}
				if (child.timeline) {
					child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
				}
				child.timeline = child._timeline = this;
				if (child._gc) {
					child._enabled(true, true);
				}
				prevTween = this._last;
				if (this._sortChildren) {
					st = child._startTime;
					while (prevTween && prevTween._startTime > st) {
						prevTween = prevTween._prev;
					}
				}
				if (prevTween) {
					child._next = prevTween._next;
					prevTween._next = child;
				} else {
					child._next = this._first;
					this._first = child;
				}
				if (child._next) {
					child._next._prev = child;
				} else {
					this._last = child;
				}
				child._prev = prevTween;
				this._recent = child;
				if (this._timeline) {
					this._uncache(true);
				}
				return this;
			};

			p._remove = function(tween, skipDisable) {
				if (tween.timeline === this) {
					if (!skipDisable) {
						tween._enabled(false, true);
					}

					if (tween._prev) {
						tween._prev._next = tween._next;
					} else if (this._first === tween) {
						this._first = tween._next;
					}
					if (tween._next) {
						tween._next._prev = tween._prev;
					} else if (this._last === tween) {
						this._last = tween._prev;
					}
					tween._next = tween._prev = tween.timeline = null;
					if (tween === this._recent) {
						this._recent = this._last;
					}

					if (this._timeline) {
						this._uncache(true);
					}
				}
				return this;
			};

			p.render = function(time, suppressEvents, force) {
				var tween = this._first,
					next;
				this._totalTime = this._time = this._rawPrevTime = time;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (tween._active || (time >= tween._startTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			};

			p.rawTime = function() {
				if (!_tickerActive) {
					_ticker.wake();
				}
				return this._totalTime;
			};

	/*
	 * ----------------------------------------------------------------
	 * TweenLite
	 * ----------------------------------------------------------------
	 */
			var TweenLite = _class("TweenLite", function(target, duration, vars) {
					Animation.call(this, duration, vars);
					this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

					if (target == null) {
						throw "Cannot tween a null target.";
					}

					this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

					var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
						overwrite = this.vars.overwrite,
						i, targ, targets;

					this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

					if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
						this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
						this._propLookup = [];
						this._siblings = [];
						for (i = 0; i < targets.length; i++) {
							targ = targets[i];
							if (!targ) {
								targets.splice(i--, 1);
								continue;
							} else if (typeof(targ) === "string") {
								targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
								if (typeof(targ) === "string") {
									targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
								}
								continue;
							} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
								targets.splice(i--, 1);
								this._targets = targets = targets.concat(_slice(targ));
								continue;
							}
							this._siblings[i] = _register(targ, this, false);
							if (overwrite === 1) if (this._siblings[i].length > 1) {
								_applyOverwrite(targ, this, null, 1, this._siblings[i]);
							}
						}

					} else {
						this._propLookup = {};
						this._siblings = _register(target, this, false);
						if (overwrite === 1) if (this._siblings.length > 1) {
							_applyOverwrite(target, this, null, 1, this._siblings);
						}
					}
					if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
						this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
						this.render(Math.min(0, -this._delay)); //in case delay is negative
					}
				}, true),
				_isSelector = function(v) {
					return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
				},
				_autoCSS = function(vars, target) {
					var css = {},
						p;
					for (p in vars) {
						if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
							css[p] = vars[p];
							delete vars[p];
						}
					}
					vars.css = css;
				};

			p = TweenLite.prototype = new Animation();
			p.constructor = TweenLite;
			p.kill()._gc = false;

	//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

			p.ratio = 0;
			p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
			p._notifyPluginsOfEnabled = p._lazy = false;

			TweenLite.version = "2.1.0";
			TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
			TweenLite.defaultOverwrite = "auto";
			TweenLite.ticker = _ticker;
			TweenLite.autoSleep = 120;
			TweenLite.lagSmoothing = function(threshold, adjustedLag) {
				_ticker.lagSmoothing(threshold, adjustedLag);
			};

			TweenLite.selector = window.$ || window.jQuery || function(e) {
				var selector = window.$ || window.jQuery;
				if (selector) {
					TweenLite.selector = selector;
					return selector(e);
				}
				if (!_doc) { //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
					_doc = window.document;
				}
				return (!_doc) ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
			};

			var _lazyTweens = [],
				_lazyLookup = {},
				_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
				_relExp = /[\+-]=-?[\.\d]/,
				//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
				_setRatio = function(v) {
					var pt = this._firstPT,
						min = 0.000001,
						val;
					while (pt) {
						val = !pt.blob ? pt.c * v + pt.s : (v === 1 && this.end != null) ? this.end : v ? this.join("") : this.start;
						if (pt.m) {
							val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
						} else if (val < min) if (val > -min && !pt.blob) { //prevents issues with converting very small numbers to strings in the browser
							val = 0;
						}
						if (!pt.f) {
							pt.t[pt.p] = val;
						} else if (pt.fp) {
							pt.t[pt.p](pt.fp, val);
						} else {
							pt.t[pt.p](val);
						}
						pt = pt._next;
					}
				},
				_blobRound = function(v) {
					return (((v * 1000) | 0) / 1000) + "";
				},
				//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
				_blobDif = function(start, end, filter, pt) {
					var a = [],
						charIndex = 0,
						s = "",
						color = 0,
						startNums, endNums, num, i, l, nonNumbers, currentNum;
					a.start = start;
					a.end = end;
					start = a[0] = start + ""; //ensure values are strings
					end = a[1] = end + "";
					if (filter) {
						filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
						start = a[0];
						end = a[1];
					}
					a.length = 0;
					startNums = start.match(_numbersExp) || [];
					endNums = end.match(_numbersExp) || [];
					if (pt) {
						pt._next = null;
						pt.blob = 1;
						a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
					}
					l = endNums.length;
					for (i = 0; i < l; i++) {
						currentNum = endNums[i];
						nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
						s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
						charIndex += nonNumbers.length;
						if (color) { //sense rgba() values and round them.
							color = (color + 1) % 5;
						} else if (nonNumbers.substr(-5) === "rgba(") {
							color = 1;
						}
						if (currentNum === startNums[i] || startNums.length <= i) {
							s += currentNum;
						} else {
							if (s) {
								a.push(s);
								s = "";
							}
							num = parseFloat(startNums[i]);
							a.push(num);
							a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color && color < 4) ? Math.round : _blobRound}; //limiting to 3 decimal places and casting as a string can really help performance when array.join() is called!
							//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
						}
						charIndex += currentNum.length;
					}
					s += end.substr(charIndex);
					if (s) {
						a.push(s);
					}
					a.setRatio = _setRatio;
					if (_relExp.test(end)) { //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
						a.end = null;
					}
					return a;
				},
				//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
				_addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
					if (typeof(end) === "function") {
						end = end(index || 0, target);
					}
					var type = typeof(target[prop]),
						getterName = (type !== "function") ? "" : ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3)),
						s = (start !== "get") ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
						isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
						pt = {t:target, p:prop, s:s, f:(type === "function"), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0},
						blob;

					if (typeof(s) !== "number" || (typeof(end) !== "number" && !isRelative)) {
						if (funcParam || isNaN(s) || (!isRelative && isNaN(end)) || typeof(s) === "boolean" || typeof(end) === "boolean") {
							//a blob (string that has multiple numbers in it)
							pt.fp = funcParam;
							blob = _blobDif(s, (isRelative ? (parseFloat(pt.s) + pt.c) + (pt.s + "").replace(/[0-9\-\.]/g, "") : end), stringFilter || TweenLite.defaultStringFilter, pt);
							pt = {t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0}; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
						} else {
							pt.s = parseFloat(s);
							if (!isRelative) {
								pt.c = (parseFloat(end) - pt.s) || 0;
							}
						}
					}
					if (pt.c) { //only add it to the linked list if there's a change.
						if ((pt._next = this._firstPT)) {
							pt._next._prev = pt;
						}
						this._firstPT = pt;
						return pt;
					}
				},
				_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens, blobDif:_blobDif}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
				_plugins = TweenLite._plugins = {},
				_tweenLookup = _internals.tweenLookup = {},
				_tweenLookupNum = 0,
				_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1, callbackScope:1, stringFilter:1, id:1, yoyoEase:1, stagger:1},
				_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
				_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
				_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
				_nextGCFrame = 30,
				_lazyRender = _internals.lazyRender = function() {
					var l = _lazyTweens.length,
						i, tween;
					_lazyLookup = {};
					for (i = 0; i < l; i++) {
						tween = _lazyTweens[i];
						if (tween && tween._lazy !== false) {
							tween.render(tween._lazy[0], tween._lazy[1], true);
							tween._lazy = false;
						}
					}
					_lazyTweens.length = 0;
				};

			_rootTimeline._startTime = _ticker.time;
			_rootFramesTimeline._startTime = _ticker.frame;
			_rootTimeline._active = _rootFramesTimeline._active = true;
			setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

			Animation._updateRoot = TweenLite.render = function() {
					var i, a, p;
					if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
						_lazyRender();
					}
					_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
					_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
					if (_lazyTweens.length) {
						_lazyRender();
					}
					if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
						_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
						for (p in _tweenLookup) {
							a = _tweenLookup[p].tweens;
							i = a.length;
							while (--i > -1) {
								if (a[i]._gc) {
									a.splice(i, 1);
								}
							}
							if (a.length === 0) {
								delete _tweenLookup[p];
							}
						}
						//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
						p = _rootTimeline._first;
						if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
							while (p && p._paused) {
								p = p._next;
							}
							if (!p) {
								_ticker.sleep();
							}
						}
					}
				};

			_ticker.addEventListener("tick", Animation._updateRoot);

			var _register = function(target, tween, scrub) {
					var id = target._gsTweenID, a, i;
					if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
						_tweenLookup[id] = {target:target, tweens:[]};
					}
					if (tween) {
						a = _tweenLookup[id].tweens;
						a[(i = a.length)] = tween;
						if (scrub) {
							while (--i > -1) {
								if (a[i] === tween) {
									a.splice(i, 1);
								}
							}
						}
					}
					return _tweenLookup[id].tweens;
				},
				_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
					var func = overwrittenTween.vars.onOverwrite, r1, r2;
					if (func) {
						r1 = func(overwrittenTween, overwritingTween, target, killedProps);
					}
					func = TweenLite.onOverwrite;
					if (func) {
						r2 = func(overwrittenTween, overwritingTween, target, killedProps);
					}
					return (r1 !== false && r2 !== false);
				},
				_applyOverwrite = function(target, tween, props, mode, siblings) {
					var i, changed, curTween, l;
					if (mode === 1 || mode >= 4) {
						l = siblings.length;
						for (i = 0; i < l; i++) {
							if ((curTween = siblings[i]) !== tween) {
								if (!curTween._gc) {
									if (curTween._kill(null, target, tween)) {
										changed = true;
									}
								}
							} else if (mode === 5) {
								break;
							}
						}
						return changed;
					}
					//NOTE: Add tiny amount to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
					var startTime = tween._startTime + _tinyNum,
						overlaps = [],
						oCount = 0,
						zeroDur = (tween._duration === 0),
						globalStart;
					i = siblings.length;
					while (--i > -1) {
						if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
							//ignore
						} else if (curTween._timeline !== tween._timeline) {
							globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
							if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
								overlaps[oCount++] = curTween;
							}
						} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= _tinyNum * 2)) {
							overlaps[oCount++] = curTween;
						}
					}

					i = oCount;
					while (--i > -1) {
						curTween = overlaps[i];
						l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278
						if (mode === 2) if (curTween._kill(props, target, tween)) {
							changed = true;
						}
						if (mode !== 2 || (!curTween._firstPT && curTween._initted && l)) {
							if (mode !== 2 && !_onOverwrite(curTween, tween)) {
								continue;
							}
							if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
								changed = true;
							}
						}
					}
					return changed;
				},
				_checkOverlap = function(tween, reference, zeroDur) {
					var tl = tween._timeline,
						ts = tl._timeScale,
						t = tween._startTime;
					while (tl._timeline) {
						t += tl._startTime;
						ts *= tl._timeScale;
						if (tl._paused) {
							return -100;
						}
						tl = tl._timeline;
					}
					t /= ts;
					return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
				};


	//---- TweenLite instance methods -----------------------------------------------------------------------------

			p._init = function() {
				var v = this.vars,
					op = this._overwrittenProps,
					dur = this._duration,
					immediate = !!v.immediateRender,
					ease = v.ease,
					startAt = this._startAt,
					i, initPlugins, pt, p, startVars, l;
				if (v.startAt) {
					if (startAt) {
						startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
						startAt.kill();
					}
					startVars = {};
					for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
						startVars[p] = v.startAt[p];
					}
					startVars.data = "isStart";
					startVars.overwrite = false;
					startVars.immediateRender = true;
					startVars.lazy = (immediate && v.lazy !== false);
					startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
					startVars.onUpdate = v.onUpdate;
					startVars.onUpdateParams = v.onUpdateParams;
					startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
					this._startAt = TweenLite.to(this.target || {}, 0, startVars);
					if (immediate) {
						if (this._time > 0) {
							this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
						} else if (dur !== 0) {
							return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
						}
					}
				} else if (v.runBackwards && dur !== 0) {
					//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
					if (startAt) {
						startAt.render(-1, true);
						startAt.kill();
						this._startAt = null;
					} else {
						if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
							immediate = false;
						}
						pt = {};
						for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
							if (!_reservedProps[p] || p === "autoCSS") {
								pt[p] = v[p];
							}
						}
						pt.overwrite = 0;
						pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
						pt.lazy = (immediate && v.lazy !== false);
						pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
						this._startAt = TweenLite.to(this.target, 0, pt);
						if (!immediate) {
							this._startAt._init(); //ensures that the initial values are recorded
							this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
							if (this.vars.immediateRender) {
								this._startAt = null;
							}
						} else if (this._time === 0) {
							return;
						}
					}
				}
				this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
				if (v.easeParams instanceof Array && ease.config) {
					this._ease = ease.config.apply(ease, v.easeParams);
				}
				this._easeType = this._ease._type;
				this._easePower = this._ease._power;
				this._firstPT = null;

				if (this._targets) {
					l = this._targets.length;
					for (i = 0; i < l; i++) {
						if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i) ) {
							initPlugins = true;
						}
					}
				} else {
					initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
				}

				if (initPlugins) {
					TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
				}
				if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
					this._enabled(false, false);
				}
				if (v.runBackwards) {
					pt = this._firstPT;
					while (pt) {
						pt.s += pt.c;
						pt.c = -pt.c;
						pt = pt._next;
					}
				}
				this._onUpdate = v.onUpdate;
				this._initted = true;
			};

			p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
				var p, i, initPlugins, plugin, pt, v;
				if (target == null) {
					return false;
				}
				if (_lazyLookup[target._gsTweenID]) {
					_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
				}

				if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
					_autoCSS(this.vars, target);
				}
				for (p in this.vars) {
					v = this.vars[p];
					if (_reservedProps[p]) {
						if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
							this.vars[p] = v = this._swapSelfInParams(v, this);
						}

					} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

						//t - target 		[object]
						//p - property 		[string]
						//s - start			[number]
						//c - change		[number]
						//f - isFunction	[boolean]
						//n - name			[string]
						//pg - isPlugin 	[boolean]
						//pr - priority		[number]
						//m - mod           [function | 0]
						this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
						i = plugin._overwriteProps.length;
						while (--i > -1) {
							propLookup[plugin._overwriteProps[i]] = this._firstPT;
						}
						if (plugin._priority || plugin._onInitAllProps) {
							initPlugins = true;
						}
						if (plugin._onDisable || plugin._onEnable) {
							this._notifyPluginsOfEnabled = true;
						}
						if (pt._next) {
							pt._next._prev = pt;
						}

					} else {
						propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
					}
				}

				if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
					return this._initProps(target, propLookup, siblings, overwrittenProps, index);
				}
				if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
					this._kill(propLookup, target);
					return this._initProps(target, propLookup, siblings, overwrittenProps, index);
				}
				if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
					_lazyLookup[target._gsTweenID] = true;
				}
				return initPlugins;
			};

			p.render = function(time, suppressEvents, force) {
				var self = this,
					prevTime = self._time,
					duration = self._duration,
					prevRawPrevTime = self._rawPrevTime,
					isComplete, callback, pt, rawPrevTime;
				if (time >= duration - _tinyNum && time >= 0) { //to work around occasional floating point math artifacts.
					self._totalTime = self._time = duration;
					self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;
					if (!self._reversed ) {
						isComplete = true;
						callback = "onComplete";
						force = (force || self._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					}
					if (duration === 0) if (self._initted || !self.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (self._startTime === self._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
							time = 0;
						}
						if (prevRawPrevTime < 0 || (time <= 0 && time >= -_tinyNum) || (prevRawPrevTime === _tinyNum && self.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
							force = true;
							if (prevRawPrevTime > _tinyNum) {
								callback = "onReverseComplete";
							}
						}
						self._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}

				} else if (time < _tinyNum) { //to work around occasional floating point math artifacts, round super small values to 0.
					self._totalTime = self._time = 0;
					self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;
					if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
						callback = "onReverseComplete";
						isComplete = self._reversed;
					}
					if (time > -_tinyNum) {
						time = 0;
					} else if (time < 0) {
						self._active = false;
						if (duration === 0) if (self._initted || !self.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
							if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && self.data === "isPause")) {
								force = true;
							}
							self._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						}
					}
					if (!self._initted || (self._startAt && self._startAt.progress())) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
						force = true;
					}
				} else {
					self._totalTime = self._time = time;

					if (self._easeType) {
						var r = time / duration, type = self._easeType, pow = self._easePower;
						if (type === 1 || (type === 3 && r >= 0.5)) {
							r = 1 - r;
						}
						if (type === 3) {
							r *= 2;
						}
						if (pow === 1) {
							r *= r;
						} else if (pow === 2) {
							r *= r * r;
						} else if (pow === 3) {
							r *= r * r * r;
						} else if (pow === 4) {
							r *= r * r * r * r;
						}
						self.ratio = (type === 1) ? 1 - r : (type === 2) ? r : (time / duration < 0.5) ? r / 2 : 1 - (r / 2);
					} else {
						self.ratio = self._ease.getRatio(time / duration);
					}
				}

				if (self._time === prevTime && !force) {
					return;
				} else if (!self._initted) {
					self._init();
					if (!self._initted || self._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
						return;
					} else if (!force && self._firstPT && ((self.vars.lazy !== false && self._duration) || (self.vars.lazy && !self._duration))) {
						self._time = self._totalTime = prevTime;
						self._rawPrevTime = prevRawPrevTime;
						_lazyTweens.push(self);
						self._lazy = [time, suppressEvents];
						return;
					}
					//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
					if (self._time && !isComplete) {
						self.ratio = self._ease.getRatio(self._time / duration);
					} else if (isComplete && self._ease._calcEnd) {
						self.ratio = self._ease.getRatio((self._time === 0) ? 0 : 1);
					}
				}
				if (self._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
					self._lazy = false;
				}
				if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {
					self._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
				}
				if (prevTime === 0) {
					if (self._startAt) {
						if (time >= 0) {
							self._startAt.render(time, true, force);
						} else if (!callback) {
							callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
						}
					}
					if (self.vars.onStart) if (self._time !== 0 || duration === 0) if (!suppressEvents) {
						self._callback("onStart");
					}
				}
				pt = self._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](pt.c * self.ratio + pt.s);
					} else {
						pt.t[pt.p] = pt.c * self.ratio + pt.s;
					}
					pt = pt._next;
				}

				if (self._onUpdate) {
					if (time < 0) if (self._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
						self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
					}
					if (!suppressEvents) if (self._time !== prevTime || isComplete || force) {
						self._callback("onUpdate");
					}
				}
				if (callback) if (!self._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
					if (time < 0 && self._startAt && !self._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
						self._startAt.render(time, true, force);
					}
					if (isComplete) {
						if (self._timeline.autoRemoveChildren) {
							self._enabled(false, false);
						}
						self._active = false;
					}
					if (!suppressEvents && self.vars[callback]) {
						self._callback(callback);
					}
					if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
						self._rawPrevTime = 0;
					}
				}
			};

			p._kill = function(vars, target, overwritingTween) {
				if (vars === "all") {
					vars = null;
				}
				if (vars == null) if (target == null || target === this.target) {
					this._lazy = false;
					return this._enabled(false, false);
				}
				target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
				var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
					firstPT = this._firstPT,
					i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
				if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
					i = target.length;
					while (--i > -1) {
						if (this._kill(vars, target[i], overwritingTween)) {
							changed = true;
						}
					}
				} else {
					if (this._targets) {
						i = this._targets.length;
						while (--i > -1) {
							if (target === this._targets[i]) {
								propLookup = this._propLookup[i] || {};
								this._overwrittenProps = this._overwrittenProps || [];
								overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
								break;
							}
						}
					} else if (target !== this.target) {
						return false;
					} else {
						propLookup = this._propLookup;
						overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
					}

					if (propLookup) {
						killProps = vars || propLookup;
						record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
						if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
							for (p in killProps) {
								if (propLookup[p]) {
									if (!killed) {
										killed = [];
									}
									killed.push(p);
								}
							}
							if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
								return false;
							}
						}

						for (p in killProps) {
							if ((pt = propLookup[p])) {
								if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
									if (pt.f) {
										pt.t[pt.p](pt.s);
									} else {
										pt.t[pt.p] = pt.s;
									}
									changed = true;
								}
								if (pt.pg && pt.t._kill(killProps)) {
									changed = true; //some plugins need to be notified so they can perform cleanup tasks first
								}
								if (!pt.pg || pt.t._overwriteProps.length === 0) {
									if (pt._prev) {
										pt._prev._next = pt._next;
									} else if (pt === this._firstPT) {
										this._firstPT = pt._next;
									}
									if (pt._next) {
										pt._next._prev = pt._prev;
									}
									pt._next = pt._prev = null;
								}
								delete propLookup[p];
							}
							if (record) {
								overwrittenProps[p] = 1;
							}
						}
						if (!this._firstPT && this._initted && firstPT) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
							this._enabled(false, false);
						}
					}
				}
				return changed;
			};

			p.invalidate = function() {
				if (this._notifyPluginsOfEnabled) {
					TweenLite._onPluginEvent("_onDisable", this);
				}
				var t = this._time;
				this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
				this._notifyPluginsOfEnabled = this._active = this._lazy = false;
				this._propLookup = (this._targets) ? {} : [];
				Animation.prototype.invalidate.call(this);
				if (this.vars.immediateRender) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(t, false, this.vars.lazy !== false);
				}
				return this;
			};

			p._enabled = function(enabled, ignoreTimeline) {
				if (!_tickerActive) {
					_ticker.wake();
				}
				if (enabled && this._gc) {
					var targets = this._targets,
						i;
					if (targets) {
						i = targets.length;
						while (--i > -1) {
							this._siblings[i] = _register(targets[i], this, true);
						}
					} else {
						this._siblings = _register(this.target, this, true);
					}
				}
				Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
				if (this._notifyPluginsOfEnabled) if (this._firstPT) {
					return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
				}
				return false;
			};


	//----TweenLite static methods -----------------------------------------------------

			TweenLite.to = function(target, duration, vars) {
				return new TweenLite(target, duration, vars);
			};

			TweenLite.from = function(target, duration, vars) {
				vars.runBackwards = true;
				vars.immediateRender = (vars.immediateRender != false);
				return new TweenLite(target, duration, vars);
			};

			TweenLite.fromTo = function(target, duration, fromVars, toVars) {
				toVars.startAt = fromVars;
				toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
				return new TweenLite(target, duration, toVars);
			};

			TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
				return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
			};

			TweenLite.set = function(target, vars) {
				return new TweenLite(target, 0, vars);
			};

			TweenLite.getTweensOf = function(target, onlyActive) {
				if (target == null) { return []; }
				target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
				var i, a, j, t;
				if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
					i = target.length;
					a = [];
					while (--i > -1) {
						a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
					}
					i = a.length;
					//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
					while (--i > -1) {
						t = a[i];
						j = i;
						while (--j > -1) {
							if (t === a[j]) {
								a.splice(i, 1);
							}
						}
					}
				} else if (target._gsTweenID) {
					a = _register(target).concat();
					i = a.length;
					while (--i > -1) {
						if (a[i]._gc || (onlyActive && !a[i].isActive())) {
							a.splice(i, 1);
						}
					}
				}
				return a || [];
			};

			TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
				if (typeof(onlyActive) === "object") {
					vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
					onlyActive = false;
				}
				var a = TweenLite.getTweensOf(target, onlyActive),
					i = a.length;
				while (--i > -1) {
					a[i]._kill(vars, target);
				}
			};



	/*
	 * ----------------------------------------------------------------
	 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
	 * ----------------------------------------------------------------
	 */
			var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
						this._overwriteProps = (props || "").split(",");
						this._propName = this._overwriteProps[0];
						this._priority = priority || 0;
						this._super = TweenPlugin.prototype;
					}, true);

			p = TweenPlugin.prototype;
			TweenPlugin.version = "1.19.0";
			TweenPlugin.API = 2;
			p._firstPT = null;
			p._addTween = _addPropTween;
			p.setRatio = _setRatio;

			p._kill = function(lookup) {
				var a = this._overwriteProps,
					pt = this._firstPT,
					i;
				if (lookup[this._propName] != null) {
					this._overwriteProps = [];
				} else {
					i = a.length;
					while (--i > -1) {
						if (lookup[a[i]] != null) {
							a.splice(i, 1);
						}
					}
				}
				while (pt) {
					if (lookup[pt.n] != null) {
						if (pt._next) {
							pt._next._prev = pt._prev;
						}
						if (pt._prev) {
							pt._prev._next = pt._next;
							pt._prev = null;
						} else if (this._firstPT === pt) {
							this._firstPT = pt._next;
						}
					}
					pt = pt._next;
				}
				return false;
			};

			p._mod = p._roundProps = function(lookup) {
				var pt = this._firstPT,
					val;
				while (pt) {
					val = lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ]);
					if (val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
						if (pt.f === 2) {
							pt.t._applyPT.m = val;
						} else {
							pt.m = val;
						}
					}
					pt = pt._next;
				}
			};

			TweenLite._onPluginEvent = function(type, tween) {
				var pt = tween._firstPT,
					changed, pt2, first, last, next;
				if (type === "_onInitAllProps") {
					//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
					while (pt) {
						next = pt._next;
						pt2 = first;
						while (pt2 && pt2.pr > pt.pr) {
							pt2 = pt2._next;
						}
						if ((pt._prev = pt2 ? pt2._prev : last)) {
							pt._prev._next = pt;
						} else {
							first = pt;
						}
						if ((pt._next = pt2)) {
							pt2._prev = pt;
						} else {
							last = pt;
						}
						pt = next;
					}
					pt = tween._firstPT = first;
				}
				while (pt) {
					if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
						changed = true;
					}
					pt = pt._next;
				}
				return changed;
			};

			TweenPlugin.activate = function(plugins) {
				var i = plugins.length;
				while (--i > -1) {
					if (plugins[i].API === TweenPlugin.API) {
						_plugins[(new plugins[i]())._propName] = plugins[i];
					}
				}
				return true;
			};

			//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
			_gsDefine.plugin = function(config) {
				if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
				var propName = config.propName,
					priority = config.priority || 0,
					overwriteProps = config.overwriteProps,
					map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_mod", mod:"_mod", initAll:"_onInitAllProps"},
					Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
						function() {
							TweenPlugin.call(this, propName, priority);
							this._overwriteProps = overwriteProps || [];
						}, (config.global === true)),
					p = Plugin.prototype = new TweenPlugin(propName),
					prop;
				p.constructor = Plugin;
				Plugin.API = config.API;
				for (prop in map) {
					if (typeof(config[prop]) === "function") {
						p[map[prop]] = config[prop];
					}
				}
				Plugin.version = config.version;
				TweenPlugin.activate([Plugin]);
				return Plugin;
			};


			//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
			a = window._gsQueue;
			if (a) {
				for (i = 0; i < a.length; i++) {
					a[i]();
				}
				for (p in _defLookup) {
					if (!_defLookup[p].func) {
						window.console.log("GSAP encountered missing dependency: " + p);
					}
				}
			}

			_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

	})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ })
/******/ ]);